let link = element("link");
  link.rel = "stylesheet";
  link.type = "text/css";
  link.href = "http://bafzbeiaibpp2sngseh3c27izssije5wmiyqex6t6fxouhipu3de5djuzuy.ipns.localhost/sidebar-layout/build/menu-toggle-btn.svelte.css";
  document.head.append(link);

  export function stylesLoaded (cb) {
    link.onload = () => { if (cb) { cb() } };
  }

  /* menu-toggle-btn.svelte generated by Svelte v3.23.0 */
import {
	SvelteComponentDev,
	add_location,
	attr_dev,
	detach_dev,
	dispatch_dev,
	element,
	init,
	insert_dev,
	listen_dev,
	noop,
	run_all,
	safe_not_equal,
	set_style,
	validate_slots
} from "https://cdn.skypack.dev/svelte@v3.35.0/internal";

import { createEventDispatcher } from "https://cdn.skypack.dev/svelte@v3.35.0";
const file = "menu-toggle-btn.svelte";

function create_fragment(ctx) {
	let div;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "menu-toggle-button svelte-1ku8u79");
			set_style(div, "left", /*sideWidth*/ ctx[0]);
			add_location(div, file, 30, 0, 599);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(window, "mouseup", /*mouseupHandler*/ ctx[3], false, false, false),
					listen_dev(window, "mousemove", /*mousemoveHandler*/ ctx[2], false, false, false),
					listen_dev(div, "mousedown", /*mousedownHandler*/ ctx[1], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*sideWidth*/ 1) {
				set_style(div, "left", /*sideWidth*/ ctx[0]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { sidebarClosed } = $$props;
	let { sideWidth } = $$props;
	let tempWidth = sideWidth;
	let isMoving = false;
	let isMouseDown = false;
	let isToggling = false;
	const dispatch = createEventDispatcher();

	function mousedownHandler(event) {
		isMouseDown = true;
		isToggling = true;
	}

	function mousemoveHandler(e) {
		isMoving = true;

		if (isMouseDown === true && !sidebarClosed) {
			dispatch("sidebarResize", { width: event.clientX });
			return true;
		}

		isMoving = false;
	}

	function mouseupHandler(e) {
		if (!isMoving && isToggling) {
			dispatch("sidebarToggle");
		}

		isMouseDown = false;
		isMoving = false;
		isToggling = false;
	}

	const writable_props = ["sidebarClosed", "sideWidth"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Menu_toggle_btn> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Menu_toggle_btn", $$slots, []);

	$$self.$set = $$props => {
		if ("sidebarClosed" in $$props) $$invalidate(4, sidebarClosed = $$props.sidebarClosed);
		if ("sideWidth" in $$props) $$invalidate(0, sideWidth = $$props.sideWidth);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		sidebarClosed,
		sideWidth,
		tempWidth,
		isMoving,
		isMouseDown,
		isToggling,
		dispatch,
		mousedownHandler,
		mousemoveHandler,
		mouseupHandler
	});

	$$self.$inject_state = $$props => {
		if ("sidebarClosed" in $$props) $$invalidate(4, sidebarClosed = $$props.sidebarClosed);
		if ("sideWidth" in $$props) $$invalidate(0, sideWidth = $$props.sideWidth);
		if ("tempWidth" in $$props) $$invalidate(5, tempWidth = $$props.tempWidth);
		if ("isMoving" in $$props) isMoving = $$props.isMoving;
		if ("isMouseDown" in $$props) isMouseDown = $$props.isMouseDown;
		if ("isToggling" in $$props) isToggling = $$props.isToggling;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*sidebarClosed, sideWidth*/ 17) {
			$: if (sidebarClosed) {
				$$invalidate(5, tempWidth = sideWidth);
				$$invalidate(0, sideWidth = 0);
			}
		}

		if ($$self.$$.dirty & /*sidebarClosed, tempWidth*/ 48) {
			$: if (!sidebarClosed) {
				$$invalidate(0, sideWidth = tempWidth);
			}
		}
	};

	return [sideWidth, mousedownHandler, mousemoveHandler, mouseupHandler, sidebarClosed];
}

class Menu_toggle_btn extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { sidebarClosed: 4, sideWidth: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Menu_toggle_btn",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*sidebarClosed*/ ctx[4] === undefined && !("sidebarClosed" in props)) {
			console.warn("<Menu_toggle_btn> was created without expected prop 'sidebarClosed'");
		}

		if (/*sideWidth*/ ctx[0] === undefined && !("sideWidth" in props)) {
			console.warn("<Menu_toggle_btn> was created without expected prop 'sideWidth'");
		}
	}

	get sidebarClosed() {
		throw new Error("<Menu_toggle_btn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sidebarClosed(value) {
		throw new Error("<Menu_toggle_btn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sideWidth() {
		throw new Error("<Menu_toggle_btn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sideWidth(value) {
		throw new Error("<Menu_toggle_btn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Menu_toggle_btn;