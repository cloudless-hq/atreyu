let link = element("link");
  link.rel = "stylesheet";
  link.type = "text/css";
  link.href = "http://bafzbeiaibpp2sngseh3c27izssije5wmiyqex6t6fxouhipu3de5djuzuy.ipns.localhost/sidebar-layout/build/sidebar-layout.svelte.css";
  document.head.append(link);

  export function stylesLoaded (cb) {
    link.onload = () => { if (cb) { cb() } };
  }

  /* sidebar-layout.svelte generated by Svelte v3.23.0 */
import {
	SvelteComponentDev,
	add_location,
	attr_dev,
	create_slot,
	detach_dev,
	dispatch_dev,
	element,
	init,
	insert_dev,
	safe_not_equal,
	set_style,
	toggle_class,
	transition_in,
	transition_out,
	update_slot,
	validate_slots
} from "https://cdn.skypack.dev/svelte@v3.31.0/internal";

const file = "sidebar-layout.svelte";

function create_fragment(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", "with-sidebar svelte-v98ms9");
			set_style(div, "--height", /*height*/ ctx[4]);
			set_style(div, "--top", /*top*/ ctx[5]);
			set_style(div, "--side-width", /*sideWidth*/ ctx[1]);
			set_style(div, "--content-min", /*contentMin*/ ctx[2]);
			toggle_class(div, "closed", /*closed*/ ctx[3]);
			toggle_class(div, "right", /*right*/ ctx[0]);
			add_location(div, file, 56, 0, 1164);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			if (!current || dirty & /*height*/ 16) {
				set_style(div, "--height", /*height*/ ctx[4]);
			}

			if (!current || dirty & /*top*/ 32) {
				set_style(div, "--top", /*top*/ ctx[5]);
			}

			if (!current || dirty & /*sideWidth*/ 2) {
				set_style(div, "--side-width", /*sideWidth*/ ctx[1]);
			}

			if (!current || dirty & /*contentMin*/ 4) {
				set_style(div, "--content-min", /*contentMin*/ ctx[2]);
			}

			if (dirty & /*closed*/ 8) {
				toggle_class(div, "closed", /*closed*/ ctx[3]);
			}

			if (dirty & /*right*/ 1) {
				toggle_class(div, "right", /*right*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { right = false } = $$props;
	let { sideWidth = "auto" } = $$props;
	let { contentMin = 50 } = $$props;
	let { closed } = $$props;
	let { height = "100vh" } = $$props;
	let { top = "0" } = $$props;
	const writable_props = ["right", "sideWidth", "contentMin", "closed", "height", "top"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Sidebar_layout> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Sidebar_layout", $$slots, ['default']);

	$$self.$set = $$props => {
		if ("right" in $$props) $$invalidate(0, right = $$props.right);
		if ("sideWidth" in $$props) $$invalidate(1, sideWidth = $$props.sideWidth);
		if ("contentMin" in $$props) $$invalidate(2, contentMin = $$props.contentMin);
		if ("closed" in $$props) $$invalidate(3, closed = $$props.closed);
		if ("height" in $$props) $$invalidate(4, height = $$props.height);
		if ("top" in $$props) $$invalidate(5, top = $$props.top);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		right,
		sideWidth,
		contentMin,
		closed,
		height,
		top
	});

	$$self.$inject_state = $$props => {
		if ("right" in $$props) $$invalidate(0, right = $$props.right);
		if ("sideWidth" in $$props) $$invalidate(1, sideWidth = $$props.sideWidth);
		if ("contentMin" in $$props) $$invalidate(2, contentMin = $$props.contentMin);
		if ("closed" in $$props) $$invalidate(3, closed = $$props.closed);
		if ("height" in $$props) $$invalidate(4, height = $$props.height);
		if ("top" in $$props) $$invalidate(5, top = $$props.top);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [right, sideWidth, contentMin, closed, height, top, $$scope, $$slots];
}

class Sidebar_layout extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			right: 0,
			sideWidth: 1,
			contentMin: 2,
			closed: 3,
			height: 4,
			top: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Sidebar_layout",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*closed*/ ctx[3] === undefined && !("closed" in props)) {
			console.warn("<Sidebar_layout> was created without expected prop 'closed'");
		}
	}

	get right() {
		throw new Error("<Sidebar_layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set right(value) {
		throw new Error("<Sidebar_layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sideWidth() {
		throw new Error("<Sidebar_layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sideWidth(value) {
		throw new Error("<Sidebar_layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get contentMin() {
		throw new Error("<Sidebar_layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set contentMin(value) {
		throw new Error("<Sidebar_layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closed() {
		throw new Error("<Sidebar_layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closed(value) {
		throw new Error("<Sidebar_layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<Sidebar_layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<Sidebar_layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get top() {
		throw new Error("<Sidebar_layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set top(value) {
		throw new Error("<Sidebar_layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Sidebar_layout;