{
  "version": 3,
  "sources": ["../app/src/lib/proxy-object.js", "../app/src/store/service-worker-source.js", "../app/src/store/data.js"],
  "sourcesContent": ["// TODO: only in debug/dev mode\n// This is my own code, its in vendor, because i want to release as standdalone package maybe?\nimport { getJsonPath } from '../store/helpers.js'\n\nconst errorHandlers = {\n  deleteProperty () {\n    console.error('error: calling `delete` on atreyu proxy.')\n  },\n  defineProperty (oTarget, sKey, oDesc) {\n    console.error('error: calling `defineProperty` on atreyu proxy.')\n  },\n  getOwnPropertyDescriptor (oTarget, sKey) {\n    console.error('error: calling `getOwnPropertyDescriptor` on atreyu proxy.')\n    return { configurable: true, enumerable: false, value: 5 }\n  },\n  ownKeys (oTarget, sKey) {\n    console.error('error: calling ownKeys on atreyu proxy not supported.')\n    return ['ownKeys test']\n  },\n  getPrototypeOf (target) {\n    console.error('error: getting prototype on atreyu proxy not supported.')\n    return Object\n  }\n}\n\nconst _start = Symbol('start')\nconst _end = Symbol('end')\n\nfunction clean (name, endRegex) {\n  let cleanKey\n  let delim\n  let isPathEnd = false\n\n  const rxRes = endRegex.exec(name)\n\n  if (rxRes) {\n    isPathEnd = true\n    delim = rxRes[0]\n    let suffixLen = name.length - rxRes.index\n    cleanKey = name.slice(0, -suffixLen)\n  } else {\n    cleanKey = name\n  }\n\n  if (cleanKey !== '') { // THANK you js for wasting half my day. apparently Number('') is 0\n    const maybeNumber = Number(cleanKey)\n    cleanKey = !isNaN(maybeNumber) ? maybeNumber : cleanKey\n  }\n\n  return { isPathEnd, cleanKey, delim }\n}\n\nfunction makeProxy ({ from, get, set, call, delims = ['$'], id }) {\n  const endRegex = new RegExp(`(\\\\${delims.join('|\\\\')})$`)\n\n  function objProxy (rootPath, subObj, rev) {\n    return new Proxy(subObj, {\n      ...errorHandlers,\n      has (target, key) {\n        if (key === Symbol.iterator) {\n          // console.log('iterables not supported yet, plase use array operations')\n          return\n        }\n        if (key === 'length') {\n          return true\n        }\n        console.log('has function trap not well supported', target, key)\n        return true\n      },\n      apply (target, thisArg, args) {\n        const path = [...rootPath]\n        path.pop()\n        const cleanKey = rootPath[rootPath.length - 1]\n\n        if (cleanKey === 'slice') {\n          const arr = {\n            length: args[1] - args[0], // TODO: make end max length Math.min(end, items.length)\n            [_start]: args[0],\n            [_end]: args[1]\n          }\n\n          return objProxy(path, arr, rev)\n        } else if (cleanKey === 'forEach') {\n          console.error('direct forEach call not allowed. please post your use case to get support.')\n        } else if (cleanKey === 'map') {\n          console.error('direct map call not allowed. please post your use case to get support.')\n          console.log(args, target, subObj)\n        }\n\n        if (cleanKey === '_loadRef') {\n          const ref = args[0]\n          if (ref?.length > 0) {\n            return getJsonPath(thisArg, ref )\n          } else {\n            // FIXME: dont return root proxy but the path to the $ref\n            return thisArg\n          }\n        }\n\n        return call(rootPath, args, '', id)\n      },\n      set (target, key, newValue, subObjProxy) {\n        const { cleanKey } = clean(key, endRegex)\n\n        const path = [...rootPath, cleanKey]\n\n        // subObj = { ...subObj }\n        // subObj[cleanKey] = newValue\n        let delim = '' // TODO: not impl yet\n\n        return set(path, newValue, delim, id)\n      },\n      get (obj, key) {\n        if (key === Symbol.toPrimitive) {\n          return (_hint) => {\n            // console.warn('Rendering hint \"' + hint + '\" not supported yet, falling back to empty string, did you forget to add trailing \"$\" to your atreyu data store access? If this is a valid usecase please open and explain in a github issue. Encountered at path:', rootPath)\n            const path = [...rootPath]\n            path.pop()\n            const cleanKey = rootPath[rootPath.length - 1]\n            return get(path, subObj[cleanKey], cleanKey, id)\n          }\n        }\n\n        if (typeof key !== 'string') {\n          console.warn('did your forget the trailing \"$\"? Non string key access not supported yet, if needed, raise github issue explaining usecase ', { rootPath, key })\n          return false\n        }\n\n        let { isPathEnd, cleanKey, delim } = clean(key, endRegex)\n\n        if (cleanKey === 'map') {\n          return fun => {\n            if (typeof obj[_start] === 'undefined') {\n              console.error('map is not allowed on virtual unbounded arrays, you need to use slice first. Please read about non ataomic falcor arrays before you use this!')\n              return []\n            }\n            for (let i = 0; i < obj.length; i++) {\n              obj[i] = fun(objProxy([...rootPath, i + obj[_start]], [], rev), i, i + obj[_start])\n            }\n            return obj\n          }\n        }\n\n        if (cleanKey === '_rev' && typeof subObj[cleanKey] === 'undefined') {\n          return get([...rootPath, cleanKey], subObj, delim, id)\n        }\n\n        if (typeof obj?.[_start] !== 'undefined') {\n          if (!isNaN(cleanKey)) {\n            cleanKey = cleanKey + obj[_start]\n          } else if (cleanKey !== 'length') {\n            console.error('unexpected slice access, please raise github issue with your usecase')\n          }\n        }\n\n        if (isPathEnd) {\n          return get([...rootPath, cleanKey], subObj[cleanKey], delim, id)\n        }\n\n        if (typeof subObj[cleanKey] === 'undefined') {\n          if (cleanKey === 'length') {\n            return get([...rootPath, cleanKey], 0, delim, id)\n          }\n          return objProxy([...rootPath, cleanKey], from, rev)\n        }\n\n        if (typeof subObj[cleanKey] !== 'object') {\n          if (cleanKey === 'length') {\n            return get([...rootPath, cleanKey], subObj[cleanKey], delim, id)\n          }\n          return subObj[cleanKey]\n        }\n\n        return objProxy([...rootPath, cleanKey], subObj[cleanKey], rev)\n      }\n    })\n  }\n\n  return objProxy([], from, 0)\n}\nexport { makeProxy }\n", "import { Observable } from '/_ayu/build/deps/falcor-observable.js'\n\n/* eslint-disable functional/no-this-expression, functional/no-class */\nclass ServiceWorkerSource {\n  constructor ({ wake }) {\n    this._inflight = {}\n    this._id = 0 // Identifier used to correlate each Request to each response\n    this._active = 0\n    this._timer\n\n    const init = () => {\n      this._worker = navigator.serviceWorker.controller\n      this._worker?.postMessage(JSON.stringify([-1, 'hello mike' ]))\n    }\n    if (!this._worker) {\n      init()\n    }\n\n    navigator.serviceWorker.addEventListener('message', e => {\n      if (e.data.startsWith('navigate:')) {\n        return\n      }\n      if (!this._worker) {\n        init()\n      }\n      const { id, error, value, done, hello } = JSON.parse(e.data)\n\n      if (hello) {\n        // delete after timeout to not crash a message that was the reason for waking the worker...\n        // TODO: find better solution?\n        setTimeout(() => {\n          Object.values(this._inflight).forEach(stale => stale('service worker restarted, canceled:', stale))\n        }, 800)\n      } else if (typeof this._inflight[id] === 'function') {\n        this._inflight[id](error, value, done)\n      } else {\n        console.log(e.data)\n      }\n    })\n\n    if (wake) {\n      this._waker = setInterval(() => {\n        this._worker?.postMessage(JSON.stringify([-1, 'waky waky']))\n      }, wake)\n    }\n  }\n\n  isActive () {\n    // console.log('isactive', this._timer, Object.keys(this._inflight).length)\n    // Object.keys(this._inflight).length > 1\n    // console.log(this._active)\n    return this._active !== false // this._timer !== null currently only the sync endoint is allowed to run forever\n  }\n\n  get (paths) {\n    return this._getResponse(['get', paths])\n  }\n\n  set (jsonGraphEnvelope) {\n    return this._getResponse(['set', jsonGraphEnvelope])\n  }\n\n  call (callPath, args, pathSuffixes, paths) {\n    return this._getResponse(['call', callPath, args, pathSuffixes, paths])\n  }\n\n  // Creates an observable stream that will send a request\n  // to a Model server, and retrieve the response.\n  // The request and response are correlated using a unique\n  // identifier which the client sends with the request and\n  // the server echoes back along with the response.\n  _getResponse (action) {\n    const id = this._id++\n\n    if (action[1] !== 'call' && action[1][0] !== '_sync') {\n      // console.log('start', action)\n      this._active = this._active ? this._active + 1 : 1\n    }\n\n    return Observable.create(subscriber => {\n      this._inflight[id] = (error, value, done) => {\n        if (error) {\n          subscriber.onError(error)\n        } else if (done) {\n          subscriber.onCompleted()\n        } else {\n          subscriber.onNext(value)\n        }\n      }\n\n      this._worker.postMessage(JSON.stringify([id, ...action]))\n\n      return () => {\n        delete this._inflight[id]\n        if (action[1] !== 'call' && action[1][0] !== '_sync') {\n          this._active--\n\n          if (this._timer) {\n            clearTimeout(this._timer)\n          }\n          this._timer = setTimeout(() => {\n            // console.log('finishing', action, this._active)\n            this._timer = null\n            if (this._active === 0) {\n              this._active = false\n            }\n          }, 30)\n        }\n      }\n    })\n  }\n}\n/* eslint-enable functional/no-this-expression, functional/no-class */\n\nexport default ServiceWorkerSource\n", "import { makeProxy } from '../lib/proxy-object.js'\nimport { falcor } from '/_ayu/build/deps/falcor.js'\nimport { extractFromCache, setPathValue, getJsonPath } from './helpers.js'\nimport ServiceWorkerSource from './service-worker-source.js'\n\nconst _undefined = Symbol('undefined')\n\n/* eslint-disable functional/no-this-expression, functional/no-class */\n// Implemented like this for compatibilty with practices in falcor\nclass frameScheduler {\n  schedule (action) {\n    let id = requestAnimationFrame(action)\n    return {\n      dispose: () => {\n        if (id) {\n          cancelAnimationFrame(id)\n          id = null\n        }\n      }\n    }\n  }\n  scheduleWithState (state, action) {\n    let id = requestAnimationFrame(() => {\n      action(this, state)\n    })\n    return {\n      dispose: () => {\n        if (id) {\n          cancelAnimationFrame(id)\n          id = null\n        }\n      }\n    }\n  }\n}\n/* eslint-enable functional/no-this-expression, functional/no-class */\n\n\nexport default function makeDataStore ({ source, maxSize, collectRatio, maxRetries, cache, onChange = () => {}, onModelChange, errorSelector, onAccess } = {}) {\n  // let invalidationHandler\n\n  if (typeof source === 'undefined') {\n    source = new ServiceWorkerSource({ wake: 20_000 })\n  }\n  const model = falcor({\n    source: source || undefined,\n    maxSize: maxSize || 500000,\n    collectRatio: collectRatio || 0.75,\n    maxRetries: maxRetries || 1, // todo 0 requires fix in falcor due to falsy check\n    // _useServerPaths: true,\n    cache,\n    scheduler: frameScheduler, // this is the internal scheduler, default to immediate\n    // beforeInvalidate: paths => {\n    //   console.log('before invalidate does not work', paths)\n    //   // if (invalidationHandler) {\n    //   //   invalidationHandler(paths)\n    //   // }\n    // },\n    // Jafar Husain: we notify of changes but you can calculate what changed based on the version annotations from root to any level of detail when you need. this balances the cost of pushing all changes and the cost of polling in a change pull model.\n    onChange: () => {\n      // TODO: batch by frame or already done by internal scheduler?\n      // console.log('falcor model change')\n      update()\n      onModelChange?.()\n    },\n    // comparator: (oldValEnv, newValEnv, path) => {\n    //   if (oldValEnv === newValEnv) {\n    //     return false\n    //   }\n    //   if (oldValEnv && oldValEnv.value && newValEnv && newValEnv.value) {\n    //     if (\n    //       oldValEnv.$type !== newValEnv.$type ||\n    //       oldValEnv.$expires !== newValEnv.$expires\n    //     ) {\n    //       return true\n    //     }\n    //   }\n    //   // HACK: because of probable falcor bug with unwrapperd newVal arg and path wrong\n    //   const newVal = newValEnv && newValEnv.value ? newValEnv.value : newValEnv\n    //   const oldVal = oldValEnv && oldValEnv.value ? oldValEnv.value : oldValEnv\n    //   if (oldVal && oldVal._rev && newVal && newVal._rev) {\n    //     if (oldVal._rev === newVal._rev) {\n    //       return false\n    //     } else {\n    //       console.log('check cache changed')\n    //       console.log({ oldValEnv, newValEnv })\n    //       return true\n    //     }\n    //   }\n    //   console.log({ oldVal, newVal, path })\n    //   return newVal === oldVal\n    // },\n    errorSelector: function (path, error, c) {\n      if (errorSelector) {\n        errorSelector(path, error, c)\n      } else {\n        console.error(path, error, c)\n      }\n      return error\n      // console.log('hasdfhfsdhfsdhdfs', error, path, c)\n      // return error.$expires = -1000 * 60 * 2 // let errors expire in two minutes, bug: does not work\n    }\n  })\n    .treatErrorsAsValues()\n    .batch((new frameScheduler())) // the batch scheduler default to timeout(1) we use the same frame scheduling as internal\n\n  // .treatErrorsAsValues() + boxValues() as standard!!, to se what are errors!\n\n  // TODO: make batch configurable for debugging\n\n  // TODO: model.progressively() instead of extract from cache?\n\n  const boxedModel = model.boxValues()\n\n  // used for serving stale data when falcor cache is invalidated and we do not want to remove all dependent dom nodes until data has been refetched\n  const cacheMap = new Map()\n  let latestTick = 0\n  const lastUpdt = new Map()\n  let ticker = null\n  const deps = {}\n  const keys = new Map()\n  const placeholders = new Map()\n  const duplicates = {}\n\n  // TODO subscribe feature eg. $ { a.b + a.c }\n  // TODO: skip double update in svelte subscriptions\n  const delims = [\n    '$', '$value', // $ is shorthand for $value\n    '$not', // shorthand to be able to do if (x.a$not) instead of if (!x.a$ && !x.a$loading)\n    '$loading',\n    '$promise',\n\n    // TODO:\n    // FIXME: Also expose these as store init functions and allow importing a deep store instead of always the data root!\n    // this allows skipping rerender without fixing the diff checking of svelte\n    '$$', // dereference\n    '$$unbox', // deref and unbox\n    '$$unbatch', // etc. // deref and unbatch\n\n    '$error', '$rev', '$ref', '$version', '$schema', '$timestamp', '$expires', '$size', '$type', '$key', '$refKey' ]\n  const makeAyuProxy = (id, subModel) => makeProxy({\n    id,\n    from: () => {},\n    get: (path, subVal, delim, id) => {\n      if (path[path.length - 1] === '') {\n        path.pop()\n      }\n      path = subModel ? [...subModel.getPath(), ...path] : path\n\n      const name = path[path.length - 1]\n\n      if (name === 'length') {\n        // if an array was sliced before in the proxy it gives us the length of the slice\n        if (typeof subVal === 'number' && subVal > 0) {\n          return subVal\n        }\n      }\n\n      let boxKey = ''\n\n      if (delim && !delims.includes(delim)) {\n        boxKey = delim\n      }\n\n      let curViewKey\n      if (delim === '$key' || delim == '$refKey') {\n        curViewKey = path.slice(0, path.length - 1).join('.')\n\n        if (delim === '$key') {\n          path = path.concat('_id') // FIXME: for $ref case!\n        }\n      }\n\n      const pathString = path.join('.') + (boxKey ? `.${boxKey}` : '')\n      // TODO make dep path prefix configurable for performance vs memory optimization\n\n      if (!deps[id]) {\n        deps[id] = new Map()\n      }\n\n      if (!deps[id].has(pathString)) {\n        deps[id].set(pathString, { path })\n      }\n\n      if (boxKey !== '') {\n        path = path.concat(boxKey)\n      }\n\n      let adjustedModel\n      if (boxKey !== '' || delim === '$ref' || delim === '$refKey') {\n        adjustedModel = subModel ? subModel.boxValues() : boxedModel\n      } else {\n        adjustedModel = subModel || model\n      }\n\n      onAccess?.(path)\n\n      let falcorCacheVal\n      if (delim === '$ref' || delim === '$refKey') {\n        const cacheVEnvelope = getJsonPath(adjustedModel.getCache(path), path)\n        // console.log({cacheVEnvelope})\n        if (cacheVEnvelope?.$type === 'ref') {\n          falcorCacheVal = cacheVEnvelope.value\n        } else if (cacheVEnvelope?.$type === 'atom') {\n          falcorCacheVal = cacheVEnvelope?.$value ? { $type: 'error', value: { message: 'tried using value as reference', val: cacheVEnvelope?.$value } } : _undefined\n        }\n      } else {\n        const falcorCacheRes = extractFromCache({ obj: adjustedModel._root.cache, path })\n        falcorCacheVal = (falcorCacheRes?.value === undefined && falcorCacheRes?.$type === 'atom') ? _undefined : falcorCacheRes.value\n      }\n\n      let cacheVal\n      let existingProm\n      if (typeof falcorCacheVal !== 'undefined') {\n        cacheVal = falcorCacheVal\n      } else {\n        [ cacheVal, existingProm ] = cacheMap.get(pathString) || []\n      }\n\n      let key\n\n      // TODO: properly respect invalidation and expiries\n      if (!ticker) {\n        // start new tick interval\n        ++latestTick\n\n        ticker = requestAnimationFrame(() => {\n          // end the current tick interval, from now everything will request an update from falcor again\n          ++latestTick\n          // we dont need to tick every eventloop, but only the loops with ayu get requests\n          ticker = null\n\n          // at the end of each tick, check if cache got too big\n          if (cacheMap.size > 700_000) {\n            console.info('clearing data store cache')\n            cacheMap.clear()\n          }\n        })\n      }\n\n      let newProm\n      if ((falcorCacheVal === undefined || latestTick !== lastUpdt.get(pathString)) && delim !== '$refKey') {\n        // TODO: instead of undefined delegating to falcor here we can make small\n        // prom that returns from our model cache, gets load off falcor internals\n\n        lastUpdt.set(pathString, latestTick)\n\n        // TODO: use get() instead and use info about box, migrate all internals to envelopes and only unpack in last step\n        newProm = adjustedModel.getValue(path)\n          .then(val => {\n            if (typeof val === 'undefined' || (val?.$type === 'atom' && val?.value === undefined)) {\n              cacheMap.set(pathString, [_undefined])\n\n              if (delim === '$key') {\n                if (cacheVal && cacheVal !== _undefined) {\n                  const viewKeys = keys.get(cacheVal)\n\n                  if (viewKeys && viewKeys[curViewKey]) {\n                    if ((viewKeys._maybeLatest?.latestTick || 0) < viewKeys[curViewKey].latestTick) {\n                      viewKeys._maybeLatest = viewKeys[curViewKey]\n                    }\n                    delete viewKeys[curViewKey]\n                    keys.set(cacheVal, viewKeys)\n                  }\n                }\n\n                placeholders.set(pathString, true)\n                // console.log('undefined value received', { pathString, key, val, curViewKey, keys: [...keys] })\n              }\n            } else {\n              if (delim === '$ref') {\n                if (val.$type === 'ref') {\n                  val = val.value\n                }\n              }\n\n              if (delim === '$key') {\n                if (key) {\n                  const previousViewKeys = keys.get(val) || {}\n                  // if (keys.has(val)) {\n                  //  console.log('existing view key', {previousViewKeys, curViewKey, key, val})\n                  // }\n                  if (!previousViewKeys[curViewKey]) {\n                    previousViewKeys[curViewKey] = { key, latestTick }\n                    keys.set(val, previousViewKeys)\n                    keys.delete(pathString)\n                  }\n                } else if (cacheVal === _undefined || placeholders.has(pathString)) {\n                  // force regeneration of temp ids for appended list entries,\n                  // as otherwise the animation from hidden palceholder to new item is weird\n                  // console.log('force regeneration of temp id', pathString)\n                  keys.delete(pathString)\n                }\n                placeholders.delete(pathString)\n\n                // console.log('value received', { pathString, key, val, curViewKey, keys: [...keys] })\n              }\n\n              cacheMap.set(pathString, [val])\n            }\n            // loading = false\n            return val\n          })\n          .catch(err => {\n            // loading = false\n            return new Promise((_resolve, reject) => reject({\n              message: 'failed falcor get',\n              path,\n              err\n            }))\n          })\n        // loading = true\n        cacheMap.set(pathString, [cacheVal, newProm])\n      }\n\n      if (delim === '$key' || delim === '$refKey') {\n        if (falcorCacheVal === undefined) { //\n          // console.log('undefined value', { cacheVal, falcorCacheVal })\n          if (duplicates.firstIds) {\n            const firstIdPath = (cacheVal && cacheVal !== _undefined) ? duplicates.firstIds.get(`${cacheVal}`) : true\n            if (firstIdPath && firstIdPath !== pathString) {\n              // console.log('duplicate', pathString, duplicates.firstIds.get(`${cacheVal}`), cacheVal)\n              placeholders.set(pathString, { fresh: true })\n            }\n          }\n        }\n\n        if (cacheVal === _undefined || falcorCacheVal === _undefined) {\n          const placeholder = placeholders.get(pathString)\n          // console.log('fresh _undef value')\n          if (placeholder?.fresh || !placeholder) {\n            placeholders.set(pathString, { fresh: false })\n            keys.delete(pathString)\n          }\n        }\n\n        const pathOverride = keys.get(pathString)\n\n        if (cacheVal && cacheVal !== _undefined) {\n          if (delim === '$refKey') {\n            cacheVal = cacheVal.join('.')\n          }\n          const valueOverrides = keys.get(cacheVal)\n          const currentViewValueOverride = valueOverrides?.[curViewKey]\n          const isExpired = currentViewValueOverride ? !((currentViewValueOverride.latestTick + 6) > latestTick) : null\n          const latestValueOverride = valueOverrides ? Object.values(valueOverrides).reduce(\n            (biggest, current) => {\n              if (current.latestTick > biggest.latestTick) {\n                return current\n              }\n              return biggest\n            }, { latestTick: 0 }\n          ) : null\n\n          if (falcorCacheVal !== undefined && falcorCacheVal !== _undefined) {\n            placeholders.delete(pathString)\n            if (duplicates.curViewKey !== curViewKey) {\n              duplicates.curViewKey = curViewKey\n              duplicates.firstIds = new Map()\n            }\n\n            duplicates.firstIds.set(`${cacheVal}`, pathString)\n          }\n\n          // console.log(pathString + ' have: ' , { cacheVal, falcorCacheVal, pathOverride, valueOverrides, currentViewValueOverride, isExpired, latestTick, latestValueOverride, placeholder: placeholders.get(pathString) })\n\n          const noOverrides = !valueOverrides && !pathOverride\n          if (noOverrides) {\n            // console.log('used: cached value without key overrides', cacheVal)\n            return cacheVal\n          }\n\n          if (currentViewValueOverride && !isExpired && !pathOverride) {\n            // console.log('used: ' + currentViewValueOverride.key, { currentViewValueOverride })\n            return currentViewValueOverride.key\n          }\n\n          if (latestValueOverride && !pathOverride && !placeholders.has(pathString)) {\n            // console.log('used: ' + latestValueOverride.key, { latestValueOverride })\n            return latestValueOverride.key\n          }\n\n          if (!currentViewValueOverride && !placeholders.has(pathString)) {\n            if (!valueOverrides) {\n              keys.set(cacheVal, { [curViewKey]: { key: pathOverride, latestTick } })\n            } else {\n              valueOverrides[curViewKey] = { key: pathOverride, latestTick }\n              keys.set(cacheVal, valueOverrides)\n            }\n\n            keys.delete(pathString)\n\n            // console.log('used after set valOverride and del pathString:', {pathOverride})\n            return pathOverride\n          }\n        }\n\n        if (pathOverride) {\n          // console.log('used:', { pathOverride })\n          return pathOverride\n        }\n\n        key = `first_seen_${pathString}_${latestTick} `\n        // console.log('used: new temp id', { key })\n        keys.set(pathString, key)\n        return key\n      }\n\n      let loadingFirstValue = true\n      let value\n\n      // undefined means we don't know the value, _undefined means we know the value is undefined\n      if (typeof cacheVal !== 'undefined') {\n        if (cacheVal === _undefined) {\n          value = undefined\n          loadingFirstValue = false\n        } else {\n          value = cacheVal\n          loadingFirstValue = false\n        }\n      }\n\n      if (delim === '$promise') {\n        if (newProm) {\n          return newProm\n        } else if (existingProm) {\n          return existingProm\n        } else {\n          return Promise.resolve(value)\n        }\n      } else if (delim === '$loading') {\n        return loadingFirstValue\n      } else if (delim === '$not') {\n        return loadingFirstValue ? { toString: () => {''} } : !value\n      } else {\n        if (value?.$type === 'atom') {\n          console.warn('Missing data in ayu data store at:', path)\n          return ''\n        }\n        return loadingFirstValue ? '' : value\n      }\n    },\n\n    set: (path, newValue, delim, _id) => {\n      if (path[path.length - 1] === '') {\n        path.pop()\n      }\n\n      // console.log({ path, newValue, delim, _id })\n\n      path = subModel ? [...subModel.getPath(), ...path] : path\n\n      let boxKey = ''\n      if (delim && !delims.includes(delim)) {\n        boxKey = delim\n      }\n\n      let adjustedModel\n      if (boxKey !== '') {\n        adjustedModel = subModel ? subModel.boxValues() : boxedModel\n        path = path.concat(boxKey)\n      } else {\n        adjustedModel = subModel || model\n      }\n\n      const { parentAtom } = extractFromCache({ obj: adjustedModel._root.cache, path })\n      if (parentAtom) {\n        path = parentAtom.obj.$_absolutePath\n        newValue = setPathValue(parentAtom.obj.value, parentAtom.relPath, newValue)\n      }\n\n      adjustedModel.setValue(path, newValue)\n        .then(() => {})\n        .catch(err => console.error(err))\n\n      return true\n    },\n\n    call: (path, args, _delim, _id) => {\n      return (subModel || model).call(path, args)\n    },\n    delims\n  })\n\n  const runQueue = new Set()\n  const subscribers = new Set()\n  function update () {\n    // console.log('svelte store subscribers updating')\n    if (subscribers.size > 0) {\n      const queueOpener = !runQueue.size\n\n      subscribers.forEach(([run, invalidate, subscriptionProxy, id]) => {\n        let changed = false\n        if (!deps[id]) {\n          changed = true\n        } else {\n          for (const [ pathString, { lastVer, path } ] of deps[id]) {\n            const newVer = model.getVersion(path) // FIXME: path inside atom object are all -1 instead of atom parent value use own getVersion\n\n            // console.log({ newVer, data: model.getCache(path) })\n\n            if (newVer === -1 || !lastVer || lastVer !== newVer) {\n              deps[id].set(pathString, { path, lastVer: newVer })\n              changed = true\n              // break ? how expensive is this vs store code subscriptions executions in svelte?\n            }\n          }\n        }\n\n        if (changed) {\n          invalidate()\n          runQueue.add([run, subscriptionProxy])\n        }\n      })\n\n      if (queueOpener) {\n        runQueue.forEach(([run, subscriptionProxy]) => {\n          run(subscriptionProxy)\n        })\n\n        runQueue.clear()\n      }\n    }\n  }\n\n  let subscrCounter = 0\n  function subscribe (run, invalidate, subModel) {\n    const id = `${subscribers.size}_${subscrCounter++}`\n    const subscriptionProxy = makeAyuProxy(id, subModel)\n\n    const doRun = (..._args) => {\n      return run(..._args)\n    }\n\n    const doInvalidate = (..._args) => {\n      if (invalidate) {\n        return invalidate(..._args)\n      }\n    }\n\n    const subscriber = [doRun, doInvalidate, subscriptionProxy, id]\n\n    subscribers.add(subscriber)\n\n    run(subscriptionProxy)\n\n    return () => {\n      delete deps[id]\n      return subscribers.delete(subscriber)\n    }\n  }\n\n  let seq\n  let timeout\n  const doSync = async () => {\n    try {\n      // TODO: full support for long running observable subscriptions to avoid this loop\n      const data = (await boxedModel.call(['_sync'], [seq]))?.json\n      seq = data?._seq.value || seq\n\n      // TODO: support invalidation and re-preloading by connecting to router\n      onChange({ data, model, _where: 'window' })\n    } catch (err) {\n      console.log(err)\n    } finally {\n      if (timeout) {\n        clearTimeout(timeout)\n      }\n      timeout = setTimeout(() => {\n        timeout = null\n        doSync()\n      }, 5)\n    }\n  }\n\n  async function init () {\n    const userId = await model.getValue(['_session', 'userId'])\n    if (userId) {\n      doSync()\n    }\n  }\n  init()\n\n  // page was restored from the bfcache, sync is broken and needs to be re-initialized\n  self.addEventListener('pageshow', e => {\n    if (e.persisted) {\n      console.log('bf cache resume, retriggering _sync init')\n      clearTimeout(timeout)\n      init()\n    }\n  })\n\n  return {\n    deref: paths => {\n      return paths.map(path => {\n        const subModel = model.deref({ '$__path': path })\n\n        return {\n          subscribe: (run, invalidate) => {\n            return subscribe(run, invalidate, subModel)\n          },\n          set: () => {},\n          falcor: subModel\n        }\n      })\n    },\n\n    subscribe,\n    set: () => {},\n    falcor: model,\n    deps\n  }\n}\n\n// change path detection feature postponed for performance reasons:\n// const cache = model.getCache()\n// const changes = {}\n// diffCache(cache, model).forEach(change => {\n//   changes[change[0]] = change[1]\n// })\n// const entries = Object.entries(changes)\n// for (let i = 0; i < entries.length; i++) {\n//   const entr = entries[i]\n//   const chPath = entr[0].split('.')\n//   const compPath = ['falcor', 'messages', contactId, view, 'length']\n//   while (chPath.length > 0) {\n//     if (chPath.shift() !== compPath.shift()) {\n//       break\n//     }\n//   }\n//   if (chPath.length === 0) {\n//     updatePage = true\n//     break\n//   }\n// invalidationHandler = paths => {\n//  invalidationCache = {}\n//  paths.forEach(path => {\n//    console.log(extractFromCache({obj: model._root.cache, path}).description)\n//  })\n"],
  "mappings": "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",
  "names": ["cleanKey", "id"]
}
