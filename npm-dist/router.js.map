{
  "version": 3,
  "sources": ["../app/build/deps/falcor-observable.js", "../app/build/deps/falcor-router.js", "../app/src/schema/helpers.js", "../app/src/schema/falcor-paths.js", "../app/src/schema/window-paths.js", "../app/src/schema/default-routes.js", "../app/src/lib/url-logger.js", "../app/src/schema/falcor-handlers/index.js", "../app/src/deps/luxon.js", "../app/src/lib/helpers.js", "../app/src/lib/req.js", "../app/src/falcor/router.js"],
  "sourcesContent": ["function getAugmentedNamespace(n) {\n  if (n.__esModule) return n;\n  var f = n.default;\n\tif (typeof f == \"function\") {\n\t\tvar a = function a () {\n\t\t\tif (this instanceof a) {\n        return Reflect.construct(f, arguments, this.constructor);\n\t\t\t}\n\t\t\treturn f.apply(this, arguments);\n\t\t};\n\t\ta.prototype = f.prototype;\n  } else a = {};\n  Object.defineProperty(a, '__esModule', {value: true});\n\tObject.keys(n).forEach(function (k) {\n\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn n[k];\n\t\t\t}\n\t\t});\n\t});\n\treturn a;\n}\n\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n}\n\n/* global window */\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = symbolObservablePonyfill(root);\n\nvar es = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tdefault: result\n});\n\nvar require$$0 = /*@__PURE__*/getAugmentedNamespace(es);\n\nconst symbolError$1 = Symbol(\"try-catch-error\");\nlet lastError                = null;\n\nfunction popError$1()        {\n  if (!lastError) {\n    throw new Error(\"popError may only be called once\");\n  }\n  const { e } = lastError;\n  lastError = null;\n  return e;\n}\n\nlet tryCatch$1                             \n                                          \n                                                         \n                                                                      ;\n\nlet tryCatchResult$1                                               \n                                                            \n                                                                           \n                \n                               \n         \n         \n        \n                              ;\n\n{\n  const throwError = (e       ) => {\n    throw e;\n  };\n\n  tryCatch$1 = (function doTryCatch(f, ...args) {\n    try {\n      f.call(this, ...args);\n    } catch (e) {\n      // See https://github.com/ReactiveX/rxjs/issues/3004#issuecomment-339720668\n      setTimeout(() => { throwError(e); }, 0);\n    }\n  }     );\n\n  tryCatchResult$1 = (function doTryCatchResult(f, ...args) {\n    try {\n      return f.call(this, ...args);\n    } catch (e) {\n      lastError = { e };\n      return symbolError$1;\n    }\n  }     );\n}\n\nvar tryCatch_1 = { tryCatch: tryCatch$1, tryCatchResult: tryCatchResult$1, symbolError: symbolError$1, popError: popError$1 };\n\nconst symbolObservable = require$$0.default;\nconst {\n  tryCatch,\n  tryCatchResult,\n  symbolError,\n  popError\n} = tryCatch_1;\n             \n                     \n                               \n             \n                              \n\n                                                      \n                       \n                             \n                   \n                   \n \n\n                                \n                      \n                   \n \n\n                                                            \n\n                                                \n                                       \n             \n\n                                             \n                                      \n             \n\n                                      \n                                                  \n                              \n                                    \n                         \n  \n\n                                                    \n                                           \n                                           \n \n                                  \n                                                                                \n \n                                           \n                             \n                            \n              \n                \n\n                                                                              \n            \n                                                             \n                                      \n                           \n                   \n \n\n                                                 \n                    \n                        \n\n// Functions to be called within tryCatch().\n\nfunction callNext      (observer                , value   )       {\n  const { next } = observer;\n  if (typeof next === \"function\") {\n    next.call(observer, value);\n  }\n}\n\nfunction callError      (observer                , errorValue   )       {\n  const { error } = observer;\n  if (typeof error === \"function\") {\n    error.call(observer, errorValue);\n  }\n}\n\nfunction callComplete      (observer                )       {\n  const { complete } = observer;\n  if (typeof complete === \"function\") {\n    complete.call(observer);\n  }\n}\n\nfunction callStart      (\n  observer                ,\n  subscription                    \n)       {\n  const { start } = observer;\n  if (typeof start === \"function\") {\n    start.call(observer, subscription);\n  }\n}\n\nfunction callCleanup      (subscription                    ) {\n  const cleanup = subscription._cleanup;\n  if (typeof cleanup === \"function\") {\n    subscription._cleanup = undefined;\n    cleanup();\n  } else if (typeof cleanup === \"object\" && cleanup !== null) {\n    subscription._cleanup = undefined;\n    cleanup.unsubscribe();\n  }\n}\n\nclass SubscriptionObserver              \n                                                                                   {\n                                    \n\n  constructor(subscription                    )       {\n    this._subscription = subscription;\n  }\n\n  next(value   )       {\n    const subscription = this._subscription;\n    const observer = subscription._observer;\n    if (typeof observer === \"undefined\") {\n      return;\n    }\n    tryCatch(callNext, observer, value);\n  }\n\n  error(errorValue   )       {\n    const subscription = this._subscription;\n    const observer = subscription._observer;\n    if (typeof observer === \"undefined\") {\n      return;\n    }\n    subscription._observer = undefined;\n    tryCatch(callError, observer, errorValue);\n    tryCatch(callCleanup, subscription);\n  }\n\n  complete()       {\n    const subscription = this._subscription;\n    const observer = subscription._observer;\n    if (typeof observer === \"undefined\") {\n      return;\n    }\n    subscription._observer = undefined;\n    tryCatch(callComplete, observer);\n    tryCatch(callCleanup, subscription);\n  }\n\n  get closed()          {\n    return typeof this._subscription._observer === \"undefined\";\n  }\n\n  onNext(value   )       {\n    this.next(value);\n  }\n  onError(errorValue   )       {\n    this.error(errorValue);\n  }\n  onCompleted()       {\n    this.complete();\n  }\n  get isStopped()          {\n    return this.closed;\n  }\n}\n\nlet Subscription$1 = class Subscription                                                     {\n                                   \n                    \n\n  constructor(\n    subscriber                              ,\n    observer                \n  )       {\n    this._observer = observer;\n    tryCatch(callStart, observer, this);\n    if (typeof this._observer === \"undefined\") {\n      return;\n    }\n    const subscriptionObserver = new SubscriptionObserver(this);\n    const subscriberResult = tryCatchResult(subscriber, subscriptionObserver);\n    if (subscriberResult === symbolError) {\n      // XXX implies E must always be Error.\n      subscriptionObserver.error((popError()     ));\n      return;\n    }\n    const cleanup          = subscriberResult;\n    if (cleanup === null || typeof cleanup === \"undefined\") {\n      return;\n    }\n    if (typeof cleanup !== \"function\" && typeof cleanup !== \"object\") {\n      throw new TypeError(\n        \"unexpected subscriber result type \" + typeof cleanup\n      );\n    }\n    if (\n      typeof cleanup === \"object\" &&\n      typeof cleanup.unsubscribe !== \"function\"\n    ) {\n      throw new TypeError(\"expected unsubscribe property to be a function\");\n    }\n    this._cleanup = cleanup;\n    if (typeof this._observer === \"undefined\") {\n      tryCatch(callCleanup, this);\n    }\n  }\n\n  unsubscribe()       {\n    const observer = this._observer;\n    if (typeof observer === \"undefined\") {\n      return;\n    }\n    this._observer = undefined;\n    tryCatch(callCleanup, this);\n  }\n\n  get closed()          {\n    return typeof this._observer === \"undefined\";\n  }\n\n  dispose()       {\n    this.unsubscribe();\n  }\n  get isDisposed()          {\n    return this.closed;\n  }\n};\n\nlet EsObservable;\n\nlet BaseObservable$1 = class BaseObservable                                                    {\n                                            \n\n  constructor(subscriber                              )       {\n    if (typeof subscriber !== \"function\") {\n      throw new TypeError(\"Function expected\");\n    }\n    this._subscriber = subscriber;\n  }\n\n  // $FlowFixMe: No symbol or computed property support.\n  [symbolObservable]()                    {\n    return new EsObservable(this._subscriber);\n  }\n\n  // Flow doesn't support returning a differently parameterized this type so\n  // specify types on subclasses instead.\n  pipe(...operators       )      {\n    return this.constructor.from(\n      // $FlowFixMe: No symbol support.\n      operators.reduce((acc, curr) => curr(acc), this[symbolObservable]())\n    );\n  }\n\n  static of(...values     )       {\n    return new this(observer => {\n      for (const value of values) {\n        observer.next(value);\n      }\n      observer.complete();\n    });\n  }\n\n  static from(input                       )       {\n    if (typeof input === \"undefined\" || input === null) {\n      throw new TypeError();\n    }\n\n    if (typeof input === \"object\") {\n      const observableProp                           =\n        // $FlowFixMe: No symbol support.\n        input[symbolObservable];\n      if (typeof observableProp === \"function\") {\n        const observable = observableProp.call(input);\n        if (typeof observable !== \"object\" || observable === null) {\n          throw new TypeError();\n        }\n        if ((observable     ).constructor === this) {\n          return (observable     );\n        }\n        // Avoid additional wrapping between compatible observable implementations.\n        if (observable instanceof BaseObservable) {\n          return new this(observable._subscriber);\n        }\n        return new this(observer => observable.subscribe(observer));\n      }\n      if (typeof input.subscribe === \"function\") {\n        // Not part of ES Observable spec\n        const classic                           = (input     );\n        return new this(observer => {\n          const disposable = classic.subscribe(observer);\n          return () => disposable.dispose();\n        });\n      }\n      if (typeof input.then === \"function\") {\n        // Not part of ES Observable spec\n        const promiseLike                  = (input     );\n        return new this(observer => {\n          promiseLike.then(\n            value => {\n              observer.next(value);\n              observer.complete();\n            },\n            errorValue => {\n              observer.error(errorValue);\n            }\n          );\n        });\n      }\n    }\n\n    // $FlowFixMe: No symbol support.\n    if (typeof input[Symbol.iterator] === \"function\") {\n      return new this(observer => {\n        // $FlowFixMe: No symbol support.\n        for (const value of (input             )) {\n          observer.next(value);\n        }\n        observer.complete();\n      });\n    }\n\n    throw new TypeError();\n  }\n\n  static fromClassicObservable(classic                          )       {\n    return this.from(classic);\n  }\n\n  static empty()       {\n    return new this(observer => {\n      observer.complete();\n    });\n  }\n\n  static throw(errorValue   )       {\n    return new this(observer => {\n      observer.error(errorValue);\n    });\n  }\n\n  static defer(factory                             )       {\n    return new this(observer => {\n      const result = factory();\n      const obs = this.from(result);\n      return new Subscription$1(obs._subscriber, observer);\n    });\n  }\n};\n\n// eslint-disable-next-line no-shadow\nEsObservable = class EsObservable               extends BaseObservable$1      \n                               {\n  subscribe(\n    observerOrOnNext                                        ,\n    onError                          ,\n    onComplete             \n  )                {\n    const observer =\n      typeof observerOrOnNext === \"object\" && observerOrOnNext !== null\n        ? observerOrOnNext\n        : {\n            next: observerOrOnNext,\n            error: onError,\n            complete: onComplete\n          };\n    return new Subscription$1(this._subscriber, observer);\n  }\n\n  // $FlowFixMe: No symbol or computed property support.\n  [symbolObservable]()       {\n    return this;\n  }\n\n  // To pass ES Observable tests these static functions must work without this.\n  static of(...values     )       {\n    const C = typeof this === \"function\" ? this : (EsObservable     );\n    return super.of.call(C, ...values);\n  }\n\n  static from(input                       )       {\n    const C = typeof this === \"function\" ? this : (EsObservable     );\n    return super.from.call(C, input);\n  }\n\n                                    \n                                                                 \n              \n                                      \n                                      \n                               \n                  \n                                      \n                                       \n                                      \n                               \n                      \n                                      \n                                       \n                                       \n                                      \n                               \n                          \n                                      \n                                       \n                                       \n                                       \n                                      \n                               \n                              \n                                      \n                                       \n                                       \n                                       \n                                       \n                                      \n                               \n                                  \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                      \n                               \n                                      \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                      \n                               \n                                          \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                      \n                               \n                                               \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                        \n                                \n                                                                           \n};\n\nvar esObservable = {\n  BaseObservable: BaseObservable$1,\n  Observable: EsObservable,\n  Subscription: Subscription$1\n};\n\nconst { BaseObservable, Subscription } = esObservable;\n\n                                                        \n\n                              \n                  \n                       \n \n\n                                                             \n                         \n                          \n                      \n                      \n \n\n                                             \n                               \n                                \n                           \n  \n\n                                                   \n            \n                                                          \n                                 \n                            \n                 \n \n\n                                                               \n\n                                                       \n                                              \n                    \n\nclass EsFromClassicObserver               {\n                                   \n  constructor(observer                       )       {\n    this._observer = observer;\n  }\n  next(value   )       {\n    const observer = this._observer;\n    const { onNext } = observer;\n    if (typeof onNext === \"function\") {\n      onNext.call(observer, value);\n    }\n  }\n  error(errorValue   )       {\n    const observer = this._observer;\n    const { onError } = observer;\n    if (typeof onError === \"function\") {\n      onError.call(observer, errorValue);\n    }\n  }\n  complete()       {\n    const observer = this._observer;\n    const { onCompleted } = observer;\n    if (typeof onCompleted === \"function\") {\n      onCompleted.call(observer);\n    }\n  }\n}\n\nclass ClassicObservable               extends BaseObservable      \n                                      {\n  subscribe(\n    observerOrOnNext                                               ,\n    onError                     ,\n    onCompleted             \n  )              {\n    const observer =\n      typeof observerOrOnNext === \"object\" && observerOrOnNext !== null\n        ? new EsFromClassicObserver(observerOrOnNext)\n        : {\n            next: observerOrOnNext,\n            error: onError,\n            complete: onCompleted\n          };\n    return new Subscription(this._subscriber, observer);\n  }\n\n  static create(subscriber                                 )       {\n    const C = typeof this === \"function\" ? this : (ClassicObservable     );\n    if (typeof subscriber !== \"function\") {\n      throw new TypeError(\"Function expected\");\n    }\n    return new C(observer => {\n      const cleanup = subscriber(observer);\n      if (typeof cleanup !== \"object\" || cleanup === null) {\n        return cleanup;\n      }\n      if (typeof cleanup.dispose === \"function\") {\n        return () => {\n          cleanup.dispose();\n        };\n      }\n      // Will cause constructor to throw\n      return ({ unsubscribe: cleanup.dispose }     );\n    });\n  }\n\n                                         \n                                                                      \n              \n                                      \n                                      \n                                    \n                  \n                                      \n                                       \n                                      \n                                    \n                      \n                                      \n                                       \n                                       \n                                      \n                                    \n                          \n                                      \n                                       \n                                       \n                                       \n                                      \n                                    \n                              \n                                      \n                                       \n                                       \n                                       \n                                       \n                                      \n                                    \n                                  \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                      \n                                    \n                                      \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                      \n                                    \n                                          \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                      \n                                    \n                                               \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                        \n                                     \n                                                                                \n}\n\nvar classicObservable = { Observable: ClassicObservable };\n\nvar Observable = classicObservable.Observable;\n\nexport { Observable };\n", "var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction getAugmentedNamespace(n) {\n  if (n.__esModule) return n;\n  var f = n.default;\n\tif (typeof f == \"function\") {\n\t\tvar a = function a () {\n\t\t\tif (this instanceof a) {\n        return Reflect.construct(f, arguments, this.constructor);\n\t\t\t}\n\t\t\treturn f.apply(this, arguments);\n\t\t};\n\t\ta.prototype = f.prototype;\n  } else a = {};\n  Object.defineProperty(a, '__esModule', {value: true});\n\tObject.keys(n).forEach(function (k) {\n\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn n[k];\n\t\t\t}\n\t\t});\n\t});\n\treturn a;\n}\n\nvar prefix$1 = String.fromCharCode(30);\n\nvar prefix = prefix$1;\nvar Keys$6 = {\n    ranges: prefix + 'ranges',\n    integers: prefix + 'integers',\n    keys: prefix + 'keys',\n    named: prefix + 'named',\n    name: prefix + 'name',\n    match: prefix + 'match'\n};\n\nvar Keys_1 = Keys$6;\n\nvar isArray$6 = Array.isArray;\nvar convertPathKeyTo$3 = function convertPathKeyTo(onRange, onKey) {\n    return function converter(keySet) {\n        var isKeySet = typeof keySet === 'object';\n        var out = [];\n\n        // The keySet we determine what type is this keyset.\n        if (isKeySet) {\n            if (isArray$6(keySet)) {\n                var reducer = null;\n                keySet.forEach(function(key) {\n                    if (typeof key === 'object') {\n                        reducer = onRange(out, key, reducer);\n                    }\n                    else {\n                        reducer = onKey(out, key, reducer);\n                    }\n                });\n            }\n\n            // What passed in is a range.\n            else {\n                onRange(out, keySet);\n            }\n        }\n\n        // simple value for keyset.\n        else {\n            onKey(out, keySet);\n        }\n\n        return out;\n    };\n};\n\n/**\n * Will determine of the argument is a number.\n *\n * '1' returns true\n * 1 returns true\n * [1] returns false\n * null returns false\n * @param {*} x\n */\n\nvar isNumber$2 = function(x) {\n    return String(Number(x)) === String(x) && typeof x !== 'object';\n};\n\nvar convertPathKeyTo$2 = convertPathKeyTo$3;\nvar isNumber$1 = isNumber$2;\n\nfunction onRange$2(out, range) {\n    out[out.length] = range;\n}\n\n/**\n * @param {Number|String} key must be a number\n */\nfunction keyReduce(out, key, range) {\n    if (!isNumber$1(key)) {\n        return range;\n    }\n\n    /* eslint-disable no-param-reassign */\n    key = +key;\n    if (range) {\n        if (key - 1 === range.to) {\n            range.to = key;\n        }\n\n        else if (key + 1 === range.from) {\n            range.from = key;\n        }\n\n        else {\n            range = null;\n        }\n    }\n\n    if (!range) {\n        range = {to: key, from: key};\n        out[out.length] = range;\n    }\n    /* eslint-enable no-param-reassign */\n\n    return range;\n}\n\nvar convertPathKeyToRange$1 = convertPathKeyTo$2(onRange$2, keyReduce);\n\nvar rangeToArray$2 = function onRange(range) {\n    var out = [];\n    var i = range.from;\n    var to = range.to;\n    var outIdx = out.length;\n    for (; i <= to; ++i, ++outIdx) {\n        out[outIdx] = i;\n    }\n\n    return out;\n};\n\nvar convertPathKeyTo$1 = convertPathKeyTo$3;\nvar isNumber = isNumber$2;\nvar rangeToArray$1 = rangeToArray$2;\n\nfunction onRange$1(out, range) {\n    var len = out.length - 1;\n    rangeToArray$1(range).forEach(function(el) {\n        out[++len] = el;\n    });\n}\n\nfunction onKey$1(out, key) {\n    if (isNumber(key)) {\n        out[out.length] = key;\n    }\n}\n\n/**\n * will attempt to get integers from the key\n * or keySet provided. assumes everything passed in is an integer\n * or range of integers.\n */\nvar convertPathKeyToIntegers$1 = convertPathKeyTo$1(onRange$1, onKey$1);\n\nvar convertPathKeyTo = convertPathKeyTo$3;\nvar rangeToArray = rangeToArray$2;\n\nfunction onKey(out, key) {\n    out[out.length] = key;\n}\n\nfunction onRange(out, range) {\n    var len = out.length - 1;\n    rangeToArray(range).forEach(function(el) {\n        out[++len] = el;\n    });\n}\n\n/**\n * will attempt to get integers from the key\n * or keySet provided. assumes everything passed in is an integer\n * or range of integers.\n */\nvar convertPathKeyToKeys$1 = convertPathKeyTo(onRange, onKey);\n\n// Disable eslint for import statements\n/* eslint-disable max-len */\nvar Keys$5 = Keys_1;\nvar convertPathKeyToRange = convertPathKeyToRange$1;\nvar convertPathKeyToIntegers = convertPathKeyToIntegers$1;\nvar convertPathKeyToKeys = convertPathKeyToKeys$1;\nvar isArray$5 = Array.isArray;\n/* eslint-enable max-len */\n\n/**\n * takes the path that was matched and converts it to the\n * virtual path.\n */\nvar convertPathToRoute$1 = function convertPathToRoute(path, route) {\n    var matched = [];\n    // Always use virtual path since path can be longer since\n    // it contains suffixes.\n    for (var i = 0, len = route.length; i < len; ++i) {\n\n        if (route[i].type) {\n            var virt = route[i];\n            switch (virt.type) {\n                case Keys$5.ranges:\n                    matched[i] =\n                        convertPathKeyToRange(path[i]);\n                    break;\n                case Keys$5.integers:\n                    matched[i] =\n                        convertPathKeyToIntegers(path[i]);\n                    break;\n                case Keys$5.keys:\n                    matched[i] =\n                        convertPathKeyToKeys(path[i]);\n                    break;\n                default:\n                    var err = new Error('Unknown route type.');\n                    err.throwToNext = true;\n                    break;\n            }\n            if (virt.named) {\n                matched[virt.name] = matched[matched.length - 1];\n            }\n        }\n\n        // Dealing with specific keys or array of specific keys.\n        // If route has an array at this position, arrayify the\n        // path[i] element.\n        else {\n            if (isArray$5(route[i]) && !isArray$5(path[i])) {\n                matched[matched.length] = [path[i]];\n            }\n\n            else {\n                matched[matched.length] = path[i];\n            }\n        }\n    }\n\n    return matched;\n};\n\nvar isPathValue$1 = function(x) {\n    return x.hasOwnProperty('path') && x.hasOwnProperty('value');\n};\n\nvar slice$1 = function slice(args, index) {\n    var len = args.length;\n    var out = [];\n    var j = 0;\n    var i = index;\n    while (i < len) {\n        out[j] = args[i];\n        ++i;\n        ++j;\n    }\n    return out;\n};\n\nvar convertPathToRoute = convertPathToRoute$1;\nvar isPathValue = isPathValue$1;\nvar slice = slice$1;\nvar isArray$4 = Array.isArray;\n\n/**\n *   Creates the named variables and coerces it into its\n * virtual type.\n *\n * @param {Array} route - The route that produced this action wrapper\n * @private\n */\nfunction createNamedVariables(route, action) {\n    return function innerCreateNamedVariables(matchedPath) {\n        var convertedArguments;\n        var len = -1;\n        var restOfArgs = slice(arguments, 1);\n        var isJSONObject = !isArray$4(matchedPath);\n\n        // A set uses a json object\n        if (isJSONObject) {\n            restOfArgs = [];\n            convertedArguments = matchedPath;\n        }\n\n        // Could be an array of pathValues for a set operation.\n        else if (isPathValue(matchedPath[0])) {\n            convertedArguments = [];\n\n            matchedPath.forEach(function(pV) {\n                pV.path = convertPathToRoute(pV.path, route);\n                convertedArguments[++len] = pV;\n            });\n        }\n\n        // else just convert and assign\n        else {\n            convertedArguments =\n                convertPathToRoute(matchedPath, route);\n        }\n        return action.apply(this, [convertedArguments].concat(restOfArgs));\n    };\n}\nvar actionWrapper$1 = createNamedVariables;\n\nvar tokenizer = {exports: {}};\n\nvar TokenTypes$6 = {\n    token: 'token',\n    dotSeparator: '.',\n    commaSeparator: ',',\n    openingBracket: '[',\n    closingBracket: ']',\n    openingBrace: '{',\n    closingBrace: '}',\n    escape: '\\\\',\n    space: ' ',\n    colon: ':',\n    quote: 'quote',\n    unknown: 'unknown'\n};\n\nvar TokenTypes_1 = TokenTypes$6;\n\nvar TokenTypes$5 = TokenTypes_1;\nvar DOT_SEPARATOR = '.';\nvar COMMA_SEPARATOR = ',';\nvar OPENING_BRACKET = '[';\nvar CLOSING_BRACKET = ']';\nvar OPENING_BRACE = '{';\nvar CLOSING_BRACE = '}';\nvar COLON = ':';\nvar ESCAPE = '\\\\';\nvar DOUBLE_OUOTES = '\"';\nvar SINGE_OUOTES = \"'\";\nvar SPACE = \" \";\nvar SPECIAL_CHARACTERS = '\\\\\\'\"[]., ';\nvar EXT_SPECIAL_CHARACTERS = '\\\\{}\\'\"[]., :';\n\nvar Tokenizer$2 = tokenizer.exports = function(string, ext) {\n    this._string = string;\n    this._idx = -1;\n    this._extended = ext;\n    this.parseString = '';\n};\n\nTokenizer$2.prototype = {\n    /**\n     * grabs the next token either from the peek operation or generates the\n     * next token.\n     */\n    next: function() {\n        var nextToken = this._nextToken ?\n            this._nextToken : getNext(this._string, this._idx, this._extended);\n\n        this._idx = nextToken.idx;\n        this._nextToken = false;\n        this.parseString += nextToken.token.token;\n\n        return nextToken.token;\n    },\n\n    /**\n     * will peak but not increment the tokenizer\n     */\n    peek: function() {\n        var nextToken = this._nextToken ?\n            this._nextToken : getNext(this._string, this._idx, this._extended);\n        this._nextToken = nextToken;\n\n        return nextToken.token;\n    }\n};\n\nTokenizer$2.toNumber = function toNumber(x) {\n    if (!isNaN(+x)) {\n        return +x;\n    }\n    return NaN;\n};\n\nfunction toOutput(token, type, done) {\n    return {\n        token: token,\n        done: done,\n        type: type\n    };\n}\n\nfunction getNext(string, idx, ext) {\n    var output = false;\n    var token = '';\n    var specialChars = ext ?\n        EXT_SPECIAL_CHARACTERS : SPECIAL_CHARACTERS;\n    var done;\n\n    do {\n\n        done = idx + 1 >= string.length;\n        if (done) {\n            break;\n        }\n\n        // we have to peek at the next token\n        var character = string[idx + 1];\n\n        if (character !== undefined &&\n            specialChars.indexOf(character) === -1) {\n\n            token += character;\n            ++idx;\n            continue;\n        }\n\n        // The token to delimiting character transition.\n        else if (token.length) {\n            break;\n        }\n\n        ++idx;\n        var type;\n        switch (character) {\n            case DOT_SEPARATOR:\n                type = TokenTypes$5.dotSeparator;\n                break;\n            case COMMA_SEPARATOR:\n                type = TokenTypes$5.commaSeparator;\n                break;\n            case OPENING_BRACKET:\n                type = TokenTypes$5.openingBracket;\n                break;\n            case CLOSING_BRACKET:\n                type = TokenTypes$5.closingBracket;\n                break;\n            case OPENING_BRACE:\n                type = TokenTypes$5.openingBrace;\n                break;\n            case CLOSING_BRACE:\n                type = TokenTypes$5.closingBrace;\n                break;\n            case SPACE:\n                type = TokenTypes$5.space;\n                break;\n            case DOUBLE_OUOTES:\n            case SINGE_OUOTES:\n                type = TokenTypes$5.quote;\n                break;\n            case ESCAPE:\n                type = TokenTypes$5.escape;\n                break;\n            case COLON:\n                type = TokenTypes$5.colon;\n                break;\n            default:\n                type = TokenTypes$5.unknown;\n                break;\n        }\n        output = toOutput(character, type, false);\n        break;\n    } while (!done);\n\n    if (!output && token.length) {\n        output = toOutput(token, TokenTypes$5.token, false);\n    }\n\n    if (!output) {\n        output = {done: true};\n    }\n\n    return {\n        token: output,\n        idx: idx\n    };\n}\n\nvar tokenizerExports = tokenizer.exports;\n\nvar exceptions$1 = {\n    indexer: {\n        nested: 'Indexers cannot be nested.',\n        needQuotes: 'unquoted indexers must be numeric.',\n        empty: 'cannot have empty indexers.',\n        leadingDot: 'Indexers cannot have leading dots.',\n        leadingComma: 'Indexers cannot have leading comma.',\n        requiresComma: 'Indexers require commas between indexer args.',\n        routedTokens: 'Only one token can be used per indexer when specifying routed tokens.'\n    },\n    range: {\n        precedingNaN: 'ranges must be preceded by numbers.',\n        suceedingNaN: 'ranges must be suceeded by numbers.'\n    },\n    routed: {\n        invalid: 'Invalid routed token.  only integers|ranges|keys are supported.'\n    },\n    quote: {\n        empty: 'cannot have empty quoted keys.',\n        illegalEscape: 'Invalid escape character.  Only quotes are escapable.'\n    },\n    unexpectedToken: 'Unexpected token.',\n    invalidIdentifier: 'Invalid Identifier.',\n    invalidPath: 'Please provide a valid path.',\n    throwError: function(err, tokenizer, token) {\n        if (token) {\n            throw err + ' -- ' + tokenizer.parseString + ' with next token: ' + token;\n        }\n        throw err + ' -- ' + tokenizer.parseString;\n    }\n};\n\nvar Tokenizer$1 = tokenizerExports;\nvar TokenTypes$4 = TokenTypes_1;\nvar E$4 = exceptions$1;\n\n/**\n * The indexer is all the logic that happens in between\n * the '[', opening bracket, and ']' closing bracket.\n */\nvar range$1 = function range(tokenizer, openingToken, state, out) {\n    var token = tokenizer.peek();\n    var dotCount = 1;\n    var done = false;\n    var inclusive = true;\n\n    // Grab the last token off the stack.  Must be an integer.\n    var idx = state.indexer.length - 1;\n    var from = Tokenizer$1.toNumber(state.indexer[idx]);\n    var to;\n\n    if (isNaN(from)) {\n        E$4.throwError(E$4.range.precedingNaN, tokenizer);\n    }\n\n    // Why is number checking so difficult in javascript.\n\n    while (!done && !token.done) {\n\n        switch (token.type) {\n\n            // dotSeparators at the top level have no meaning\n            case TokenTypes$4.dotSeparator:\n                if (dotCount === 3) {\n                    E$4.throwError(E$4.unexpectedToken, tokenizer);\n                }\n                ++dotCount;\n\n                if (dotCount === 3) {\n                    inclusive = false;\n                }\n                break;\n\n            case TokenTypes$4.token:\n                // move the tokenizer forward and save to.\n                to = Tokenizer$1.toNumber(tokenizer.next().token);\n\n                // throw potential error.\n                if (isNaN(to)) {\n                    E$4.throwError(E$4.range.suceedingNaN, tokenizer);\n                }\n\n                done = true;\n                break;\n\n            default:\n                done = true;\n                break;\n        }\n\n        // Keep cycling through the tokenizer.  But ranges have to peek\n        // before they go to the next token since there is no 'terminating'\n        // character.\n        if (!done) {\n            tokenizer.next();\n\n            // go to the next token without consuming.\n            token = tokenizer.peek();\n        }\n\n        // break and remove state information.\n        else {\n            break;\n        }\n    }\n\n    state.indexer[idx] = {from: from, to: inclusive ? to : to - 1};\n};\n\nvar TokenTypes$3 = TokenTypes_1;\nvar E$3 = exceptions$1;\nvar quoteE = E$3.quote;\n\n/**\n * quote is all the parse tree in between quotes.  This includes the only\n * escaping logic.\n *\n * parse-tree:\n * <opening-quote>(.|(<escape><opening-quote>))*<opening-quote>\n */\nvar quote$1 = function quote(tokenizer, openingToken, state, out) {\n    var token = tokenizer.next();\n    var innerToken = '';\n    var openingQuote = openingToken.token;\n    var escaping = false;\n    var done = false;\n\n    while (!token.done) {\n\n        switch (token.type) {\n            case TokenTypes$3.token:\n            case TokenTypes$3.space:\n\n            case TokenTypes$3.dotSeparator:\n            case TokenTypes$3.commaSeparator:\n\n            case TokenTypes$3.openingBracket:\n            case TokenTypes$3.closingBracket:\n            case TokenTypes$3.openingBrace:\n            case TokenTypes$3.closingBrace:\n                if (escaping) {\n                    E$3.throwError(quoteE.illegalEscape, tokenizer);\n                }\n\n                innerToken += token.token;\n                break;\n\n\n            case TokenTypes$3.quote:\n                // the simple case.  We are escaping\n                if (escaping) {\n                    innerToken += token.token;\n                    escaping = false;\n                }\n\n                // its not a quote that is the opening quote\n                else if (token.token !== openingQuote) {\n                    innerToken += token.token;\n                }\n\n                // last thing left.  Its a quote that is the opening quote\n                // therefore we must produce the inner token of the indexer.\n                else {\n                    done = true;\n                }\n\n                break;\n            case TokenTypes$3.escape:\n                escaping = true;\n                break;\n\n            default:\n                E$3.throwError(E$3.unexpectedToken, tokenizer);\n        }\n\n        // If done, leave loop\n        if (done) {\n            break;\n        }\n\n        // Keep cycling through the tokenizer.\n        token = tokenizer.next();\n    }\n\n    if (innerToken.length === 0) {\n        E$3.throwError(quoteE.empty, tokenizer);\n    }\n\n    state.indexer[state.indexer.length] = innerToken;\n};\n\nvar RoutedTokens$2 = {\n    integers: 'integers',\n    ranges: 'ranges',\n    keys: 'keys'\n};\n\nvar TokenTypes$2 = TokenTypes_1;\nvar RoutedTokens$1 = RoutedTokens$2;\nvar E$2 = exceptions$1;\nvar routedE = E$2.routed;\n\n/**\n * The routing logic.\n *\n * parse-tree:\n * <opening-brace><routed-token>(:<token>)<closing-brace>\n */\nvar routed$1 = function routed(tokenizer, openingToken, state, out) {\n    var routeToken = tokenizer.next();\n    var named = false;\n    var name = '';\n\n    // ensure the routed token is a valid ident.\n    switch (routeToken.token) {\n        case RoutedTokens$1.integers:\n        case RoutedTokens$1.ranges:\n        case RoutedTokens$1.keys:\n            //valid\n            break;\n        default:\n            E$2.throwError(routedE.invalid, tokenizer);\n            break;\n    }\n\n    // Now its time for colon or ending brace.\n    var next = tokenizer.next();\n\n    // we are parsing a named identifier.\n    if (next.type === TokenTypes$2.colon) {\n        named = true;\n\n        // Get the token name.\n        next = tokenizer.next();\n        if (next.type !== TokenTypes$2.token) {\n            E$2.throwError(routedE.invalid, tokenizer);\n        }\n        name = next.token;\n\n        // move to the closing brace.\n        next = tokenizer.next();\n    }\n\n    // must close with a brace.\n\n    if (next.type === TokenTypes$2.closingBrace) {\n        var outputToken = {\n            type: routeToken.token,\n            named: named,\n            name: name\n        };\n        state.indexer[state.indexer.length] = outputToken;\n    }\n\n    // closing brace expected\n    else {\n        E$2.throwError(routedE.invalid, tokenizer);\n    }\n\n};\n\nvar TokenTypes$1 = TokenTypes_1;\nvar E$1 = exceptions$1;\nvar idxE = E$1.indexer;\nvar range = range$1;\nvar quote = quote$1;\nvar routed = routed$1;\n\n/**\n * The indexer is all the logic that happens in between\n * the '[', opening bracket, and ']' closing bracket.\n */\nvar indexer$1 = function indexer(tokenizer, openingToken, state, out) {\n    var token = tokenizer.next();\n    var done = false;\n    var allowedMaxLength = 1;\n    var routedIndexer = false;\n\n    // State variables\n    state.indexer = [];\n\n    while (!token.done) {\n\n        switch (token.type) {\n            case TokenTypes$1.token:\n            case TokenTypes$1.quote:\n\n                // ensures that token adders are properly delimited.\n                if (state.indexer.length === allowedMaxLength) {\n                    E$1.throwError(idxE.requiresComma, tokenizer);\n                }\n                break;\n        }\n\n        switch (token.type) {\n            // Extended syntax case\n            case TokenTypes$1.openingBrace:\n                routedIndexer = true;\n                routed(tokenizer, token, state);\n                break;\n\n\n            case TokenTypes$1.token:\n                var t = +token.token;\n                if (isNaN(t)) {\n                    E$1.throwError(idxE.needQuotes, tokenizer);\n                }\n                state.indexer[state.indexer.length] = t;\n                break;\n\n            // dotSeparators at the top level have no meaning\n            case TokenTypes$1.dotSeparator:\n                if (!state.indexer.length) {\n                    E$1.throwError(idxE.leadingDot, tokenizer);\n                }\n                range(tokenizer, token, state);\n                break;\n\n            // Spaces do nothing.\n            case TokenTypes$1.space:\n                break;\n\n            case TokenTypes$1.closingBracket:\n                done = true;\n                break;\n\n\n            // The quotes require their own tree due to what can be in it.\n            case TokenTypes$1.quote:\n                quote(tokenizer, token, state);\n                break;\n\n\n            // Its time to decend the parse tree.\n            case TokenTypes$1.openingBracket:\n                E$1.throwError(idxE.nested, tokenizer);\n                break;\n\n            case TokenTypes$1.commaSeparator:\n                ++allowedMaxLength;\n                break;\n\n            default:\n                E$1.throwError(E$1.unexpectedToken, tokenizer);\n                break;\n        }\n\n        // If done, leave loop\n        if (done) {\n            break;\n        }\n\n        // Keep cycling through the tokenizer.\n        token = tokenizer.next();\n    }\n\n    if (state.indexer.length === 0) {\n        E$1.throwError(idxE.empty, tokenizer);\n    }\n\n    if (state.indexer.length > 1 && routedIndexer) {\n        E$1.throwError(idxE.routedTokens, tokenizer);\n    }\n\n    // Remember, if an array of 1, keySets will be generated.\n    if (state.indexer.length === 1) {\n        state.indexer = state.indexer[0];\n    }\n\n    out[out.length] = state.indexer;\n\n    // Clean state.\n    state.indexer = undefined;\n};\n\nvar TokenTypes = TokenTypes_1;\nvar E = exceptions$1;\nvar indexer = indexer$1;\n\n/**\n * The top level of the parse tree.  This returns the generated path\n * from the tokenizer.\n */\nvar head$1 = function head(tokenizer) {\n    var token = tokenizer.next();\n    var state = {};\n    var out = [];\n\n    while (!token.done) {\n\n        switch (token.type) {\n            case TokenTypes.token:\n                var first = +token.token[0];\n                if (!isNaN(first)) {\n                    E.throwError(E.invalidIdentifier, tokenizer);\n                }\n                out[out.length] = token.token;\n                break;\n\n            // dotSeparators at the top level have no meaning\n            case TokenTypes.dotSeparator:\n                if (out.length === 0) {\n                    E.throwError(E.unexpectedToken, tokenizer);\n                }\n                break;\n\n            // Spaces do nothing.\n            case TokenTypes.space:\n                // NOTE: Spaces at the top level are allowed.\n                // titlesById  .summary is a valid path.\n                break;\n\n\n            // Its time to decend the parse tree.\n            case TokenTypes.openingBracket:\n                indexer(tokenizer, token, state, out);\n                break;\n\n            default:\n                E.throwError(E.unexpectedToken, tokenizer);\n                break;\n        }\n\n        // Keep cycling through the tokenizer.\n        token = tokenizer.next();\n    }\n\n    if (out.length === 0) {\n        E.throwError(E.invalidPath, tokenizer);\n    }\n\n    return out;\n};\n\nvar Tokenizer = tokenizerExports;\nvar head = head$1;\nvar RoutedTokens = RoutedTokens$2;\n\nvar parser = function parser(string, extendedRules) {\n    return head(new Tokenizer(string, extendedRules));\n};\n\nvar src = parser;\n\n// Constructs the paths from paths / pathValues that have strings.\n// If it does not have a string, just moves the value into the return\n// results.\nparser.fromPathsOrPathValues = function(paths, ext) {\n    if (!paths) {\n        return [];\n    }\n\n    var out = [];\n    for (var i = 0, len = paths.length; i < len; i++) {\n\n        // Is the path a string\n        if (typeof paths[i] === 'string') {\n            out[i] = parser(paths[i], ext);\n        }\n\n        // is the path a path value with a string value.\n        else if (typeof paths[i].path === 'string') {\n            out[i] = {\n                path: parser(paths[i].path, ext), value: paths[i].value\n            };\n        }\n\n        // just copy it over.\n        else {\n            out[i] = paths[i];\n        }\n    }\n\n    return out;\n};\n\n// If the argument is a string, this with convert, else just return\n// the path provided.\nparser.fromPath = function(path, ext) {\n    if (!path) {\n        return [];\n    }\n\n    if (typeof path === 'string') {\n        return parser(path, ext);\n    }\n\n    return path;\n};\n\n// Potential routed tokens.\nparser.RoutedTokens = RoutedTokens;\n\nvar Keys$4 = Keys_1;\nvar convertTypes$1 = function convertTypes(virtualPath) {\n    virtualPath.route = virtualPath.route.map(function(key) {\n        if (typeof key === 'object') {\n            switch (key.type) {\n                case 'keys':\n                    key.type = Keys$4.keys;\n                    break;\n                case 'integers':\n                    key.type = Keys$4.integers;\n                    break;\n                case 'ranges':\n                    key.type = Keys$4.ranges;\n                    break;\n                default:\n                    var err = new Error('Unknown route type.');\n                    err.throwToNext = true;\n                    break;\n            }\n        }\n        return key;\n    });\n};\n\nvar Keys$3 = Keys_1;\n\n/**\n * beautify the virtual path, meaning paths with virtual keys will\n * not be displayed as a stringified object but instead as a string.\n *\n * @param {Array} route -\n */\nvar prettifyRoute$1 = function prettifyRoute(route) {\n    var length = 0;\n    var str = [];\n    for (var i = 0, len = route.length; i < len; ++i, ++length) {\n        var value = route[i];\n        if (typeof value === 'object') {\n            value = value.type;\n        }\n\n        if (value === Keys$3.integers) {\n            str[length] = 'integers';\n        }\n\n        else if (value === Keys$3.ranges) {\n            str[length] = 'ranges';\n        }\n\n        else if (value === Keys$3.keys) {\n            str[length] = 'keys';\n        }\n\n        else {\n            if (Array.isArray(value)) {\n                str[length] = JSON.stringify(value);\n            }\n\n            else {\n                str[length] = value;\n            }\n        }\n    }\n\n    return str;\n};\n\n/*eslint-disable*/\n\nvar exceptions = {\n    innerReferences: 'References with inner references are not allowed.',\n    unknown: 'Unknown Error',\n    routeWithSamePrecedence: 'Two routes cannot have the same precedence or path.',\n    circularReference: 'There appears to be a circular reference, maximum reference following exceeded.'\n};\n\nfunction cloneArray$5(arr, index) {\n    var a = [];\n    var len = arr.length;\n    for (var i = index || 0; i < len; i++) {\n        a[i] = arr[i];\n    }\n    return a;\n}\n\nvar cloneArray_1$1 = cloneArray$5;\n\nvar Keys$2 = Keys_1;\nvar actionWrapper = actionWrapper$1;\nvar pathSyntax = src;\nvar convertTypes = convertTypes$1;\nvar prettifyRoute = prettifyRoute$1;\nvar errors$2 = exceptions;\nvar cloneArray$4 = cloneArray_1$1;\nvar ROUTE_ID = -3;\n\nvar parseTree$1 = function parseTree(routes) {\n    var pTree = {};\n    var parseMap = {};\n    routes.forEach(function forEachRoute(route) {\n        // converts the virtual string path to a real path with\n        // extended syntax on.\n        if (typeof route.route === 'string') {\n            route.prettyRoute = route.route;\n            route.route = pathSyntax(route.route, true);\n            convertTypes(route);\n        }\n        if (route.get) {\n            route.getId = ++ROUTE_ID;\n        }\n        if (route.set) {\n            route.setId = ++ROUTE_ID;\n        }\n        if (route.call) {\n            route.callId = ++ROUTE_ID;\n        }\n\n        setHashOrThrowError(parseMap, route);\n        buildParseTree(pTree, route, 0);\n    });\n    return pTree;\n};\n\nfunction buildParseTree(node, routeObject, depth) {\n\n    var route = routeObject.route;\n    var get = routeObject.get;\n    var set = routeObject.set;\n    var call = routeObject.call;\n    var el = route[depth];\n\n    el = !isNaN(+el) && +el || el;\n    var isArray = Array.isArray(el);\n    var i = 0;\n\n    do {\n        var value = el;\n        var next;\n        if (isArray) {\n            value = value[i];\n        }\n\n        // There is a ranged token in this location with / without name.\n        // only happens from parsed path-syntax paths.\n        if (typeof value === 'object') {\n            var routeType = value.type;\n            next = decendTreeByRoutedToken(node, routeType, value);\n        }\n\n        // This is just a simple key.  Could be a ranged key.\n        else {\n            next = decendTreeByRoutedToken(node, value);\n\n            // we have to create a falcor-router virtual object\n            // so that the rest of the algorithm can match and coerse\n            // when needed.\n            if (next) {\n                route[depth] = {type: value, named: false};\n            }\n            else {\n                if (!node[value]) {\n                    node[value] = {};\n                }\n                next = node[value];\n            }\n        }\n\n        // Continue to recurse or put get/set.\n        if (depth + 1 === route.length) {\n\n            // Insert match into routeSyntaxTree\n            var matchObject = next[Keys$2.match] || {};\n            if (!next[Keys$2.match]) {\n                next[Keys$2.match] = matchObject;\n            }\n\n            matchObject.prettyRoute = routeObject.prettyRoute;\n\n            if (get) {\n                matchObject.get = actionWrapper(route, get);\n                matchObject.getId = routeObject.getId;\n            }\n            if (set) {\n                matchObject.set = actionWrapper(route, set);\n                matchObject.setId = routeObject.setId;\n            }\n            if (call) {\n                matchObject.call = actionWrapper(route, call);\n                matchObject.callId = routeObject.callId;\n            }\n        } else {\n            buildParseTree(next, routeObject, depth + 1);\n        }\n\n    } while (isArray && ++i < el.length);\n}\n\n/**\n * ensure that two routes of the same precedence do not get\n * set in.\n */\nfunction setHashOrThrowError(parseMap, routeObject) {\n    var route = routeObject.route;\n    var get = routeObject.get;\n    var set = routeObject.set;\n    var call = routeObject.call;\n\n    getHashesFromRoute(route).\n        map(function mapHashToString(hash) { return hash.join(','); }).\n        forEach(function forEachRouteHash(hash) {\n            if (get && parseMap[hash + 'get'] ||\n                set && parseMap[hash + 'set'] ||\n                    call && parseMap[hash + 'call']) {\n                throw new Error(errors$2.routeWithSamePrecedence + ' ' +\n                               prettifyRoute(route));\n            }\n            if (get) {\n                parseMap[hash + 'get'] = true;\n            }\n            if (set) {\n                parseMap[hash + 'set'] = true;\n            }\n            if (call) {\n                parseMap[hash + 'call'] = true;\n            }\n        });\n}\n\n/**\n * decends the rst and fills in any naming information at the node.\n * if what is passed in is not a routed token identifier, then the return\n * value will be null\n */\nfunction decendTreeByRoutedToken(node, value, routeToken) {\n    var next = null;\n    switch (value) {\n        case Keys$2.keys:\n        case Keys$2.integers:\n        case Keys$2.ranges:\n            next = node[value];\n            if (!next) {\n                next = node[value] = {};\n            }\n            break;\n    }\n    if (next && routeToken) {\n        // matches the naming information on the node.\n        next[Keys$2.named] = routeToken.named;\n        next[Keys$2.name] = routeToken.name;\n    }\n\n    return next;\n}\n\n/**\n * creates a hash of the virtual path where integers and ranges\n * will collide but everything else is unique.\n */\nfunction getHashesFromRoute(route, depth, hashes, hash) {\n    /*eslint-disable no-func-assign, no-param-reassign*/\n    depth = depth || 0;\n    hashes = hashes || [];\n    hash = hash || [];\n    /*eslint-enable no-func-assign, no-param-reassign*/\n\n    var routeValue = route[depth];\n    var isArray = Array.isArray(routeValue);\n    var length = isArray && routeValue.length || 0;\n    var idx = 0;\n    var value;\n\n    if (typeof routeValue === 'object' && !isArray) {\n        value = routeValue.type;\n    }\n\n    else if (!isArray) {\n        value = routeValue;\n    }\n\n    do {\n        if (isArray) {\n            value = routeValue[idx];\n        }\n\n        if (value === Keys$2.integers || value === Keys$2.ranges) {\n            hash[depth] = '__I__';\n        }\n\n        else if (value === Keys$2.keys) {\n            hash[depth] ='__K__';\n        }\n\n        else {\n            hash[depth] = value;\n        }\n\n        // recurse down the routed token\n        if (depth + 1 !== route.length) {\n            getHashesFromRoute(route, depth + 1, hashes, hash);\n        }\n\n        // Or just add it to hashes\n        else {\n            hashes.push(cloneArray$4(hash));\n        }\n    } while (isArray && ++idx < length);\n\n    return hashes;\n}\n\nvar Precedence$1 = {\n    specific: 4,\n    ranges: 2,\n    integers: 2,\n    keys: 1\n};\nvar Precedence_1 = Precedence$1;\n\nvar isArray$3 = Array.isArray;\n\n/**\n * Takes in a keySet and a note attempts to iterate over it.\n * If the value is a primitive, the key will be returned and the note will\n * be marked done\n * If the value is an object, then each value of the range will be returned\n * and when finished the note will be marked done.\n * If the value is an array, each value will be iterated over, if any of the\n * inner values are ranges, those will be iterated over.  When fully done,\n * the note will be marked done.\n *\n * @param {Object|Array|String|Number} keySet -\n * @param {Object} note - The non filled note\n * @returns {String|Number|undefined} - The current iteration value.\n * If undefined, then the keySet is empty\n * @public\n */\nvar iterateKeySet$4 = function iterateKeySet(keySet, note) {\n    if (note.isArray === undefined) {\n        initializeNote(keySet, note);\n    }\n\n    // Array iteration\n    if (note.isArray) {\n        var nextValue;\n\n        // Cycle through the array and pluck out the next value.\n        do {\n            if (note.loaded && note.rangeOffset > note.to) {\n                ++note.arrayOffset;\n                note.loaded = false;\n            }\n\n            var idx = note.arrayOffset, length = keySet.length;\n            if (idx >= length) {\n                note.done = true;\n                break;\n            }\n\n            var el = keySet[note.arrayOffset];\n            var type = typeof el;\n\n            // Inner range iteration.\n            if (type === 'object') {\n                if (!note.loaded) {\n                    initializeRange(el, note);\n                }\n\n                // Empty to/from\n                if (note.empty) {\n                    continue;\n                }\n\n                nextValue = note.rangeOffset++;\n            }\n\n            // Primitive iteration in array.\n            else {\n                ++note.arrayOffset;\n                nextValue = el;\n            }\n        } while (nextValue === undefined);\n\n        return nextValue;\n    }\n\n    // Range iteration\n    else if (note.isObject) {\n        if (!note.loaded) {\n            initializeRange(keySet, note);\n        }\n        if (note.rangeOffset > note.to) {\n            note.done = true;\n            return undefined;\n        }\n\n        return note.rangeOffset++;\n    }\n\n    // Primitive value\n    else {\n        note.done = true;\n        return keySet;\n    }\n};\n\nfunction initializeRange(key, memo) {\n    var from = memo.from = key.from || 0;\n    var to = memo.to = key.to ||\n        (typeof key.length === 'number' &&\n        memo.from + key.length - 1 || 0);\n    memo.rangeOffset = memo.from;\n    memo.loaded = true;\n    if (from > to) {\n        memo.empty = true;\n    }\n}\n\nfunction initializeNote(key, note) {\n    note.done = false;\n    var isObject = note.isObject = !!(key && typeof key === 'object');\n    note.isArray = isObject && isArray$3(key);\n    note.arrayOffset = 0;\n}\n\nvar iterateKeySet$3 = iterateKeySet$4;\n\n/**\n * @param {Array} paths -\n * @returns {Object} -\n */\nvar toTree$1 = function toTree(paths) {\n    return paths.reduce(function(acc, path) {\n        innerToTree(acc, path, 0);\n        return acc;\n    }, {});\n};\n\nfunction innerToTree(seed, path, depth) {\n\n    var keySet = path[depth];\n    var iteratorNote = {};\n    var key;\n    var nextDepth = depth + 1;\n\n    key = iterateKeySet$3(keySet, iteratorNote);\n\n    do {\n\n        var next = seed[key];\n        if (!next) {\n            if (nextDepth === path.length) {\n                seed[key] = null;\n            } else {\n                next = seed[key] = {};\n            }\n        }\n\n        if (nextDepth < path.length) {\n            innerToTree(next, path, nextDepth);\n        }\n\n        if (!iteratorNote.done) {\n            key = iterateKeySet$3(keySet, iteratorNote);\n        }\n    } while (!iteratorNote.done);\n}\n\nvar iterateKeySet$2 = iterateKeySet$4;\n\n/**\n * Tests to see if the intersection should be stripped from the\n * total paths.  The only way this happens currently is if the entirety\n * of the path is contained in the tree.\n * @private\n */\nvar hasIntersection$3 = function hasIntersection(tree, path, depth) {\n    var current = tree;\n    var intersects = true;\n\n    // Continue iteratively going down a path until a complex key is\n    // encountered, then recurse.\n    for (;intersects && depth < path.length; ++depth) {\n        var key = path[depth];\n        var keyType = typeof key;\n\n        // We have to iterate key set\n        if (key && keyType === 'object') {\n            var note = {};\n            var innerKey = iterateKeySet$2(key, note);\n            var nextDepth = depth + 1;\n\n            // Loop through the innerKeys setting the intersects flag\n            // to each result.  Break out on false.\n            do {\n                var next = current[innerKey];\n                intersects = next !== undefined;\n\n                if (intersects) {\n                    intersects = hasIntersection(next, path, nextDepth);\n                }\n                innerKey = iterateKeySet$2(key, note);\n            } while (intersects && !note.done);\n\n            // Since we recursed, we shall not pass any further!\n            break;\n        }\n\n        // Its a simple key, just move forward with the testing.\n        current = current[key];\n        intersects = current !== undefined;\n    }\n\n    return intersects;\n};\n\nvar hasIntersection$2 = hasIntersection$3;\n\n/**\n * Compares the paths passed in with the tree.  Any of the paths that are in\n * the tree will be stripped from the paths.\n *\n * **Does not mutate** the incoming paths object.\n * **Proper subset** only matching.\n *\n * @param {Array} paths - A list of paths (complex or simple) to strip the\n * intersection\n * @param {Object} tree -\n * @public\n */\nvar pathsComplementFromTree = function pathsComplementFromTree(paths, tree) {\n    var out = [];\n    var outLength = -1;\n\n    for (var i = 0, len = paths.length; i < len; ++i) {\n        // If this does not intersect then add it to the output.\n        if (!hasIntersection$2(tree, paths[i], 0)) {\n            out[++outLength] = paths[i];\n        }\n    }\n    return out;\n};\n\nvar hasIntersection$1 = hasIntersection$3;\n\n/**\n * Compares the paths passed in with the tree.  Any of the paths that are in\n * the tree will be stripped from the paths.\n *\n * **Does not mutate** the incoming paths object.\n * **Proper subset** only matching.\n *\n * @param {Array} paths - A list of paths (complex or simple) to strip the\n * intersection\n * @param {Object} tree -\n * @public\n */\nvar pathsComplementFromLengthTree = function pathsComplementFromLengthTree(paths, tree) {\n    var out = [];\n    var outLength = -1;\n\n    for (var i = 0, len = paths.length; i < len; ++i) {\n        // If this does not intersect then add it to the output.\n        var path = paths[i];\n        if (!hasIntersection$1(tree[path.length], path, 0)) {\n            out[++outLength] = path;\n        }\n    }\n    return out;\n};\n\nvar toPaths$1 = {exports: {}};\n\nvar isArray$2 = Array.isArray;\nvar typeOfObject = \"object\";\nvar typeOfString = \"string\";\nvar typeOfNumber = \"number\";\nvar MAX_SAFE_INTEGER = 9007199254740991; // Number.MAX_SAFE_INTEGER in es6\nvar MAX_SAFE_INTEGER_DIGITS = 16; // String(Number.MAX_SAFE_INTEGER).length\nvar MIN_SAFE_INTEGER_DIGITS = 17; // String(Number.MIN_SAFE_INTEGER).length (including sign)\nvar abs = Math.abs;\nvar safeNumberRegEx = /^(0|(\\-?[1-9][0-9]*))$/;\n\n/* jshint forin: false */\ntoPaths$1.exports = function toPaths(lengths) {\n    var pathmap;\n    var allPaths = [];\n    var allPathsLength = 0;\n    for (var length in lengths) {\n        if (isSafeNumber(length) && isObject$1(pathmap = lengths[length])) {\n            var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;\n            var pathsIndex = -1;\n            var pathsCount = paths.length;\n            while (++pathsIndex < pathsCount) {\n                allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);\n            }\n        }\n    }\n    return allPaths;\n};\n\nfunction isObject$1(value) {\n    return value !== null && typeof value === typeOfObject;\n}\n\nfunction collapsePathMap(pathmap, depth, length) {\n\n    var key;\n    var code = getHashCode(String(depth));\n    var subs = Object.create(null);\n\n    var codes = [];\n    var codesIndex = -1;\n    var codesCount = 0;\n\n    var pathsets = [];\n    var pathsetsCount = 0;\n\n    var subPath, subCode,\n        subKeys, subKeysIndex, subKeysCount,\n        subSets, subSetsIndex, subSetsCount,\n        pathset, pathsetIndex, pathsetCount,\n        firstSubKey, pathsetClone;\n\n    subKeys = [];\n    subKeysIndex = -1;\n\n    if (depth < length - 1) {\n\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n\n        while (++subKeysIndex < subKeysCount) {\n            key = subKeys[subKeysIndex];\n            subPath = collapsePathMap(pathmap[key], depth + 1, length);\n            subCode = subPath.code;\n            if(subs[subCode]) {\n                subPath = subs[subCode];\n            } else {\n                codes[codesCount++] = subCode;\n                subPath = subs[subCode] = {\n                    keys: [],\n                    sets: subPath.sets\n                };\n            }\n            code = getHashCode(code + key + subCode);\n\n            isSafeNumber(key) &&\n                subPath.keys.push(parseInt(key, 10)) ||\n                subPath.keys.push(key);\n        }\n\n        while(++codesIndex < codesCount) {\n\n            key = codes[codesIndex];\n            subPath = subs[key];\n            subKeys = subPath.keys;\n            subKeysCount = subKeys.length;\n\n            if (subKeysCount > 0) {\n\n                subSets = subPath.sets;\n                subSetsIndex = -1;\n                subSetsCount = subSets.length;\n                firstSubKey = subKeys[0];\n\n                while (++subSetsIndex < subSetsCount) {\n\n                    pathset = subSets[subSetsIndex];\n                    pathsetIndex = -1;\n                    pathsetCount = pathset.length;\n                    pathsetClone = new Array(pathsetCount + 1);\n                    pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;\n\n                    while (++pathsetIndex < pathsetCount) {\n                        pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];\n                    }\n\n                    pathsets[pathsetsCount++] = pathsetClone;\n                }\n            }\n        }\n    } else {\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n        if (subKeysCount > 1) {\n            pathsets[pathsetsCount++] = [subKeys];\n        } else {\n            pathsets[pathsetsCount++] = subKeys;\n        }\n        while (++subKeysIndex < subKeysCount) {\n            code = getHashCode(code + subKeys[subKeysIndex]);\n        }\n    }\n\n    return {\n        code: code,\n        sets: pathsets\n    };\n}\n\nfunction collapsePathSetIndexes(pathset) {\n\n    var keysetIndex = -1;\n    var keysetCount = pathset.length;\n\n    while (++keysetIndex < keysetCount) {\n        var keyset = pathset[keysetIndex];\n        if (isArray$2(keyset)) {\n            pathset[keysetIndex] = collapseIndex(keyset);\n        }\n    }\n\n    return pathset;\n}\n\n/**\n * Collapse range indexers, e.g. when there is a continuous\n * range in an array, turn it into an object instead:\n *\n * [1,2,3,4,5,6] => {\"from\":1, \"to\":6}\n *\n * @private\n */\nfunction collapseIndex(keyset) {\n\n    // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?\n    // var hash = {};\n    var keyIndex = -1;\n    var keyCount = keyset.length - 1;\n    var isSparseRange = keyCount > 0;\n\n    while (++keyIndex <= keyCount) {\n\n        var key = keyset[keyIndex];\n\n        if (!isSafeNumber(key) /* || hash[key] === true*/ ) {\n            isSparseRange = false;\n            break;\n        }\n        // hash[key] = true;\n        // Cast number indexes to integers.\n        keyset[keyIndex] = parseInt(key, 10);\n    }\n\n    if (isSparseRange === true) {\n\n        keyset.sort(sortListAscending);\n\n        var from = keyset[0];\n        var to = keyset[keyCount];\n\n        // If we re-introduce deduped integer indexers, change this comparson to \"===\".\n        if (to - from <= keyCount) {\n            return {\n                from: from,\n                to: to\n            };\n        }\n    }\n\n    return keyset;\n}\n\nfunction sortListAscending(a, b) {\n    return a - b;\n}\n\n/* jshint forin: false */\nfunction getSortedKeys(map, keys, sort) {\n    var len = 0;\n    for (var key in map) {\n        keys[len++] = key;\n    }\n    if (len > 1) {\n        keys.sort(sort);\n    }\n    return len;\n}\n\nfunction getHashCode(key) {\n    var code = 5381;\n    var index = -1;\n    var count = key.length;\n    while (++index < count) {\n        code = (code << 5) + code + key.charCodeAt(index);\n    }\n    return String(code);\n}\n\n/**\n * Return true if argument is a number or can be cast to a number which\n * roundtrips to the same string.\n * @private\n */\nfunction isSafeNumber(val) {\n    var num = val;\n    var type = typeof val;\n    if (type === typeOfString) {\n        var length = val.length;\n        // Number.MIN_SAFE_INTEGER is 17 digits including the sign.\n        // Anything longer cannot be safe.\n        if (length === 0 || length > MIN_SAFE_INTEGER_DIGITS) {\n            return false;\n        }\n        if (!safeNumberRegEx.test(val)) {\n            return false;\n        }\n        // Number.MAX_SAFE_INTEGER is 16 digits.\n        // Anything shorter must be safe.\n        if (length < MAX_SAFE_INTEGER_DIGITS) {\n            return true;\n        }\n        num = +val;\n    } else if (type !== typeOfNumber) {\n        return false;\n    }\n    // Number.isSafeInteger(num) in es6.\n    return num % 1 === 0 && abs(num) <= MAX_SAFE_INTEGER;\n}\n\n// export for testing\ntoPaths$1.exports._isSafeNumber = isSafeNumber;\n\nvar toPathsExports = toPaths$1.exports;\n\nvar toPaths = toPathsExports;\nvar toTree = toTree$1;\n\nvar collapse$1 = function collapse(paths) {\n    var collapseMap = paths.\n        reduce(function(acc, path) {\n            var len = path.length;\n            if (!acc[len]) {\n                acc[len] = [];\n            }\n            acc[len].push(path);\n            return acc;\n        }, {});\n\n    Object.\n        keys(collapseMap).\n        forEach(function(collapseKey) {\n            collapseMap[collapseKey] = toTree(collapseMap[collapseKey]);\n        });\n\n    return toPaths(collapseMap);\n};\n\nfunction cloneArray$3(arr, index) {\n    var a = [];\n    var len = arr.length;\n    for (var i = index || 0; i < len; i++) {\n        a[i] = arr[i];\n    }\n    return a;\n}\n\nvar cloneArray_1 = cloneArray$3;\n\nvar catAndSlice$2 = function catAndSlice(a, b, slice) {\n    var next = [], i, j, len;\n    for (i = 0, len = a.length; i < len; ++i) {\n        next[i] = a[i];\n    }\n\n    for (j = slice || 0, len = b.length; j < len; ++j, ++i) {\n        next[i] = b[j];\n    }\n\n    return next;\n};\n\nvar types$1 = {\n    $ref: 'ref',\n    $atom: 'atom',\n    $error: 'error'\n};\n\n/*eslint-disable*/\n\nvar errors$1 = {\n    innerReferences: 'References with inner references are not allowed.',\n    circularReference: 'There appears to be a circular reference, maximum reference following exceeded.'\n};\n\nvar cloneArray$2 = cloneArray_1;\nvar $ref$1 = types$1.$ref;\nvar errors = errors$1;\n\n/**\n * performs the simplified cache reference follow.  This\n * differs from get as there is just following and reporting,\n * not much else.\n *\n * @param {Object} cacheRoot\n * @param {Array} ref\n */\nvar followReference$2 = function followReference(cacheRoot, ref, maxRefFollow) {\n    var current = cacheRoot;\n    var refPath = ref;\n    var depth = -1;\n    var length = refPath.length;\n    var key, next, type;\n    var referenceCount = 0;\n\n    while (++depth < length) {\n        key = refPath[depth];\n        next = current[key];\n        type = next && next.$type;\n\n        if (!next || type && type !== $ref$1) {\n            current = next;\n            break;\n        }\n\n        // Show stopper exception.  This route is malformed.\n        if (type && type === $ref$1 && depth + 1 < length) {\n            var err = new Error(errors.innerReferences);\n            err.throwToNext = true;\n            throw err;\n        }\n\n        // potentially follow reference\n        if (depth + 1 === length) {\n            if (type === $ref$1) {\n                depth = -1;\n                refPath = next.value;\n                length = refPath.length;\n                next = cacheRoot;\n                referenceCount++;\n            }\n\n            if (referenceCount > maxRefFollow) {\n                throw new Error(errors.circularReference);\n            }\n        }\n        current = next;\n    }\n\n    return [current, cloneArray$2(refPath)];\n};\n\nvar iterateKeySet$1 = iterateKeySet$4;\nvar cloneArray$1 = cloneArray_1;\nvar catAndSlice$1 = catAndSlice$2;\nvar $types = types$1;\nvar $ref = $types.$ref;\nvar followReference$1 = followReference$2;\n\n/**\n * The fastest possible optimize of paths.\n *\n * What it does:\n * - Any atom short-circuit / found value will be removed from the path.\n * - All paths will be exploded which means that collapse will need to be\n *   ran afterwords.\n * - Any missing path will be optimized as much as possible.\n */\nvar optimizePathSets$1 = function optimizePathSets(cache, paths, maxRefFollow) {\n    var optimized = [];\n    paths.forEach(function(p) {\n        optimizePathSet(cache, cache, p, 0, optimized, [], maxRefFollow);\n    });\n\n    return optimized;\n};\n\n\n/**\n * optimizes one pathSet at a time.\n */\nfunction optimizePathSet(cache, cacheRoot, pathSet,\n                         depth, out, optimizedPath, maxRefFollow) {\n\n    // at missing, report optimized path.\n    if (cache === undefined) {\n        out[out.length] = catAndSlice$1(optimizedPath, pathSet, depth);\n        return;\n    }\n\n    // all other sentinels are short circuited.\n    // Or we found a primitive (which includes null)\n    if (cache === null || (cache.$type && cache.$type !== $ref) ||\n            (typeof cache !== 'object')) {\n        return;\n    }\n\n    // If the reference is the last item in the path then do not\n    // continue to search it.\n    if (cache.$type === $ref && depth === pathSet.length) {\n        return;\n    }\n\n    var keySet = pathSet[depth];\n    var isKeySet = typeof keySet === 'object';\n    var nextDepth = depth + 1;\n    var iteratorNote = false;\n    var key = keySet;\n    if (isKeySet) {\n        iteratorNote = {};\n        key = iterateKeySet$1(keySet, iteratorNote);\n    }\n    var next, nextOptimized;\n    do {\n        next = cache[key];\n        var optimizedPathLength = optimizedPath.length;\n        if (key !== null) {\n            optimizedPath[optimizedPathLength] = key;\n        }\n\n        if (next && next.$type === $ref && nextDepth < pathSet.length) {\n            var refResults =\n                followReference$1(cacheRoot, next.value, maxRefFollow);\n            next = refResults[0];\n\n            // must clone to avoid the mutation from above destroying the cache.\n            nextOptimized = cloneArray$1(refResults[1]);\n        } else {\n            nextOptimized = optimizedPath;\n        }\n\n        optimizePathSet(next, cacheRoot, pathSet, nextDepth,\n                        out, nextOptimized, maxRefFollow);\n        optimizedPath.length = optimizedPathLength;\n\n        if (iteratorNote && !iteratorNote.done) {\n            key = iterateKeySet$1(keySet, iteratorNote);\n        }\n    } while (iteratorNote && !iteratorNote.done);\n}\n\n/**\n * Helper for getPathCount. Used to determine the size of a key or range.\n * @function\n * @param {Object} rangeOrKey\n * @return The size of the key or range passed in.\n */\nfunction getRangeOrKeySize(rangeOrKey) {\n    if (rangeOrKey == null) {\n        return 1;\n    } else if (Array.isArray(rangeOrKey)) {\n        throw new Error(\"Unexpected Array found in keySet: \" + JSON.stringify(rangeOrKey));\n    } else if (typeof rangeOrKey === \"object\") {\n        return getRangeSize(rangeOrKey);\n    } else {\n        return 1;\n    }\n}\n\n/**\n * Returns the size (number of items) in a Range,\n * @function\n * @param {Object} range The Range with both \"from\" and \"to\", or just \"to\"\n * @return The number of items in the range.\n */\nfunction getRangeSize(range) {\n\n    var to = range.to;\n    var length = range.length;\n\n    if (to != null) {\n        if (isNaN(to) || parseInt(to, 10) !== to) {\n            throw new Error(\"Invalid range, 'to' is not an integer: \" + JSON.stringify(range));\n        }\n        var from = range.from || 0;\n        if (isNaN(from) || parseInt(from, 10) !== from) {\n            throw new Error(\"Invalid range, 'from' is not an integer: \" + JSON.stringify(range));\n        }\n        if (from <= to) {\n            return (to - from) + 1;\n        } else {\n            return 0;\n        }\n    } else if (length != null) {\n        if (isNaN(length) || parseInt(length, 10) !== length) {\n            throw new Error(\"Invalid range, 'length' is not an integer: \" + JSON.stringify(range));\n        } else {\n            return length;\n        }\n    } else {\n        throw new Error(\"Invalid range, expected 'to' or 'length': \" + JSON.stringify(range));\n    }\n}\n\n/**\n * Returns a count of the number of paths this pathset\n * represents.\n *\n * For example, [\"foo\", {\"from\":0, \"to\":10}, \"bar\"],\n * would represent 11 paths (0 to 10, inclusive), and\n * [\"foo, [\"baz\", \"boo\"], \"bar\"] would represent 2 paths.\n *\n * @function\n * @param {Object[]} pathSet the path set.\n *\n * @return The number of paths this represents\n */\nfunction getPathCount(pathSet) {\n    if (pathSet.length === 0) {\n        throw new Error(\"All paths must have length larger than zero.\");\n    }\n\n    var numPaths = 1;\n\n    for (var i = 0; i < pathSet.length; i++) {\n        var segment = pathSet[i];\n\n        if (Array.isArray(segment)) {\n\n            var numKeys = 0;\n\n            for (var j = 0; j < segment.length; j++) {\n                var keySet = segment[j];\n\n                numKeys += getRangeOrKeySize(keySet);\n            }\n\n            numPaths *= numKeys;\n\n        } else {\n            numPaths *= getRangeOrKeySize(segment);\n        }\n    }\n\n    return numPaths;\n}\n\n\nvar pathCount = getPathCount;\n\nvar lib = {\n    iterateKeySet: iterateKeySet$4,\n    toTree: toTree$1,\n    pathsComplementFromTree: pathsComplementFromTree,\n    pathsComplementFromLengthTree: pathsComplementFromLengthTree,\n    hasIntersection: hasIntersection$3,\n    toPaths: toPathsExports,\n    collapse: collapse$1,\n    optimizePathSets: optimizePathSets$1,\n    pathCount: pathCount\n};\n\nvar iterateKeySet = lib.iterateKeySet;\n\nvar specific = function specificMatcher(keySet, currentNode) {\n    // --------------------------------------\n    // Specific key\n    // --------------------------------------\n    var iteratorNote = {};\n    var nexts = [];\n\n    var key = iterateKeySet(keySet, iteratorNote);\n    do {\n\n        if (currentNode[key]) {\n            nexts[nexts.length] = key;\n        }\n\n        if (!iteratorNote.done) {\n            key = iterateKeySet(keySet, iteratorNote);\n        }\n    } while (!iteratorNote.done);\n\n    return nexts;\n};\n\nvar isArray$1 = Array.isArray;\n/**\n * plucks any integers from the path key.  Makes no effort\n * to convert the key into any specific format.\n */\nvar pluckIntergers = function pluckIntegers(keySet) {\n    var ints = [];\n\n    if (typeof keySet === 'object') {\n        if (isArray$1(keySet)) {\n            keySet.forEach(function(key) {\n                // Range case\n                if (typeof key === 'object') {\n                    ints[ints.length] = key;\n                }\n\n                else if (!isNaN(+key)) {\n                    ints[ints.length] = +key;\n                }\n            });\n        }\n        // Range case\n        else {\n            ints[ints.length] = keySet;\n        }\n    }\n\n    else if (!isNaN(+keySet)) {\n        ints[ints.length] = +keySet;\n    }\n\n    return ints;\n};\n\n/**\n * Determines if the object is a routed token by hasOwnProperty\n * of type and named\n */\n\nvar isRoutedToken$1 = function isRoutedToken(obj) {\n    return obj.hasOwnProperty('type') && obj.hasOwnProperty('named');\n};\n\nvar CallNotFoundError$1 = {exports: {}};\n\nvar hasRequiredCallNotFoundError;\n\nfunction requireCallNotFoundError () {\n\tif (hasRequiredCallNotFoundError) return CallNotFoundError$1.exports;\n\thasRequiredCallNotFoundError = 1;\n\tvar MESSAGE = 'function does not exist.';\n\tvar CallNotFoundError = CallNotFoundError$1.exports = function CallNotFoundError() {\n\t    this.message = MESSAGE;\n\t    this.stack = (new Error()).stack;\n\t};\n\n\tCallNotFoundError.prototype = new Error();\n\treturn CallNotFoundError$1.exports;\n}\n\nvar Keys$1 = Keys_1;\nvar Precedence = Precedence_1;\nvar cloneArray = cloneArray_1$1;\nvar specificMatcher = specific;\nvar pluckIntegers = pluckIntergers;\nvar pathUtils = lib;\nvar collapse = pathUtils.collapse;\nvar isRoutedToken = isRoutedToken$1;\nvar CallNotFoundError = requireCallNotFoundError();\n\nvar intTypes = [{\n        type: Keys$1.ranges,\n        precedence: Precedence.ranges\n    }, {\n        type: Keys$1.integers,\n        precedence: Precedence.integers\n    }];\nvar keyTypes = [{\n        type: Keys$1.keys,\n        precedence: Precedence.keys\n    }];\nvar allTypes = intTypes.concat(keyTypes);\nvar get = 'get';\nvar set = 'set';\nvar call = 'call';\n\n/**\n * Creates a custom matching function for the match tree.\n * @param Object rst The routed syntax tree\n * @param String method the method to call at the end of the path.\n * @return {matched: Array.<Match>, missingPaths: Array.<Array>}\n */\nvar matcher$1 = function matcher(rst) {\n    /**\n     * This is where the matching is done.  Will recursively\n     * match the paths until it has found all the matchable\n     * functions.\n     * @param {[]} paths\n     */\n    return function innerMatcher(method, paths) {\n        var matched = [];\n        var missing = [];\n        match(rst, paths, method, matched, missing);\n\n        // We are at the end of the path but there is no match and its a\n        // call.  Therefore we are going to throw an informative error.\n        if (method === call && matched.length === 0) {\n            var err = new CallNotFoundError();\n            err.throwToNext = true;\n\n            throw err;\n        }\n\n        // Reduce into groups multiple matched routes into route sets where\n        // each match matches the same route endpoint.  From here we can reduce\n        // the matched paths into the most optimal pathSet with collapse.\n        var reducedMatched = matched.reduce(function(acc, matchedRoute) {\n            if (!acc[matchedRoute.id]) {\n                acc[matchedRoute.id] = [];\n            }\n            acc[matchedRoute.id].push(matchedRoute);\n\n            return acc;\n        }, {});\n\n        var collapsedMatched = [];\n\n        // For every set of matched routes, collapse and reduce its matched set\n        // down to the minimal amount of collapsed sets.\n        Object.\n            keys(reducedMatched).\n            forEach(function(k) {\n                var reducedMatch = reducedMatched[k];\n\n                // If the reduced match is of length one then there is no\n                // need to perform collapsing, as there is nothing to collapse\n                // over.\n                if (reducedMatch.length === 1) {\n                    collapsedMatched.push(reducedMatch[0]);\n                    return;\n                }\n\n                // Since there are more than 1 routes, we need to see if\n                // they can collapse and alter the amount of arrays.\n                var collapsedResults =\n                        collapse(\n                            reducedMatch.\n                                map(function(x) {\n                                    return x.requested;\n                                }));\n\n                // For every collapsed result we use the previously match result\n                // and update its requested and virtual path.  Then add that\n                // match to the collapsedMatched set.\n                collapsedResults.forEach(function(path, i) {\n                    var collapsedMatch = reducedMatch[i];\n                    var reducedVirtualPath = collapsedMatch.virtual;\n                    path.forEach(function(atom, index) {\n\n                        // If its not a routed atom then wholesale replace\n                        if (!isRoutedToken(reducedVirtualPath[index])) {\n                            reducedVirtualPath[index] = atom;\n                        }\n                    });\n                    collapsedMatch.requested = path;\n                    collapsedMatched.push(reducedMatch[i]);\n                });\n            });\n        return collapsedMatched;\n    };\n};\n\nfunction match(\n        curr, path, method, matchedFunctions,\n        missingPaths, depth, requested, virtual, precedence) {\n\n    // Nothing left to match\n    if (!curr) {\n        return;\n    }\n\n    /* eslint-disable no-param-reassign */\n    depth = depth || 0;\n    requested = requested || [];\n    virtual = virtual || [];\n    precedence = precedence || [];\n    matchedFunctions = matchedFunctions || [];\n    /* eslint-disable no-param-reassign */\n\n    // At this point in the traversal we have hit a matching function.\n    // Its time to terminate.\n    // Get: simple method matching\n    // Set/Call: The method is unique.  If the path is not complete,\n    // meaning the depth is equivalent to the length,\n    // then we match a 'get' method, else we match a 'set' or 'call' method.\n    var atEndOfPath = path.length === depth;\n    var isSet = method === set;\n    var isCall = method === call;\n    var methodToUse = method;\n    if ((isCall || isSet) && !atEndOfPath) {\n        methodToUse = get;\n    }\n\n    // Stores the matched result if found along or at the end of\n    // the path.  If we are doing a set and there is no set handler\n    // but there is a get handler, then we need to use the get\n    // handler.  This is so that the current value that is in the\n    // clients cache does not get materialized away.\n    var currentMatch = curr[Keys$1.match];\n\n    // From https://github.com/Netflix/falcor-router/issues/76\n    // Set: When there is no set hander then we should default to running\n    // the get handler so that we do not destroy the client local values.\n    if (currentMatch && isSet && !currentMatch[set]) {\n        methodToUse = get;\n    }\n\n    // Check to see if we have\n    if (currentMatch && currentMatch[methodToUse]) {\n        matchedFunctions[matchedFunctions.length] = {\n\n            // Used for collapsing paths that use routes with multiple\n            // string indexers.\n            id: currentMatch[methodToUse + 'Id'],\n            requested: cloneArray(requested),\n            prettyRoute: currentMatch.prettyRoute,\n            action: currentMatch[methodToUse],\n            authorize: currentMatch.authorize,\n            virtual: cloneArray(virtual),\n            precedence: +(precedence.join('')),\n            suffix: path.slice(depth),\n            isSet: atEndOfPath && isSet,\n            isCall: atEndOfPath && isCall\n        };\n    }\n\n    // If the depth has reached the end then we need to stop recursing.  This\n    // can cause odd side effects with matching against {keys} as the last\n    // argument when a path has been exhausted (undefined is still a key value).\n    //\n    // Example:\n    // route1: [{keys}]\n    // route2: [{keys}][{keys}]\n    //\n    // path: ['('].\n    //\n    // This will match route1 and 2 since we do not bail out on length and there\n    // is a {keys} matcher which will match \"undefined\" value.\n    if (depth === path.length) {\n        return;\n    }\n\n    var keySet = path[depth];\n    var i, len, key, next;\n\n    // -------------------------------------------\n    // Specific key matcher.\n    // -------------------------------------------\n    var specificKeys = specificMatcher(keySet, curr);\n    for (i = 0, len = specificKeys.length; i < len; ++i) {\n        key = specificKeys[i];\n        virtual[depth] = key;\n        requested[depth] = key;\n        precedence[depth] = Precedence.specific;\n\n        // Its time to recurse\n        match(\n            curr[specificKeys[i]],\n            path, method, matchedFunctions,\n            missingPaths, depth + 1,\n            requested, virtual, precedence);\n\n        // Removes the virtual, requested, and precedence info\n        virtual.length = depth;\n        requested.length = depth;\n        precedence.length = depth;\n    }\n\n    var ints = pluckIntegers(keySet);\n    var keys = keySet;\n    var intsLength = ints.length;\n\n    // -------------------------------------------\n    // ints, ranges, and keys matcher.\n    // -------------------------------------------\n    allTypes.\n        filter(function(typeAndPrecedence) {\n            var type = typeAndPrecedence.type;\n            // one extra move required for int types\n            if (type === Keys$1.integers || type === Keys$1.ranges) {\n                return curr[type] && intsLength;\n            }\n            return curr[type];\n        }).\n        forEach(function(typeAndPrecedence) {\n            var type = typeAndPrecedence.type;\n            var prec = typeAndPrecedence.precedence;\n            next = curr[type];\n\n            virtual[depth] = {\n                type: type,\n                named: next[Keys$1.named],\n                name: next[Keys$1.name]\n            };\n\n            // The requested set of info needs to be set either\n            // as ints, if int matchers or keys\n            if (type === Keys$1.integers || type === Keys$1.ranges) {\n                requested[depth] = ints;\n            } else {\n                requested[depth] = keys;\n            }\n\n            precedence[depth] = prec;\n\n            // Continue the matching algo.\n            match(\n                next,\n                path, method, matchedFunctions,\n                missingPaths, depth + 1,\n                requested, virtual, precedence);\n\n            // removes the added keys\n            virtual.length = depth;\n            requested.length = depth;\n            precedence.length = depth;\n        });\n}\n\nvar JSONGraphError$2 = {exports: {}};\n\nvar JSONGraphError$1 = JSONGraphError$2.exports = function JSONGraphError(typeValue) {\n    this.typeValue = typeValue;\n};\nJSONGraphError$1.prototype = new Error();\n\nvar JSONGraphErrorExports = JSONGraphError$2.exports;\n\nvar Observable = {};\n\nvar root$1 = {};\n\nvar hasRequiredRoot;\n\nfunction requireRoot () {\n\tif (hasRequiredRoot) return root$1;\n\thasRequiredRoot = 1;\n\t(function (exports) {\n\t\t/**\n\t\t * window: browser in DOM main thread\n\t\t * self: browser in WebWorker\n\t\t * global: Node.js/other\n\t\t */\n\t\texports.root = (typeof window == 'object' && window.window === window && window\n\t\t    || typeof self == 'object' && self.self === self && self\n\t\t    || typeof commonjsGlobal == 'object' && commonjsGlobal.global === commonjsGlobal && commonjsGlobal);\n\t\tif (!exports.root) {\n\t\t    throw new Error('RxJS could not find any global context (window, self, global)');\n\t\t}\n\t\t\n\t} (root$1));\n\treturn root$1;\n}\n\nvar toSubscriber = {};\n\nvar Subscriber = {};\n\nvar isFunction = {};\n\nvar hasRequiredIsFunction;\n\nfunction requireIsFunction () {\n\tif (hasRequiredIsFunction) return isFunction;\n\thasRequiredIsFunction = 1;\n\tfunction isFunction$1(x) {\n\t    return typeof x === 'function';\n\t}\n\tisFunction.isFunction = isFunction$1;\n\t\n\treturn isFunction;\n}\n\nvar Subscription = {};\n\nvar isArray = {};\n\nvar hasRequiredIsArray;\n\nfunction requireIsArray () {\n\tif (hasRequiredIsArray) return isArray;\n\thasRequiredIsArray = 1;\n\tisArray.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n\t\n\treturn isArray;\n}\n\nvar isObject = {};\n\nvar hasRequiredIsObject;\n\nfunction requireIsObject () {\n\tif (hasRequiredIsObject) return isObject;\n\thasRequiredIsObject = 1;\n\tfunction isObject$1(x) {\n\t    return x != null && typeof x === 'object';\n\t}\n\tisObject.isObject = isObject$1;\n\t\n\treturn isObject;\n}\n\nvar tryCatch = {};\n\nvar errorObject = {};\n\nvar hasRequiredErrorObject;\n\nfunction requireErrorObject () {\n\tif (hasRequiredErrorObject) return errorObject;\n\thasRequiredErrorObject = 1;\n\t// typeof any so that it we don't have to cast when comparing a result to the error object\n\terrorObject.errorObject = { e: {} };\n\t\n\treturn errorObject;\n}\n\nvar hasRequiredTryCatch;\n\nfunction requireTryCatch () {\n\tif (hasRequiredTryCatch) return tryCatch;\n\thasRequiredTryCatch = 1;\n\tvar errorObject_1 = requireErrorObject();\n\tvar tryCatchTarget;\n\tfunction tryCatcher() {\n\t    try {\n\t        return tryCatchTarget.apply(this, arguments);\n\t    }\n\t    catch (e) {\n\t        errorObject_1.errorObject.e = e;\n\t        return errorObject_1.errorObject;\n\t    }\n\t}\n\tfunction tryCatch$1(fn) {\n\t    tryCatchTarget = fn;\n\t    return tryCatcher;\n\t}\n\ttryCatch.tryCatch = tryCatch$1;\n\t\n\treturn tryCatch;\n}\n\nvar UnsubscriptionError = {};\n\nvar hasRequiredUnsubscriptionError;\n\nfunction requireUnsubscriptionError () {\n\tif (hasRequiredUnsubscriptionError) return UnsubscriptionError;\n\thasRequiredUnsubscriptionError = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * An error thrown when one or more errors have occurred during the\n\t * `unsubscribe` of a {@link Subscription}.\n\t */\n\tvar UnsubscriptionError$1 = (function (_super) {\n\t    __extends(UnsubscriptionError, _super);\n\t    function UnsubscriptionError(errors) {\n\t        _super.call(this);\n\t        this.errors = errors;\n\t        var err = Error.call(this, errors ?\n\t            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n  ') : '');\n\t        this.name = err.name = 'UnsubscriptionError';\n\t        this.stack = err.stack;\n\t        this.message = err.message;\n\t    }\n\t    return UnsubscriptionError;\n\t}(Error));\n\tUnsubscriptionError.UnsubscriptionError = UnsubscriptionError$1;\n\t\n\treturn UnsubscriptionError;\n}\n\nvar hasRequiredSubscription;\n\nfunction requireSubscription () {\n\tif (hasRequiredSubscription) return Subscription;\n\thasRequiredSubscription = 1;\n\tvar isArray_1 = requireIsArray();\n\tvar isObject_1 = requireIsObject();\n\tvar isFunction_1 = requireIsFunction();\n\tvar tryCatch_1 = requireTryCatch();\n\tvar errorObject_1 = requireErrorObject();\n\tvar UnsubscriptionError_1 = requireUnsubscriptionError();\n\t/**\n\t * Represents a disposable resource, such as the execution of an Observable. A\n\t * Subscription has one important method, `unsubscribe`, that takes no argument\n\t * and just disposes the resource held by the subscription.\n\t *\n\t * Additionally, subscriptions may be grouped together through the `add()`\n\t * method, which will attach a child Subscription to the current Subscription.\n\t * When a Subscription is unsubscribed, all its children (and its grandchildren)\n\t * will be unsubscribed as well.\n\t *\n\t * @class Subscription\n\t */\n\tvar Subscription$1 = (function () {\n\t    /**\n\t     * @param {function(): void} [unsubscribe] A function describing how to\n\t     * perform the disposal of resources when the `unsubscribe` method is called.\n\t     */\n\t    function Subscription(unsubscribe) {\n\t        /**\n\t         * A flag to indicate whether this Subscription has already been unsubscribed.\n\t         * @type {boolean}\n\t         */\n\t        this.closed = false;\n\t        this._parent = null;\n\t        this._parents = null;\n\t        this._subscriptions = null;\n\t        if (unsubscribe) {\n\t            this._unsubscribe = unsubscribe;\n\t        }\n\t    }\n\t    /**\n\t     * Disposes the resources held by the subscription. May, for instance, cancel\n\t     * an ongoing Observable execution or cancel any other type of work that\n\t     * started when the Subscription was created.\n\t     * @return {void}\n\t     */\n\t    Subscription.prototype.unsubscribe = function () {\n\t        var hasErrors = false;\n\t        var errors;\n\t        if (this.closed) {\n\t            return;\n\t        }\n\t        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n\t        this.closed = true;\n\t        this._parent = null;\n\t        this._parents = null;\n\t        // null out _subscriptions first so any child subscriptions that attempt\n\t        // to remove themselves from this subscription will noop\n\t        this._subscriptions = null;\n\t        var index = -1;\n\t        var len = _parents ? _parents.length : 0;\n\t        // if this._parent is null, then so is this._parents, and we\n\t        // don't have to remove ourselves from any parent subscriptions.\n\t        while (_parent) {\n\t            _parent.remove(this);\n\t            // if this._parents is null or index >= len,\n\t            // then _parent is set to null, and the loop exits\n\t            _parent = ++index < len && _parents[index] || null;\n\t        }\n\t        if (isFunction_1.isFunction(_unsubscribe)) {\n\t            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n\t            if (trial === errorObject_1.errorObject) {\n\t                hasErrors = true;\n\t                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?\n\t                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);\n\t            }\n\t        }\n\t        if (isArray_1.isArray(_subscriptions)) {\n\t            index = -1;\n\t            len = _subscriptions.length;\n\t            while (++index < len) {\n\t                var sub = _subscriptions[index];\n\t                if (isObject_1.isObject(sub)) {\n\t                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n\t                    if (trial === errorObject_1.errorObject) {\n\t                        hasErrors = true;\n\t                        errors = errors || [];\n\t                        var err = errorObject_1.errorObject.e;\n\t                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n\t                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n\t                        }\n\t                        else {\n\t                            errors.push(err);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (hasErrors) {\n\t            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n\t        }\n\t    };\n\t    /**\n\t     * Adds a tear down to be called during the unsubscribe() of this\n\t     * Subscription.\n\t     *\n\t     * If the tear down being added is a subscription that is already\n\t     * unsubscribed, is the same reference `add` is being called on, or is\n\t     * `Subscription.EMPTY`, it will not be added.\n\t     *\n\t     * If this subscription is already in an `closed` state, the passed\n\t     * tear down logic will be executed immediately.\n\t     *\n\t     * @param {TeardownLogic} teardown The additional logic to execute on\n\t     * teardown.\n\t     * @return {Subscription} Returns the Subscription used or created to be\n\t     * added to the inner subscriptions list. This Subscription can be used with\n\t     * `remove()` to remove the passed teardown logic from the inner subscriptions\n\t     * list.\n\t     */\n\t    Subscription.prototype.add = function (teardown) {\n\t        if (!teardown || (teardown === Subscription.EMPTY)) {\n\t            return Subscription.EMPTY;\n\t        }\n\t        if (teardown === this) {\n\t            return this;\n\t        }\n\t        var subscription = teardown;\n\t        switch (typeof teardown) {\n\t            case 'function':\n\t                subscription = new Subscription(teardown);\n\t            case 'object':\n\t                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n\t                    return subscription;\n\t                }\n\t                else if (this.closed) {\n\t                    subscription.unsubscribe();\n\t                    return subscription;\n\t                }\n\t                else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n\t                    var tmp = subscription;\n\t                    subscription = new Subscription();\n\t                    subscription._subscriptions = [tmp];\n\t                }\n\t                break;\n\t            default:\n\t                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n\t        }\n\t        var subscriptions = this._subscriptions || (this._subscriptions = []);\n\t        subscriptions.push(subscription);\n\t        subscription._addParent(this);\n\t        return subscription;\n\t    };\n\t    /**\n\t     * Removes a Subscription from the internal list of subscriptions that will\n\t     * unsubscribe during the unsubscribe process of this Subscription.\n\t     * @param {Subscription} subscription The subscription to remove.\n\t     * @return {void}\n\t     */\n\t    Subscription.prototype.remove = function (subscription) {\n\t        var subscriptions = this._subscriptions;\n\t        if (subscriptions) {\n\t            var subscriptionIndex = subscriptions.indexOf(subscription);\n\t            if (subscriptionIndex !== -1) {\n\t                subscriptions.splice(subscriptionIndex, 1);\n\t            }\n\t        }\n\t    };\n\t    Subscription.prototype._addParent = function (parent) {\n\t        var _a = this, _parent = _a._parent, _parents = _a._parents;\n\t        if (!_parent || _parent === parent) {\n\t            // If we don't have a parent, or the new parent is the same as the\n\t            // current parent, then set this._parent to the new parent.\n\t            this._parent = parent;\n\t        }\n\t        else if (!_parents) {\n\t            // If there's already one parent, but not multiple, allocate an Array to\n\t            // store the rest of the parent Subscriptions.\n\t            this._parents = [parent];\n\t        }\n\t        else if (_parents.indexOf(parent) === -1) {\n\t            // Only add the new parent to the _parents list if it's not already there.\n\t            _parents.push(parent);\n\t        }\n\t    };\n\t    Subscription.EMPTY = (function (empty) {\n\t        empty.closed = true;\n\t        return empty;\n\t    }(new Subscription()));\n\t    return Subscription;\n\t}());\n\tSubscription.Subscription = Subscription$1;\n\tfunction flattenUnsubscriptionErrors(errors) {\n\t    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);\n\t}\n\t\n\treturn Subscription;\n}\n\nvar Observer = {};\n\nvar hasRequiredObserver;\n\nfunction requireObserver () {\n\tif (hasRequiredObserver) return Observer;\n\thasRequiredObserver = 1;\n\tObserver.empty = {\n\t    closed: true,\n\t    next: function (value) { },\n\t    error: function (err) { throw err; },\n\t    complete: function () { }\n\t};\n\t\n\treturn Observer;\n}\n\nvar rxSubscriber = {};\n\nvar hasRequiredRxSubscriber;\n\nfunction requireRxSubscriber () {\n\tif (hasRequiredRxSubscriber) return rxSubscriber;\n\thasRequiredRxSubscriber = 1;\n\tvar root_1 = requireRoot();\n\tvar Symbol = root_1.root.Symbol;\n\trxSubscriber.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n\t    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n\t\n\treturn rxSubscriber;\n}\n\nvar hasRequiredSubscriber;\n\nfunction requireSubscriber () {\n\tif (hasRequiredSubscriber) return Subscriber;\n\thasRequiredSubscriber = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar isFunction_1 = requireIsFunction();\n\tvar Subscription_1 = requireSubscription();\n\tvar Observer_1 = requireObserver();\n\tvar rxSubscriber_1 = requireRxSubscriber();\n\t/**\n\t * Implements the {@link Observer} interface and extends the\n\t * {@link Subscription} class. While the {@link Observer} is the public API for\n\t * consuming the values of an {@link Observable}, all Observers get converted to\n\t * a Subscriber, in order to provide Subscription-like capabilities such as\n\t * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n\t * implementing operators, but it is rarely used as a public API.\n\t *\n\t * @class Subscriber<T>\n\t */\n\tvar Subscriber$1 = (function (_super) {\n\t    __extends(Subscriber, _super);\n\t    /**\n\t     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n\t     * defined Observer or a `next` callback function.\n\t     * @param {function(e: ?any): void} [error] The `error` callback of an\n\t     * Observer.\n\t     * @param {function(): void} [complete] The `complete` callback of an\n\t     * Observer.\n\t     */\n\t    function Subscriber(destinationOrNext, error, complete) {\n\t        _super.call(this);\n\t        this.syncErrorValue = null;\n\t        this.syncErrorThrown = false;\n\t        this.syncErrorThrowable = false;\n\t        this.isStopped = false;\n\t        switch (arguments.length) {\n\t            case 0:\n\t                this.destination = Observer_1.empty;\n\t                break;\n\t            case 1:\n\t                if (!destinationOrNext) {\n\t                    this.destination = Observer_1.empty;\n\t                    break;\n\t                }\n\t                if (typeof destinationOrNext === 'object') {\n\t                    if (destinationOrNext instanceof Subscriber) {\n\t                        this.destination = destinationOrNext;\n\t                        this.destination.add(this);\n\t                    }\n\t                    else {\n\t                        this.syncErrorThrowable = true;\n\t                        this.destination = new SafeSubscriber(this, destinationOrNext);\n\t                    }\n\t                    break;\n\t                }\n\t            default:\n\t                this.syncErrorThrowable = true;\n\t                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n\t                break;\n\t        }\n\t    }\n\t    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };\n\t    /**\n\t     * A static factory for a Subscriber, given a (potentially partial) definition\n\t     * of an Observer.\n\t     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n\t     * @param {function(e: ?any): void} [error] The `error` callback of an\n\t     * Observer.\n\t     * @param {function(): void} [complete] The `complete` callback of an\n\t     * Observer.\n\t     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n\t     * Observer represented by the given arguments.\n\t     */\n\t    Subscriber.create = function (next, error, complete) {\n\t        var subscriber = new Subscriber(next, error, complete);\n\t        subscriber.syncErrorThrowable = false;\n\t        return subscriber;\n\t    };\n\t    /**\n\t     * The {@link Observer} callback to receive notifications of type `next` from\n\t     * the Observable, with a value. The Observable may call this method 0 or more\n\t     * times.\n\t     * @param {T} [value] The `next` value.\n\t     * @return {void}\n\t     */\n\t    Subscriber.prototype.next = function (value) {\n\t        if (!this.isStopped) {\n\t            this._next(value);\n\t        }\n\t    };\n\t    /**\n\t     * The {@link Observer} callback to receive notifications of type `error` from\n\t     * the Observable, with an attached {@link Error}. Notifies the Observer that\n\t     * the Observable has experienced an error condition.\n\t     * @param {any} [err] The `error` exception.\n\t     * @return {void}\n\t     */\n\t    Subscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            this.isStopped = true;\n\t            this._error(err);\n\t        }\n\t    };\n\t    /**\n\t     * The {@link Observer} callback to receive a valueless notification of type\n\t     * `complete` from the Observable. Notifies the Observer that the Observable\n\t     * has finished sending push-based notifications.\n\t     * @return {void}\n\t     */\n\t    Subscriber.prototype.complete = function () {\n\t        if (!this.isStopped) {\n\t            this.isStopped = true;\n\t            this._complete();\n\t        }\n\t    };\n\t    Subscriber.prototype.unsubscribe = function () {\n\t        if (this.closed) {\n\t            return;\n\t        }\n\t        this.isStopped = true;\n\t        _super.prototype.unsubscribe.call(this);\n\t    };\n\t    Subscriber.prototype._next = function (value) {\n\t        this.destination.next(value);\n\t    };\n\t    Subscriber.prototype._error = function (err) {\n\t        this.destination.error(err);\n\t        this.unsubscribe();\n\t    };\n\t    Subscriber.prototype._complete = function () {\n\t        this.destination.complete();\n\t        this.unsubscribe();\n\t    };\n\t    Subscriber.prototype._unsubscribeAndRecycle = function () {\n\t        var _a = this, _parent = _a._parent, _parents = _a._parents;\n\t        this._parent = null;\n\t        this._parents = null;\n\t        this.unsubscribe();\n\t        this.closed = false;\n\t        this.isStopped = false;\n\t        this._parent = _parent;\n\t        this._parents = _parents;\n\t        return this;\n\t    };\n\t    return Subscriber;\n\t}(Subscription_1.Subscription));\n\tSubscriber.Subscriber = Subscriber$1;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar SafeSubscriber = (function (_super) {\n\t    __extends(SafeSubscriber, _super);\n\t    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n\t        _super.call(this);\n\t        this._parentSubscriber = _parentSubscriber;\n\t        var next;\n\t        var context = this;\n\t        if (isFunction_1.isFunction(observerOrNext)) {\n\t            next = observerOrNext;\n\t        }\n\t        else if (observerOrNext) {\n\t            context = observerOrNext;\n\t            next = observerOrNext.next;\n\t            error = observerOrNext.error;\n\t            complete = observerOrNext.complete;\n\t            if (isFunction_1.isFunction(context.unsubscribe)) {\n\t                this.add(context.unsubscribe.bind(context));\n\t            }\n\t            context.unsubscribe = this.unsubscribe.bind(this);\n\t        }\n\t        this._context = context;\n\t        this._next = next;\n\t        this._error = error;\n\t        this._complete = complete;\n\t    }\n\t    SafeSubscriber.prototype.next = function (value) {\n\t        if (!this.isStopped && this._next) {\n\t            var _parentSubscriber = this._parentSubscriber;\n\t            if (!_parentSubscriber.syncErrorThrowable) {\n\t                this.__tryOrUnsub(this._next, value);\n\t            }\n\t            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n\t                this.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            var _parentSubscriber = this._parentSubscriber;\n\t            if (this._error) {\n\t                if (!_parentSubscriber.syncErrorThrowable) {\n\t                    this.__tryOrUnsub(this._error, err);\n\t                    this.unsubscribe();\n\t                }\n\t                else {\n\t                    this.__tryOrSetError(_parentSubscriber, this._error, err);\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t            else if (!_parentSubscriber.syncErrorThrowable) {\n\t                this.unsubscribe();\n\t                throw err;\n\t            }\n\t            else {\n\t                _parentSubscriber.syncErrorValue = err;\n\t                _parentSubscriber.syncErrorThrown = true;\n\t                this.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.complete = function () {\n\t        if (!this.isStopped) {\n\t            var _parentSubscriber = this._parentSubscriber;\n\t            if (this._complete) {\n\t                if (!_parentSubscriber.syncErrorThrowable) {\n\t                    this.__tryOrUnsub(this._complete);\n\t                    this.unsubscribe();\n\t                }\n\t                else {\n\t                    this.__tryOrSetError(_parentSubscriber, this._complete);\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t            else {\n\t                this.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n\t        try {\n\t            fn.call(this._context, value);\n\t        }\n\t        catch (err) {\n\t            this.unsubscribe();\n\t            throw err;\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n\t        try {\n\t            fn.call(this._context, value);\n\t        }\n\t        catch (err) {\n\t            parent.syncErrorValue = err;\n\t            parent.syncErrorThrown = true;\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t    SafeSubscriber.prototype._unsubscribe = function () {\n\t        var _parentSubscriber = this._parentSubscriber;\n\t        this._context = null;\n\t        this._parentSubscriber = null;\n\t        _parentSubscriber.unsubscribe();\n\t    };\n\t    return SafeSubscriber;\n\t}(Subscriber$1));\n\t\n\treturn Subscriber;\n}\n\nvar hasRequiredToSubscriber;\n\nfunction requireToSubscriber () {\n\tif (hasRequiredToSubscriber) return toSubscriber;\n\thasRequiredToSubscriber = 1;\n\tvar Subscriber_1 = requireSubscriber();\n\tvar rxSubscriber_1 = requireRxSubscriber();\n\tvar Observer_1 = requireObserver();\n\tfunction toSubscriber$1(nextOrObserver, error, complete) {\n\t    if (nextOrObserver) {\n\t        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n\t            return nextOrObserver;\n\t        }\n\t        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {\n\t            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n\t        }\n\t    }\n\t    if (!nextOrObserver && !error && !complete) {\n\t        return new Subscriber_1.Subscriber(Observer_1.empty);\n\t    }\n\t    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n\t}\n\ttoSubscriber.toSubscriber = toSubscriber$1;\n\t\n\treturn toSubscriber;\n}\n\nvar observable = {};\n\nvar hasRequiredObservable$1;\n\nfunction requireObservable$1 () {\n\tif (hasRequiredObservable$1) return observable;\n\thasRequiredObservable$1 = 1;\n\tvar root_1 = requireRoot();\n\tfunction getSymbolObservable(context) {\n\t    var $$observable;\n\t    var Symbol = context.Symbol;\n\t    if (typeof Symbol === 'function') {\n\t        if (Symbol.observable) {\n\t            $$observable = Symbol.observable;\n\t        }\n\t        else {\n\t            $$observable = Symbol('observable');\n\t            Symbol.observable = $$observable;\n\t        }\n\t    }\n\t    else {\n\t        $$observable = '@@observable';\n\t    }\n\t    return $$observable;\n\t}\n\tobservable.getSymbolObservable = getSymbolObservable;\n\tobservable.$$observable = getSymbolObservable(root_1.root);\n\t\n\treturn observable;\n}\n\nvar hasRequiredObservable;\n\nfunction requireObservable () {\n\tif (hasRequiredObservable) return Observable;\n\thasRequiredObservable = 1;\n\tvar root_1 = requireRoot();\n\tvar toSubscriber_1 = requireToSubscriber();\n\tvar observable_1 = requireObservable$1();\n\t/**\n\t * A representation of any set of values over any amount of time. This the most basic building block\n\t * of RxJS.\n\t *\n\t * @class Observable<T>\n\t */\n\tvar Observable$1 = (function () {\n\t    /**\n\t     * @constructor\n\t     * @param {Function} subscribe the function that is  called when the Observable is\n\t     * initially subscribed to. This function is given a Subscriber, to which new values\n\t     * can be `next`ed, or an `error` method can be called to raise an error, or\n\t     * `complete` can be called to notify of a successful completion.\n\t     */\n\t    function Observable(subscribe) {\n\t        this._isScalar = false;\n\t        if (subscribe) {\n\t            this._subscribe = subscribe;\n\t        }\n\t    }\n\t    /**\n\t     * Creates a new Observable, with this Observable as the source, and the passed\n\t     * operator defined as the new observable's operator.\n\t     * @method lift\n\t     * @param {Operator} operator the operator defining the operation to take on the observable\n\t     * @return {Observable} a new observable with the Operator applied\n\t     */\n\t    Observable.prototype.lift = function (operator) {\n\t        var observable = new Observable();\n\t        observable.source = this;\n\t        observable.operator = operator;\n\t        return observable;\n\t    };\n\t    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n\t        var operator = this.operator;\n\t        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n\t        if (operator) {\n\t            operator.call(sink, this.source);\n\t        }\n\t        else {\n\t            sink.add(this._trySubscribe(sink));\n\t        }\n\t        if (sink.syncErrorThrowable) {\n\t            sink.syncErrorThrowable = false;\n\t            if (sink.syncErrorThrown) {\n\t                throw sink.syncErrorValue;\n\t            }\n\t        }\n\t        return sink;\n\t    };\n\t    Observable.prototype._trySubscribe = function (sink) {\n\t        try {\n\t            return this._subscribe(sink);\n\t        }\n\t        catch (err) {\n\t            sink.syncErrorThrown = true;\n\t            sink.syncErrorValue = err;\n\t            sink.error(err);\n\t        }\n\t    };\n\t    /**\n\t     * @method forEach\n\t     * @param {Function} next a handler for each value emitted by the observable\n\t     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n\t     * @return {Promise} a promise that either resolves on observable completion or\n\t     *  rejects with the handled error\n\t     */\n\t    Observable.prototype.forEach = function (next, PromiseCtor) {\n\t        var _this = this;\n\t        if (!PromiseCtor) {\n\t            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n\t                PromiseCtor = root_1.root.Rx.config.Promise;\n\t            }\n\t            else if (root_1.root.Promise) {\n\t                PromiseCtor = root_1.root.Promise;\n\t            }\n\t        }\n\t        if (!PromiseCtor) {\n\t            throw new Error('no Promise impl found');\n\t        }\n\t        return new PromiseCtor(function (resolve, reject) {\n\t            var subscription = _this.subscribe(function (value) {\n\t                if (subscription) {\n\t                    // if there is a subscription, then we can surmise\n\t                    // the next handling is asynchronous. Any errors thrown\n\t                    // need to be rejected explicitly and unsubscribe must be\n\t                    // called manually\n\t                    try {\n\t                        next(value);\n\t                    }\n\t                    catch (err) {\n\t                        reject(err);\n\t                        subscription.unsubscribe();\n\t                    }\n\t                }\n\t                else {\n\t                    // if there is NO subscription, then we're getting a nexted\n\t                    // value synchronously during subscription. We can just call it.\n\t                    // If it errors, Observable's `subscribe` will ensure the\n\t                    // unsubscription logic is called, then synchronously rethrow the error.\n\t                    // After that, Promise will trap the error and send it\n\t                    // down the rejection path.\n\t                    next(value);\n\t                }\n\t            }, reject, resolve);\n\t        });\n\t    };\n\t    Observable.prototype._subscribe = function (subscriber) {\n\t        return this.source.subscribe(subscriber);\n\t    };\n\t    /**\n\t     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n\t     * @method Symbol.observable\n\t     * @return {Observable} this instance of the observable\n\t     */\n\t    Observable.prototype[observable_1.$$observable] = function () {\n\t        return this;\n\t    };\n\t    // HACK: Since TypeScript inherits static properties too, we have to\n\t    // fight against TypeScript here so Subject can have a different static create signature\n\t    /**\n\t     * Creates a new cold Observable by calling the Observable constructor\n\t     * @static true\n\t     * @owner Observable\n\t     * @method create\n\t     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n\t     * @return {Observable} a new cold observable\n\t     */\n\t    Observable.create = function (subscribe) {\n\t        return new Observable(subscribe);\n\t    };\n\t    return Observable;\n\t}());\n\tObservable.Observable = Observable$1;\n\t\n\treturn Observable;\n}\n\nvar queue = {};\n\nvar QueueAction = {};\n\nvar AsyncAction = {};\n\nvar Action = {};\n\nvar hasRequiredAction;\n\nfunction requireAction () {\n\tif (hasRequiredAction) return Action;\n\thasRequiredAction = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscription_1 = requireSubscription();\n\t/**\n\t * A unit of work to be executed in a {@link Scheduler}. An action is typically\n\t * created from within a Scheduler and an RxJS user does not need to concern\n\t * themselves about creating and manipulating an Action.\n\t *\n\t * ```ts\n\t * class Action<T> extends Subscription {\n\t *   new (scheduler: Scheduler, work: (state?: T) => void);\n\t *   schedule(state?: T, delay: number = 0): Subscription;\n\t * }\n\t * ```\n\t *\n\t * @class Action<T>\n\t */\n\tvar Action$1 = (function (_super) {\n\t    __extends(Action, _super);\n\t    function Action(scheduler, work) {\n\t        _super.call(this);\n\t    }\n\t    /**\n\t     * Schedules this action on its parent Scheduler for execution. May be passed\n\t     * some context object, `state`. May happen at some point in the future,\n\t     * according to the `delay` parameter, if specified.\n\t     * @param {T} [state] Some contextual data that the `work` function uses when\n\t     * called by the Scheduler.\n\t     * @param {number} [delay] Time to wait before executing the work, where the\n\t     * time unit is implicit and defined by the Scheduler.\n\t     * @return {void}\n\t     */\n\t    Action.prototype.schedule = function (state, delay) {\n\t        return this;\n\t    };\n\t    return Action;\n\t}(Subscription_1.Subscription));\n\tAction.Action = Action$1;\n\t\n\treturn Action;\n}\n\nvar hasRequiredAsyncAction;\n\nfunction requireAsyncAction () {\n\tif (hasRequiredAsyncAction) return AsyncAction;\n\thasRequiredAsyncAction = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar root_1 = requireRoot();\n\tvar Action_1 = requireAction();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar AsyncAction$1 = (function (_super) {\n\t    __extends(AsyncAction, _super);\n\t    function AsyncAction(scheduler, work) {\n\t        _super.call(this, scheduler, work);\n\t        this.scheduler = scheduler;\n\t        this.work = work;\n\t        this.pending = false;\n\t    }\n\t    AsyncAction.prototype.schedule = function (state, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        if (this.closed) {\n\t            return this;\n\t        }\n\t        // Always replace the current state with the new state.\n\t        this.state = state;\n\t        // Set the pending flag indicating that this action has been scheduled, or\n\t        // has recursively rescheduled itself.\n\t        this.pending = true;\n\t        var id = this.id;\n\t        var scheduler = this.scheduler;\n\t        //\n\t        // Important implementation note:\n\t        //\n\t        // Actions only execute once by default, unless rescheduled from within the\n\t        // scheduled callback. This allows us to implement single and repeat\n\t        // actions via the same code path, without adding API surface area, as well\n\t        // as mimic traditional recursion but across asynchronous boundaries.\n\t        //\n\t        // However, JS runtimes and timers distinguish between intervals achieved by\n\t        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n\t        // serial `setTimeout` calls can be individually delayed, which delays\n\t        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n\t        // guarantee the interval callback will be invoked more precisely to the\n\t        // interval period, regardless of load.\n\t        //\n\t        // Therefore, we use `setInterval` to schedule single and repeat actions.\n\t        // If the action reschedules itself with the same delay, the interval is not\n\t        // canceled. If the action doesn't reschedule, or reschedules with a\n\t        // different delay, the interval will be canceled after scheduled callback\n\t        // execution.\n\t        //\n\t        if (id != null) {\n\t            this.id = this.recycleAsyncId(scheduler, id, delay);\n\t        }\n\t        this.delay = delay;\n\t        // If this action has already an async Id, don't request a new one.\n\t        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\t        return this;\n\t    };\n\t    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n\t    };\n\t    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        // If this action is rescheduled with the same delay time, don't clear the interval id.\n\t        if (delay !== null && this.delay === delay) {\n\t            return id;\n\t        }\n\t        // Otherwise, if the action's delay time is different from the current delay,\n\t        // clear the interval id\n\t        return root_1.root.clearInterval(id) && undefined || undefined;\n\t    };\n\t    /**\n\t     * Immediately executes this action and the `work` it contains.\n\t     * @return {any}\n\t     */\n\t    AsyncAction.prototype.execute = function (state, delay) {\n\t        if (this.closed) {\n\t            return new Error('executing a cancelled action');\n\t        }\n\t        this.pending = false;\n\t        var error = this._execute(state, delay);\n\t        if (error) {\n\t            return error;\n\t        }\n\t        else if (this.pending === false && this.id != null) {\n\t            // Dequeue if the action didn't reschedule itself. Don't call\n\t            // unsubscribe(), because the action could reschedule later.\n\t            // For example:\n\t            // ```\n\t            // scheduler.schedule(function doWork(counter) {\n\t            //   /* ... I'm a busy worker bee ... */\n\t            //   var originalAction = this;\n\t            //   /* wait 100ms before rescheduling the action */\n\t            //   setTimeout(function () {\n\t            //     originalAction.schedule(counter + 1);\n\t            //   }, 100);\n\t            // }, 1000);\n\t            // ```\n\t            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n\t        }\n\t    };\n\t    AsyncAction.prototype._execute = function (state, delay) {\n\t        var errored = false;\n\t        var errorValue = undefined;\n\t        try {\n\t            this.work(state);\n\t        }\n\t        catch (e) {\n\t            errored = true;\n\t            errorValue = !!e && e || new Error(e);\n\t        }\n\t        if (errored) {\n\t            this.unsubscribe();\n\t            return errorValue;\n\t        }\n\t    };\n\t    AsyncAction.prototype._unsubscribe = function () {\n\t        var id = this.id;\n\t        var scheduler = this.scheduler;\n\t        var actions = scheduler.actions;\n\t        var index = actions.indexOf(this);\n\t        this.work = null;\n\t        this.delay = null;\n\t        this.state = null;\n\t        this.pending = false;\n\t        this.scheduler = null;\n\t        if (index !== -1) {\n\t            actions.splice(index, 1);\n\t        }\n\t        if (id != null) {\n\t            this.id = this.recycleAsyncId(scheduler, id, null);\n\t        }\n\t    };\n\t    return AsyncAction;\n\t}(Action_1.Action));\n\tAsyncAction.AsyncAction = AsyncAction$1;\n\t\n\treturn AsyncAction;\n}\n\nvar hasRequiredQueueAction;\n\nfunction requireQueueAction () {\n\tif (hasRequiredQueueAction) return QueueAction;\n\thasRequiredQueueAction = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar AsyncAction_1 = requireAsyncAction();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar QueueAction$1 = (function (_super) {\n\t    __extends(QueueAction, _super);\n\t    function QueueAction(scheduler, work) {\n\t        _super.call(this, scheduler, work);\n\t        this.scheduler = scheduler;\n\t        this.work = work;\n\t    }\n\t    QueueAction.prototype.schedule = function (state, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        if (delay > 0) {\n\t            return _super.prototype.schedule.call(this, state, delay);\n\t        }\n\t        this.delay = delay;\n\t        this.state = state;\n\t        this.scheduler.flush(this);\n\t        return this;\n\t    };\n\t    QueueAction.prototype.execute = function (state, delay) {\n\t        return (delay > 0 || this.closed) ?\n\t            _super.prototype.execute.call(this, state, delay) :\n\t            this._execute(state, delay);\n\t    };\n\t    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        // If delay exists and is greater than 0, or if the delay is null (the\n\t        // action wasn't rescheduled) but was originally scheduled as an async\n\t        // action, then recycle as an async action.\n\t        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n\t            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n\t        }\n\t        // Otherwise flush the scheduler starting with this action.\n\t        return scheduler.flush(this);\n\t    };\n\t    return QueueAction;\n\t}(AsyncAction_1.AsyncAction));\n\tQueueAction.QueueAction = QueueAction$1;\n\t\n\treturn QueueAction;\n}\n\nvar QueueScheduler = {};\n\nvar AsyncScheduler = {};\n\nvar Scheduler = {};\n\nvar hasRequiredScheduler;\n\nfunction requireScheduler () {\n\tif (hasRequiredScheduler) return Scheduler;\n\thasRequiredScheduler = 1;\n\t/**\n\t * An execution context and a data structure to order tasks and schedule their\n\t * execution. Provides a notion of (potentially virtual) time, through the\n\t * `now()` getter method.\n\t *\n\t * Each unit of work in a Scheduler is called an {@link Action}.\n\t *\n\t * ```ts\n\t * class Scheduler {\n\t *   now(): number;\n\t *   schedule(work, delay?, state?): Subscription;\n\t * }\n\t * ```\n\t *\n\t * @class Scheduler\n\t */\n\tvar Scheduler$1 = (function () {\n\t    function Scheduler(SchedulerAction, now) {\n\t        if (now === void 0) { now = Scheduler.now; }\n\t        this.SchedulerAction = SchedulerAction;\n\t        this.now = now;\n\t    }\n\t    /**\n\t     * Schedules a function, `work`, for execution. May happen at some point in\n\t     * the future, according to the `delay` parameter, if specified. May be passed\n\t     * some context object, `state`, which will be passed to the `work` function.\n\t     *\n\t     * The given arguments will be processed an stored as an Action object in a\n\t     * queue of actions.\n\t     *\n\t     * @param {function(state: ?T): ?Subscription} work A function representing a\n\t     * task, or some unit of work to be executed by the Scheduler.\n\t     * @param {number} [delay] Time to wait before executing the work, where the\n\t     * time unit is implicit and defined by the Scheduler itself.\n\t     * @param {T} [state] Some contextual data that the `work` function uses when\n\t     * called by the Scheduler.\n\t     * @return {Subscription} A subscription in order to be able to unsubscribe\n\t     * the scheduled work.\n\t     */\n\t    Scheduler.prototype.schedule = function (work, delay, state) {\n\t        if (delay === void 0) { delay = 0; }\n\t        return new this.SchedulerAction(this, work).schedule(state, delay);\n\t    };\n\t    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n\t    return Scheduler;\n\t}());\n\tScheduler.Scheduler = Scheduler$1;\n\t\n\treturn Scheduler;\n}\n\nvar hasRequiredAsyncScheduler;\n\nfunction requireAsyncScheduler () {\n\tif (hasRequiredAsyncScheduler) return AsyncScheduler;\n\thasRequiredAsyncScheduler = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Scheduler_1 = requireScheduler();\n\tvar AsyncScheduler$1 = (function (_super) {\n\t    __extends(AsyncScheduler, _super);\n\t    function AsyncScheduler() {\n\t        _super.apply(this, arguments);\n\t        this.actions = [];\n\t        /**\n\t         * A flag to indicate whether the Scheduler is currently executing a batch of\n\t         * queued actions.\n\t         * @type {boolean}\n\t         */\n\t        this.active = false;\n\t        /**\n\t         * An internal ID used to track the latest asynchronous task such as those\n\t         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n\t         * others.\n\t         * @type {any}\n\t         */\n\t        this.scheduled = undefined;\n\t    }\n\t    AsyncScheduler.prototype.flush = function (action) {\n\t        var actions = this.actions;\n\t        if (this.active) {\n\t            actions.push(action);\n\t            return;\n\t        }\n\t        var error;\n\t        this.active = true;\n\t        do {\n\t            if (error = action.execute(action.state, action.delay)) {\n\t                break;\n\t            }\n\t        } while (action = actions.shift()); // exhaust the scheduler queue\n\t        this.active = false;\n\t        if (error) {\n\t            while (action = actions.shift()) {\n\t                action.unsubscribe();\n\t            }\n\t            throw error;\n\t        }\n\t    };\n\t    return AsyncScheduler;\n\t}(Scheduler_1.Scheduler));\n\tAsyncScheduler.AsyncScheduler = AsyncScheduler$1;\n\t\n\treturn AsyncScheduler;\n}\n\nvar hasRequiredQueueScheduler;\n\nfunction requireQueueScheduler () {\n\tif (hasRequiredQueueScheduler) return QueueScheduler;\n\thasRequiredQueueScheduler = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar AsyncScheduler_1 = requireAsyncScheduler();\n\tvar QueueScheduler$1 = (function (_super) {\n\t    __extends(QueueScheduler, _super);\n\t    function QueueScheduler() {\n\t        _super.apply(this, arguments);\n\t    }\n\t    return QueueScheduler;\n\t}(AsyncScheduler_1.AsyncScheduler));\n\tQueueScheduler.QueueScheduler = QueueScheduler$1;\n\t\n\treturn QueueScheduler;\n}\n\nvar hasRequiredQueue;\n\nfunction requireQueue () {\n\tif (hasRequiredQueue) return queue;\n\thasRequiredQueue = 1;\n\tvar QueueAction_1 = requireQueueAction();\n\tvar QueueScheduler_1 = requireQueueScheduler();\n\tqueue.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);\n\t\n\treturn queue;\n}\n\nvar defer$1 = {};\n\nvar defer = {};\n\nvar DeferObservable = {};\n\nvar subscribeToResult = {};\n\nvar isPromise = {};\n\nvar hasRequiredIsPromise;\n\nfunction requireIsPromise () {\n\tif (hasRequiredIsPromise) return isPromise;\n\thasRequiredIsPromise = 1;\n\tfunction isPromise$1(value) {\n\t    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n\t}\n\tisPromise.isPromise = isPromise$1;\n\t\n\treturn isPromise;\n}\n\nvar iterator = {};\n\nvar hasRequiredIterator;\n\nfunction requireIterator () {\n\tif (hasRequiredIterator) return iterator;\n\thasRequiredIterator = 1;\n\tvar root_1 = requireRoot();\n\tfunction symbolIteratorPonyfill(root) {\n\t    var Symbol = root.Symbol;\n\t    if (typeof Symbol === 'function') {\n\t        if (!Symbol.iterator) {\n\t            Symbol.iterator = Symbol('iterator polyfill');\n\t        }\n\t        return Symbol.iterator;\n\t    }\n\t    else {\n\t        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n\t        var Set_1 = root.Set;\n\t        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {\n\t            return '@@iterator';\n\t        }\n\t        var Map_1 = root.Map;\n\t        // required for compatability with es6-shim\n\t        if (Map_1) {\n\t            var keys = Object.getOwnPropertyNames(Map_1.prototype);\n\t            for (var i = 0; i < keys.length; ++i) {\n\t                var key = keys[i];\n\t                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n\t                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {\n\t                    return key;\n\t                }\n\t            }\n\t        }\n\t        return '@@iterator';\n\t    }\n\t}\n\titerator.symbolIteratorPonyfill = symbolIteratorPonyfill;\n\titerator.$$iterator = symbolIteratorPonyfill(root_1.root);\n\t\n\treturn iterator;\n}\n\nvar InnerSubscriber = {};\n\nvar hasRequiredInnerSubscriber;\n\nfunction requireInnerSubscriber () {\n\tif (hasRequiredInnerSubscriber) return InnerSubscriber;\n\thasRequiredInnerSubscriber = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar InnerSubscriber$1 = (function (_super) {\n\t    __extends(InnerSubscriber, _super);\n\t    function InnerSubscriber(parent, outerValue, outerIndex) {\n\t        _super.call(this);\n\t        this.parent = parent;\n\t        this.outerValue = outerValue;\n\t        this.outerIndex = outerIndex;\n\t        this.index = 0;\n\t    }\n\t    InnerSubscriber.prototype._next = function (value) {\n\t        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n\t    };\n\t    InnerSubscriber.prototype._error = function (error) {\n\t        this.parent.notifyError(error, this);\n\t        this.unsubscribe();\n\t    };\n\t    InnerSubscriber.prototype._complete = function () {\n\t        this.parent.notifyComplete(this);\n\t        this.unsubscribe();\n\t    };\n\t    return InnerSubscriber;\n\t}(Subscriber_1.Subscriber));\n\tInnerSubscriber.InnerSubscriber = InnerSubscriber$1;\n\t\n\treturn InnerSubscriber;\n}\n\nvar hasRequiredSubscribeToResult;\n\nfunction requireSubscribeToResult () {\n\tif (hasRequiredSubscribeToResult) return subscribeToResult;\n\thasRequiredSubscribeToResult = 1;\n\tvar root_1 = requireRoot();\n\tvar isArray_1 = requireIsArray();\n\tvar isPromise_1 = requireIsPromise();\n\tvar isObject_1 = requireIsObject();\n\tvar Observable_1 = requireObservable();\n\tvar iterator_1 = requireIterator();\n\tvar InnerSubscriber_1 = requireInnerSubscriber();\n\tvar observable_1 = requireObservable$1();\n\tfunction subscribeToResult$1(outerSubscriber, result, outerValue, outerIndex) {\n\t    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\t    if (destination.closed) {\n\t        return null;\n\t    }\n\t    if (result instanceof Observable_1.Observable) {\n\t        if (result._isScalar) {\n\t            destination.next(result.value);\n\t            destination.complete();\n\t            return null;\n\t        }\n\t        else {\n\t            return result.subscribe(destination);\n\t        }\n\t    }\n\t    else if (isArray_1.isArray(result)) {\n\t        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n\t            destination.next(result[i]);\n\t        }\n\t        if (!destination.closed) {\n\t            destination.complete();\n\t        }\n\t    }\n\t    else if (isPromise_1.isPromise(result)) {\n\t        result.then(function (value) {\n\t            if (!destination.closed) {\n\t                destination.next(value);\n\t                destination.complete();\n\t            }\n\t        }, function (err) { return destination.error(err); })\n\t            .then(null, function (err) {\n\t            // Escaping the Promise trap: globally throw unhandled errors\n\t            root_1.root.setTimeout(function () { throw err; });\n\t        });\n\t        return destination;\n\t    }\n\t    else if (result && typeof result[iterator_1.$$iterator] === 'function') {\n\t        var iterator = result[iterator_1.$$iterator]();\n\t        do {\n\t            var item = iterator.next();\n\t            if (item.done) {\n\t                destination.complete();\n\t                break;\n\t            }\n\t            destination.next(item.value);\n\t            if (destination.closed) {\n\t                break;\n\t            }\n\t        } while (true);\n\t    }\n\t    else if (result && typeof result[observable_1.$$observable] === 'function') {\n\t        var obs = result[observable_1.$$observable]();\n\t        if (typeof obs.subscribe !== 'function') {\n\t            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n\t        }\n\t        else {\n\t            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n\t        }\n\t    }\n\t    else {\n\t        var value = isObject_1.isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n\t        var msg = (\"You provided \" + value + \" where a stream was expected.\")\n\t            + ' You can provide an Observable, Promise, Array, or Iterable.';\n\t        destination.error(new TypeError(msg));\n\t    }\n\t    return null;\n\t}\n\tsubscribeToResult.subscribeToResult = subscribeToResult$1;\n\t\n\treturn subscribeToResult;\n}\n\nvar OuterSubscriber = {};\n\nvar hasRequiredOuterSubscriber;\n\nfunction requireOuterSubscriber () {\n\tif (hasRequiredOuterSubscriber) return OuterSubscriber;\n\thasRequiredOuterSubscriber = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar OuterSubscriber$1 = (function (_super) {\n\t    __extends(OuterSubscriber, _super);\n\t    function OuterSubscriber() {\n\t        _super.apply(this, arguments);\n\t    }\n\t    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n\t        this.destination.next(innerValue);\n\t    };\n\t    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n\t        this.destination.error(error);\n\t    };\n\t    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        this.destination.complete();\n\t    };\n\t    return OuterSubscriber;\n\t}(Subscriber_1.Subscriber));\n\tOuterSubscriber.OuterSubscriber = OuterSubscriber$1;\n\t\n\treturn OuterSubscriber;\n}\n\nvar hasRequiredDeferObservable;\n\nfunction requireDeferObservable () {\n\tif (hasRequiredDeferObservable) return DeferObservable;\n\thasRequiredDeferObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = requireObservable();\n\tvar subscribeToResult_1 = requireSubscribeToResult();\n\tvar OuterSubscriber_1 = requireOuterSubscriber();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar DeferObservable$1 = (function (_super) {\n\t    __extends(DeferObservable, _super);\n\t    function DeferObservable(observableFactory) {\n\t        _super.call(this);\n\t        this.observableFactory = observableFactory;\n\t    }\n\t    /**\n\t     * Creates an Observable that, on subscribe, calls an Observable factory to\n\t     * make an Observable for each new Observer.\n\t     *\n\t     * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n\t     * is subscribed.\n\t     * </span>\n\t     *\n\t     * <img src=\"./img/defer.png\" width=\"100%\">\n\t     *\n\t     * `defer` allows you to create the Observable only when the Observer\n\t     * subscribes, and create a fresh Observable for each Observer. It waits until\n\t     * an Observer subscribes to it, and then it generates an Observable,\n\t     * typically with an Observable factory function. It does this afresh for each\n\t     * subscriber, so although each subscriber may think it is subscribing to the\n\t     * same Observable, in fact each subscriber gets its own individual\n\t     * Observable.\n\t     *\n\t     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>\n\t     * var clicksOrInterval = Rx.Observable.defer(function () {\n\t     *   if (Math.random() > 0.5) {\n\t     *     return Rx.Observable.fromEvent(document, 'click');\n\t     *   } else {\n\t     *     return Rx.Observable.interval(1000);\n\t     *   }\n\t     * });\n\t     * clicksOrInterval.subscribe(x => console.log(x));\n\t     *\n\t     * // Results in the following behavior:\n\t     * // If the result of Math.random() is greater than 0.5 it will listen\n\t     * // for clicks anywhere on the \"document\"; when document is clicked it\n\t     * // will log a MouseEvent object to the console. If the result is less\n\t     * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n\t     *\n\t     * @see {@link create}\n\t     *\n\t     * @param {function(): Observable|Promise} observableFactory The Observable\n\t     * factory function to invoke for each Observer that subscribes to the output\n\t     * Observable. May also return a Promise, which will be converted on the fly\n\t     * to an Observable.\n\t     * @return {Observable} An Observable whose Observers' subscriptions trigger\n\t     * an invocation of the given Observable factory function.\n\t     * @static true\n\t     * @name defer\n\t     * @owner Observable\n\t     */\n\t    DeferObservable.create = function (observableFactory) {\n\t        return new DeferObservable(observableFactory);\n\t    };\n\t    DeferObservable.prototype._subscribe = function (subscriber) {\n\t        return new DeferSubscriber(subscriber, this.observableFactory);\n\t    };\n\t    return DeferObservable;\n\t}(Observable_1.Observable));\n\tDeferObservable.DeferObservable = DeferObservable$1;\n\tvar DeferSubscriber = (function (_super) {\n\t    __extends(DeferSubscriber, _super);\n\t    function DeferSubscriber(destination, factory) {\n\t        _super.call(this, destination);\n\t        this.factory = factory;\n\t        this.tryDefer();\n\t    }\n\t    DeferSubscriber.prototype.tryDefer = function () {\n\t        try {\n\t            this._callFactory();\n\t        }\n\t        catch (err) {\n\t            this._error(err);\n\t        }\n\t    };\n\t    DeferSubscriber.prototype._callFactory = function () {\n\t        var result = this.factory();\n\t        if (result) {\n\t            this.add(subscribeToResult_1.subscribeToResult(this, result));\n\t        }\n\t    };\n\t    return DeferSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\t\n\treturn DeferObservable;\n}\n\nvar hasRequiredDefer$1;\n\nfunction requireDefer$1 () {\n\tif (hasRequiredDefer$1) return defer;\n\thasRequiredDefer$1 = 1;\n\tvar DeferObservable_1 = requireDeferObservable();\n\tdefer.defer = DeferObservable_1.DeferObservable.create;\n\t\n\treturn defer;\n}\n\nvar hasRequiredDefer;\n\nfunction requireDefer () {\n\tif (hasRequiredDefer) return defer$1;\n\thasRequiredDefer = 1;\n\tvar Observable_1 = requireObservable();\n\tvar defer_1 = requireDefer$1();\n\tObservable_1.Observable.defer = defer_1.defer;\n\t\n\treturn defer$1;\n}\n\nvar of$1 = {};\n\nvar of = {};\n\nvar ArrayObservable = {};\n\nvar ScalarObservable = {};\n\nvar hasRequiredScalarObservable;\n\nfunction requireScalarObservable () {\n\tif (hasRequiredScalarObservable) return ScalarObservable;\n\thasRequiredScalarObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = requireObservable();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar ScalarObservable$1 = (function (_super) {\n\t    __extends(ScalarObservable, _super);\n\t    function ScalarObservable(value, scheduler) {\n\t        _super.call(this);\n\t        this.value = value;\n\t        this.scheduler = scheduler;\n\t        this._isScalar = true;\n\t        if (scheduler) {\n\t            this._isScalar = false;\n\t        }\n\t    }\n\t    ScalarObservable.create = function (value, scheduler) {\n\t        return new ScalarObservable(value, scheduler);\n\t    };\n\t    ScalarObservable.dispatch = function (state) {\n\t        var done = state.done, value = state.value, subscriber = state.subscriber;\n\t        if (done) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(value);\n\t        if (subscriber.closed) {\n\t            return;\n\t        }\n\t        state.done = true;\n\t        this.schedule(state);\n\t    };\n\t    ScalarObservable.prototype._subscribe = function (subscriber) {\n\t        var value = this.value;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(ScalarObservable.dispatch, 0, {\n\t                done: false, value: value, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            subscriber.next(value);\n\t            if (!subscriber.closed) {\n\t                subscriber.complete();\n\t            }\n\t        }\n\t    };\n\t    return ScalarObservable;\n\t}(Observable_1.Observable));\n\tScalarObservable.ScalarObservable = ScalarObservable$1;\n\t\n\treturn ScalarObservable;\n}\n\nvar EmptyObservable = {};\n\nvar hasRequiredEmptyObservable;\n\nfunction requireEmptyObservable () {\n\tif (hasRequiredEmptyObservable) return EmptyObservable;\n\thasRequiredEmptyObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = requireObservable();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar EmptyObservable$1 = (function (_super) {\n\t    __extends(EmptyObservable, _super);\n\t    function EmptyObservable(scheduler) {\n\t        _super.call(this);\n\t        this.scheduler = scheduler;\n\t    }\n\t    /**\n\t     * Creates an Observable that emits no items to the Observer and immediately\n\t     * emits a complete notification.\n\t     *\n\t     * <span class=\"informal\">Just emits 'complete', and nothing else.\n\t     * </span>\n\t     *\n\t     * <img src=\"./img/empty.png\" width=\"100%\">\n\t     *\n\t     * This static operator is useful for creating a simple Observable that only\n\t     * emits the complete notification. It can be used for composing with other\n\t     * Observables, such as in a {@link mergeMap}.\n\t     *\n\t     * @example <caption>Emit the number 7, then complete.</caption>\n\t     * var result = Rx.Observable.empty().startWith(7);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n\t     * var interval = Rx.Observable.interval(1000);\n\t     * var result = interval.mergeMap(x =>\n\t     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n\t     * );\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * // Results in the following to the console:\n\t     * // x is equal to the count on the interval eg(0,1,2,3,...)\n\t     * // x will occur every 1000ms\n\t     * // if x % 2 is equal to 1 print abc\n\t     * // if x % 2 is not equal to 1 nothing will be output\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link never}\n\t     * @see {@link of}\n\t     * @see {@link throw}\n\t     *\n\t     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n\t     * the emission of the complete notification.\n\t     * @return {Observable} An \"empty\" Observable: emits only the complete\n\t     * notification.\n\t     * @static true\n\t     * @name empty\n\t     * @owner Observable\n\t     */\n\t    EmptyObservable.create = function (scheduler) {\n\t        return new EmptyObservable(scheduler);\n\t    };\n\t    EmptyObservable.dispatch = function (arg) {\n\t        var subscriber = arg.subscriber;\n\t        subscriber.complete();\n\t    };\n\t    EmptyObservable.prototype._subscribe = function (subscriber) {\n\t        var scheduler = this.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n\t        }\n\t        else {\n\t            subscriber.complete();\n\t        }\n\t    };\n\t    return EmptyObservable;\n\t}(Observable_1.Observable));\n\tEmptyObservable.EmptyObservable = EmptyObservable$1;\n\t\n\treturn EmptyObservable;\n}\n\nvar isScheduler = {};\n\nvar hasRequiredIsScheduler;\n\nfunction requireIsScheduler () {\n\tif (hasRequiredIsScheduler) return isScheduler;\n\thasRequiredIsScheduler = 1;\n\tfunction isScheduler$1(value) {\n\t    return value && typeof value.schedule === 'function';\n\t}\n\tisScheduler.isScheduler = isScheduler$1;\n\t\n\treturn isScheduler;\n}\n\nvar hasRequiredArrayObservable;\n\nfunction requireArrayObservable () {\n\tif (hasRequiredArrayObservable) return ArrayObservable;\n\thasRequiredArrayObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = requireObservable();\n\tvar ScalarObservable_1 = requireScalarObservable();\n\tvar EmptyObservable_1 = requireEmptyObservable();\n\tvar isScheduler_1 = requireIsScheduler();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar ArrayObservable$1 = (function (_super) {\n\t    __extends(ArrayObservable, _super);\n\t    function ArrayObservable(array, scheduler) {\n\t        _super.call(this);\n\t        this.array = array;\n\t        this.scheduler = scheduler;\n\t        if (!scheduler && array.length === 1) {\n\t            this._isScalar = true;\n\t            this.value = array[0];\n\t        }\n\t    }\n\t    ArrayObservable.create = function (array, scheduler) {\n\t        return new ArrayObservable(array, scheduler);\n\t    };\n\t    /**\n\t     * Creates an Observable that emits some values you specify as arguments,\n\t     * immediately one after the other, and then emits a complete notification.\n\t     *\n\t     * <span class=\"informal\">Emits the arguments you provide, then completes.\n\t     * </span>\n\t     *\n\t     * <img src=\"./img/of.png\" width=\"100%\">\n\t     *\n\t     * This static operator is useful for creating a simple Observable that only\n\t     * emits the arguments given, and the complete notification thereafter. It can\n\t     * be used for composing with other Observables, such as with {@link concat}.\n\t     * By default, it uses a `null` IScheduler, which means the `next`\n\t     * notifications are sent synchronously, although with a different IScheduler\n\t     * it is possible to determine when those notifications will be delivered.\n\t     *\n\t     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n\t     * var numbers = Rx.Observable.of(10, 20, 30);\n\t     * var letters = Rx.Observable.of('a', 'b', 'c');\n\t     * var interval = Rx.Observable.interval(1000);\n\t     * var result = numbers.concat(letters).concat(interval);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link empty}\n\t     * @see {@link never}\n\t     * @see {@link throw}\n\t     *\n\t     * @param {...T} values Arguments that represent `next` values to be emitted.\n\t     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n\t     * the emissions of the `next` notifications.\n\t     * @return {Observable<T>} An Observable that emits each given input value.\n\t     * @static true\n\t     * @name of\n\t     * @owner Observable\n\t     */\n\t    ArrayObservable.of = function () {\n\t        var array = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            array[_i - 0] = arguments[_i];\n\t        }\n\t        var scheduler = array[array.length - 1];\n\t        if (isScheduler_1.isScheduler(scheduler)) {\n\t            array.pop();\n\t        }\n\t        else {\n\t            scheduler = null;\n\t        }\n\t        var len = array.length;\n\t        if (len > 1) {\n\t            return new ArrayObservable(array, scheduler);\n\t        }\n\t        else if (len === 1) {\n\t            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n\t        }\n\t        else {\n\t            return new EmptyObservable_1.EmptyObservable(scheduler);\n\t        }\n\t    };\n\t    ArrayObservable.dispatch = function (state) {\n\t        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\n\t        if (index >= count) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(array[index]);\n\t        if (subscriber.closed) {\n\t            return;\n\t        }\n\t        state.index = index + 1;\n\t        this.schedule(state);\n\t    };\n\t    ArrayObservable.prototype._subscribe = function (subscriber) {\n\t        var index = 0;\n\t        var array = this.array;\n\t        var count = array.length;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(ArrayObservable.dispatch, 0, {\n\t                array: array, index: index, count: count, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            for (var i = 0; i < count && !subscriber.closed; i++) {\n\t                subscriber.next(array[i]);\n\t            }\n\t            subscriber.complete();\n\t        }\n\t    };\n\t    return ArrayObservable;\n\t}(Observable_1.Observable));\n\tArrayObservable.ArrayObservable = ArrayObservable$1;\n\t\n\treturn ArrayObservable;\n}\n\nvar hasRequiredOf$1;\n\nfunction requireOf$1 () {\n\tif (hasRequiredOf$1) return of;\n\thasRequiredOf$1 = 1;\n\tvar ArrayObservable_1 = requireArrayObservable();\n\tof.of = ArrayObservable_1.ArrayObservable.of;\n\t\n\treturn of;\n}\n\nvar hasRequiredOf;\n\nfunction requireOf () {\n\tif (hasRequiredOf) return of$1;\n\thasRequiredOf = 1;\n\tvar Observable_1 = requireObservable();\n\tvar of_1 = requireOf$1();\n\tObservable_1.Observable.of = of_1.of;\n\t\n\treturn of$1;\n}\n\nvar from$1 = {};\n\nvar from = {};\n\nvar FromObservable = {};\n\nvar PromiseObservable = {};\n\nvar hasRequiredPromiseObservable;\n\nfunction requirePromiseObservable () {\n\tif (hasRequiredPromiseObservable) return PromiseObservable;\n\thasRequiredPromiseObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar root_1 = requireRoot();\n\tvar Observable_1 = requireObservable();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar PromiseObservable$1 = (function (_super) {\n\t    __extends(PromiseObservable, _super);\n\t    function PromiseObservable(promise, scheduler) {\n\t        _super.call(this);\n\t        this.promise = promise;\n\t        this.scheduler = scheduler;\n\t    }\n\t    /**\n\t     * Converts a Promise to an Observable.\n\t     *\n\t     * <span class=\"informal\">Returns an Observable that just emits the Promise's\n\t     * resolved value, then completes.</span>\n\t     *\n\t     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n\t     * Observable. If the Promise resolves with a value, the output Observable\n\t     * emits that resolved value as a `next`, and then completes. If the Promise\n\t     * is rejected, then the output Observable emits the corresponding Error.\n\t     *\n\t     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n\t     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n\t     * result.subscribe(x => console.log(x), e => console.error(e));\n\t     *\n\t     * @see {@link bindCallback}\n\t     * @see {@link from}\n\t     *\n\t     * @param {Promise<T>} promise The promise to be converted.\n\t     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n\t     * the delivery of the resolved value (or the rejection).\n\t     * @return {Observable<T>} An Observable which wraps the Promise.\n\t     * @static true\n\t     * @name fromPromise\n\t     * @owner Observable\n\t     */\n\t    PromiseObservable.create = function (promise, scheduler) {\n\t        return new PromiseObservable(promise, scheduler);\n\t    };\n\t    PromiseObservable.prototype._subscribe = function (subscriber) {\n\t        var _this = this;\n\t        var promise = this.promise;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler == null) {\n\t            if (this._isScalar) {\n\t                if (!subscriber.closed) {\n\t                    subscriber.next(this.value);\n\t                    subscriber.complete();\n\t                }\n\t            }\n\t            else {\n\t                promise.then(function (value) {\n\t                    _this.value = value;\n\t                    _this._isScalar = true;\n\t                    if (!subscriber.closed) {\n\t                        subscriber.next(value);\n\t                        subscriber.complete();\n\t                    }\n\t                }, function (err) {\n\t                    if (!subscriber.closed) {\n\t                        subscriber.error(err);\n\t                    }\n\t                })\n\t                    .then(null, function (err) {\n\t                    // escape the promise trap, throw unhandled errors\n\t                    root_1.root.setTimeout(function () { throw err; });\n\t                });\n\t            }\n\t        }\n\t        else {\n\t            if (this._isScalar) {\n\t                if (!subscriber.closed) {\n\t                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });\n\t                }\n\t            }\n\t            else {\n\t                promise.then(function (value) {\n\t                    _this.value = value;\n\t                    _this._isScalar = true;\n\t                    if (!subscriber.closed) {\n\t                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));\n\t                    }\n\t                }, function (err) {\n\t                    if (!subscriber.closed) {\n\t                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));\n\t                    }\n\t                })\n\t                    .then(null, function (err) {\n\t                    // escape the promise trap, throw unhandled errors\n\t                    root_1.root.setTimeout(function () { throw err; });\n\t                });\n\t            }\n\t        }\n\t    };\n\t    return PromiseObservable;\n\t}(Observable_1.Observable));\n\tPromiseObservable.PromiseObservable = PromiseObservable$1;\n\tfunction dispatchNext(arg) {\n\t    var value = arg.value, subscriber = arg.subscriber;\n\t    if (!subscriber.closed) {\n\t        subscriber.next(value);\n\t        subscriber.complete();\n\t    }\n\t}\n\tfunction dispatchError(arg) {\n\t    var err = arg.err, subscriber = arg.subscriber;\n\t    if (!subscriber.closed) {\n\t        subscriber.error(err);\n\t    }\n\t}\n\t\n\treturn PromiseObservable;\n}\n\nvar IteratorObservable = {};\n\nvar hasRequiredIteratorObservable;\n\nfunction requireIteratorObservable () {\n\tif (hasRequiredIteratorObservable) return IteratorObservable;\n\thasRequiredIteratorObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar root_1 = requireRoot();\n\tvar Observable_1 = requireObservable();\n\tvar iterator_1 = requireIterator();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar IteratorObservable$1 = (function (_super) {\n\t    __extends(IteratorObservable, _super);\n\t    function IteratorObservable(iterator, scheduler) {\n\t        _super.call(this);\n\t        this.scheduler = scheduler;\n\t        if (iterator == null) {\n\t            throw new Error('iterator cannot be null.');\n\t        }\n\t        this.iterator = getIterator(iterator);\n\t    }\n\t    IteratorObservable.create = function (iterator, scheduler) {\n\t        return new IteratorObservable(iterator, scheduler);\n\t    };\n\t    IteratorObservable.dispatch = function (state) {\n\t        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n\t        if (hasError) {\n\t            subscriber.error(state.error);\n\t            return;\n\t        }\n\t        var result = iterator.next();\n\t        if (result.done) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(result.value);\n\t        state.index = index + 1;\n\t        if (subscriber.closed) {\n\t            if (typeof iterator.return === 'function') {\n\t                iterator.return();\n\t            }\n\t            return;\n\t        }\n\t        this.schedule(state);\n\t    };\n\t    IteratorObservable.prototype._subscribe = function (subscriber) {\n\t        var index = 0;\n\t        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(IteratorObservable.dispatch, 0, {\n\t                index: index, iterator: iterator, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            do {\n\t                var result = iterator.next();\n\t                if (result.done) {\n\t                    subscriber.complete();\n\t                    break;\n\t                }\n\t                else {\n\t                    subscriber.next(result.value);\n\t                }\n\t                if (subscriber.closed) {\n\t                    if (typeof iterator.return === 'function') {\n\t                        iterator.return();\n\t                    }\n\t                    break;\n\t                }\n\t            } while (true);\n\t        }\n\t    };\n\t    return IteratorObservable;\n\t}(Observable_1.Observable));\n\tIteratorObservable.IteratorObservable = IteratorObservable$1;\n\tvar StringIterator = (function () {\n\t    function StringIterator(str, idx, len) {\n\t        if (idx === void 0) { idx = 0; }\n\t        if (len === void 0) { len = str.length; }\n\t        this.str = str;\n\t        this.idx = idx;\n\t        this.len = len;\n\t    }\n\t    StringIterator.prototype[iterator_1.$$iterator] = function () { return (this); };\n\t    StringIterator.prototype.next = function () {\n\t        return this.idx < this.len ? {\n\t            done: false,\n\t            value: this.str.charAt(this.idx++)\n\t        } : {\n\t            done: true,\n\t            value: undefined\n\t        };\n\t    };\n\t    return StringIterator;\n\t}());\n\tvar ArrayIterator = (function () {\n\t    function ArrayIterator(arr, idx, len) {\n\t        if (idx === void 0) { idx = 0; }\n\t        if (len === void 0) { len = toLength(arr); }\n\t        this.arr = arr;\n\t        this.idx = idx;\n\t        this.len = len;\n\t    }\n\t    ArrayIterator.prototype[iterator_1.$$iterator] = function () { return this; };\n\t    ArrayIterator.prototype.next = function () {\n\t        return this.idx < this.len ? {\n\t            done: false,\n\t            value: this.arr[this.idx++]\n\t        } : {\n\t            done: true,\n\t            value: undefined\n\t        };\n\t    };\n\t    return ArrayIterator;\n\t}());\n\tfunction getIterator(obj) {\n\t    var i = obj[iterator_1.$$iterator];\n\t    if (!i && typeof obj === 'string') {\n\t        return new StringIterator(obj);\n\t    }\n\t    if (!i && obj.length !== undefined) {\n\t        return new ArrayIterator(obj);\n\t    }\n\t    if (!i) {\n\t        throw new TypeError('object is not iterable');\n\t    }\n\t    return obj[iterator_1.$$iterator]();\n\t}\n\tvar maxSafeInteger = Math.pow(2, 53) - 1;\n\tfunction toLength(o) {\n\t    var len = +o.length;\n\t    if (isNaN(len)) {\n\t        return 0;\n\t    }\n\t    if (len === 0 || !numberIsFinite(len)) {\n\t        return len;\n\t    }\n\t    len = sign(len) * Math.floor(Math.abs(len));\n\t    if (len <= 0) {\n\t        return 0;\n\t    }\n\t    if (len > maxSafeInteger) {\n\t        return maxSafeInteger;\n\t    }\n\t    return len;\n\t}\n\tfunction numberIsFinite(value) {\n\t    return typeof value === 'number' && root_1.root.isFinite(value);\n\t}\n\tfunction sign(value) {\n\t    var valueAsNumber = +value;\n\t    if (valueAsNumber === 0) {\n\t        return valueAsNumber;\n\t    }\n\t    if (isNaN(valueAsNumber)) {\n\t        return valueAsNumber;\n\t    }\n\t    return valueAsNumber < 0 ? -1 : 1;\n\t}\n\t\n\treturn IteratorObservable;\n}\n\nvar ArrayLikeObservable = {};\n\nvar hasRequiredArrayLikeObservable;\n\nfunction requireArrayLikeObservable () {\n\tif (hasRequiredArrayLikeObservable) return ArrayLikeObservable;\n\thasRequiredArrayLikeObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = requireObservable();\n\tvar ScalarObservable_1 = requireScalarObservable();\n\tvar EmptyObservable_1 = requireEmptyObservable();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar ArrayLikeObservable$1 = (function (_super) {\n\t    __extends(ArrayLikeObservable, _super);\n\t    function ArrayLikeObservable(arrayLike, scheduler) {\n\t        _super.call(this);\n\t        this.arrayLike = arrayLike;\n\t        this.scheduler = scheduler;\n\t        if (!scheduler && arrayLike.length === 1) {\n\t            this._isScalar = true;\n\t            this.value = arrayLike[0];\n\t        }\n\t    }\n\t    ArrayLikeObservable.create = function (arrayLike, scheduler) {\n\t        var length = arrayLike.length;\n\t        if (length === 0) {\n\t            return new EmptyObservable_1.EmptyObservable();\n\t        }\n\t        else if (length === 1) {\n\t            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n\t        }\n\t        else {\n\t            return new ArrayLikeObservable(arrayLike, scheduler);\n\t        }\n\t    };\n\t    ArrayLikeObservable.dispatch = function (state) {\n\t        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n\t        if (subscriber.closed) {\n\t            return;\n\t        }\n\t        if (index >= length) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(arrayLike[index]);\n\t        state.index = index + 1;\n\t        this.schedule(state);\n\t    };\n\t    ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n\t        var index = 0;\n\t        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n\t        var length = arrayLike.length;\n\t        if (scheduler) {\n\t            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n\t                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            for (var i = 0; i < length && !subscriber.closed; i++) {\n\t                subscriber.next(arrayLike[i]);\n\t            }\n\t            subscriber.complete();\n\t        }\n\t    };\n\t    return ArrayLikeObservable;\n\t}(Observable_1.Observable));\n\tArrayLikeObservable.ArrayLikeObservable = ArrayLikeObservable$1;\n\t\n\treturn ArrayLikeObservable;\n}\n\nvar observeOn = {};\n\nvar Notification = {};\n\nvar hasRequiredNotification;\n\nfunction requireNotification () {\n\tif (hasRequiredNotification) return Notification;\n\thasRequiredNotification = 1;\n\tvar Observable_1 = requireObservable();\n\t/**\n\t * Represents a push-based event or value that an {@link Observable} can emit.\n\t * This class is particularly useful for operators that manage notifications,\n\t * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n\t * others. Besides wrapping the actual delivered value, it also annotates it\n\t * with metadata of, for instance, what type of push message it is (`next`,\n\t * `error`, or `complete`).\n\t *\n\t * @see {@link materialize}\n\t * @see {@link dematerialize}\n\t * @see {@link observeOn}\n\t *\n\t * @class Notification<T>\n\t */\n\tvar Notification$1 = (function () {\n\t    function Notification(kind, value, error) {\n\t        this.kind = kind;\n\t        this.value = value;\n\t        this.error = error;\n\t        this.hasValue = kind === 'N';\n\t    }\n\t    /**\n\t     * Delivers to the given `observer` the value wrapped by this Notification.\n\t     * @param {Observer} observer\n\t     * @return\n\t     */\n\t    Notification.prototype.observe = function (observer) {\n\t        switch (this.kind) {\n\t            case 'N':\n\t                return observer.next && observer.next(this.value);\n\t            case 'E':\n\t                return observer.error && observer.error(this.error);\n\t            case 'C':\n\t                return observer.complete && observer.complete();\n\t        }\n\t    };\n\t    /**\n\t     * Given some {@link Observer} callbacks, deliver the value represented by the\n\t     * current Notification to the correctly corresponding callback.\n\t     * @param {function(value: T): void} next An Observer `next` callback.\n\t     * @param {function(err: any): void} [error] An Observer `error` callback.\n\t     * @param {function(): void} [complete] An Observer `complete` callback.\n\t     * @return {any}\n\t     */\n\t    Notification.prototype.do = function (next, error, complete) {\n\t        var kind = this.kind;\n\t        switch (kind) {\n\t            case 'N':\n\t                return next && next(this.value);\n\t            case 'E':\n\t                return error && error(this.error);\n\t            case 'C':\n\t                return complete && complete();\n\t        }\n\t    };\n\t    /**\n\t     * Takes an Observer or its individual callback functions, and calls `observe`\n\t     * or `do` methods accordingly.\n\t     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n\t     * the `next` callback.\n\t     * @param {function(err: any): void} [error] An Observer `error` callback.\n\t     * @param {function(): void} [complete] An Observer `complete` callback.\n\t     * @return {any}\n\t     */\n\t    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n\t        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n\t            return this.observe(nextOrObserver);\n\t        }\n\t        else {\n\t            return this.do(nextOrObserver, error, complete);\n\t        }\n\t    };\n\t    /**\n\t     * Returns a simple Observable that just delivers the notification represented\n\t     * by this Notification instance.\n\t     * @return {any}\n\t     */\n\t    Notification.prototype.toObservable = function () {\n\t        var kind = this.kind;\n\t        switch (kind) {\n\t            case 'N':\n\t                return Observable_1.Observable.of(this.value);\n\t            case 'E':\n\t                return Observable_1.Observable.throw(this.error);\n\t            case 'C':\n\t                return Observable_1.Observable.empty();\n\t        }\n\t        throw new Error('unexpected notification kind value');\n\t    };\n\t    /**\n\t     * A shortcut to create a Notification instance of the type `next` from a\n\t     * given value.\n\t     * @param {T} value The `next` value.\n\t     * @return {Notification<T>} The \"next\" Notification representing the\n\t     * argument.\n\t     */\n\t    Notification.createNext = function (value) {\n\t        if (typeof value !== 'undefined') {\n\t            return new Notification('N', value);\n\t        }\n\t        return this.undefinedValueNotification;\n\t    };\n\t    /**\n\t     * A shortcut to create a Notification instance of the type `error` from a\n\t     * given error.\n\t     * @param {any} [err] The `error` error.\n\t     * @return {Notification<T>} The \"error\" Notification representing the\n\t     * argument.\n\t     */\n\t    Notification.createError = function (err) {\n\t        return new Notification('E', undefined, err);\n\t    };\n\t    /**\n\t     * A shortcut to create a Notification instance of the type `complete`.\n\t     * @return {Notification<any>} The valueless \"complete\" Notification.\n\t     */\n\t    Notification.createComplete = function () {\n\t        return this.completeNotification;\n\t    };\n\t    Notification.completeNotification = new Notification('C');\n\t    Notification.undefinedValueNotification = new Notification('N', undefined);\n\t    return Notification;\n\t}());\n\tNotification.Notification = Notification$1;\n\t\n\treturn Notification;\n}\n\nvar hasRequiredObserveOn;\n\nfunction requireObserveOn () {\n\tif (hasRequiredObserveOn) return observeOn;\n\thasRequiredObserveOn = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\tvar Notification_1 = requireNotification();\n\t/**\n\t * @see {@link Notification}\n\t *\n\t * @param scheduler\n\t * @param delay\n\t * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n\t * @method observeOn\n\t * @owner Observable\n\t */\n\tfunction observeOn$1(scheduler, delay) {\n\t    if (delay === void 0) { delay = 0; }\n\t    return this.lift(new ObserveOnOperator(scheduler, delay));\n\t}\n\tobserveOn.observeOn = observeOn$1;\n\tvar ObserveOnOperator = (function () {\n\t    function ObserveOnOperator(scheduler, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        this.scheduler = scheduler;\n\t        this.delay = delay;\n\t    }\n\t    ObserveOnOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n\t    };\n\t    return ObserveOnOperator;\n\t}());\n\tobserveOn.ObserveOnOperator = ObserveOnOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar ObserveOnSubscriber = (function (_super) {\n\t    __extends(ObserveOnSubscriber, _super);\n\t    function ObserveOnSubscriber(destination, scheduler, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        _super.call(this, destination);\n\t        this.scheduler = scheduler;\n\t        this.delay = delay;\n\t    }\n\t    ObserveOnSubscriber.dispatch = function (arg) {\n\t        var notification = arg.notification, destination = arg.destination;\n\t        notification.observe(destination);\n\t        this.unsubscribe();\n\t    };\n\t    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n\t        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n\t    };\n\t    ObserveOnSubscriber.prototype._next = function (value) {\n\t        this.scheduleMessage(Notification_1.Notification.createNext(value));\n\t    };\n\t    ObserveOnSubscriber.prototype._error = function (err) {\n\t        this.scheduleMessage(Notification_1.Notification.createError(err));\n\t    };\n\t    ObserveOnSubscriber.prototype._complete = function () {\n\t        this.scheduleMessage(Notification_1.Notification.createComplete());\n\t    };\n\t    return ObserveOnSubscriber;\n\t}(Subscriber_1.Subscriber));\n\tobserveOn.ObserveOnSubscriber = ObserveOnSubscriber;\n\tvar ObserveOnMessage = (function () {\n\t    function ObserveOnMessage(notification, destination) {\n\t        this.notification = notification;\n\t        this.destination = destination;\n\t    }\n\t    return ObserveOnMessage;\n\t}());\n\tobserveOn.ObserveOnMessage = ObserveOnMessage;\n\t\n\treturn observeOn;\n}\n\nvar hasRequiredFromObservable;\n\nfunction requireFromObservable () {\n\tif (hasRequiredFromObservable) return FromObservable;\n\thasRequiredFromObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar isArray_1 = requireIsArray();\n\tvar isPromise_1 = requireIsPromise();\n\tvar PromiseObservable_1 = requirePromiseObservable();\n\tvar IteratorObservable_1 = requireIteratorObservable();\n\tvar ArrayObservable_1 = requireArrayObservable();\n\tvar ArrayLikeObservable_1 = requireArrayLikeObservable();\n\tvar iterator_1 = requireIterator();\n\tvar Observable_1 = requireObservable();\n\tvar observeOn_1 = requireObserveOn();\n\tvar observable_1 = requireObservable$1();\n\tvar isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar FromObservable$1 = (function (_super) {\n\t    __extends(FromObservable, _super);\n\t    function FromObservable(ish, scheduler) {\n\t        _super.call(this, null);\n\t        this.ish = ish;\n\t        this.scheduler = scheduler;\n\t    }\n\t    /**\n\t     * Creates an Observable from an Array, an array-like object, a Promise, an\n\t     * iterable object, or an Observable-like object.\n\t     *\n\t     * <span class=\"informal\">Converts almost anything to an Observable.</span>\n\t     *\n\t     * <img src=\"./img/from.png\" width=\"100%\">\n\t     *\n\t     * Convert various other objects and data types into Observables. `from`\n\t     * converts a Promise or an array-like or an\n\t     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n\t     * object into an Observable that emits the items in that promise or array or\n\t     * iterable. A String, in this context, is treated as an array of characters.\n\t     * Observable-like objects (contains a function named with the ES2015 Symbol\n\t     * for Observable) can also be converted through this operator.\n\t     *\n\t     * @example <caption>Converts an array to an Observable</caption>\n\t     * var array = [10, 20, 30];\n\t     * var result = Rx.Observable.from(array);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * // Results in the following:\n\t     * // 10 20 30\n\t     *\n\t     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n\t     * function* generateDoubles(seed) {\n\t     *   var i = seed;\n\t     *   while (true) {\n\t     *     yield i;\n\t     *     i = 2 * i; // double it\n\t     *   }\n\t     * }\n\t     *\n\t     * var iterator = generateDoubles(3);\n\t     * var result = Rx.Observable.from(iterator).take(10);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * // Results in the following:\n\t     * // 3 6 12 24 48 96 192 384 768 1536\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link fromEvent}\n\t     * @see {@link fromEventPattern}\n\t     * @see {@link fromPromise}\n\t     *\n\t     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n\t     * Observable-like, an Array, an iterable or an array-like object to be\n\t     * converted.\n\t     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n\t     * emissions of values.\n\t     * @return {Observable<T>} The Observable whose values are originally from the\n\t     * input object that was converted.\n\t     * @static true\n\t     * @name from\n\t     * @owner Observable\n\t     */\n\t    FromObservable.create = function (ish, scheduler) {\n\t        if (ish != null) {\n\t            if (typeof ish[observable_1.$$observable] === 'function') {\n\t                if (ish instanceof Observable_1.Observable && !scheduler) {\n\t                    return ish;\n\t                }\n\t                return new FromObservable(ish, scheduler);\n\t            }\n\t            else if (isArray_1.isArray(ish)) {\n\t                return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n\t            }\n\t            else if (isPromise_1.isPromise(ish)) {\n\t                return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n\t            }\n\t            else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {\n\t                return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n\t            }\n\t            else if (isArrayLike(ish)) {\n\t                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n\t            }\n\t        }\n\t        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n\t    };\n\t    FromObservable.prototype._subscribe = function (subscriber) {\n\t        var ish = this.ish;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler == null) {\n\t            return ish[observable_1.$$observable]().subscribe(subscriber);\n\t        }\n\t        else {\n\t            return ish[observable_1.$$observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n\t        }\n\t    };\n\t    return FromObservable;\n\t}(Observable_1.Observable));\n\tFromObservable.FromObservable = FromObservable$1;\n\t\n\treturn FromObservable;\n}\n\nvar hasRequiredFrom$1;\n\nfunction requireFrom$1 () {\n\tif (hasRequiredFrom$1) return from;\n\thasRequiredFrom$1 = 1;\n\tvar FromObservable_1 = requireFromObservable();\n\tfrom.from = FromObservable_1.FromObservable.create;\n\t\n\treturn from;\n}\n\nvar hasRequiredFrom;\n\nfunction requireFrom () {\n\tif (hasRequiredFrom) return from$1;\n\thasRequiredFrom = 1;\n\tvar Observable_1 = requireObservable();\n\tvar from_1 = requireFrom$1();\n\tObservable_1.Observable.from = from_1.from;\n\t\n\treturn from$1;\n}\n\nvar _throw$1 = {};\n\nvar _throw = {};\n\nvar ErrorObservable = {};\n\nvar hasRequiredErrorObservable;\n\nfunction requireErrorObservable () {\n\tif (hasRequiredErrorObservable) return ErrorObservable;\n\thasRequiredErrorObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = requireObservable();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar ErrorObservable$1 = (function (_super) {\n\t    __extends(ErrorObservable, _super);\n\t    function ErrorObservable(error, scheduler) {\n\t        _super.call(this);\n\t        this.error = error;\n\t        this.scheduler = scheduler;\n\t    }\n\t    /**\n\t     * Creates an Observable that emits no items to the Observer and immediately\n\t     * emits an error notification.\n\t     *\n\t     * <span class=\"informal\">Just emits 'error', and nothing else.\n\t     * </span>\n\t     *\n\t     * <img src=\"./img/throw.png\" width=\"100%\">\n\t     *\n\t     * This static operator is useful for creating a simple Observable that only\n\t     * emits the error notification. It can be used for composing with other\n\t     * Observables, such as in a {@link mergeMap}.\n\t     *\n\t     * @example <caption>Emit the number 7, then emit an error.</caption>\n\t     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);\n\t     * result.subscribe(x => console.log(x), e => console.error(e));\n\t     *\n\t     * @example <caption>Map and flattens numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>\n\t     * var interval = Rx.Observable.interval(1000);\n\t     * var result = interval.mergeMap(x =>\n\t     *   x === 13 ?\n\t     *     Rx.Observable.throw('Thirteens are bad') :\n\t     *     Rx.Observable.of('a', 'b', 'c')\n\t     * );\n\t     * result.subscribe(x => console.log(x), e => console.error(e));\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link empty}\n\t     * @see {@link never}\n\t     * @see {@link of}\n\t     *\n\t     * @param {any} error The particular Error to pass to the error notification.\n\t     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n\t     * the emission of the error notification.\n\t     * @return {Observable} An error Observable: emits only the error notification\n\t     * using the given error argument.\n\t     * @static true\n\t     * @name throw\n\t     * @owner Observable\n\t     */\n\t    ErrorObservable.create = function (error, scheduler) {\n\t        return new ErrorObservable(error, scheduler);\n\t    };\n\t    ErrorObservable.dispatch = function (arg) {\n\t        var error = arg.error, subscriber = arg.subscriber;\n\t        subscriber.error(error);\n\t    };\n\t    ErrorObservable.prototype._subscribe = function (subscriber) {\n\t        var error = this.error;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(ErrorObservable.dispatch, 0, {\n\t                error: error, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            subscriber.error(error);\n\t        }\n\t    };\n\t    return ErrorObservable;\n\t}(Observable_1.Observable));\n\tErrorObservable.ErrorObservable = ErrorObservable$1;\n\t\n\treturn ErrorObservable;\n}\n\nvar hasRequired_throw$1;\n\nfunction require_throw$1 () {\n\tif (hasRequired_throw$1) return _throw;\n\thasRequired_throw$1 = 1;\n\tvar ErrorObservable_1 = requireErrorObservable();\n\t_throw._throw = ErrorObservable_1.ErrorObservable.create;\n\t\n\treturn _throw;\n}\n\nvar hasRequired_throw;\n\nfunction require_throw () {\n\tif (hasRequired_throw) return _throw$1;\n\thasRequired_throw = 1;\n\tvar Observable_1 = requireObservable();\n\tvar throw_1 = require_throw$1();\n\tObservable_1.Observable.throw = throw_1._throw;\n\t\n\treturn _throw$1;\n}\n\nvar empty$1 = {};\n\nvar empty = {};\n\nvar hasRequiredEmpty$1;\n\nfunction requireEmpty$1 () {\n\tif (hasRequiredEmpty$1) return empty;\n\thasRequiredEmpty$1 = 1;\n\tvar EmptyObservable_1 = requireEmptyObservable();\n\tempty.empty = EmptyObservable_1.EmptyObservable.create;\n\t\n\treturn empty;\n}\n\nvar hasRequiredEmpty;\n\nfunction requireEmpty () {\n\tif (hasRequiredEmpty) return empty$1;\n\thasRequiredEmpty = 1;\n\tvar Observable_1 = requireObservable();\n\tvar empty_1 = requireEmpty$1();\n\tObservable_1.Observable.empty = empty_1.empty;\n\t\n\treturn empty$1;\n}\n\nvar mergeMap$1 = {};\n\nvar mergeMap = {};\n\nvar hasRequiredMergeMap$1;\n\nfunction requireMergeMap$1 () {\n\tif (hasRequiredMergeMap$1) return mergeMap;\n\thasRequiredMergeMap$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar subscribeToResult_1 = requireSubscribeToResult();\n\tvar OuterSubscriber_1 = requireOuterSubscriber();\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Projects each source value to an Observable which is merged in the output\n\t * Observable.\n\t *\n\t * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n\t * these inner Observables using {@link mergeAll}.</span>\n\t *\n\t * <img src=\"./img/mergeMap.png\" width=\"100%\">\n\t *\n\t * Returns an Observable that emits items based on applying a function that you\n\t * supply to each item emitted by the source Observable, where that function\n\t * returns an Observable, and then merging those resulting Observables and\n\t * emitting the results of this merger.\n\t *\n\t * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n\t * var letters = Rx.Observable.of('a', 'b', 'c');\n\t * var result = letters.mergeMap(x =>\n\t *   Rx.Observable.interval(1000).map(i => x+i)\n\t * );\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // Results in the following:\n\t * // a0\n\t * // b0\n\t * // c0\n\t * // a1\n\t * // b1\n\t * // c1\n\t * // continues to list a,b,c with respective ascending integers\n\t *\n\t * @see {@link concatMap}\n\t * @see {@link exhaustMap}\n\t * @see {@link merge}\n\t * @see {@link mergeAll}\n\t * @see {@link mergeMapTo}\n\t * @see {@link mergeScan}\n\t * @see {@link switchMap}\n\t *\n\t * @param {function(value: T, ?index: number): Observable} project A function\n\t * that, when applied to an item emitted by the source Observable, returns an\n\t * Observable.\n\t * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n\t * A function to produce the value on the output Observable based on the values\n\t * and the indices of the source (outer) emission and the inner Observable\n\t * emission. The arguments passed to this function are:\n\t * - `outerValue`: the value that came from the source\n\t * - `innerValue`: the value that came from the projected Observable\n\t * - `outerIndex`: the \"index\" of the value that came from the source\n\t * - `innerIndex`: the \"index\" of the value from the projected Observable\n\t * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n\t * Observables being subscribed to concurrently.\n\t * @return {Observable} An Observable that emits the result of applying the\n\t * projection function (and the optional `resultSelector`) to each item emitted\n\t * by the source Observable and merging the results of the Observables obtained\n\t * from this transformation.\n\t * @method mergeMap\n\t * @owner Observable\n\t */\n\tfunction mergeMap$1(project, resultSelector, concurrent) {\n\t    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t    if (typeof resultSelector === 'number') {\n\t        concurrent = resultSelector;\n\t        resultSelector = null;\n\t    }\n\t    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));\n\t}\n\tmergeMap.mergeMap = mergeMap$1;\n\tvar MergeMapOperator = (function () {\n\t    function MergeMapOperator(project, resultSelector, concurrent) {\n\t        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t        this.project = project;\n\t        this.resultSelector = resultSelector;\n\t        this.concurrent = concurrent;\n\t    }\n\t    MergeMapOperator.prototype.call = function (observer, source) {\n\t        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n\t    };\n\t    return MergeMapOperator;\n\t}());\n\tmergeMap.MergeMapOperator = MergeMapOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MergeMapSubscriber = (function (_super) {\n\t    __extends(MergeMapSubscriber, _super);\n\t    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n\t        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t        _super.call(this, destination);\n\t        this.project = project;\n\t        this.resultSelector = resultSelector;\n\t        this.concurrent = concurrent;\n\t        this.hasCompleted = false;\n\t        this.buffer = [];\n\t        this.active = 0;\n\t        this.index = 0;\n\t    }\n\t    MergeMapSubscriber.prototype._next = function (value) {\n\t        if (this.active < this.concurrent) {\n\t            this._tryNext(value);\n\t        }\n\t        else {\n\t            this.buffer.push(value);\n\t        }\n\t    };\n\t    MergeMapSubscriber.prototype._tryNext = function (value) {\n\t        var result;\n\t        var index = this.index++;\n\t        try {\n\t            result = this.project(value, index);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.active++;\n\t        this._innerSub(result, value, index);\n\t    };\n\t    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n\t        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n\t    };\n\t    MergeMapSubscriber.prototype._complete = function () {\n\t        this.hasCompleted = true;\n\t        if (this.active === 0 && this.buffer.length === 0) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n\t        if (this.resultSelector) {\n\t            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n\t        }\n\t        else {\n\t            this.destination.next(innerValue);\n\t        }\n\t    };\n\t    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n\t        var result;\n\t        try {\n\t            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.destination.next(result);\n\t    };\n\t    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        var buffer = this.buffer;\n\t        this.remove(innerSub);\n\t        this.active--;\n\t        if (buffer.length > 0) {\n\t            this._next(buffer.shift());\n\t        }\n\t        else if (this.active === 0 && this.hasCompleted) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    return MergeMapSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\tmergeMap.MergeMapSubscriber = MergeMapSubscriber;\n\t\n\treturn mergeMap;\n}\n\nvar hasRequiredMergeMap;\n\nfunction requireMergeMap () {\n\tif (hasRequiredMergeMap) return mergeMap$1;\n\thasRequiredMergeMap = 1;\n\tvar Observable_1 = requireObservable();\n\tvar mergeMap_1 = requireMergeMap$1();\n\tObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\n\tObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n\t\n\treturn mergeMap$1;\n}\n\nvar _do$1 = {};\n\nvar _do = {};\n\nvar hasRequired_do$1;\n\nfunction require_do$1 () {\n\tif (hasRequired_do$1) return _do;\n\thasRequired_do$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Perform a side effect for every emission on the source Observable, but return\n\t * an Observable that is identical to the source.\n\t *\n\t * <span class=\"informal\">Intercepts each emission on the source and runs a\n\t * function, but returns an output which is identical to the source.</span>\n\t *\n\t * <img src=\"./img/do.png\" width=\"100%\">\n\t *\n\t * Returns a mirrored Observable of the source Observable, but modified so that\n\t * the provided Observer is called to perform a side effect for every value,\n\t * error, and completion emitted by the source. Any errors that are thrown in\n\t * the aforementioned Observer or handlers are safely sent down the error path\n\t * of the output Observable.\n\t *\n\t * This operator is useful for debugging your Observables for the correct values\n\t * or performing other side effects.\n\t *\n\t * Note: this is different to a `subscribe` on the Observable. If the Observable\n\t * returned by `do` is not subscribed, the side effects specified by the\n\t * Observer will never happen. `do` therefore simply spies on existing\n\t * execution, it does not trigger an execution to happen like `subscribe` does.\n\t *\n\t * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var positions = clicks\n\t *   .do(ev => console.log(ev))\n\t *   .map(ev => ev.clientX);\n\t * positions.subscribe(x => console.log(x));\n\t *\n\t * @see {@link map}\n\t * @see {@link subscribe}\n\t *\n\t * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n\t * callback for `next`.\n\t * @param {function} [error] Callback for errors in the source.\n\t * @param {function} [complete] Callback for the completion of the source.\n\t * @return {Observable} An Observable identical to the source, but runs the\n\t * specified Observer or callback(s) for each item.\n\t * @method do\n\t * @name do\n\t * @owner Observable\n\t */\n\tfunction _do$1(nextOrObserver, error, complete) {\n\t    return this.lift(new DoOperator(nextOrObserver, error, complete));\n\t}\n\t_do._do = _do$1;\n\tvar DoOperator = (function () {\n\t    function DoOperator(nextOrObserver, error, complete) {\n\t        this.nextOrObserver = nextOrObserver;\n\t        this.error = error;\n\t        this.complete = complete;\n\t    }\n\t    DoOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n\t    };\n\t    return DoOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar DoSubscriber = (function (_super) {\n\t    __extends(DoSubscriber, _super);\n\t    function DoSubscriber(destination, nextOrObserver, error, complete) {\n\t        _super.call(this, destination);\n\t        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n\t        safeSubscriber.syncErrorThrowable = true;\n\t        this.add(safeSubscriber);\n\t        this.safeSubscriber = safeSubscriber;\n\t    }\n\t    DoSubscriber.prototype._next = function (value) {\n\t        var safeSubscriber = this.safeSubscriber;\n\t        safeSubscriber.next(value);\n\t        if (safeSubscriber.syncErrorThrown) {\n\t            this.destination.error(safeSubscriber.syncErrorValue);\n\t        }\n\t        else {\n\t            this.destination.next(value);\n\t        }\n\t    };\n\t    DoSubscriber.prototype._error = function (err) {\n\t        var safeSubscriber = this.safeSubscriber;\n\t        safeSubscriber.error(err);\n\t        if (safeSubscriber.syncErrorThrown) {\n\t            this.destination.error(safeSubscriber.syncErrorValue);\n\t        }\n\t        else {\n\t            this.destination.error(err);\n\t        }\n\t    };\n\t    DoSubscriber.prototype._complete = function () {\n\t        var safeSubscriber = this.safeSubscriber;\n\t        safeSubscriber.complete();\n\t        if (safeSubscriber.syncErrorThrown) {\n\t            this.destination.error(safeSubscriber.syncErrorValue);\n\t        }\n\t        else {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    return DoSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t\n\treturn _do;\n}\n\nvar hasRequired_do;\n\nfunction require_do () {\n\tif (hasRequired_do) return _do$1;\n\thasRequired_do = 1;\n\tvar Observable_1 = requireObservable();\n\tvar do_1 = require_do$1();\n\tObservable_1.Observable.prototype.do = do_1._do;\n\tObservable_1.Observable.prototype._do = do_1._do;\n\t\n\treturn _do$1;\n}\n\nvar defaultIfEmpty$1 = {};\n\nvar defaultIfEmpty = {};\n\nvar hasRequiredDefaultIfEmpty$1;\n\nfunction requireDefaultIfEmpty$1 () {\n\tif (hasRequiredDefaultIfEmpty$1) return defaultIfEmpty;\n\thasRequiredDefaultIfEmpty$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Emits a given value if the source Observable completes without emitting any\n\t * `next` value, otherwise mirrors the source Observable.\n\t *\n\t * <span class=\"informal\">If the source Observable turns out to be empty, then\n\t * this operator will emit a default value.</span>\n\t *\n\t * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n\t *\n\t * `defaultIfEmpty` emits the values emitted by the source Observable or a\n\t * specified default value if the source Observable is empty (completes without\n\t * having emitted any `next` value).\n\t *\n\t * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n\t * var result = clicksBeforeFive.defaultIfEmpty('no clicks');\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * @see {@link empty}\n\t * @see {@link last}\n\t *\n\t * @param {any} [defaultValue=null] The default value used if the source\n\t * Observable is empty.\n\t * @return {Observable} An Observable that emits either the specified\n\t * `defaultValue` if the source Observable emits no items, or the values emitted\n\t * by the source Observable.\n\t * @method defaultIfEmpty\n\t * @owner Observable\n\t */\n\tfunction defaultIfEmpty$1(defaultValue) {\n\t    if (defaultValue === void 0) { defaultValue = null; }\n\t    return this.lift(new DefaultIfEmptyOperator(defaultValue));\n\t}\n\tdefaultIfEmpty.defaultIfEmpty = defaultIfEmpty$1;\n\tvar DefaultIfEmptyOperator = (function () {\n\t    function DefaultIfEmptyOperator(defaultValue) {\n\t        this.defaultValue = defaultValue;\n\t    }\n\t    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));\n\t    };\n\t    return DefaultIfEmptyOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar DefaultIfEmptySubscriber = (function (_super) {\n\t    __extends(DefaultIfEmptySubscriber, _super);\n\t    function DefaultIfEmptySubscriber(destination, defaultValue) {\n\t        _super.call(this, destination);\n\t        this.defaultValue = defaultValue;\n\t        this.isEmpty = true;\n\t    }\n\t    DefaultIfEmptySubscriber.prototype._next = function (value) {\n\t        this.isEmpty = false;\n\t        this.destination.next(value);\n\t    };\n\t    DefaultIfEmptySubscriber.prototype._complete = function () {\n\t        if (this.isEmpty) {\n\t            this.destination.next(this.defaultValue);\n\t        }\n\t        this.destination.complete();\n\t    };\n\t    return DefaultIfEmptySubscriber;\n\t}(Subscriber_1.Subscriber));\n\t\n\treturn defaultIfEmpty;\n}\n\nvar hasRequiredDefaultIfEmpty;\n\nfunction requireDefaultIfEmpty () {\n\tif (hasRequiredDefaultIfEmpty) return defaultIfEmpty$1;\n\thasRequiredDefaultIfEmpty = 1;\n\tvar Observable_1 = requireObservable();\n\tvar defaultIfEmpty_1 = requireDefaultIfEmpty$1();\n\tObservable_1.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;\n\t\n\treturn defaultIfEmpty$1;\n}\n\nvar materialize$2 = {};\n\nvar materialize$1 = {};\n\nvar hasRequiredMaterialize$2;\n\nfunction requireMaterialize$2 () {\n\tif (hasRequiredMaterialize$2) return materialize$1;\n\thasRequiredMaterialize$2 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\tvar Notification_1 = requireNotification();\n\t/**\n\t * Represents all of the notifications from the source Observable as `next`\n\t * emissions marked with their original types within {@link Notification}\n\t * objects.\n\t *\n\t * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n\t * {@link Notification} objects, emitted as `next` on the output Observable.\n\t * </span>\n\t *\n\t * <img src=\"./img/materialize.png\" width=\"100%\">\n\t *\n\t * `materialize` returns an Observable that emits a `next` notification for each\n\t * `next`, `error`, or `complete` emission of the source Observable. When the\n\t * source Observable emits `complete`, the output Observable will emit `next` as\n\t * a Notification of type \"complete\", and then it will emit `complete` as well.\n\t * When the source Observable emits `error`, the output will emit `next` as a\n\t * Notification of type \"error\", and then `complete`.\n\t *\n\t * This operator is useful for producing metadata of the source Observable, to\n\t * be consumed as `next` emissions. Use it in conjunction with\n\t * {@link dematerialize}.\n\t *\n\t * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n\t * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n\t * var upperCase = letters.map(x => x.toUpperCase());\n\t * var materialized = upperCase.materialize();\n\t * materialized.subscribe(x => console.log(x));\n\t *\n\t * // Results in the following:\n\t * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n\t * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n\t * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n\t * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n\t * //   [as project] (http://1\u2026, hasValue: false}\n\t *\n\t * @see {@link Notification}\n\t * @see {@link dematerialize}\n\t *\n\t * @return {Observable<Notification<T>>} An Observable that emits\n\t * {@link Notification} objects that wrap the original emissions from the source\n\t * Observable with metadata.\n\t * @method materialize\n\t * @owner Observable\n\t */\n\tfunction materialize() {\n\t    return this.lift(new MaterializeOperator());\n\t}\n\tmaterialize$1.materialize = materialize;\n\tvar MaterializeOperator = (function () {\n\t    function MaterializeOperator() {\n\t    }\n\t    MaterializeOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new MaterializeSubscriber(subscriber));\n\t    };\n\t    return MaterializeOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MaterializeSubscriber = (function (_super) {\n\t    __extends(MaterializeSubscriber, _super);\n\t    function MaterializeSubscriber(destination) {\n\t        _super.call(this, destination);\n\t    }\n\t    MaterializeSubscriber.prototype._next = function (value) {\n\t        this.destination.next(Notification_1.Notification.createNext(value));\n\t    };\n\t    MaterializeSubscriber.prototype._error = function (err) {\n\t        var destination = this.destination;\n\t        destination.next(Notification_1.Notification.createError(err));\n\t        destination.complete();\n\t    };\n\t    MaterializeSubscriber.prototype._complete = function () {\n\t        var destination = this.destination;\n\t        destination.next(Notification_1.Notification.createComplete());\n\t        destination.complete();\n\t    };\n\t    return MaterializeSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t\n\treturn materialize$1;\n}\n\nvar hasRequiredMaterialize$1;\n\nfunction requireMaterialize$1 () {\n\tif (hasRequiredMaterialize$1) return materialize$2;\n\thasRequiredMaterialize$1 = 1;\n\tvar Observable_1 = requireObservable();\n\tvar materialize_1 = requireMaterialize$2();\n\tObservable_1.Observable.prototype.materialize = materialize_1.materialize;\n\t\n\treturn materialize$2;\n}\n\nvar expand$1 = {};\n\nvar expand = {};\n\nvar hasRequiredExpand$1;\n\nfunction requireExpand$1 () {\n\tif (hasRequiredExpand$1) return expand;\n\thasRequiredExpand$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar tryCatch_1 = requireTryCatch();\n\tvar errorObject_1 = requireErrorObject();\n\tvar OuterSubscriber_1 = requireOuterSubscriber();\n\tvar subscribeToResult_1 = requireSubscribeToResult();\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Recursively projects each source value to an Observable which is merged in\n\t * the output Observable.\n\t *\n\t * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n\t * projection function to every source value as well as every output value.\n\t * It's recursive.</span>\n\t *\n\t * <img src=\"./img/expand.png\" width=\"100%\">\n\t *\n\t * Returns an Observable that emits items based on applying a function that you\n\t * supply to each item emitted by the source Observable, where that function\n\t * returns an Observable, and then merging those resulting Observables and\n\t * emitting the results of this merger. *Expand* will re-emit on the output\n\t * Observable every source value. Then, each output value is given to the\n\t * `project` function which returns an inner Observable to be merged on the\n\t * output Observable. Those output values resulting from the projection are also\n\t * given to the `project` function to produce new output values. This is how\n\t * *expand* behaves recursively.\n\t *\n\t * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var powersOfTwo = clicks\n\t *   .mapTo(1)\n\t *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n\t *   .take(10);\n\t * powersOfTwo.subscribe(x => console.log(x));\n\t *\n\t * @see {@link mergeMap}\n\t * @see {@link mergeScan}\n\t *\n\t * @param {function(value: T, index: number) => Observable} project A function\n\t * that, when applied to an item emitted by the source or the output Observable,\n\t * returns an Observable.\n\t * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n\t * Observables being subscribed to concurrently.\n\t * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n\t * each projected inner Observable.\n\t * @return {Observable} An Observable that emits the source values and also\n\t * result of applying the projection function to each value emitted on the\n\t * output Observable and and merging the results of the Observables obtained\n\t * from this transformation.\n\t * @method expand\n\t * @owner Observable\n\t */\n\tfunction expand$1(project, concurrent, scheduler) {\n\t    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t    if (scheduler === void 0) { scheduler = undefined; }\n\t    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n\t    return this.lift(new ExpandOperator(project, concurrent, scheduler));\n\t}\n\texpand.expand = expand$1;\n\tvar ExpandOperator = (function () {\n\t    function ExpandOperator(project, concurrent, scheduler) {\n\t        this.project = project;\n\t        this.concurrent = concurrent;\n\t        this.scheduler = scheduler;\n\t    }\n\t    ExpandOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n\t    };\n\t    return ExpandOperator;\n\t}());\n\texpand.ExpandOperator = ExpandOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar ExpandSubscriber = (function (_super) {\n\t    __extends(ExpandSubscriber, _super);\n\t    function ExpandSubscriber(destination, project, concurrent, scheduler) {\n\t        _super.call(this, destination);\n\t        this.project = project;\n\t        this.concurrent = concurrent;\n\t        this.scheduler = scheduler;\n\t        this.index = 0;\n\t        this.active = 0;\n\t        this.hasCompleted = false;\n\t        if (concurrent < Number.POSITIVE_INFINITY) {\n\t            this.buffer = [];\n\t        }\n\t    }\n\t    ExpandSubscriber.dispatch = function (arg) {\n\t        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;\n\t        subscriber.subscribeToProjection(result, value, index);\n\t    };\n\t    ExpandSubscriber.prototype._next = function (value) {\n\t        var destination = this.destination;\n\t        if (destination.closed) {\n\t            this._complete();\n\t            return;\n\t        }\n\t        var index = this.index++;\n\t        if (this.active < this.concurrent) {\n\t            destination.next(value);\n\t            var result = tryCatch_1.tryCatch(this.project)(value, index);\n\t            if (result === errorObject_1.errorObject) {\n\t                destination.error(errorObject_1.errorObject.e);\n\t            }\n\t            else if (!this.scheduler) {\n\t                this.subscribeToProjection(result, value, index);\n\t            }\n\t            else {\n\t                var state = { subscriber: this, result: result, value: value, index: index };\n\t                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n\t            }\n\t        }\n\t        else {\n\t            this.buffer.push(value);\n\t        }\n\t    };\n\t    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n\t        this.active++;\n\t        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n\t    };\n\t    ExpandSubscriber.prototype._complete = function () {\n\t        this.hasCompleted = true;\n\t        if (this.hasCompleted && this.active === 0) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n\t        this._next(innerValue);\n\t    };\n\t    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        var buffer = this.buffer;\n\t        this.remove(innerSub);\n\t        this.active--;\n\t        if (buffer && buffer.length > 0) {\n\t            this._next(buffer.shift());\n\t        }\n\t        if (this.hasCompleted && this.active === 0) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    return ExpandSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\texpand.ExpandSubscriber = ExpandSubscriber;\n\t\n\treturn expand;\n}\n\nvar hasRequiredExpand;\n\nfunction requireExpand () {\n\tif (hasRequiredExpand) return expand$1;\n\thasRequiredExpand = 1;\n\tvar Observable_1 = requireObservable();\n\tvar expand_1 = requireExpand$1();\n\tObservable_1.Observable.prototype.expand = expand_1.expand;\n\t\n\treturn expand$1;\n}\n\nvar reduce$1 = {};\n\nvar reduce = {};\n\nvar hasRequiredReduce$1;\n\nfunction requireReduce$1 () {\n\tif (hasRequiredReduce$1) return reduce;\n\thasRequiredReduce$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Applies an accumulator function over the source Observable, and returns the\n\t * accumulated result when the source completes, given an optional seed value.\n\t *\n\t * <span class=\"informal\">Combines together all values emitted on the source,\n\t * using an accumulator function that knows how to join a new source value into\n\t * the accumulation from the past.</span>\n\t *\n\t * <img src=\"./img/reduce.png\" width=\"100%\">\n\t *\n\t * Like\n\t * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n\t * `reduce` applies an `accumulator` function against an accumulation and each\n\t * value of the source Observable (from the past) to reduce it to a single\n\t * value, emitted on the output Observable. Note that `reduce` will only emit\n\t * one value, only when the source Observable completes. It is equivalent to\n\t * applying operator {@link scan} followed by operator {@link last}.\n\t *\n\t * Returns an Observable that applies a specified `accumulator` function to each\n\t * item emitted by the source Observable. If a `seed` value is specified, then\n\t * that value will be used as the initial value for the accumulator. If no seed\n\t * value is specified, the first item of the source is used as the seed.\n\t *\n\t * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n\t * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n\t *   .takeUntil(Rx.Observable.interval(5000));\n\t * var ones = clicksInFiveSeconds.mapTo(1);\n\t * var seed = 0;\n\t * var count = ones.reduce((acc, one) => acc + one, seed);\n\t * count.subscribe(x => console.log(x));\n\t *\n\t * @see {@link count}\n\t * @see {@link expand}\n\t * @see {@link mergeScan}\n\t * @see {@link scan}\n\t *\n\t * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n\t * called on each source value.\n\t * @param {R} [seed] The initial accumulation value.\n\t * @return {Observable<R>} An observable of the accumulated values.\n\t * @return {Observable<R>} An Observable that emits a single value that is the\n\t * result of accumulating the values emitted by the source Observable.\n\t * @method reduce\n\t * @owner Observable\n\t */\n\tfunction reduce$1(accumulator, seed) {\n\t    var hasSeed = false;\n\t    // providing a seed of `undefined` *should* be valid and trigger\n\t    // hasSeed! so don't use `seed !== undefined` checks!\n\t    // For this reason, we have to check it here at the original call site\n\t    // otherwise inside Operator/Subscriber we won't know if `undefined`\n\t    // means they didn't provide anything or if they literally provided `undefined`\n\t    if (arguments.length >= 2) {\n\t        hasSeed = true;\n\t    }\n\t    return this.lift(new ReduceOperator(accumulator, seed, hasSeed));\n\t}\n\treduce.reduce = reduce$1;\n\tvar ReduceOperator = (function () {\n\t    function ReduceOperator(accumulator, seed, hasSeed) {\n\t        if (hasSeed === void 0) { hasSeed = false; }\n\t        this.accumulator = accumulator;\n\t        this.seed = seed;\n\t        this.hasSeed = hasSeed;\n\t    }\n\t    ReduceOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n\t    };\n\t    return ReduceOperator;\n\t}());\n\treduce.ReduceOperator = ReduceOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar ReduceSubscriber = (function (_super) {\n\t    __extends(ReduceSubscriber, _super);\n\t    function ReduceSubscriber(destination, accumulator, seed, hasSeed) {\n\t        _super.call(this, destination);\n\t        this.accumulator = accumulator;\n\t        this.hasSeed = hasSeed;\n\t        this.index = 0;\n\t        this.hasValue = false;\n\t        this.acc = seed;\n\t        if (!this.hasSeed) {\n\t            this.index++;\n\t        }\n\t    }\n\t    ReduceSubscriber.prototype._next = function (value) {\n\t        if (this.hasValue || (this.hasValue = this.hasSeed)) {\n\t            this._tryReduce(value);\n\t        }\n\t        else {\n\t            this.acc = value;\n\t            this.hasValue = true;\n\t        }\n\t    };\n\t    ReduceSubscriber.prototype._tryReduce = function (value) {\n\t        var result;\n\t        try {\n\t            result = this.accumulator(this.acc, value, this.index++);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.acc = result;\n\t    };\n\t    ReduceSubscriber.prototype._complete = function () {\n\t        if (this.hasValue || this.hasSeed) {\n\t            this.destination.next(this.acc);\n\t        }\n\t        this.destination.complete();\n\t    };\n\t    return ReduceSubscriber;\n\t}(Subscriber_1.Subscriber));\n\treduce.ReduceSubscriber = ReduceSubscriber;\n\t\n\treturn reduce;\n}\n\nvar hasRequiredReduce;\n\nfunction requireReduce () {\n\tif (hasRequiredReduce) return reduce$1;\n\thasRequiredReduce = 1;\n\tvar Observable_1 = requireObservable();\n\tvar reduce_1 = requireReduce$1();\n\tObservable_1.Observable.prototype.reduce = reduce_1.reduce;\n\t\n\treturn reduce$1;\n}\n\nvar toArray$1 = {};\n\nvar toArray = {};\n\nvar hasRequiredToArray$1;\n\nfunction requireToArray$1 () {\n\tif (hasRequiredToArray$1) return toArray;\n\thasRequiredToArray$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/**\n\t * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}\n\t * @method toArray\n\t * @owner Observable\n\t */\n\tfunction toArray$1() {\n\t    return this.lift(new ToArrayOperator());\n\t}\n\ttoArray.toArray = toArray$1;\n\tvar ToArrayOperator = (function () {\n\t    function ToArrayOperator() {\n\t    }\n\t    ToArrayOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new ToArraySubscriber(subscriber));\n\t    };\n\t    return ToArrayOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar ToArraySubscriber = (function (_super) {\n\t    __extends(ToArraySubscriber, _super);\n\t    function ToArraySubscriber(destination) {\n\t        _super.call(this, destination);\n\t        this.array = [];\n\t    }\n\t    ToArraySubscriber.prototype._next = function (x) {\n\t        this.array.push(x);\n\t    };\n\t    ToArraySubscriber.prototype._complete = function () {\n\t        this.destination.next(this.array);\n\t        this.destination.complete();\n\t    };\n\t    return ToArraySubscriber;\n\t}(Subscriber_1.Subscriber));\n\t\n\treturn toArray;\n}\n\nvar hasRequiredToArray;\n\nfunction requireToArray () {\n\tif (hasRequiredToArray) return toArray$1;\n\thasRequiredToArray = 1;\n\tvar Observable_1 = requireObservable();\n\tvar toArray_1 = requireToArray$1();\n\tObservable_1.Observable.prototype.toArray = toArray_1.toArray;\n\t\n\treturn toArray$1;\n}\n\nvar map$1 = {};\n\nvar map = {};\n\nvar hasRequiredMap$1;\n\nfunction requireMap$1 () {\n\tif (hasRequiredMap$1) return map;\n\thasRequiredMap$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/**\n\t * Applies a given `project` function to each value emitted by the source\n\t * Observable, and emits the resulting values as an Observable.\n\t *\n\t * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n\t * it passes each source value through a transformation function to get\n\t * corresponding output values.</span>\n\t *\n\t * <img src=\"./img/map.png\" width=\"100%\">\n\t *\n\t * Similar to the well known `Array.prototype.map` function, this operator\n\t * applies a projection to each value and emits that projection in the output\n\t * Observable.\n\t *\n\t * @example <caption>Map every every click to the clientX position of that click</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var positions = clicks.map(ev => ev.clientX);\n\t * positions.subscribe(x => console.log(x));\n\t *\n\t * @see {@link mapTo}\n\t * @see {@link pluck}\n\t *\n\t * @param {function(value: T, index: number): R} project The function to apply\n\t * to each `value` emitted by the source Observable. The `index` parameter is\n\t * the number `i` for the i-th emission that has happened since the\n\t * subscription, starting from the number `0`.\n\t * @param {any} [thisArg] An optional argument to define what `this` is in the\n\t * `project` function.\n\t * @return {Observable<R>} An Observable that emits the values from the source\n\t * Observable transformed by the given `project` function.\n\t * @method map\n\t * @owner Observable\n\t */\n\tfunction map$1(project, thisArg) {\n\t    if (typeof project !== 'function') {\n\t        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n\t    }\n\t    return this.lift(new MapOperator(project, thisArg));\n\t}\n\tmap.map = map$1;\n\tvar MapOperator = (function () {\n\t    function MapOperator(project, thisArg) {\n\t        this.project = project;\n\t        this.thisArg = thisArg;\n\t    }\n\t    MapOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n\t    };\n\t    return MapOperator;\n\t}());\n\tmap.MapOperator = MapOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MapSubscriber = (function (_super) {\n\t    __extends(MapSubscriber, _super);\n\t    function MapSubscriber(destination, project, thisArg) {\n\t        _super.call(this, destination);\n\t        this.project = project;\n\t        this.count = 0;\n\t        this.thisArg = thisArg || this;\n\t    }\n\t    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n\t    // using try/catch optimizations.\n\t    MapSubscriber.prototype._next = function (value) {\n\t        var result;\n\t        try {\n\t            result = this.project.call(this.thisArg, value, this.count++);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.destination.next(result);\n\t    };\n\t    return MapSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t\n\treturn map;\n}\n\nvar hasRequiredMap;\n\nfunction requireMap () {\n\tif (hasRequiredMap) return map$1;\n\thasRequiredMap = 1;\n\tvar Observable_1 = requireObservable();\n\tvar map_1 = requireMap$1();\n\tObservable_1.Observable.prototype.map = map_1.map;\n\t\n\treturn map$1;\n}\n\nvar filter$1 = {};\n\nvar filter = {};\n\nvar hasRequiredFilter$1;\n\nfunction requireFilter$1 () {\n\tif (hasRequiredFilter$1) return filter;\n\thasRequiredFilter$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Filter items emitted by the source Observable by only emitting those that\n\t * satisfy a specified predicate.\n\t *\n\t * <span class=\"informal\">Like\n\t * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n\t * it only emits a value from the source if it passes a criterion function.</span>\n\t *\n\t * <img src=\"./img/filter.png\" width=\"100%\">\n\t *\n\t * Similar to the well-known `Array.prototype.filter` method, this operator\n\t * takes values from the source Observable, passes them through a `predicate`\n\t * function and only emits those values that yielded `true`.\n\t *\n\t * @example <caption>Emit only click events whose target was a DIV element</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n\t * clicksOnDivs.subscribe(x => console.log(x));\n\t *\n\t * @see {@link distinct}\n\t * @see {@link distinctUntilChanged}\n\t * @see {@link distinctUntilKeyChanged}\n\t * @see {@link ignoreElements}\n\t * @see {@link partition}\n\t * @see {@link skip}\n\t *\n\t * @param {function(value: T, index: number): boolean} predicate A function that\n\t * evaluates each value emitted by the source Observable. If it returns `true`,\n\t * the value is emitted, if `false` the value is not passed to the output\n\t * Observable. The `index` parameter is the number `i` for the i-th source\n\t * emission that has happened since the subscription, starting from the number\n\t * `0`.\n\t * @param {any} [thisArg] An optional argument to determine the value of `this`\n\t * in the `predicate` function.\n\t * @return {Observable} An Observable of values from the source that were\n\t * allowed by the `predicate` function.\n\t * @method filter\n\t * @owner Observable\n\t */\n\tfunction filter$1(predicate, thisArg) {\n\t    return this.lift(new FilterOperator(predicate, thisArg));\n\t}\n\tfilter.filter = filter$1;\n\tvar FilterOperator = (function () {\n\t    function FilterOperator(predicate, thisArg) {\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t    }\n\t    FilterOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n\t    };\n\t    return FilterOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar FilterSubscriber = (function (_super) {\n\t    __extends(FilterSubscriber, _super);\n\t    function FilterSubscriber(destination, predicate, thisArg) {\n\t        _super.call(this, destination);\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t        this.count = 0;\n\t        this.predicate = predicate;\n\t    }\n\t    // the try catch block below is left specifically for\n\t    // optimization and perf reasons. a tryCatcher is not necessary here.\n\t    FilterSubscriber.prototype._next = function (value) {\n\t        var result;\n\t        try {\n\t            result = this.predicate.call(this.thisArg, value, this.count++);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        if (result) {\n\t            this.destination.next(value);\n\t        }\n\t    };\n\t    return FilterSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t\n\treturn filter;\n}\n\nvar hasRequiredFilter;\n\nfunction requireFilter () {\n\tif (hasRequiredFilter) return filter$1;\n\thasRequiredFilter = 1;\n\tvar Observable_1 = requireObservable();\n\tvar filter_1 = requireFilter$1();\n\tObservable_1.Observable.prototype.filter = filter_1.filter;\n\t\n\treturn filter$1;\n}\n\nvar _catch$1 = {};\n\nvar _catch = {};\n\nvar hasRequired_catch$1;\n\nfunction require_catch$1 () {\n\tif (hasRequired_catch$1) return _catch;\n\thasRequired_catch$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar OuterSubscriber_1 = requireOuterSubscriber();\n\tvar subscribeToResult_1 = requireSubscribeToResult();\n\t/**\n\t * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n\t *\n\t * <img src=\"./img/catch.png\" width=\"100%\">\n\t *\n\t * @example <caption>Continues with a different Observable when there's an error</caption>\n\t *\n\t * Observable.of(1, 2, 3, 4, 5)\n\t *   .map(n => {\n\t * \t   if (n == 4) {\n\t * \t     throw 'four!';\n\t *     }\n\t *\t   return n;\n\t *   })\n\t *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n\t *   .subscribe(x => console.log(x));\n\t *   // 1, 2, 3, I, II, III, IV, V\n\t *\n\t * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n\t *\n\t * Observable.of(1, 2, 3, 4, 5)\n\t *   .map(n => {\n\t * \t   if (n === 4) {\n\t * \t     throw 'four!';\n\t *     }\n\t * \t   return n;\n\t *   })\n\t *   .catch((err, caught) => caught)\n\t *   .take(30)\n\t *   .subscribe(x => console.log(x));\n\t *   // 1, 2, 3, 1, 2, 3, ...\n\t *\n\t * @example <caption>Throws a new error when the source Observable throws an error</caption>\n\t *\n\t * Observable.of(1, 2, 3, 4, 5)\n\t *   .map(n => {\n\t *     if (n == 4) {\n\t *       throw 'four!';\n\t *     }\n\t *     return n;\n\t *   })\n\t *   .catch(err => {\n\t *     throw 'error in source. Details: ' + err;\n\t *   })\n\t *   .subscribe(\n\t *     x => console.log(x),\n\t *     err => console.log(err)\n\t *   );\n\t *   // 1, 2, 3, error in source. Details: four!\n\t *\n\t * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n\t *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n\t *  is returned by the `selector` will be used to continue the observable chain.\n\t * @return {Observable} an observable that originates from either the source or the observable returned by the\n\t *  catch `selector` function.\n\t * @method catch\n\t * @name catch\n\t * @owner Observable\n\t */\n\tfunction _catch$1(selector) {\n\t    var operator = new CatchOperator(selector);\n\t    var caught = this.lift(operator);\n\t    return (operator.caught = caught);\n\t}\n\t_catch._catch = _catch$1;\n\tvar CatchOperator = (function () {\n\t    function CatchOperator(selector) {\n\t        this.selector = selector;\n\t    }\n\t    CatchOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n\t    };\n\t    return CatchOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar CatchSubscriber = (function (_super) {\n\t    __extends(CatchSubscriber, _super);\n\t    function CatchSubscriber(destination, selector, caught) {\n\t        _super.call(this, destination);\n\t        this.selector = selector;\n\t        this.caught = caught;\n\t    }\n\t    // NOTE: overriding `error` instead of `_error` because we don't want\n\t    // to have this flag this subscriber as `isStopped`. We can mimic the\n\t    // behavior of the RetrySubscriber (from the `retry` operator), where\n\t    // we unsubscribe from our source chain, reset our Subscriber flags,\n\t    // then subscribe to the selector result.\n\t    CatchSubscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            var result = void 0;\n\t            try {\n\t                result = this.selector(err, this.caught);\n\t            }\n\t            catch (err2) {\n\t                _super.prototype.error.call(this, err2);\n\t                return;\n\t            }\n\t            this._unsubscribeAndRecycle();\n\t            this.add(subscribeToResult_1.subscribeToResult(this, result));\n\t        }\n\t    };\n\t    return CatchSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\t\n\treturn _catch;\n}\n\nvar hasRequired_catch;\n\nfunction require_catch () {\n\tif (hasRequired_catch) return _catch$1;\n\thasRequired_catch = 1;\n\tvar Observable_1 = requireObservable();\n\tvar catch_1 = require_catch$1();\n\tObservable_1.Observable.prototype.catch = catch_1._catch;\n\tObservable_1.Observable.prototype._catch = catch_1._catch;\n\t\n\treturn _catch$1;\n}\n\nvar concat$1 = {};\n\nvar concat = {};\n\nvar mergeAll = {};\n\nvar hasRequiredMergeAll;\n\nfunction requireMergeAll () {\n\tif (hasRequiredMergeAll) return mergeAll;\n\thasRequiredMergeAll = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar OuterSubscriber_1 = requireOuterSubscriber();\n\tvar subscribeToResult_1 = requireSubscribeToResult();\n\t/**\n\t * Converts a higher-order Observable into a first-order Observable which\n\t * concurrently delivers all values that are emitted on the inner Observables.\n\t *\n\t * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n\t *\n\t * <img src=\"./img/mergeAll.png\" width=\"100%\">\n\t *\n\t * `mergeAll` subscribes to an Observable that emits Observables, also known as\n\t * a higher-order Observable. Each time it observes one of these emitted inner\n\t * Observables, it subscribes to that and delivers all the values from the\n\t * inner Observable on the output Observable. The output Observable only\n\t * completes once all inner Observables have completed. Any error delivered by\n\t * a inner Observable will be immediately emitted on the output Observable.\n\t *\n\t * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n\t * var firstOrder = higherOrder.mergeAll();\n\t * firstOrder.subscribe(x => console.log(x));\n\t *\n\t * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n\t * var firstOrder = higherOrder.mergeAll(2);\n\t * firstOrder.subscribe(x => console.log(x));\n\t *\n\t * @see {@link combineAll}\n\t * @see {@link concatAll}\n\t * @see {@link exhaust}\n\t * @see {@link merge}\n\t * @see {@link mergeMap}\n\t * @see {@link mergeMapTo}\n\t * @see {@link mergeScan}\n\t * @see {@link switch}\n\t * @see {@link zipAll}\n\t *\n\t * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n\t * Observables being subscribed to concurrently.\n\t * @return {Observable} An Observable that emits values coming from all the\n\t * inner Observables emitted by the source Observable.\n\t * @method mergeAll\n\t * @owner Observable\n\t */\n\tfunction mergeAll$1(concurrent) {\n\t    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t    return this.lift(new MergeAllOperator(concurrent));\n\t}\n\tmergeAll.mergeAll = mergeAll$1;\n\tvar MergeAllOperator = (function () {\n\t    function MergeAllOperator(concurrent) {\n\t        this.concurrent = concurrent;\n\t    }\n\t    MergeAllOperator.prototype.call = function (observer, source) {\n\t        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));\n\t    };\n\t    return MergeAllOperator;\n\t}());\n\tmergeAll.MergeAllOperator = MergeAllOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MergeAllSubscriber = (function (_super) {\n\t    __extends(MergeAllSubscriber, _super);\n\t    function MergeAllSubscriber(destination, concurrent) {\n\t        _super.call(this, destination);\n\t        this.concurrent = concurrent;\n\t        this.hasCompleted = false;\n\t        this.buffer = [];\n\t        this.active = 0;\n\t    }\n\t    MergeAllSubscriber.prototype._next = function (observable) {\n\t        if (this.active < this.concurrent) {\n\t            this.active++;\n\t            this.add(subscribeToResult_1.subscribeToResult(this, observable));\n\t        }\n\t        else {\n\t            this.buffer.push(observable);\n\t        }\n\t    };\n\t    MergeAllSubscriber.prototype._complete = function () {\n\t        this.hasCompleted = true;\n\t        if (this.active === 0 && this.buffer.length === 0) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        var buffer = this.buffer;\n\t        this.remove(innerSub);\n\t        this.active--;\n\t        if (buffer.length > 0) {\n\t            this._next(buffer.shift());\n\t        }\n\t        else if (this.active === 0 && this.hasCompleted) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    return MergeAllSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\tmergeAll.MergeAllSubscriber = MergeAllSubscriber;\n\t\n\treturn mergeAll;\n}\n\nvar hasRequiredConcat$1;\n\nfunction requireConcat$1 () {\n\tif (hasRequiredConcat$1) return concat;\n\thasRequiredConcat$1 = 1;\n\tvar isScheduler_1 = requireIsScheduler();\n\tvar ArrayObservable_1 = requireArrayObservable();\n\tvar mergeAll_1 = requireMergeAll();\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Creates an output Observable which sequentially emits all values from every\n\t * given input Observable after the current Observable.\n\t *\n\t * <span class=\"informal\">Concatenates multiple Observables together by\n\t * sequentially emitting their values, one Observable after the other.</span>\n\t *\n\t * <img src=\"./img/concat.png\" width=\"100%\">\n\t *\n\t * Joins this Observable with multiple other Observables by subscribing to them\n\t * one at a time, starting with the source, and merging their results into the\n\t * output Observable. Will wait for each Observable to complete before moving\n\t * on to the next.\n\t *\n\t * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n\t * var timer = Rx.Observable.interval(1000).take(4);\n\t * var sequence = Rx.Observable.range(1, 10);\n\t * var result = timer.concat(sequence);\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // results in:\n\t * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n\t *\n\t * @example <caption>Concatenate 3 Observables</caption>\n\t * var timer1 = Rx.Observable.interval(1000).take(10);\n\t * var timer2 = Rx.Observable.interval(2000).take(6);\n\t * var timer3 = Rx.Observable.interval(500).take(10);\n\t * var result = timer1.concat(timer2, timer3);\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // results in the following:\n\t * // (Prints to console sequentially)\n\t * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n\t * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n\t * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n\t *\n\t * @see {@link concatAll}\n\t * @see {@link concatMap}\n\t * @see {@link concatMapTo}\n\t *\n\t * @param {Observable} other An input Observable to concatenate after the source\n\t * Observable. More than one input Observables may be given as argument.\n\t * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n\t * Observable subscription on.\n\t * @return {Observable} All values of each passed Observable merged into a\n\t * single Observable, in order, in serial fashion.\n\t * @method concat\n\t * @owner Observable\n\t */\n\tfunction concat$1() {\n\t    var observables = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        observables[_i - 0] = arguments[_i];\n\t    }\n\t    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));\n\t}\n\tconcat.concat = concat$1;\n\t/* tslint:enable:max-line-length */\n\t/**\n\t * Creates an output Observable which sequentially emits all values from every\n\t * given input Observable after the current Observable.\n\t *\n\t * <span class=\"informal\">Concatenates multiple Observables together by\n\t * sequentially emitting their values, one Observable after the other.</span>\n\t *\n\t * <img src=\"./img/concat.png\" width=\"100%\">\n\t *\n\t * Joins multiple Observables together by subscribing to them one at a time and\n\t * merging their results into the output Observable. Will wait for each\n\t * Observable to complete before moving on to the next.\n\t *\n\t * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n\t * var timer = Rx.Observable.interval(1000).take(4);\n\t * var sequence = Rx.Observable.range(1, 10);\n\t * var result = Rx.Observable.concat(timer, sequence);\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // results in:\n\t * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n\t *\n\t * @example <caption>Concatenate 3 Observables</caption>\n\t * var timer1 = Rx.Observable.interval(1000).take(10);\n\t * var timer2 = Rx.Observable.interval(2000).take(6);\n\t * var timer3 = Rx.Observable.interval(500).take(10);\n\t * var result = Rx.Observable.concat(timer1, timer2, timer3);\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // results in the following:\n\t * // (Prints to console sequentially)\n\t * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n\t * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n\t * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n\t *\n\t * @see {@link concatAll}\n\t * @see {@link concatMap}\n\t * @see {@link concatMapTo}\n\t *\n\t * @param {Observable} input1 An input Observable to concatenate with others.\n\t * @param {Observable} input2 An input Observable to concatenate with others.\n\t * More than one input Observables may be given as argument.\n\t * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n\t * Observable subscription on.\n\t * @return {Observable} All values of each passed Observable merged into a\n\t * single Observable, in order, in serial fashion.\n\t * @static true\n\t * @name concat\n\t * @owner Observable\n\t */\n\tfunction concatStatic() {\n\t    var observables = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        observables[_i - 0] = arguments[_i];\n\t    }\n\t    var scheduler = null;\n\t    var args = observables;\n\t    if (isScheduler_1.isScheduler(args[observables.length - 1])) {\n\t        scheduler = args.pop();\n\t    }\n\t    if (scheduler === null && observables.length === 1) {\n\t        return observables[0];\n\t    }\n\t    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));\n\t}\n\tconcat.concatStatic = concatStatic;\n\t\n\treturn concat;\n}\n\nvar hasRequiredConcat;\n\nfunction requireConcat () {\n\tif (hasRequiredConcat) return concat$1;\n\thasRequiredConcat = 1;\n\tvar Observable_1 = requireObservable();\n\tvar concat_1 = requireConcat$1();\n\tObservable_1.Observable.prototype.concat = concat_1.concat;\n\t\n\treturn concat$1;\n}\n\nvar RouterRx_1;\nvar hasRequiredRouterRx;\n\nfunction requireRouterRx () {\n\tif (hasRequiredRouterRx) return RouterRx_1;\n\thasRequiredRouterRx = 1;\n\tvar RouterRx = {\n\t  Observable: requireObservable().Observable,\n\t  Scheduler: {\n\t    queue: requireQueue().queue\n\t  }\n\t};\n\n\trequireDefer();\n\trequireOf();\n\trequireFrom();\n\trequire_throw();\n\trequireEmpty();\n\n\trequireMergeMap();\n\trequire_do();\n\trequireDefaultIfEmpty();\n\trequireMaterialize$1();\n\trequireExpand();\n\trequireReduce();\n\trequireToArray();\n\trequireMap();\n\trequireFilter();\n\trequire_catch();\n\trequireConcat();\n\n\tRouterRx_1 = RouterRx;\n\treturn RouterRx_1;\n}\n\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n}\n\n/* global window */\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = symbolObservablePonyfill(root);\n\nvar es = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tdefault: result\n});\n\nvar require$$1 = /*@__PURE__*/getAugmentedNamespace(es);\n\nvar outputToObservable;\nvar hasRequiredOutputToObservable;\n\nfunction requireOutputToObservable () {\n\tif (hasRequiredOutputToObservable) return outputToObservable;\n\thasRequiredOutputToObservable = 1;\n\tvar Observable = requireRouterRx().Observable;\n\tvar isArray = Array.isArray;\n\tvar $$observable = require$$1.default;\n\n\t/**\n\t * For the router there are several return types from user\n\t * functions.  The standard set are: synchronous type (boolean or\n\t * json graph) or an async type (observable or a thenable).\n\t */\n\toutputToObservable = function outputToObservable(valueOrObservable) {\n\t    var value = valueOrObservable;\n\n\t    // if it's one of OUR observables, great.\n\t    if (value instanceof Observable) {\n\t        return value;\n\t    }\n\n\t    // falsy value\n\t    if (!value) {\n\t        return Observable.of(value);\n\t    }\n\n\t    // lowercase-o observables, 3rd party observables\n\t    if (value[$$observable]) {\n\t        return Observable.from(value);\n\t    }\n\n\t    // Rx4 and lower observables\n\t    if (value.subscribe) {\n\t        var oldObservable = value;\n\t        return Observable.create(function(observer) {\n\t            var oldObserver = {\n\t              onNext: function (v) {\n\t                  this.observer.next(v);\n\t              },\n\t              onError: function (err) {\n\t                  this.observer.error(err);\n\t              },\n\t              onCompleted: function () {\n\t                  this.observer.complete();\n\t              },\n\t              observer: observer\n\t            };\n\t            var oldSubscription = oldObservable.subscribe(oldObserver);\n\t            return function () {\n\t                oldSubscription.dispose();\n\t            };\n\t        });\n\t    }\n\n\t    // promises\n\t    if (value.then) {\n\t        return Observable.from(value);\n\t    }\n\n\t    // from array of pathValues.\n\t    if (isArray(value)) {\n\t        return Observable.of(value);\n\t    }\n\n\t    // this will be jsong or pathValue at this point.\n\t    // NOTE: For the case of authorize this will be a boolean\n\t    return Observable.of(value);\n\t};\n\treturn outputToObservable;\n}\n\nvar isJSONG;\nvar hasRequiredIsJSONG;\n\nfunction requireIsJSONG () {\n\tif (hasRequiredIsJSONG) return isJSONG;\n\thasRequiredIsJSONG = 1;\n\tisJSONG = function isJSONG(x) {\n\t    return x.jsonGraph;\n\t};\n\treturn isJSONG;\n}\n\nvar errorToPathValue;\nvar hasRequiredErrorToPathValue;\n\nfunction requireErrorToPathValue () {\n\tif (hasRequiredErrorToPathValue) return errorToPathValue;\n\thasRequiredErrorToPathValue = 1;\n\tvar JSONGraphError = JSONGraphErrorExports;\n\terrorToPathValue = function errorToPathValue(error, path) {\n\t    var typeValue = {\n\t        $type: 'error',\n\t        value: {}\n\t    };\n\n\t    if (error.throwToNext) {\n\t        throw error;\n\t    }\n\n\t    // If it is a special JSONGraph error then pull all the data\n\t    if (error instanceof JSONGraphError) {\n\t        typeValue = error.typeValue;\n\t    }\n\n\t    else if (error instanceof Error) {\n\t        typeValue.value.message = error.message;\n\t    }\n\n\t    return {\n\t        path: path,\n\t        value: typeValue\n\t    };\n\t};\n\treturn errorToPathValue;\n}\n\nvar noteToJsongOrPV;\nvar hasRequiredNoteToJsongOrPV;\n\nfunction requireNoteToJsongOrPV () {\n\tif (hasRequiredNoteToJsongOrPV) return noteToJsongOrPV;\n\thasRequiredNoteToJsongOrPV = 1;\n\tvar isJSONG = requireIsJSONG();\n\tvar onNext = 'N';\n\tvar errorToPathValue = requireErrorToPathValue();\n\n\t/**\n\t * Takes a path and for every onNext / onError it will attempt\n\t * to pluck the value or error from the note and process it\n\t * with the path object passed in.\n\t * @param {PathSet|PathSet[]} pathOrPathSet -\n\t * @param {Boolean} isPathSet -\n\t */\n\tnoteToJsongOrPV = function noteToJsongOrPV(pathOrPathSet,\n\t                                          isPathSet,\n\t                                          routerInstance) {\n\t    return function(note) {\n\t        return convertNoteToJsongOrPV(\n\t          pathOrPathSet, note, isPathSet, routerInstance\n\t        );\n\t    };\n\t};\n\n\tfunction convertNoteToJsongOrPV(pathOrPathSet,\n\t                                note,\n\t                                isPathSet,\n\t                                routerInstance) {\n\t    var incomingJSONGOrPathValues;\n\t    var kind = note.kind;\n\n\t    // Take what comes out of the function and assume its either a pathValue or\n\t    // jsonGraph.\n\t    if (kind === onNext) {\n\t        incomingJSONGOrPathValues = note.value;\n\t    }\n\n\t    // Convert the error to a pathValue.\n\t    else {\n\t        incomingJSONGOrPathValues =\n\t            errorToPathValue(note.error, pathOrPathSet);\n\n\t        if (routerInstance._errorHook) {\n\t            routerInstance._errorHook(note.error);\n\t        }\n\t    }\n\n\t    // If its jsong we may need to optionally attach the\n\t    // paths if the paths do not exist\n\t    if (isJSONG(incomingJSONGOrPathValues) &&\n\t        !incomingJSONGOrPathValues.paths) {\n\n\t        incomingJSONGOrPathValues = {\n\t            jsonGraph: incomingJSONGOrPathValues.jsonGraph,\n\t            paths: isPathSet && pathOrPathSet || [pathOrPathSet]\n\t        };\n\t    }\n\n\t    return incomingJSONGOrPathValues;\n\t}\n\treturn noteToJsongOrPV;\n}\n\nvar runGetAction;\nvar hasRequiredRunGetAction;\n\nfunction requireRunGetAction () {\n\tif (hasRequiredRunGetAction) return runGetAction;\n\thasRequiredRunGetAction = 1;\n\tvar outputToObservable = requireOutputToObservable();\n\tvar noteToJsongOrPV = requireNoteToJsongOrPV();\n\tvar Observable = requireRouterRx().Observable;\n\n\trunGetAction = function runGetAction(routerInstance, jsongCache,\n\t    methodSummary) {\n\t    return function innerGetAction(matchAndPath) {\n\t        return getAction(routerInstance, matchAndPath,\n\t            jsongCache, methodSummary);\n\t    };\n\t};\n\n\tfunction getAction(routerInstance, matchAndPath, jsongCache, methodSummary) {\n\t    var match = matchAndPath.match;\n\t    var out;\n\t    try {\n\t        out = match.action.call(routerInstance, matchAndPath.path);\n\t        out = outputToObservable(out);\n\t        if (methodSummary) {\n\t            var _out = out;\n\t            out = Observable.defer(function () {\n\t                var route = {\n\t                    start: routerInstance._now(),\n\t                    route: matchAndPath.match.prettyRoute,\n\t                    pathSet: matchAndPath.path,\n\t                    results: []\n\t                };\n\t                methodSummary.routes.push(route);\n\t                return _out.do(function (response) {\n\t                    route.results.push({\n\t                        time: routerInstance._now(),\n\t                        value: response\n\t                    });\n\t                }, function (err) {\n\t                    route.error = err;\n\t                    route.end = routerInstance._now();\n\t                }, function () {\n\t                    route.end = routerInstance._now();\n\t                });\n\t            });\n\t        }\n\t    } catch (e) {\n\t        out = Observable.throw(e);\n\t    }\n\n\t    return out.\n\t        materialize().\n\t        filter(function(note) {\n\t            return note.kind !== 'C';\n\t        }).\n\t        map(noteToJsongOrPV(matchAndPath.path, false, routerInstance)).\n\t        map(function(jsonGraphOrPV) {\n\t            return [matchAndPath.match, jsonGraphOrPV];\n\t        });\n\t}\n\treturn runGetAction;\n}\n\nvar stripFromRange;\nvar hasRequiredStripFromRange;\n\nfunction requireStripFromRange () {\n\tif (hasRequiredStripFromRange) return stripFromRange;\n\thasRequiredStripFromRange = 1;\n\tvar isArray = Array.isArray;\n\tvar rangeToArray = rangeToArray$2;\n\tvar isNumber = isNumber$2;\n\t/**\n\t *  Takes the first argument, toStrip, and strips it from\n\t * the range.  The output is an array of ranges that represents\n\t * the remaining ranges (relative complement)\n\t *\n\t * One note.  When toStrip is an array, we simply recurse\n\t * over each key.  Else it requires a lot more logic.\n\t *\n\t * Since we recurse array keys we are not guaranteed that each strip\n\t * item coming in is a string integer.  That is why we are doing an isNaN\n\t * check. consider: {from: 0, to: 1} and [0, 'one'] intersect at 0, but will\n\t * get 'one' fed into stripFromRange.\n\t *\n\t * @param {Array|String|Number|Object} argToStrip can be a string, number,\n\t * or a routed token.  Cannot be a range itself.\n\t * @param {Range} range\n\t * @return {Array.<Range>} The relative complement.\n\t */\n\tstripFromRange = function stripFromRange(argToStrip, range) {\n\t    var ranges = [];\n\t    var matches = [];\n\t    var toStrip = argToStrip;\n\t    // TODO: More than likely a bug around numbers and stripping\n\t    var toStripIsNumber = isNumber(toStrip);\n\t    if (toStripIsNumber) {\n\t        toStrip = +toStrip;\n\t    }\n\n\t    // Strip out NaNs\n\t    if (!toStripIsNumber && typeof toStrip === 'string') {\n\t        ranges = [range];\n\t    }\n\n\t    else if (isArray(toStrip)) {\n\t        var currenRanges = [range];\n\t        toStrip.forEach(function(atom) {\n\t            var nextRanges = [];\n\t            currenRanges.forEach(function(currentRename) {\n\t                var matchAndComplement = stripFromRange(atom, currentRename);\n\t                if (matchAndComplement[0] !== undefined) {\n\t                    matches = matches.concat(matchAndComplement[0]);\n\t                }\n\n\t                nextRanges = nextRanges.concat(matchAndComplement[1]);\n\t            });\n\t            currenRanges = nextRanges;\n\t        });\n\n\t        ranges = currenRanges;\n\t    }\n\n\t    // The simple case, its just a number.\n\t    else if (toStripIsNumber) {\n\n\t        if (range.from < toStrip && toStrip < range.to) {\n\t            ranges[0] = {\n\t                from: range.from,\n\t                to: toStrip - 1\n\t            };\n\t            ranges[1] = {\n\t                from: toStrip + 1,\n\t                to: range.to\n\t            };\n\t            matches = [toStrip];\n\t        }\n\n\t        // In case its a 0 length array.\n\t        // Even though this assignment is redundant, its point is\n\t        // to capture the intention.\n\t        else if (range.from === toStrip && range.to === toStrip) {\n\t            ranges = [];\n\t            matches = [toStrip];\n\t        }\n\n\t        else if (range.from === toStrip) {\n\t            ranges[0] = {\n\t                from: toStrip + 1,\n\t                to: range.to\n\t            };\n\t            matches = [toStrip];\n\t        }\n\n\t        else if (range.to === toStrip) {\n\t            ranges[0] = {\n\t                from: range.from,\n\t                to: toStrip - 1\n\t            };\n\t            matches = [toStrip];\n\t        }\n\n\t        // return the range if no intersection.\n\t        else {\n\t            ranges = [range];\n\t        }\n\t    }\n\n\t    // Its a routed token.  Everything is matched.\n\t    else {\n\t        matches = rangeToArray(range);\n\t    }\n\n\t    // If this is a routedToken (Object) then it will match the entire\n\t    // range since its integers, keys, and ranges.\n\t    return [matches, ranges];\n\t};\n\treturn stripFromRange;\n}\n\nvar stripFromArray;\nvar hasRequiredStripFromArray;\n\nfunction requireStripFromArray () {\n\tif (hasRequiredStripFromArray) return stripFromArray;\n\thasRequiredStripFromArray = 1;\n\tvar stripFromRange = requireStripFromRange();\n\tvar Keys = Keys_1;\n\tvar isArray = Array.isArray;\n\n\t/**\n\t * Takes a string, number, or RoutedToken and removes it from\n\t * the array.  The results are the relative complement of what\n\t * remains in the array.\n\t *\n\t * Don't forget: There was an intersection test performed but\n\t * since we recurse over arrays, we will get elements that do\n\t * not intersect.\n\t *\n\t * Another one is if its a routed token and a ranged array then\n\t * no work needs to be done as integers, ranges, and keys match\n\t * that token set.\n\t *\n\t * One more note.  When toStrip is an array, we simply recurse\n\t * over each key.  Else it requires a lot more logic.\n\t *\n\t * @param {Array|String|Number|RoutedToken} toStrip\n\t * @param {Array} array\n\t * @return {Array} the relative complement.\n\t */\n\tstripFromArray = function stripFromArray(toStrip, array) {\n\t    var complement;\n\t    var matches = [];\n\t    var typeToStrip = typeof toStrip;\n\t    var isRangedArray = typeof array[0] === 'object';\n\t    var isNumber = typeToStrip === 'number';\n\t    var isString = typeToStrip === 'string';\n\t    var isRoutedToken = !isNumber && !isString;\n\t    var routeType = isRoutedToken && toStrip.type || false;\n\t    var isKeys = routeType === Keys.keys;\n\t    var toStripIsArray = isArray(toStrip);\n\n\t    // The early break case.  If its a key, then there is never a\n\t    // relative complement.\n\t    if (isKeys) {\n\t        complement = [];\n\t        matches = array;\n\t    }\n\n\t    // Recurse over all the keys of the array.\n\t    else if (toStripIsArray) {\n\t        var currentArray = array;\n\t        toStrip.forEach(function(atom) {\n\t            var results = stripFromArray(atom, currentArray);\n\t            if (results[0] !== undefined) { // eslint-disable-line no-undefined\n\t                matches = matches.concat(results[0]);\n\t            }\n\t            currentArray = results[1];\n\t        });\n\t        complement = currentArray;\n\t    }\n\n\t    // The simple case, remove only the matching element from array.\n\t    else if (!isRangedArray && !isRoutedToken) {\n\t        matches = [toStrip];\n\t        complement = array.filter(function(x) {\n\t            return toStrip !== x;\n\t        });\n\t    }\n\n\t    // 1: from comments above\n\t    else if (isRangedArray && !isRoutedToken) {\n\t        complement = array.reduce(function(comp, range) {\n\t            var results = stripFromRange(toStrip, range);\n\t            if (results[0] !== undefined) { // eslint-disable-line no-undefined\n\t                matches = matches.concat(results[0]);\n\t            }\n\t            return comp.concat(results[1]);\n\t        }, []);\n\t    }\n\n\t    // Strips elements based on routed token type.\n\t    // We already matched keys above, so we only need to strip numbers.\n\t    else if (!isRangedArray && isRoutedToken) {\n\t        complement = array.filter(function(el) {\n\t            var type = typeof el;\n\t            if (type === 'number') {\n\t                matches[matches.length] = el;\n\t                return false;\n\t            }\n\t            return true;\n\t        });\n\t    }\n\n\t    // The final complement is rangedArray with a routedToken,\n\t    // relative complement is always empty.\n\t    else {\n\t        complement = [];\n\t        matches = array;\n\t    }\n\n\t    return [matches, complement];\n\t};\n\treturn stripFromArray;\n}\n\nvar strip;\nvar hasRequiredStrip;\n\nfunction requireStrip () {\n\tif (hasRequiredStrip) return strip;\n\thasRequiredStrip = 1;\n\tvar isArray = Array.isArray;\n\tvar stripFromArray = requireStripFromArray();\n\tvar stripFromRange = requireStripFromRange();\n\n\t/**\n\t *  Takes a virtual atom and the matched atom and returns an\n\t * array of results that is relative complement with matchedAtom\n\t * as the rhs.  I believe the proper set syntax is virutalAtom \\ matchedAtom.\n\t *\n\t * 1) An assumption made is that the matched atom and virtual atom have\n\t * an intersection.  This makes the algorithm easier since if the matched\n\t * atom is a primitive and the virtual atom is an object\n\t * then there is no relative complement to create.  This also means if\n\t * the direct equality test fails and matchedAtom is not an object\n\t * then virtualAtom is an object.  The inverse applies.\n\t *\n\t *\n\t * @param {String|Number|Array|Object} matchedAtom\n\t * @param {String|Number|Array|Object} virtualAtom\n\t * @return {Array} the tuple of what was matched and the relative complenment.\n\t */\n\tstrip = function strip(matchedAtom, virtualAtom) {\n\t    var relativeComplement = [];\n\t    var matchedResults;\n\t    var typeOfMatched = typeof matchedAtom;\n\t    var isArrayMatched = isArray(matchedAtom);\n\t    var isObjectMatched = typeOfMatched === 'object';\n\n\t    // Lets assume they are not objects  This covers the\n\t    // string / number cases.\n\t    if (matchedAtom === virtualAtom ||\n\t       String(matchedAtom) === String(virtualAtom)) {\n\n\t        matchedResults = [matchedAtom];\n\t    }\n\n\t    // See function comment 1)\n\t    else if (!isObjectMatched) {\n\t        matchedResults = [matchedAtom];\n\t    }\n\n\t    // Its a complex object set potentially.  Let the\n\t    // subroutines handle the cases.\n\t    else {\n\t        var results;\n\n\t        // The matchedAtom needs to reduced to everything that is not in\n\t        // the virtualAtom.\n\t        if (isArrayMatched) {\n\t            results = stripFromArray(virtualAtom, matchedAtom);\n\t            matchedResults = results[0];\n\t            relativeComplement = results[1];\n\t        } else {\n\t            results = stripFromRange(virtualAtom, matchedAtom);\n\t            matchedResults = results[0];\n\t            relativeComplement = results[1];\n\t        }\n\t    }\n\n\t    if (matchedResults.length === 1) {\n\t        matchedResults = matchedResults[0];\n\t    }\n\n\t    return [matchedResults, relativeComplement];\n\t};\n\treturn strip;\n}\n\nvar catAndSlice;\nvar hasRequiredCatAndSlice;\n\nfunction requireCatAndSlice () {\n\tif (hasRequiredCatAndSlice) return catAndSlice;\n\thasRequiredCatAndSlice = 1;\n\tcatAndSlice = function catAndSlice(a, b, slice) {\n\t    var next = [], i, j, len;\n\t    for (i = 0, len = a.length; i < len; ++i) {\n\t        next[i] = a[i];\n\t    }\n\n\t    for (j = slice || 0, len = b.length; j < len; ++j, ++i) {\n\t        next[i] = b[j];\n\t    }\n\n\t    return next;\n\t};\n\treturn catAndSlice;\n}\n\nvar stripPath;\nvar hasRequiredStripPath;\n\nfunction requireStripPath () {\n\tif (hasRequiredStripPath) return stripPath;\n\thasRequiredStripPath = 1;\n\tvar strip = requireStrip();\n\tvar catAndSlice = requireCatAndSlice();\n\n\t/**\n\t * Takes in the matched path and virtual path and creates the\n\t * set of paths that represent the virtualPath being stripped\n\t * from the matchedPath.\n\t *\n\t * @example\n\t * Terms:\n\t * * Relative Complement: Of sets A and B the relative complement of A in B is\n\t * the parts of B that A do not contain.  In our example its virtualPath (A) in\n\t * matchedPath (B).\n\t *\n\t * Example:\n\t * matchedInput = [[A, D], [B, E], [C, F]]\n\t * virtualIntput = [A, Keys, C]\n\t *\n\t * This will produce 2 arrays from the matched operation.\n\t * [\n\t *   [D, [B, E], [C, F]],\n\t *   [A, [B, E], [F]]\n\t * ]\n\t *\n\t *\n\t * All the complexity of this function is hidden away in strip and its inner\n\t * stripping functions.\n\t * @param {PathSet} matchedPath\n\t * @param {PathSet} virtualPath\n\t */\n\tstripPath = function stripPath(matchedPath, virtualPath) {\n\t    var relativeComplement = [];\n\t    var exactMatch = [];\n\t    var current = [];\n\n\t    // Always use virtual path because it can be shorter.\n\t    for (var i = 0, len = virtualPath.length; i < len; ++i) {\n\t        var matchedAtom = matchedPath[i];\n\t        var virtualAtom = virtualPath[i];\n\t        var stripResults = strip(matchedAtom, virtualAtom);\n\t        var innerMatch = stripResults[0];\n\t        var innerComplement = stripResults[1];\n\t        var hasComplement = innerComplement.length > 0;\n\n\t        // using the algorithm partially described above we need to split and\n\t        // combine output depending on what comes out of the split function.\n\t        // 1.  If there is no relative complement do no copying / slicing.\n\t        // 2.  If there is both the catAndslice.\n\n\t        if (hasComplement) {\n\t            var flattendIC = innerComplement.length === 1 ?\n\t                innerComplement[0] : innerComplement;\n\t            current[i] = flattendIC;\n\t            relativeComplement[relativeComplement.length] =\n\t                catAndSlice(current, matchedPath, i + 1);\n\t        }\n\n\t        // The exact match needs to be produced for calling function.\n\t        exactMatch[i] = innerMatch;\n\t        current[i] = innerMatch;\n\t    }\n\n\t    return [exactMatch, relativeComplement];\n\t};\n\treturn stripPath;\n}\n\nvar isRange;\nvar hasRequiredIsRange;\n\nfunction requireIsRange () {\n\tif (hasRequiredIsRange) return isRange;\n\thasRequiredIsRange = 1;\n\tisRange = function isRange(range) {\n\t    return range.hasOwnProperty('to') && range.hasOwnProperty('from');\n\t};\n\treturn isRange;\n}\n\nvar hasAtomIntersection;\nvar hasRequiredHasAtomIntersection;\n\nfunction requireHasAtomIntersection () {\n\tif (hasRequiredHasAtomIntersection) return hasAtomIntersection;\n\thasRequiredHasAtomIntersection = 1;\n\tvar Keys = Keys_1;\n\tvar isArray = Array.isArray;\n\tvar isRoutedToken = isRoutedToken$1;\n\tvar isRange = requireIsRange();\n\n\t/**\n\t * Takes a matched and virtual atom and validates that they have an\n\t * intersection.\n\t */\n\thasAtomIntersection = function hasAtomIntersection(matchedAtom, virtualAtom) {\n\t    var virtualIsRoutedToken = isRoutedToken(virtualAtom);\n\t    var isKeys = virtualIsRoutedToken && virtualAtom.type === Keys.keys;\n\t    var matched = false;\n\t    var i, len;\n\n\t    // To simplify the algorithm we do not allow matched atom to be an\n\t    // array.  This makes the intersection test very simple.\n\t    if (isArray(matchedAtom)) {\n\t        for (i = 0, len = matchedAtom.length; i < len && !matched; ++i) {\n\t            matched = hasAtomIntersection(matchedAtom[i], virtualAtom);\n\t        }\n\t    }\n\n\t    // the == is very intentional here with all the use cases review.\n\t    else if (doubleEquals(matchedAtom, virtualAtom)) {\n\t        matched = true;\n\t    }\n\n\t    // Keys match everything.\n\t    else if (isKeys) {\n\t        matched = true;\n\t    }\n\n\t    // The routed token is for integers at this point.\n\t    else if (virtualIsRoutedToken) {\n\t        matched = isNumber(matchedAtom) || isRange(matchedAtom);\n\t    }\n\n\t    // is virtual an array (last option)\n\t    // Go through each of the array elements and compare against matched item.\n\t    else if (isArray(virtualAtom)) {\n\t        for (i = 0, len = virtualAtom.length; i < len && !matched; ++i) {\n\t            matched = hasAtomIntersection(matchedAtom, virtualAtom[i]);\n\t        }\n\t    }\n\n\t    return matched;\n\t};\n\n\t//\n\tfunction isNumber(x) {\n\t    return String(Number(x)) === String(x);\n\t}\n\n\t/**\n\t * This was very intentional ==.  The reason is that '1' must equal 1.\n\t * {} of anysort are always false and array ['one'] == 'one' but that is\n\t * fine because i would have to go through the array anyways at the\n\t * last elseif check.\n\t */\n\tfunction doubleEquals(a, b) {\n\t    return a == b; // eslint-disable-line eqeqeq\n\t}\n\treturn hasAtomIntersection;\n}\n\nvar hasIntersection;\nvar hasRequiredHasIntersection;\n\nfunction requireHasIntersection () {\n\tif (hasRequiredHasIntersection) return hasIntersection;\n\thasRequiredHasIntersection = 1;\n\tvar hasAtomIntersection = requireHasAtomIntersection();\n\n\t/**\n\t * Checks to see if there is an intersection between the matched and\n\t * virtual paths.\n\t */\n\thasIntersection = function hasIntersection(matchedPath, virtualPath) {\n\t    var intersection = true;\n\n\t    // cycles through the atoms and ensure each one has an intersection.\n\t    // only use the virtual path because it can be shorter than the full\n\t    // matched path (since it includes suffix).\n\t    for (var i = 0, len = virtualPath.length; i < len && intersection; ++i) {\n\t        intersection = hasAtomIntersection(matchedPath[i], virtualPath[i]);\n\t    }\n\n\t    return intersection;\n\t};\n\treturn hasIntersection;\n}\n\n/* eslint-disable max-len */\n\nvar getExecutableMatches;\nvar hasRequiredGetExecutableMatches;\n\nfunction requireGetExecutableMatches () {\n\tif (hasRequiredGetExecutableMatches) return getExecutableMatches;\n\thasRequiredGetExecutableMatches = 1;\n\tvar pathUtils = lib;\n\tvar collapse = pathUtils.collapse;\n\tvar stripPath = requireStripPath();\n\tvar hasIntersection = requireHasIntersection();\n\t/* eslint-enable max-len */\n\n\t/**\n\t * takes in the set of ordered matches and pathSet that got those matches.\n\t * From there it will give back a list of matches to execute.\n\t */\n\tgetExecutableMatches = function getExecutableMatches(matches, pathSet) {\n\t    var remainingPaths = pathSet;\n\t    var matchAndPaths = [];\n\t    var out = {\n\t        matchAndPaths: matchAndPaths,\n\t        unhandledPaths: false\n\t    };\n\t    for (var i = 0; i < matches.length && remainingPaths.length > 0; ++i) {\n\t        var availablePaths = remainingPaths;\n\t        var match = matches[i];\n\n\t        remainingPaths = [];\n\n\t        if (i > 0) {\n\t            availablePaths = collapse(availablePaths);\n\t        }\n\n\t        // For every available path attempt to intersect.  If there\n\t        // is an intersection then strip and replace.\n\t        // any relative complements, add to remainingPaths\n\t        for (var j = 0; j < availablePaths.length; ++j) {\n\t            var path = availablePaths[j];\n\t            if (hasIntersection(path, match.virtual)) {\n\t                var stripResults = stripPath(path, match.virtual);\n\t                matchAndPaths[matchAndPaths.length] = {\n\t                    path: stripResults[0],\n\t                    match: match\n\t                };\n\t                remainingPaths = remainingPaths.concat(stripResults[1]);\n\t            } else if (i < matches.length - 1) {\n\t                remainingPaths[remainingPaths.length] = path;\n\t            }\n\t        }\n\t    }\n\n\t    // Adds the remaining paths to the unhandled paths section.\n\t    if (remainingPaths && remainingPaths.length) {\n\t        out.unhandledPaths = remainingPaths;\n\t    }\n\n\t    return out;\n\t};\n\treturn getExecutableMatches;\n}\n\nvar runByPrecedence;\nvar hasRequiredRunByPrecedence;\n\nfunction requireRunByPrecedence () {\n\tif (hasRequiredRunByPrecedence) return runByPrecedence;\n\thasRequiredRunByPrecedence = 1;\n\tvar Observable = requireRouterRx().Observable;\n\tvar getExecutableMatches = requireGetExecutableMatches();\n\n\t/**\n\t * Sorts and strips the set of available matches given the pathSet.\n\t */\n\trunByPrecedence = function runByPrecedence(pathSet, matches, actionRunner) {\n\n\t    // Precendence matching\n\t    var sortedMatches = matches.\n\t        sort(function(a, b) {\n\t            if (a.precedence < b.precedence) {\n\t                return 1;\n\t            } else if (a.precedence > b.precedence) {\n\t                return -1;\n\t            }\n\n\t            return 0;\n\t        });\n\n\t    var execs = getExecutableMatches(sortedMatches, [pathSet]);\n\n\t    var setOfMatchedPaths = Observable.\n\t        from(execs.matchAndPaths).\n\t        flatMap(actionRunner).\n\n\t        // Note: We do not wait for each observable to finish,\n\t        // but repeat the cycle per onNext.\n\t        map(function(actionTuple) {\n\n\t            return {\n\t                match: actionTuple[0],\n\t                value: actionTuple[1]\n\t            };\n\t        });\n\n\t    if (execs.unhandledPaths) {\n\t        setOfMatchedPaths = setOfMatchedPaths.\n\t            concat(Observable.of({\n\t                match: {suffix: []},\n\t                value: {\n\t                    isMessage: true,\n\t                    unhandledPaths: execs.unhandledPaths\n\t                }\n\t            }));\n\t    }\n\n\t    return setOfMatchedPaths;\n\t};\n\treturn runByPrecedence;\n}\n\nvar types;\nvar hasRequiredTypes;\n\nfunction requireTypes () {\n\tif (hasRequiredTypes) return types;\n\thasRequiredTypes = 1;\n\ttypes = {\n\t    $ref: 'ref',\n\t    $atom: 'atom',\n\t    $error: 'error'\n\t};\n\treturn types;\n}\n\nvar followReference;\nvar hasRequiredFollowReference;\n\nfunction requireFollowReference () {\n\tif (hasRequiredFollowReference) return followReference;\n\thasRequiredFollowReference = 1;\n\tvar cloneArray = cloneArray_1$1;\n\tvar $ref = requireTypes().$ref;\n\tvar errors = exceptions;\n\n\t/**\n\t * performs the simplified cache reference follow.  This\n\t * differs from get as there is just following and reporting,\n\t * not much else.\n\t *\n\t * @param {Object} cacheRoot\n\t * @param {Array} ref\n\t */\n\tfollowReference = function followReference(cacheRoot, ref, maxRefFollow) {\n\t    var current = cacheRoot;\n\t    var refPath = ref;\n\t    var depth = -1;\n\t    var length = refPath.length;\n\t    var key, next, type;\n\t    var referenceCount = 0;\n\n\t    while (++depth < length) {\n\t        key = refPath[depth];\n\t        next = current[key];\n\t        type = next && next.$type;\n\n\t        if (!next || type && type !== $ref) {\n\t            current = next;\n\t            break;\n\t        }\n\n\t        // Show stopper exception.  This route is malformed.\n\t        if (type && type === $ref && depth + 1 < length) {\n\t            var err = new Error(errors.innerReferences);\n\t            err.throwToNext = true;\n\t            throw err;\n\t        }\n\n\t        // potentially follow reference\n\t        if (depth + 1 === length) {\n\t            if (type === $ref) {\n\t                depth = -1;\n\t                refPath = next.value;\n\t                length = refPath.length;\n\t                next = cacheRoot;\n\t                referenceCount++;\n\t            }\n\n\t            if (referenceCount > maxRefFollow) {\n\t                throw new Error(errors.circularReference);\n\t            }\n\t        }\n\t        current = next;\n\t    }\n\n\t    return [current, cloneArray(refPath)];\n\t};\n\treturn followReference;\n}\n\nvar optimizePathSets;\nvar hasRequiredOptimizePathSets;\n\nfunction requireOptimizePathSets () {\n\tif (hasRequiredOptimizePathSets) return optimizePathSets;\n\thasRequiredOptimizePathSets = 1;\n\tvar iterateKeySet = lib.iterateKeySet;\n\tvar cloneArray = cloneArray_1$1;\n\tvar catAndSlice = requireCatAndSlice();\n\tvar $types = requireTypes();\n\tvar $ref = $types.$ref;\n\tvar followReference = requireFollowReference();\n\n\t/**\n\t * The fastest possible optimize of paths.\n\t *\n\t * What it does:\n\t * - Any atom short-circuit / found value will be removed from the path.\n\t * - All paths will be exploded which means that collapse will need to be\n\t *   ran afterwords.\n\t * - Any missing path will be optimized as much as possible.\n\t */\n\toptimizePathSets = function optimizePathSets(cache, paths, maxRefFollow) {\n\t    var optimized = [];\n\t    paths.forEach(function(p) {\n\t        optimizePathSet(cache, cache, p, 0, optimized, [], maxRefFollow);\n\t    });\n\n\t    return optimized;\n\t};\n\n\n\t/**\n\t * optimizes one pathSet at a time.\n\t */\n\tfunction optimizePathSet(cache, cacheRoot, pathSet,\n\t                         depth, out, optimizedPath, maxRefFollow) {\n\n\t    // at missing, report optimized path.\n\t    if (cache === undefined) {\n\t        out[out.length] = catAndSlice(optimizedPath, pathSet, depth);\n\t        return;\n\t    }\n\n\t    // all other sentinels are short circuited.\n\t    // Or we found a primitive (which includes null)\n\t    if (cache === null || (cache.$type && cache.$type !== $ref) ||\n\t            (typeof cache !== 'object')) {\n\t        return;\n\t    }\n\n\t    // If the reference is the last item in the path then do not\n\t    // continue to search it.\n\t    if (cache.$type === $ref && depth === pathSet.length) {\n\t        return;\n\t    }\n\n\t    var keySet = pathSet[depth];\n\t    var nextDepth = depth + 1;\n\t    var iteratorNote = {};\n\t    var key, next, nextOptimized;\n\n\t    key = iterateKeySet(keySet, iteratorNote);\n\t    do {\n\t        next = cache[key];\n\t        var optimizedPathLength = optimizedPath.length;\n\t        if (key !== null) {\n\t            optimizedPath[optimizedPathLength] = key;\n\t        }\n\n\t        if (next && next.$type === $ref && nextDepth < pathSet.length) {\n\t            var refResults =\n\t                followReference(cacheRoot, next.value, maxRefFollow);\n\t            next = refResults[0];\n\n\t            // must clone to avoid the mutation from above destroying the cache.\n\t            nextOptimized = cloneArray(refResults[1]);\n\t        } else {\n\t            nextOptimized = optimizedPath;\n\t        }\n\n\t        optimizePathSet(next, cacheRoot, pathSet, nextDepth,\n\t                        out, nextOptimized, maxRefFollow);\n\t        optimizedPath.length = optimizedPathLength;\n\n\t        if (!iteratorNote.done) {\n\t            key = iterateKeySet(keySet, iteratorNote);\n\t        }\n\t    } while (!iteratorNote.done);\n\t}\n\treturn optimizePathSets;\n}\n\nvar clone;\nvar hasRequiredClone;\n\nfunction requireClone () {\n\tif (hasRequiredClone) return clone;\n\thasRequiredClone = 1;\n\tclone = function copy(valueType) {\n\t    if ((typeof valueType !== 'object') || (valueType === null)) {\n\t        return valueType;\n\t    }\n\n\t    return Object.\n\t        keys(valueType).\n\t        reduce(function(acc, k) {\n\t            acc[k] = valueType[k];\n\t            return acc;\n\t        }, {});\n\t};\n\treturn clone;\n}\n\nvar jsongMerge;\nvar hasRequiredJsongMerge;\n\nfunction requireJsongMerge () {\n\tif (hasRequiredJsongMerge) return jsongMerge;\n\thasRequiredJsongMerge = 1;\n\tvar iterateKeySet = lib.iterateKeySet;\n\tvar types = requireTypes();\n\tvar $ref = types.$ref;\n\tvar $error = types.$error;\n\tvar clone = requireClone();\n\tvar cloneArray = cloneArray_1$1;\n\tvar catAndSlice = requireCatAndSlice();\n\n\t/**\n\t * merges jsong into a seed\n\t */\n\tjsongMerge = function jsongMerge(cache, jsongEnv, routerInstance) {\n\t    var paths = jsongEnv.paths;\n\t    var j = jsongEnv.jsonGraph;\n\t    var references = [];\n\t    var values = [];\n\n\t    paths.forEach(function(p) {\n\t        merge({\n\t            router: routerInstance,\n\t            cacheRoot: cache,\n\t            messageRoot: j,\n\t            references: references,\n\t            values: values,\n\t            requestedPath: [],\n\t            requestIdx: -1,\n\t            ignoreCount: 0\n\t        },  cache, j, 0, p);\n\t    });\n\n\t    return {\n\t        references: references,\n\t        values: values\n\t    };\n\t};\n\n\tfunction merge(config, cache, message, depth, path, fromParent, fromKey) {\n\t    var cacheRoot = config.cacheRoot;\n\t    var messageRoot = config.messageRoot;\n\t    var requestedPath = config.requestedPath;\n\t    var ignoreCount = config.ignoreCount;\n\t    var typeOfMessage = typeof message;\n\t    var requestIdx = config.requestIdx;\n\t    var updateRequestedPath = ignoreCount <= depth;\n\t    if (updateRequestedPath) {\n\t        requestIdx = ++config.requestIdx;\n\t    }\n\n\t    // The message at this point should always be defined.\n\t    // Reached the end of the JSONG message path\n\t    if (message === null || typeOfMessage !== 'object' || message.$type) {\n\t        fromParent[fromKey] = clone(message);\n\n\t        // If we notice an error while merging, we'll fire the error hook\n\t        // for logging purposes.\n\t        if (message && message.$type === $error) {\n\t            config.router._pathErrorHook({ path: path, value: message });\n\t        }\n\n\t        // NOTE: If we have found a reference at our cloning position\n\t        // and we have resolved our path then add the reference to\n\t        // the unfulfilledRefernces.\n\t        if (message && message.$type === $ref) {\n\t            var references = config.references;\n\t            references.push({\n\t                path: cloneArray(requestedPath),\n\t                value: message.value\n\t            });\n\t        }\n\n\t        // We are dealing with a value.  We need this for call\n\t        // Call needs to report all of its values into the jsongCache\n\t        // and paths.\n\t        else {\n\t            var values = config.values;\n\t            values.push({\n\t                path: cloneArray(requestedPath),\n\t                value: (message && message.type) ? message.value : message\n\t            });\n\t        }\n\n\t        return;\n\t    }\n\n\t    var outerKey = path[depth];\n\t    var iteratorNote = {};\n\t    var key;\n\t    key = iterateKeySet(outerKey, iteratorNote);\n\n\t    // We always attempt this as a loop.  If the memo exists then\n\t    // we assume that the permutation is needed.\n\t    do {\n\n\t        // If the cache exists and we are not at our height, then\n\t        // just follow cache, else attempt to follow message.\n\t        var cacheRes = cache[key];\n\t        var messageRes = message[key];\n\n\t        // We no longer materialize inside of jsonGraph merge.  Either the\n\t        // client should specify all of the paths\n\t        if (messageRes !== undefined) {\n\n\t            var nextPath = path;\n\t            var nextDepth = depth + 1;\n\t            if (updateRequestedPath) {\n\t                requestedPath[requestIdx] = key;\n\t            }\n\n\t            // We do not continue with this branch since the cache\n\t            if (cacheRes === undefined) {\n\t                cacheRes = cache[key] = {};\n\t            }\n\n\t            var nextIgnoreCount = ignoreCount;\n\n\t            // TODO: Potential performance gain since we know that\n\t            // references are always pathSets of 1, they can be evaluated\n\t            // iteratively.\n\n\t            // There is only a need to consider message references since the\n\t            // merge is only for the path that is provided.\n\t            if (messageRes && messageRes.$type === $ref &&\n\t                depth < path.length - 1) {\n\n\t                nextDepth = 0;\n\t                nextPath = catAndSlice(messageRes.value, path, depth + 1);\n\t                cache[key] = clone(messageRes);\n\n\t                // Reset position in message and cache.\n\t                nextIgnoreCount = messageRes.value.length;\n\t                messageRes = messageRoot;\n\t                cacheRes = cacheRoot;\n\t            }\n\n\t            // move forward down the path progression.\n\t            config.ignoreCount = nextIgnoreCount;\n\t            merge(config, cacheRes, messageRes,\n\t                  nextDepth, nextPath, cache, key);\n\t            config.ignoreCount = ignoreCount;\n\t        }\n\n\t        if (updateRequestedPath) {\n\t            requestedPath.length = requestIdx;\n\t        }\n\n\t        // Are we done with the loop?\n\t        key = iterateKeySet(outerKey, iteratorNote);\n\t    } while (!iteratorNote.done);\n\t}\n\treturn jsongMerge;\n}\n\nvar pathValueMerge;\nvar hasRequiredPathValueMerge;\n\nfunction requirePathValueMerge () {\n\tif (hasRequiredPathValueMerge) return pathValueMerge;\n\thasRequiredPathValueMerge = 1;\n\tvar clone = requireClone();\n\tvar types = requireTypes();\n\tvar $ref = types.$ref;\n\tvar iterateKeySet = lib.iterateKeySet;\n\n\t/**\n\t * merges pathValue into a cache\n\t */\n\tpathValueMerge = function pathValueMerge(cache, pathValue) {\n\t    var refs = [];\n\t    var values = [];\n\t    var invalidations = [];\n\t    var valueType = true;\n\n\t    // The pathValue invalidation shape.\n\t    if (pathValue.invalidated === true) {\n\t        invalidations.push({path: pathValue.path});\n\t        valueType = false;\n\t    }\n\n\t    // References.  Needed for evaluationg suffixes in all three types, get,\n\t    // call and set.\n\t    else if ((pathValue.value !== null) && (pathValue.value.$type === $ref)) {\n\t        refs.push({\n\t            path: pathValue.path,\n\t            value: pathValue.value.value\n\t        });\n\t    }\n\n\t    // Values.  Needed for reporting for call.\n\t    else {\n\t        values.push(pathValue);\n\t    }\n\n\t    // If the type of pathValue is a valueType (reference or value) then merge\n\t    // it into the jsonGraph cache.\n\t    if (valueType) {\n\t        innerPathValueMerge(cache, pathValue);\n\t    }\n\n\t    return {\n\t        references: refs,\n\t        values: values,\n\t        invalidations: invalidations\n\t    };\n\t};\n\n\tfunction innerPathValueMerge(cache, pathValue) {\n\t    var path = pathValue.path;\n\t    var curr = cache;\n\t    var next, key, cloned, outerKey, iteratorNote;\n\t    var i, len;\n\n\t    for (i = 0, len = path.length - 1; i < len; ++i) {\n\t        outerKey = path[i];\n\n\t        // Setup the memo and the key.\n\t        if (outerKey && typeof outerKey === 'object') {\n\t            iteratorNote = {};\n\t            key = iterateKeySet(outerKey, iteratorNote);\n\t        } else {\n\t            key = outerKey;\n\t            iteratorNote = false;\n\t        }\n\n\t        do {\n\t            next = curr[key];\n\n\t            if (!next) {\n\t                next = curr[key] = {};\n\t            }\n\n\t            if (iteratorNote) {\n\t                innerPathValueMerge(\n\t                    next, {\n\t                        path: path.slice(i + 1),\n\t                        value: pathValue.value\n\t                    });\n\n\t                if (!iteratorNote.done) {\n\t                    key = iterateKeySet(outerKey, iteratorNote);\n\t                }\n\t            }\n\n\t            else {\n\t                curr = next;\n\t            }\n\t        } while (iteratorNote && !iteratorNote.done);\n\n\t        // All memoized paths need to be stopped to avoid\n\t        // extra key insertions.\n\t        if (iteratorNote) {\n\t            return;\n\t        }\n\t    }\n\n\n\t    // TODO: This clearly needs a re-write.  I am just unsure of how i want\n\t    // this to look.  Plus i want to measure performance.\n\t    outerKey = path[i];\n\n\t    iteratorNote = {};\n\t    key = iterateKeySet(outerKey, iteratorNote);\n\n\t    do {\n\n\t        cloned = clone(pathValue.value);\n\t        curr[key] = cloned;\n\n\t        if (!iteratorNote.done) {\n\t            key = iterateKeySet(outerKey, iteratorNote);\n\t        }\n\t    } while (!iteratorNote.done);\n\t}\n\treturn pathValueMerge;\n}\n\nvar isMessage;\nvar hasRequiredIsMessage;\n\nfunction requireIsMessage () {\n\tif (hasRequiredIsMessage) return isMessage;\n\thasRequiredIsMessage = 1;\n\tisMessage = function isMessage(output) {\n\t    return output.hasOwnProperty('isMessage');\n\t};\n\treturn isMessage;\n}\n\nvar mergeCacheAndGatherRefsAndInvalidations_1;\nvar hasRequiredMergeCacheAndGatherRefsAndInvalidations;\n\nfunction requireMergeCacheAndGatherRefsAndInvalidations () {\n\tif (hasRequiredMergeCacheAndGatherRefsAndInvalidations) return mergeCacheAndGatherRefsAndInvalidations_1;\n\thasRequiredMergeCacheAndGatherRefsAndInvalidations = 1;\n\tvar jsongMerge = requireJsongMerge();\n\tvar pathValueMerge = requirePathValueMerge();\n\tvar isJSONG = requireIsJSONG();\n\tvar isMessage = requireIsMessage();\n\tmergeCacheAndGatherRefsAndInvalidations_1 = mergeCacheAndGatherRefsAndInvalidations;\n\n\t/**\n\t * takes the response from an action and merges it into the\n\t * cache.  Anything that is an invalidation will be added to\n\t * the first index of the return value, and the inserted refs\n\t * are the second index of the return value.  The third index\n\t * of the return value is messages from the action handlers\n\t *\n\t * @param {Object} cache\n\t * @param {Array} jsongOrPVs\n\t */\n\tfunction mergeCacheAndGatherRefsAndInvalidations(\n\t    cache, jsongOrPVs, routerInstance\n\t) {\n\t    var references = [];\n\t    var len = -1;\n\t    var invalidations = [];\n\t    var unhandledPaths = [];\n\t    var messages = [];\n\t    var values = [];\n\n\t    // Go through each of the outputs from the route end point and separate out\n\t    // each type of potential output.\n\t    //\n\t    // * There are values that need to be merged into the JSONGraphCache\n\t    // * There are references that need to be merged and potentially followed\n\t    // * There are messages that can alter the behavior of the\n\t    //   recurseMatchAndExecute cycle.\n\t    // * unhandledPaths happens when a path matches a route but the route does\n\t    //   not match the entire path, therefore there is unmatched paths.\n\t    jsongOrPVs.forEach(function(jsongOrPV) {\n\t        var refsAndValues = [];\n\n\t        if (isMessage(jsongOrPV)) {\n\t            messages[messages.length] = jsongOrPV;\n\t        }\n\n\t        else if (isJSONG(jsongOrPV)) {\n\t            refsAndValues = jsongMerge(cache, jsongOrPV, routerInstance);\n\t        }\n\n\t        // Last option are path values.\n\t        else {\n\t            refsAndValues = pathValueMerge(cache, jsongOrPV);\n\t        }\n\n\t        var refs = refsAndValues.references;\n\t        var vals = refsAndValues.values;\n\t        var invs = refsAndValues.invalidations;\n\t        var unhandled = refsAndValues.unhandledPaths;\n\n\t        if (vals && vals.length) {\n\t            values = values.concat(vals);\n\t        }\n\n\t        if (invs && invs.length) {\n\t            invalidations = invalidations.concat(invs);\n\t        }\n\n\t        if (unhandled && unhandled.length) {\n\t            unhandledPaths = unhandledPaths.concat(unhandled);\n\t        }\n\n\t        if (refs && refs.length) {\n\t            refs.forEach(function(ref) {\n\t                references[++len] = ref;\n\t            });\n\t        }\n\t    });\n\n\t    return {\n\t        invalidations: invalidations,\n\t        references: references,\n\t        messages: messages,\n\t        values: values,\n\t        unhandledPaths: unhandledPaths\n\t    };\n\t}\n\treturn mergeCacheAndGatherRefsAndInvalidations_1;\n}\n\nvar recurseMatchAndExecute;\nvar hasRequiredRecurseMatchAndExecute;\n\nfunction requireRecurseMatchAndExecute () {\n\tif (hasRequiredRecurseMatchAndExecute) return recurseMatchAndExecute;\n\thasRequiredRecurseMatchAndExecute = 1;\n\tvar Rx = requireRouterRx();\n\tvar Observable = Rx.Observable;\n\tvar runByPrecedence = requireRunByPrecedence();\n\tvar pathUtils = lib;\n\tvar collapse = pathUtils.collapse;\n\tvar optimizePathSets = requireOptimizePathSets();\n\tvar mCGRI = requireMergeCacheAndGatherRefsAndInvalidations();\n\tvar isArray = Array.isArray;\n\n\t/**\n\t * The recurse and match function will async recurse as long as\n\t * there are still more paths to be executed.  The match function\n\t * will return a set of objects that have how much of the path that\n\t * is matched.  If there still is more, denoted by suffixes,\n\t * paths to be matched then the recurser will keep running.\n\t */\n\trecurseMatchAndExecute = function recurseMatchAndExecute(\n\t        match, actionRunner, paths,\n\t        method, routerInstance, jsongCache) {\n\n\t    return _recurseMatchAndExecute(\n\t        match, actionRunner, paths,\n\t        method, routerInstance, jsongCache);\n\t};\n\n\t/**\n\t * performs the actual recursing\n\t */\n\tfunction _recurseMatchAndExecute(\n\t        match, actionRunner, paths,\n\t        method, routerInstance, jsongCache) {\n\t    var unhandledPaths = [];\n\t    var invalidated = [];\n\t    var reportedPaths = [];\n\t    var currentMethod = method;\n\t    return Observable.\n\n\t        // Each pathSet (some form of collapsed path) need to be sent\n\t        // independently.  for each collapsed pathSet will, if producing\n\t        // refs, be the highest likelihood of collapsibility.\n\t        from(paths).\n\t        expand(function(nextPaths) {\n\t            if (!nextPaths.length) {\n\t                return Observable.empty();\n\t            }\n\n\t            // We have to return an Observable of error instead of just\n\t            // throwing.\n\t            var matchedResults;\n\t            try {\n\t                matchedResults = match(currentMethod, nextPaths);\n\t            } catch (e) {\n\t                return Observable.throw(e);\n\t            }\n\n\t            // When there is explicitly not a match then we need to handle\n\t            // the unhandled paths.\n\t            if (!matchedResults.length) {\n\t                unhandledPaths.push(nextPaths);\n\t                return Observable.empty();\n\t            }\n\t            return runByPrecedence(nextPaths, matchedResults, actionRunner).\n\t                // Generate from the combined results the next requestable paths\n\t                // and insert errors / values into the cache.\n\t                flatMap(function(results) {\n\t                    var value = results.value;\n\t                    var suffix = results.match.suffix;\n\n\t                    // TODO: MaterializedPaths, use result.path to build up a\n\t                    // \"foundPaths\" array.  This could be used to materialize\n\t                    // if that is the case.  I don't think this is a\n\t                    // requirement, but it could be.\n\t                    if (!isArray(value)) {\n\t                        value = [value];\n\t                    }\n\n\t                    var invsRefsAndValues =\n\t                        mCGRI(jsongCache, value, routerInstance);\n\t                    var invalidations = invsRefsAndValues.invalidations;\n\t                    var unhandled = invsRefsAndValues.unhandledPaths;\n\t                    var messages = invsRefsAndValues.messages;\n\t                    var pathsToExpand = [];\n\n\t                    if (suffix.length > 0) {\n\t                        pathsToExpand = invsRefsAndValues.references;\n\t                    }\n\n\t                    // Merge the invalidations and unhandledPaths.\n\t                    invalidations.forEach(function(invalidation) {\n\t                        invalidated[invalidated.length] = invalidation.path;\n\t                    });\n\n\t                    unhandled.forEach(function(unhandledPath) {\n\t                        unhandledPaths[unhandledPaths.length] = unhandledPath;\n\t                    });\n\n\t                    // Merges the remaining suffix with remaining nextPaths\n\t                    pathsToExpand = pathsToExpand.map(function(next) {\n\t                        return next.value.concat(suffix);\n\t                    });\n\n\t                    // Alters the behavior of the expand\n\t                    messages.forEach(function(message) {\n\t                        // mutates the method type for the matcher\n\t                        if (message.method) {\n\t                            currentMethod = message.method;\n\t                        }\n\n\t                        // Mutates the nextPaths and adds any additionalPaths\n\t                        else if (message.additionalPath) {\n\t                            var path = message.additionalPath;\n\t                            pathsToExpand[pathsToExpand.length] = path;\n\t                            reportedPaths[reportedPaths.length] = path;\n\t                        }\n\n\t                        // Any invalidations that come down from a call\n\t                        else if (message.invalidations) {\n\t                            message.\n\t                                invalidations.\n\t                                forEach(function(invalidation) {\n\t                                    invalidated.push(invalidation);\n\t                                });\n\t                        }\n\n\t                        // We need to add the unhandledPaths to the jsonGraph\n\t                        // response.\n\t                        else if (message.unhandledPaths) {\n\t                            unhandledPaths = unhandledPaths.\n\t                                concat(message.unhandledPaths);\n\t                        }\n\t                    });\n\n\t                    // Explodes and collapse the tree to remove\n\t                    // redundants and get optimized next set of\n\t                    // paths to evaluate.\n\t                    pathsToExpand = optimizePathSets(\n\t                        jsongCache, pathsToExpand, routerInstance.maxRefFollow);\n\n\t                    if (pathsToExpand.length) {\n\t                        pathsToExpand = collapse(pathsToExpand);\n\t                    }\n\n\t                    return Observable.\n\t                        from(pathsToExpand);\n\t                }).\n\t                defaultIfEmpty([]);\n\n\t        }, Number.POSITIVE_INFINITY, Rx.Scheduler.queue).\n\t        reduce(function(acc, x) {\n\t            return acc;\n\t        }, null).\n\t        map(function() {\n\t            return {\n\t                unhandledPaths: unhandledPaths,\n\t                invalidated: invalidated,\n\t                jsonGraph: jsongCache,\n\t                reportedPaths: reportedPaths\n\t            };\n\t        });\n\t}\n\treturn recurseMatchAndExecute;\n}\n\n/**\n * takes in a range and normalizes it to have a to / from\n */\n\nvar normalize;\nvar hasRequiredNormalize;\n\nfunction requireNormalize () {\n\tif (hasRequiredNormalize) return normalize;\n\thasRequiredNormalize = 1;\n\tnormalize = function normalize(range) {\n\t    var from = range.from || 0;\n\t    var to;\n\t    if (typeof range.to === 'number') {\n\t        to = range.to;\n\t    } else {\n\t        to = from + range.length - 1;\n\t    }\n\n\t    return {to: to, from: from};\n\t};\n\treturn normalize;\n}\n\nvar normalizePathSets;\nvar hasRequiredNormalizePathSets;\n\nfunction requireNormalizePathSets () {\n\tif (hasRequiredNormalizePathSets) return normalizePathSets;\n\thasRequiredNormalizePathSets = 1;\n\tvar normalize = requireNormalize();\n\n\t/**\n\t * warning:  This mutates the array of arrays.\n\t * It only converts the ranges to properly normalized ranges\n\t * so the rest of the algos do not have to consider it.\n\t */\n\tnormalizePathSets = function normalizePathSets(path) {\n\t    path.forEach(function(key, i) {\n\t        // the algo becomes very simple if done recursively.  If\n\t        // speed is needed, this is an easy optimization to make.\n\t        if (Array.isArray(key)) {\n\t            normalizePathSets(key);\n\t        }\n\n\t        else if (typeof key === 'object') {\n\t            path[i] = normalize(path[i]);\n\t        }\n\t    });\n\t    return path;\n\t};\n\treturn normalizePathSets;\n}\n\nvar materialize;\nvar hasRequiredMaterialize;\n\nfunction requireMaterialize () {\n\tif (hasRequiredMaterialize) return materialize;\n\thasRequiredMaterialize = 1;\n\tvar pathValueMerge = requirePathValueMerge();\n\tvar optimizePathSets = requireOptimizePathSets();\n\tvar $atom = requireTypes().$atom;\n\n\t/**\n\t * given a set of paths and a jsonGraph envelope, materialize missing will\n\t * crawl all the paths to ensure that they have been fully filled in.  The\n\t * paths that are missing will be filled with materialized atoms.\n\t */\n\tmaterialize = function materializeMissing(router, paths, jsongEnv) {\n\t    var jsonGraph = jsongEnv.jsonGraph;\n\t    var materializedAtom = {$type: $atom};\n\n\t    // Optimizes the pathSets from the jsong then\n\t    // inserts atoms of undefined.\n\t    optimizePathSets(jsonGraph, paths, router.maxRefFollow).\n\t        forEach(function(optMissingPath) {\n\t            pathValueMerge(jsonGraph, {\n\t                path: optMissingPath,\n\t                value: materializedAtom\n\t            });\n\t        });\n\n\t    return {jsonGraph: jsonGraph};\n\t};\n\treturn materialize;\n}\n\nvar MaxPathsExceededError_1;\nvar hasRequiredMaxPathsExceededError;\n\nfunction requireMaxPathsExceededError () {\n\tif (hasRequiredMaxPathsExceededError) return MaxPathsExceededError_1;\n\thasRequiredMaxPathsExceededError = 1;\n\tvar MESSAGE = \"Maximum number of paths exceeded.\";\n\n\tvar MaxPathsExceededError = function MaxPathsExceededError(message) {\n\t    this.message = message === undefined ? MESSAGE : message;\n\t    this.stack = (new Error()).stack;\n\t};\n\n\tMaxPathsExceededError.prototype = new Error();\n\tMaxPathsExceededError.prototype.throwToNext = true;\n\n\tMaxPathsExceededError_1 = MaxPathsExceededError;\n\treturn MaxPathsExceededError_1;\n}\n\nvar getPathsCount_1;\nvar hasRequiredGetPathsCount;\n\nfunction requireGetPathsCount () {\n\tif (hasRequiredGetPathsCount) return getPathsCount_1;\n\thasRequiredGetPathsCount = 1;\n\tvar falcorPathUtils = lib;\n\n\tfunction getPathsCount(pathSets) {\n\t    return pathSets.reduce(function(numPaths, pathSet) {\n\t        return numPaths + falcorPathUtils.pathCount(pathSet);\n\t    }, 0);\n\t}\n\n\tgetPathsCount_1 = getPathsCount;\n\treturn getPathsCount_1;\n}\n\nvar rxNewToRxNewAndOld;\nvar hasRequiredRxNewToRxNewAndOld;\n\nfunction requireRxNewToRxNewAndOld () {\n\tif (hasRequiredRxNewToRxNewAndOld) return rxNewToRxNewAndOld;\n\thasRequiredRxNewToRxNewAndOld = 1;\n\tfunction noop() {}\n\n\tfunction toRxNewObserver(observer) {\n\t    var onNext = observer.onNext;\n\t    var onError = observer.onError;\n\t    var onCompleted = observer.onCompleted;\n\t    if (\n\t        typeof onNext !== \"function\" &&\n\t        typeof onError !== \"function\" &&\n\t        typeof onCompleted !== \"function\"\n\t    ) {\n\t        return observer;\n\t    }\n\t    // old observer!\n\t    return {\n\t        next: typeof onNext === \"function\"\n\t            ? function(x) {\n\t                  this.destination.onNext(x);\n\t              }\n\t            : noop,\n\t        error: typeof onError === \"function\"\n\t            ? function(err) {\n\t                  this.destination.onError(err);\n\t              }\n\t            : noop,\n\t        complete: typeof onCompleted === \"function\"\n\t            ? function() {\n\t                  this.destination.onCompleted();\n\t              }\n\t            : noop,\n\t        destination: observer\n\t    };\n\t}\n\n\t// WHY NOT BOTH?\n\trxNewToRxNewAndOld = function rxNewToRxNewAndOld(rxNewObservable) {\n\t    var _subscribe = rxNewObservable.subscribe;\n\n\t    rxNewObservable.subscribe = function(observerOrNextFn, errFn, compFn) {\n\t        var subscription;\n\t        if (typeof observerOrNextFn !== \"object\" || observerOrNextFn === null) {\n\t            subscription = _subscribe.call(\n\t                this,\n\t                observerOrNextFn,\n\t                errFn,\n\t                compFn\n\t            );\n\t        } else {\n\t            var observer = toRxNewObserver(observerOrNextFn);\n\t            subscription = _subscribe.call(this, observer);\n\t        }\n\n\t        var _unsubscribe = subscription.unsubscribe;\n\n\t        subscription.unsubscribe = subscription.dispose = function() {\n\t            this.isDisposed = true;\n\t            _unsubscribe.call(this);\n\t        };\n\n\t        return subscription;\n\t    };\n\n\t    return rxNewObservable;\n\t};\n\treturn rxNewToRxNewAndOld;\n}\n\nvar get_1;\nvar hasRequiredGet;\n\nfunction requireGet () {\n\tif (hasRequiredGet) return get_1;\n\thasRequiredGet = 1;\n\tvar runGetAction = requireRunGetAction();\n\tvar get = 'get';\n\tvar recurseMatchAndExecute = requireRecurseMatchAndExecute();\n\tvar normalizePathSets = requireNormalizePathSets();\n\tvar materialize = requireMaterialize();\n\tvar Observable = requireRouterRx().Observable;\n\tvar mCGRI = requireMergeCacheAndGatherRefsAndInvalidations();\n\tvar MaxPathsExceededError = requireMaxPathsExceededError();\n\tvar getPathsCount = requireGetPathsCount();\n\tvar outputToObservable = requireOutputToObservable();\n\tvar rxNewToRxNewAndOld = requireRxNewToRxNewAndOld();\n\n\t/**\n\t * The router get function\n\t */\n\tget_1 = function routerGet(paths) {\n\n\t    var router = this;\n\n\t    return rxNewToRxNewAndOld(Observable.defer(function() {\n\t        var methodSummary;\n\t        if (router._methodSummaryHook) {\n\t            methodSummary = {\n\t                method: 'get',\n\t                pathSets: paths,\n\t                start: router._now(),\n\t                results: [],\n\t                routes: []\n\t            };\n\t        }\n\n\t        var result = Observable.defer(function () {\n\t            var jsongCache = {};\n\t            var action = runGetAction(router, jsongCache, methodSummary);\n\t            var normPS = normalizePathSets(paths);\n\n\t            if (getPathsCount(normPS) > router.maxPaths) {\n\t                throw new MaxPathsExceededError();\n\t            }\n\n\t            return recurseMatchAndExecute(router._matcher, action, normPS,\n\t                                        get, router, jsongCache).\n\n\t                // Turn it(jsongGraph, invalidations, missing, etc.) into a\n\t                // jsonGraph envelope\n\t                flatMap(function flatMapAfterRouterGet(details) {\n\t                    var out = {\n\t                        jsonGraph: details.jsonGraph\n\t                    };\n\n\n\t                    // If the unhandledPaths are present then we need to\n\t                    // call the backup method for generating materialized.\n\t                    if (details.unhandledPaths.length && router._unhandled) {\n\t                        var unhandledPaths = details.unhandledPaths;\n\n\t                        // The 3rd argument is the beginning of the actions\n\t                        // arguments, which for get is the same as the\n\t                        // unhandledPaths.\n\t                        return outputToObservable(\n\t                            router._unhandled.get(unhandledPaths)).\n\n\t                            // Merge the solution back into the overall message.\n\t                            map(function(jsonGraphFragment) {\n\t                                mCGRI(out.jsonGraph, [{\n\t                                    jsonGraph: jsonGraphFragment.jsonGraph,\n\t                                    paths: unhandledPaths\n\t                                }], router);\n\t                                return out;\n\t                            }).\n\t                            defaultIfEmpty(out);\n\t                    }\n\n\t                    return Observable.of(out);\n\t                }).\n\n\t            // We will continue to materialize over the whole jsonGraph message.\n\t            // This makes sense if you think about pathValues and an API that if\n\t            // ask for a range of 10 and only 8 were returned, it would not\n\t            // materialize for you, instead, allow the router to do that.\n\t                map(function(jsonGraphEnvelope) {\n\t                    return materialize(router, normPS, jsonGraphEnvelope);\n\t                });\n\t        });\n\n\t        if (router._methodSummaryHook || router._errorHook) {\n\t            result = result.\n\t                do(function (response) {\n\t                    if (router._methodSummaryHook) {\n\t                        methodSummary.results.push({\n\t                            time: router._now(),\n\t                            value: response\n\t                        });\n\t                    }\n\t                }, function (err) {\n\t                    if (router._methodSummaryHook) {\n\t                        methodSummary.end = router._now();\n\t                        methodSummary.error = err;\n\t                        router._methodSummaryHook(methodSummary);\n\t                    }\n\t                    if (router._errorHook) {\n\t                        router._errorHook(err);\n\t                    }\n\t                }, function () {\n\t                    if (router._methodSummaryHook) {\n\t                        methodSummary.end = router._now();\n\t                        router._methodSummaryHook(methodSummary);\n\t                    }\n\t                });\n\t        }\n\n\t        return result;\n\t    }));\n\t};\n\treturn get_1;\n}\n\nvar spreadPaths;\nvar hasRequiredSpreadPaths;\n\nfunction requireSpreadPaths () {\n\tif (hasRequiredSpreadPaths) return spreadPaths;\n\thasRequiredSpreadPaths = 1;\n\tvar iterateKeySet = lib.iterateKeySet;\n\tvar cloneArray = cloneArray_1$1;\n\n\t/**\n\t * Takes in a ptahSet and will create a set of simple paths.\n\t * @param {Array} paths\n\t */\n\tspreadPaths = function spreadPaths(paths) {\n\t    var allPaths = [];\n\t    paths.forEach(function(x) {\n\t        _spread(x, 0, allPaths);\n\t    });\n\n\t    return allPaths;\n\t};\n\n\tfunction _spread(pathSet, depth, out, currentPath) {\n\n\t    /* eslint-disable no-param-reassign */\n\t    currentPath = currentPath || [];\n\t    /* eslint-enable no-param-reassign */\n\n\t    if (depth === pathSet.length) {\n\t        out[out.length] = cloneArray(currentPath);\n\t        return;\n\t    }\n\n\t    // Simple case\n\t    var key = pathSet[depth];\n\t    if (typeof key !== 'object') {\n\t        currentPath[depth] = key;\n\t        _spread(pathSet, depth + 1, out, currentPath);\n\t        return;\n\t    }\n\n\t    // complex key.\n\t    var iteratorNote = {};\n\t    var innerKey = iterateKeySet(key, iteratorNote);\n\t    do {\n\t        // spreads the paths\n\t        currentPath[depth] = innerKey;\n\t        _spread(pathSet, depth + 1, out, currentPath);\n\t        currentPath.length = depth;\n\n\t        innerKey = iterateKeySet(key, iteratorNote);\n\t    } while (!iteratorNote.done);\n\t}\n\treturn spreadPaths;\n}\n\n/**\n * To simplify this algorithm, the path must be a simple\n * path with no complex keys.\n *\n * Note: The path coming in must contain no references, as\n * all set data caches have no references.\n * @param {Object} cache\n * @param {PathSet} path\n */\n\nvar getValue;\nvar hasRequiredGetValue;\n\nfunction requireGetValue () {\n\tif (hasRequiredGetValue) return getValue;\n\thasRequiredGetValue = 1;\n\tgetValue = function getValue(cache, path) {\n\t    return path.reduce(function(acc, key) {\n\t        return acc[key];\n\t    }, cache);\n\t};\n\treturn getValue;\n}\n\n/* eslint-disable max-len */\n\nvar runSetAction_1;\nvar hasRequiredRunSetAction;\n\nfunction requireRunSetAction () {\n\tif (hasRequiredRunSetAction) return runSetAction_1;\n\thasRequiredRunSetAction = 1;\n\tvar outputToObservable = requireOutputToObservable();\n\tvar noteToJsongOrPV = requireNoteToJsongOrPV();\n\tvar spreadPaths = requireSpreadPaths();\n\tvar getValue = requireGetValue();\n\tvar jsongMerge = requireJsongMerge();\n\tvar optimizePathSets = requireOptimizePathSets();\n\tvar hasIntersection = requireHasIntersection();\n\tvar pathValueMerge = requirePathValueMerge();\n\tvar Observable = requireRouterRx().Observable;\n\t/* eslint-enable max-len */\n\n\trunSetAction_1 = function outerRunSetAction(routerInstance, modelContext,\n\t                                            jsongCache, methodSummary) {\n\t    return function innerRunSetAction(matchAndPath) {\n\t        return runSetAction(routerInstance, modelContext,\n\t                            matchAndPath, jsongCache, methodSummary);\n\t    };\n\t};\n\n\tfunction runSetAction(routerInstance, jsongMessage, matchAndPath,\n\t    jsongCache, methodSummary) {\n\t    var match = matchAndPath.match;\n\t    var out;\n\t    var arg = matchAndPath.path;\n\n\t    // We are at out destination.  Its time to get out\n\t    // the pathValues from the\n\t    if (match.isSet) {\n\t        var paths = spreadPaths(jsongMessage.paths);\n\n\t        // We have to ensure that the paths maps in order\n\t        // to the optimized paths array.\n\t        var optimizedPathsAndPaths =\n\t            paths.\n\t                // Optimizes each path.\n\t                map(function(path) {\n\t                    return [optimizePathSets(\n\t                        jsongCache, [path], routerInstance.maxRefFollow)[0],\n\t                        path];\n\t                }).\n\t                // only includes the paths from the set that intersect\n\t                // the virtual path\n\t                filter(function(optimizedAndPath) {\n\t                    return optimizedAndPath[0] &&\n\t                        hasIntersection(optimizedAndPath[0], match.virtual);\n\t                });\n\t        var optimizedPaths = optimizedPathsAndPaths.map(function(opp) {\n\t            return opp[0];\n\t        });\n\t        var subSetPaths = optimizedPathsAndPaths.map(function(opp) {\n\t            return opp[1];\n\t        });\n\t        var tmpJsonGraph = subSetPaths.\n\t            reduce(function(json, path, i) {\n\t                pathValueMerge(json, {\n\t                    path: optimizedPaths[i],\n\t                    value: getValue(jsongMessage.jsonGraph, path)\n\t                });\n\t                return json;\n\t            }, {});\n\n\t        // Takes the temporary JSONGraph, attaches only the matched paths\n\t        // then creates the subset json and assigns it to the argument to\n\t        // the set function.\n\t        var subJsonGraphEnv = {\n\t            jsonGraph: tmpJsonGraph,\n\t            paths: [match.requested]\n\t        };\n\t        arg = {};\n\t        jsongMerge(arg, subJsonGraphEnv, routerInstance);\n\t    }\n\t    try {\n\t        out = match.action.call(routerInstance, arg);\n\t        out = outputToObservable(out);\n\n\t        if (methodSummary) {\n\t            var _out = out;\n\t            out = Observable.defer(function () {\n\t                var route = {\n\t                    route: matchAndPath.match.prettyRoute,\n\t                    pathSet: matchAndPath.path,\n\t                    start: routerInstance._now()\n\t                };\n\t                methodSummary.routes.push(route);\n\n\t                return _out.do(\n\t                    function (result) {\n\t                        route.results = route.results || [];\n\t                        route.results.push({\n\t                            time: routerInstance._now(),\n\t                            value: result\n\t                        });\n\t                    },\n\t                    function (err) {\n\t                        route.error = err;\n\t                        route.end = routerInstance._now();\n\t                    },\n\t                    function () {\n\t                        route.end = routerInstance._now();\n\t                    }\n\t                )\n\t            });\n\t        }\n\t    } catch (e) {\n\t        out = Observable.throw(e);\n\t    }\n\n\t    return out.\n\t        materialize().\n\t        filter(function(note) {\n\t            return note.kind !== 'C';\n\t        }).\n\t        map(noteToJsongOrPV(matchAndPath.path, false, routerInstance)).\n\t        map(function(jsonGraphOrPV) {\n\t            return [matchAndPath.match, jsonGraphOrPV];\n\t        });\n\t}\n\treturn runSetAction_1;\n}\n\n/**\n * @param {PathSet} path - A simple path\n * @param {Object} tree - The tree should have `null` leaves to denote a\n * leaf node.\n */\n\nvar hasIntersectionWithTree;\nvar hasRequiredHasIntersectionWithTree;\n\nfunction requireHasIntersectionWithTree () {\n\tif (hasRequiredHasIntersectionWithTree) return hasIntersectionWithTree;\n\thasRequiredHasIntersectionWithTree = 1;\n\thasIntersectionWithTree = function hasIntersectionWithTree(path, tree) {\n\t    return _hasIntersection(path, tree, 0);\n\t};\n\n\tfunction _hasIntersection(path, node, depth) {\n\n\t    // Exit / base condition.  We have reached the\n\t    // length of our path and we are at a node of null.\n\t    if (depth === path.length && node === null) {\n\t        return true;\n\t    }\n\n\t    var key = path[depth];\n\t    var next = node[key];\n\n\t    // If its not undefined, then its a branch.\n\t    if (node !== undefined) {\n\t        return _hasIntersection(path, next, depth + 1);\n\t    }\n\n\t    return false;\n\t}\n\treturn hasIntersectionWithTree;\n}\n\nvar set_1;\nvar hasRequiredSet;\n\nfunction requireSet () {\n\tif (hasRequiredSet) return set_1;\n\thasRequiredSet = 1;\n\tvar set = 'set';\n\tvar recurseMatchAndExecute = requireRecurseMatchAndExecute();\n\tvar runSetAction = requireRunSetAction();\n\tvar materialize = requireMaterialize();\n\tvar Observable = requireRouterRx().Observable;\n\tvar spreadPaths = requireSpreadPaths();\n\tvar pathValueMerge = requirePathValueMerge();\n\tvar optimizePathSets = requireOptimizePathSets();\n\tvar hasIntersectionWithTree =\n\t    requireHasIntersectionWithTree();\n\tvar getValue = requireGetValue();\n\tvar normalizePathSets = requireNormalizePathSets();\n\tvar pathUtils = lib;\n\tvar collapse = pathUtils.collapse;\n\tvar mCGRI = requireMergeCacheAndGatherRefsAndInvalidations();\n\tvar MaxPathsExceededError = requireMaxPathsExceededError();\n\tvar getPathsCount = requireGetPathsCount();\n\tvar outputToObservable = requireOutputToObservable();\n\tvar rxNewToRxNewAndOld = requireRxNewToRxNewAndOld();\n\n\t/**\n\t * @returns {Observable.<JSONGraph>}\n\t * @private\n\t */\n\tset_1 = function routerSet(jsonGraph) {\n\n\t    var router = this;\n\n\t    var source = Observable.defer(function() {\n\t        var jsongCache = {};\n\n\t        var methodSummary;\n\t        if (router._methodSummaryHook) {\n\t            methodSummary = {\n\t                method: 'set',\n\t                jsonGraphEnvelope: jsonGraph,\n\t                start: router._now(),\n\t                results: [],\n\t                routes: []\n\t            };\n\t        }\n\n\t        var action = runSetAction(router, jsonGraph, jsongCache, methodSummary);\n\t        jsonGraph.paths = normalizePathSets(jsonGraph.paths);\n\n\t        if (getPathsCount(jsonGraph.paths) > router.maxPaths) {\n\t            throw new MaxPathsExceededError();\n\t        }\n\n\t        var innerSource = recurseMatchAndExecute(router._matcher, action,\n\t            jsonGraph.paths, set, router, jsongCache).\n\n\t            // Takes the jsonGraphEnvelope and extra details that comes out\n\t            // of the recursive matching algorithm and either attempts the\n\t            // fallback options or returns the built jsonGraph.\n\t            flatMap(function(details) {\n\t                var out = {\n\t                    jsonGraph: details.jsonGraph\n\t                };\n\n\t                // If there is an unhandler then we should call that method and\n\t                // provide the subset of jsonGraph that represents the missing\n\t                // routes.\n\t                if (details.unhandledPaths.length && router._unhandled) {\n\t                    var unhandledPaths = details.unhandledPaths;\n\t                    var jsonGraphFragment = {};\n\n\t                    // PERFORMANCE:\n\t                    //   We know this is a potential performance downfall\n\t                    //   but we want to see if its even a corner case.\n\t                    //   Most likely this will not be hit, but if it does\n\t                    //   then we can take care of it\n\t                    // Set is interesting.  This is what has to happen.\n\t                    // 1. incoming paths are spread so that each one is simple.\n\t                    // 2. incoming path, one at a time, are optimized by the\n\t                    //    incoming jsonGraph.\n\t                    // 3. test intersection against incoming optimized path and\n\t                    //    unhandledPathSet\n\t                    // 4. If 3 is true, build the jsonGraphFragment by using a\n\t                    //    pathValue of optimizedPath and vale from un-optimized\n\t                    //    path and original jsonGraphEnvelope.\n\t                    var jsonGraphEnvelope = {jsonGraph: jsonGraphFragment};\n\t                    var unhandledPathsTree = unhandledPaths.\n\t                        reduce(function(acc, path) {\n\t                            pathValueMerge(acc, {path: path, value: null});\n\t                            return acc;\n\t                        }, {});\n\n\t                    // 1. Spread\n\t                    var pathIntersection = spreadPaths(jsonGraph.paths).\n\n\t                        // 2.1 Optimize.  We know its one at a time therefore we\n\t                        // just pluck [0] out.\n\t                        map(function(path) {\n\t                            return [\n\t                                // full path\n\t                                path,\n\n\t                                // optimized path\n\t                                optimizePathSets(details.jsonGraph, [path],\n\t                                                    router.maxRefFollow)[0]]\n\t                        }).\n\n\t                        // 2.2 Remove all the optimized paths that were found in\n\t                        // the cache.\n\t                        filter(function(x) { return x[1]; }).\n\n\t                        // 3.1 test intersection.\n\t                        map(function(pathAndOPath) {\n\t                            var oPath = pathAndOPath[1];\n\t                            var hasIntersection = hasIntersectionWithTree(\n\t                                oPath, unhandledPathsTree);\n\n\t                            // Creates the pathValue if there are a path\n\t                            // intersection\n\t                            if (hasIntersection) {\n\t                                var value =\n\t                                    getValue(jsonGraph.jsonGraph,\n\t                                        pathAndOPath[0]);\n\n\t                                return {\n\t                                    path: oPath,\n\t                                    value: value\n\t                                };\n\t                            }\n\n\t                            return null;\n\t                        }).\n\n\t                        // 3.2 strip out nulls (the non-intersection paths).\n\t                        filter(function(x) { return x !== null; });\n\n\t                        // 4. build the optimized JSONGraph envelope.\n\t                        pathIntersection.\n\t                            reduce(function(acc, pathValue) {\n\t                                pathValueMerge(acc, pathValue);\n\t                                return acc;\n\t                            }, jsonGraphFragment);\n\n\t                    jsonGraphEnvelope.paths = collapse(\n\t                        pathIntersection.map(function(pV) {\n\t                            return pV.path;\n\t                        }));\n\n\t                    return outputToObservable(\n\t                        router._unhandled.set(jsonGraphEnvelope)).\n\n\t                        // Merge the solution back into the overall message.\n\t                        map(function(unhandledJsonGraphEnv) {\n\t                            mCGRI(out.jsonGraph, [{\n\t                                jsonGraph: unhandledJsonGraphEnv.jsonGraph,\n\t                                paths: unhandledPaths\n\t                            }], router);\n\t                            return out;\n\t                        }).\n\t                        defaultIfEmpty(out);\n\t                }\n\n\t                return Observable.of(out);\n\t            }).\n\n\t            // We will continue to materialize over the whole jsonGraph message.\n\t            // This makes sense if you think about pathValues and an API that\n\t            // if ask for a range of 10 and only 8 were returned, it would not\n\t            // materialize for you, instead, allow the router to do that.\n\t            map(function(jsonGraphEnvelope) {\n\t                return materialize(router, jsonGraph.paths, jsonGraphEnvelope);\n\t            });\n\n\t            if (router._errorHook || router._methodSummaryHook) {\n\t                innerSource = innerSource.\n\t                    do(\n\t                        function (response) {\n\t                            if (router._methodSummaryHook) {\n\t                                methodSummary.results.push({\n\t                                    time: router._now(),\n\t                                    value: response\n\t                                });\n\t                            }\n\t                        }, function (err) {\n\t                            if (router._methodSummaryHook) {\n\t                                methodSummary.end = router._now();\n\t                                methodSummary.error = err;\n\t                                router._methodSummaryHook(methodSummary);\n\t                            }\n\t                            if (router._errorHook) {\n\t                                router._errorHook(err);\n\t                            }\n\t                        }, function () {\n\t                            if (router._methodSummaryHook) {\n\t                                methodSummary.end = router._now();\n\t                                router._methodSummaryHook(methodSummary);\n\t                            }\n\t                        }\n\t                    );\n\t            }\n\t            return innerSource;\n\t    });\n\n\t    if (router._errorHook) {\n\t        source = source.\n\t            do(null, function summaryHookErrorHandler(err) {\n\t                router._errorHook(err);\n\t            });\n\t    }\n\n\t    return rxNewToRxNewAndOld(source);\n\t};\n\treturn set_1;\n}\n\nvar CallRequiresPathsError_1;\nvar hasRequiredCallRequiresPathsError;\n\nfunction requireCallRequiresPathsError () {\n\tif (hasRequiredCallRequiresPathsError) return CallRequiresPathsError_1;\n\thasRequiredCallRequiresPathsError = 1;\n\tvar MESSAGE = 'Any JSONG-Graph returned from call must have paths.';\n\tvar CallRequiresPathsError = function CallRequiresPathsError() {\n\t    this.message = MESSAGE;\n\t    this.stack = (new Error()).stack;\n\t};\n\n\tCallRequiresPathsError.prototype = new Error();\n\n\tCallRequiresPathsError_1 = CallRequiresPathsError;\n\treturn CallRequiresPathsError_1;\n}\n\nvar runCallAction_1;\nvar hasRequiredRunCallAction;\n\nfunction requireRunCallAction () {\n\tif (hasRequiredRunCallAction) return runCallAction_1;\n\thasRequiredRunCallAction = 1;\n\tvar isJSONG = requireIsJSONG();\n\tvar outputToObservable = requireOutputToObservable();\n\tvar noteToJsongOrPV = requireNoteToJsongOrPV();\n\tvar CallRequiresPathsError = requireCallRequiresPathsError();\n\tvar mCGRI = requireMergeCacheAndGatherRefsAndInvalidations();\n\tvar Observable = requireRouterRx().Observable;\n\n\trunCallAction_1 =  outerRunCallAction;\n\n\tfunction outerRunCallAction(routerInstance, callPath, args,\n\t                            suffixes, paths, jsongCache, methodSummary) {\n\t    return function innerRunCallAction(matchAndPath) {\n\t        return runCallAction(matchAndPath, routerInstance, callPath,\n\t                             args, suffixes, paths, jsongCache, methodSummary);\n\t    };\n\t}\n\n\tfunction runCallAction(matchAndPath, routerInstance, callPath, args,\n\t                       suffixes, paths, jsongCache, methodSummary) {\n\n\t    var match = matchAndPath.match;\n\t    var matchedPath = matchAndPath.path;\n\t    var out;\n\n\t    // We are at out destination.  Its time to get out\n\t    // the pathValues from the\n\t    if (match.isCall) {\n\n\t        // This is where things get interesting\n\t        out = Observable.\n\t            defer(function() {\n\t                var next;\n\t                try {\n\t                    next = match.\n\t                        action.call(\n\t                            routerInstance, matchedPath, args, suffixes, paths);\n\t                } catch (e) {\n\t                    e.throwToNext = true;\n\t                    throw e;\n\t                }\n\t                var output = outputToObservable(next);\n\n\t                if (methodSummary) {\n\t                    var route = {\n\t                        start: routerInstance._now(),\n\t                        route: matchAndPath.match.prettyRoute,\n\t                        pathSet: matchAndPath.path,\n\t                        results: []\n\t                    };\n\t                    methodSummary.routes.push(route);\n\n\t                    output = output.do(\n\t                        function (response) {\n\t                            route.results.push({\n\t                                time: routerInstance._now(),\n\t                                value: response\n\t                            });\n\t                        },\n\t                        function (err) {\n\t                            route.error = err;\n\t                            route.end = routerInstance._now();\n\t                        },\n\t                        function () {\n\t                            route.end = routerInstance._now();\n\t                        }\n\t                    );\n\t                }\n\t                return output.toArray();\n\t            }).\n\n\t            // Required to get the references from the outputting jsong\n\t            // and pathValues.\n\t            map(function(res) {\n\n\t                // checks call for isJSONG and if there is jsong without paths\n\t                // throw errors.\n\t                var refs = [];\n\t                var values = [];\n\n\t                // Will flatten any arrays of jsong/pathValues.\n\t                var callOutput = res.\n\n\t                    // Filters out any falsy values\n\t                    filter(function(x) {\n\t                        return x;\n\t                    }).\n\t                    reduce(function(flattenedRes, next) {\n\t                        return flattenedRes.concat(next);\n\t                    }, []);\n\n\t                // An empty output from call\n\t                if (callOutput.length === 0) {\n\t                    return [];\n\t                }\n\n\t                var refLen = -1;\n\t                callOutput.forEach(function(r) {\n\n\t                    // its json graph.\n\t                    if (isJSONG(r)) {\n\n\t                        // This is a hard error and must fully stop the server\n\t                        if (!r.paths) {\n\t                            var err =\n\t                                new CallRequiresPathsError();\n\t                            err.throwToNext = true;\n\t                            throw err;\n\t                        }\n\t                    }\n\n\t                });\n\n\t                var invsRefsAndValues =\n\t                    mCGRI(jsongCache, callOutput, routerInstance);\n\t                invsRefsAndValues.references.forEach(function(ref) {\n\t                    refs[++refLen] = ref;\n\t                });\n\n\t                values = invsRefsAndValues.values.map(function(pv) {\n\t                    return pv.path;\n\t                });\n\n\t                var callLength = callOutput.length;\n\t                var callPathSave1 = callPath.slice(0, callPath.length - 1);\n\t                var hasSuffixes = suffixes && suffixes.length;\n\t                var hasPaths = paths && paths.length;\n\n\t                // We are going to use recurseMatchAndExecute to run\n\t                // the paths and suffixes for call.  For that to happen\n\t                // we must send a message to the outside to switch from\n\t                // call to get.\n\t                callOutput[++callLength] = {isMessage: true, method: 'get'};\n\n\t                // If there are paths to add then push them into the next\n\t                // paths through 'additionalPaths' message.\n\t                if (hasPaths && (callLength + 1)) {\n\t                    paths.forEach(function(path) {\n\t                        callOutput[++callLength] = {\n\t                            isMessage: true,\n\t                            additionalPath: callPathSave1.concat(path)\n\t                        };\n\t                    });\n\t                }\n\n\t                // Suffix is the same as paths except for how to calculate\n\t                // a path per reference found from the callPath.\n\t                if (hasSuffixes) {\n\n\t                    // matchedPath is the optimized path to call.\n\t                    // e.g:\n\t                    // callPath: [genreLists, 0, add] ->\n\t                    // matchedPath: [lists, 'abc', add]\n\t                    var optimizedPathLength = matchedPath.length - 1;\n\n\t                    // For every reference build the complete path\n\t                    // from the callPath - 1 and concat remaining\n\t                    // path from the PathReference (path is where the\n\t                    // reference was found, not the value of the reference).\n\t                    // e.g: from the above example the output is:\n\t                    // output = {path: [lists, abc, 0], value: [titles, 123]}\n\t                    //\n\t                    // This means the refs object = [output];\n\t                    // callPathSave1: [genreLists, 0],\n\t                    // optimizedPathLength: 3 - 1 = 2\n\t                    // ref.path.slice(2): [lists, abc, 0].slice(2) = [0]\n\t                    // deoptimizedPath: [genreLists, 0, 0]\n\t                    //\n\t                    // Add the deoptimizedPath to the callOutput messages.\n\t                    // This will make the outer expand run those as a 'get'\n\t                    refs.forEach(function(ref) {\n\t                        var deoptimizedPath = callPathSave1.concat(\n\t                                ref.path.slice(optimizedPathLength));\n\t                        suffixes.forEach(function(suffix) {\n\t                            var additionalPath =\n\t                                deoptimizedPath.concat(suffix);\n\t                            callOutput[++callLength] = {\n\t                                isMessage: true,\n\t                                additionalPath: additionalPath\n\t                            };\n\t                        });\n\t                    });\n\t                }\n\n\t                // If there are no suffixes but there are references, report\n\t                // the paths to the references.  There may be values as well,\n\t                // add those to the output.\n\t                if (refs.length && !hasSuffixes || values.length) {\n\t                    var additionalPaths = [];\n\t                    if (refs.length && !hasSuffixes) {\n\t                        additionalPaths = refs.\n\t                            map(function(x) { return x.path; });\n\t                    }\n\t                    additionalPaths.\n\t                        concat(values).\n\t                        forEach(function(path) {\n\t                            callOutput[++callLength] = {\n\t                                isMessage: true,\n\t                                additionalPath: path\n\t                            };\n\t                        });\n\t                }\n\n\t                return callOutput;\n\t            }).\n\n\t            // When call has an error it needs to be propagated to the next\n\t            // level instead of onCompleted'ing\n\t            do(null, function(e) {\n\t                e.throwToNext = true;\n\t                throw e;\n\t            });\n\t    } else {\n\t        out = Observable.defer(function () {\n\t            return outputToObservable(\n\t                match.action.call(routerInstance, matchAndPath.path)\n\t            );\n\t        });\n\n\t        if (methodSummary) {\n\t            var route = {\n\t                start: routerInstance._now(),\n\t                route: matchAndPath.match.prettyRoute,\n\t                pathSet: matchAndPath.path,\n\t                results: []\n\t            };\n\t            methodSummary.routes.push(route);\n\n\t            out = out.do(\n\t                function (response) {\n\t                    route.results.push({\n\t                        time: routerInstance._now(),\n\t                        value: response\n\t                    });\n\t                },\n\t                function (err) {\n\t                    route.error = err;\n\t                    route.end = routerInstance._now();\n\t                },\n\t                function () {\n\t                    route.end = routerInstance._now();\n\t                }\n\t            );\n\t        }\n\t    }\n\n\t    return out.\n\t        materialize().\n\t        filter(function(note) {\n\t            return note.kind !== 'C';\n\t        }).\n\t        map(noteToJsongOrPV(matchAndPath.path, false, routerInstance)).\n\t        map(function(jsonGraphOrPV) {\n\t            return [matchAndPath.match, jsonGraphOrPV];\n\t        });\n\t}\n\treturn runCallAction_1;\n}\n\nvar call_1;\nvar hasRequiredCall;\n\nfunction requireCall () {\n\tif (hasRequiredCall) return call_1;\n\thasRequiredCall = 1;\n\tvar call = 'call';\n\tvar runCallAction = requireRunCallAction();\n\tvar recurseMatchAndExecute = requireRecurseMatchAndExecute();\n\tvar normalizePathSets = requireNormalizePathSets();\n\tvar CallNotFoundError = requireCallNotFoundError();\n\tvar materialize = requireMaterialize();\n\tvar pathUtils = lib;\n\tvar collapse = pathUtils.collapse;\n\tvar Observable = requireRouterRx().Observable;\n\tvar MaxPathsExceededError = requireMaxPathsExceededError();\n\tvar getPathsCount = requireGetPathsCount();\n\tvar outputToObservable = requireOutputToObservable();\n\tvar rxNewToRxNewAndOld = requireRxNewToRxNewAndOld();\n\n\t/**\n\t * Performs the call mutation.  If a call is unhandled, IE throws error, then\n\t * we will chain to the next dataSource in the line.\n\t */\n\tcall_1 = function routerCall(callPath, args,\n\t                                     refPathsArg, thisPathsArg) {\n\t    var router = this;\n\n\t    var source = Observable.defer(function () {\n\t        var methodSummary;\n\t        if (router._methodSummaryHook) {\n\t            methodSummary = {\n\t                method: 'call',\n\t                start: router._now(),\n\t                callPath: callPath,\n\t                args: args,\n\t                refPaths: refPathsArg,\n\t                thisPaths: thisPathsArg,\n\t                results: [],\n\t                routes: []\n\t            };\n\t        }\n\n\t        var innerSource = Observable.defer(function() {\n\n\t            var refPaths = normalizePathSets(refPathsArg || []);\n\t            var thisPaths = normalizePathSets(thisPathsArg || []);\n\t            var jsongCache = {};\n\t            var action = runCallAction(router, callPath, args,\n\t                refPaths, thisPaths, jsongCache, methodSummary);\n\t            var callPaths = [callPath];\n\n\t            if (getPathsCount(refPaths) +\n\t                getPathsCount(thisPaths) +\n\t                getPathsCount(callPaths) >\n\t                router.maxPaths) {\n\t                throw new MaxPathsExceededError();\n\t            }\n\n\t            return recurseMatchAndExecute(router._matcher, action,\n\t                callPaths, call,\n\t                router, jsongCache).\n\n\t                // Take that\n\t                map(function(jsongResult) {\n\t                    var reportedPaths = jsongResult.reportedPaths;\n\t                    var jsongEnv = {\n\t                        jsonGraph: jsongResult.jsonGraph\n\t                    };\n\n\t                    // Call must report the paths that have been produced.\n\t                    if (reportedPaths.length) {\n\t                    // Collapse the reported paths as they may be inefficient\n\t                    // to send across the wire.\n\t                        jsongEnv.paths = collapse(reportedPaths);\n\t                    }\n\t                    else {\n\t                        jsongEnv.paths = [];\n\t                        jsongEnv.jsonGraph = {};\n\t                    }\n\n\t                    // add the invalidated paths to the jsonGraph Envelope\n\t                    var invalidated = jsongResult.invalidated;\n\t                    if (invalidated && invalidated.length) {\n\t                        jsongEnv.invalidated = invalidated;\n\t                    }\n\n\t                    // Calls are currently materialized.\n\t                    materialize(router, reportedPaths, jsongEnv);\n\t                    return jsongEnv;\n\t                }).\n\n\t            // For us to be able to chain call requests then the error that is\n\t            // caught has to be a 'function does not exist.' error.  From that\n\t            // we will try the next dataSource in the line.\n\t                catch(function catchException(e) {\n\t                    if (e instanceof CallNotFoundError && router._unhandled) {\n\t                        return outputToObservable(\n\t                            router._unhandled.\n\t                            call(callPath, args, refPaths, thisPaths));\n\t                    }\n\t                    throw e;\n\t                });\n\t        });\n\n\t        if (router._methodSummaryHook || router._errorHook) {\n\t            innerSource = innerSource.\n\t                do(function (response) {\n\t                    if (router._methodSummaryHook) {\n\t                        methodSummary.results.push({\n\t                            time: router._now(),\n\t                            value: response\n\t                        });\n\t                    }\n\t                }, function (err) {\n\t                    if (router._methodSummaryHook) {\n\t                        methodSummary.error = err;\n\t                        methodSummary.end = router._now();\n\t                        router._methodSummaryHook(methodSummary);\n\t                    }\n\t                    if (router._errorHook) {\n\t                        router._errorHook(err);\n\t                    }\n\t                }, function () {\n\t                    if (router._methodSummaryHook) {\n\t                        methodSummary.end = router._now();\n\t                        router._methodSummaryHook(methodSummary);\n\t                    }\n\t                });\n\t        }\n\n\t        return innerSource\n\t    });\n\n\n\n\n\n\n\n\t        return rxNewToRxNewAndOld(source);\n\t};\n\treturn call_1;\n}\n\nvar Keys = Keys_1;\nvar parseTree = parseTree$1;\nvar matcher = matcher$1;\nvar JSONGraphError = JSONGraphErrorExports;\nvar MAX_REF_FOLLOW = 50;\nvar MAX_PATHS = 9000;\n\nvar noOp = function noOp() {};\nvar defaultNow = function defaultNow() {\n    return Date.now();\n};\n\nvar Router = function(routes, options) {\n    this._routes = routes;\n    this._rst = parseTree(routes);\n    this._matcher = matcher(this._rst);\n    this._setOptions(options);\n};\n\nRouter.createClass = function(routes) {\n    function C(options) {\n        this._setOptions(options);\n    }\n\n    C.prototype = new Router(routes);\n    C.prototype.constructor = C;\n\n    return C;\n};\n\nRouter.prototype = {\n    /**\n     * Performs the get algorithm on the router.\n     * @param {PathSet[]} paths -\n     * @returns {Observable.<JSONGraphEnvelope>}\n     */\n    get: requireGet(),\n\n    /**\n     * Takes in a jsonGraph and outputs a Observable.<jsonGraph>.  The set\n     * method will use get until it evaluates the last key of the path inside\n     * of paths.  At that point it will produce an intermediate structure that\n     * matches the path and has the value that is found in the jsonGraph env.\n     *\n     * One of the requirements for interaction with a dataSource is that the\n     * set message must be optimized to the best of the incoming sources\n     * knowledge.\n     *\n     * @param {JSONGraphEnvelope} jsonGraph -\n     * @returns {Observable.<JSONGraphEnvelope>}\n     */\n    set: requireSet(),\n\n    /**\n     * Invokes a function in the DataSource's JSONGraph object at the path\n     * provided in the callPath argument.  If there are references that are\n     * followed, a get will be performed to get to the call function.\n     *\n     * @param {Path} callPath -\n     * @param {Array.<*>} args -\n     * @param {Array.<PathSet>} refPaths -\n     * @param {Array.<PathSet>} thisPaths -\n     */\n    call: requireCall(),\n\n    /**\n     * When a route misses on a call, get, or set the unhandledDataSource will\n     * have a chance to fulfill that request.\n     * @param {DataSource} dataSource -\n     */\n    routeUnhandledPathsTo: function routeUnhandledPathsTo(dataSource) {\n        this._unhandled = dataSource;\n    },\n\n    _setOptions: function _setOptions(options) {\n        var opts = options || {};\n        this._debug = opts.debug;\n        this._pathErrorHook = (opts.hooks && opts.hooks.pathError) || noOp;\n        this._errorHook = opts.hooks && opts.hooks.error;\n        this._methodSummaryHook = opts.hooks && opts.hooks.methodSummary;\n        this._now = (opts.hooks && opts.hooks.now) || opts.now || defaultNow;\n        this.maxRefFollow = opts.maxRefFollow || MAX_REF_FOLLOW;\n        this.maxPaths = opts.maxPaths || MAX_PATHS;\n    }\n};\n\nRouter.ranges = Keys.ranges;\nRouter.integers = Keys.integers;\nRouter.keys = Keys.keys;\nRouter.JSONGraphError = JSONGraphError;\nvar Router_1 = Router;\n\nvar Router$1 = /*@__PURE__*/getDefaultExportFromCjs(Router_1);\n\nexport { Router$1 as Router };\n", "export function addPathTags (paths, tags) {\n  if (typeof tags === 'string') {\n    tags = [ tags ]\n  }\n\n  Object.values(paths).forEach(pathConf => {\n    if (tags.includes('window') && !pathConf.get) {\n      pathConf.get = {}\n    }\n\n    const methodConfs = Object.values(pathConf).filter(conf => typeof conf === 'object')\n\n    methodConfs.forEach(conf => {\n      tags.forEach(tag => {\n        if (!conf.tags) {\n          conf.tags = [tag]\n        } else if (!conf.tags.includes(tag)) {\n          conf.tags.push(tag)\n        }\n      })\n    })\n  })\n\n  return paths\n}\n", "// example working : )\n// 'test.pest': { // test if wildcard like path handling works\n//   get: {\n//     handler: async ({ dbs, titleRanges }) => {\n//       return [{ path: ['test', 'pest', 'x', 'y'], value: 1 }]\n//     }\n//   }\n// },\n// TODO migrate to box shorthand :  {$atom: somevalue}, {$ref: [1, 'b', 'd'}, {$error: 'error 1 occured'}\n\n// TODO: custom scalar/ schema format support + validation\nexport default {\n  '_sync': {\n    call: {\n      operationId: '_sync'\n    }\n  },\n\n  '_users': {\n    get: {\n      handler: async ({ dbs, session: { org, userId } }) => {\n        const { rows: sessions } = await dbs.couch.query(`ayu_main/by_type_and_title`, {\n          partition: 'system',\n          reduce: false,\n          include_docs: true,\n          startkey: [ 'session' ],\n          endkey: ['session', {}]\n        })\n\n        const users = sessions.map(row => row.doc).sort((a, b) => b.lastLogin - a.lastLogin).reduce((agg, session) => {\n          if (!agg[session.title]) {\n            agg[session.title] = session\n            agg[session.title].numSessions = 1\n          } else {\n            agg[session.title].numSessions += 1\n          }\n          return agg\n        }, {})\n\n        return {\n          jsonGraph: {\n            _users: { $type: 'atom', value: Object.values(users) }\n          }\n        }\n      }\n    }\n  },\n\n  '_sessions': {\n    get: {\n      handler: async ({ dbs, session: { org, userId } }) => {\n        const sessionName = userId + (org ? ` (${org})` : '')\n\n        const { rows: sessions } = await dbs.couch.query(`ayu_main/by_type_and_title`, {\n          partition: 'system',\n          reduce: false,\n          include_docs: true,\n          startkey: [ 'session', sessionName],\n          endkey: ['session', sessionName, {}]\n        })\n\n        return {\n          jsonGraph: {\n            _sessions: { $type: 'atom', value: sessions.map(row => row.doc).sort((a, b) => b.lastLogin - a.lastLogin) }\n          }\n        }\n      }\n    }\n  },\n\n  '_pouch': {\n    get: {\n      handler: async ({ dbs }) => {\n        return {\n          jsonGraph: {\n            _pouch: { $type: 'atom', value:  await dbs.pouch.info() }\n          }\n        }\n      }\n    }\n  },\n  '_couch': {\n    get: {\n      handler: async ({ dbs }) => {\n        return {\n          jsonGraph: {\n            _couch: { $type: 'atom', value:  await dbs.couch?.info?.() }\n          }\n        }\n      }\n    }\n  },\n\n  // // fetch(`/_api/_couch/${loggedInDbName}/${session.sessionId}`)\n  '_session[{keys:keys}]': {\n    get: {\n      handler: ({ _keys, session }) => {\n        return {\n          jsonGraph: {\n            _session: session\n          }\n        }\n      }\n    }\n  },\n\n  '_hash': {\n    get: {\n      handler: () => {\n        return {\n          jsonGraph: {\n            _hash: { $type: 'atom', value: self.ipfsHash }\n          }\n        }\n      }\n    }\n  },\n  '_updating': {\n    get: {\n      handler: () => {\n        return {\n          jsonGraph: {\n            _updating: self.updating\n          }\n        }\n      }\n    },\n    set: {\n      handler: ({_updating, model}) => {\n        self.updating = _updating\n        model.invalidate('_hash')\n        return {\n          jsonGraph: {\n            _updating\n          }\n        }\n      }\n    }\n  },\n  // '_changes.length': {\n  //   get: {\n  //     handler: async ({ dbs }) => {\n  //       const pouchRes = await dbs.pouch.info()\n  //       return { path: ['_changes', 'length'], value: pouchRes.update_seq }\n  //     }\n  //   }\n  // },\n  // '_changes': {\n  //   get: {\n  //     handler: ({ _ids, _keys, _dbs }) => {\n  //       consoe.log('fixme')\n  //       // const _pouchRes = await db.allDocs({\n  //       //   include_docs: true,\n  //       //   conflicts: true,\n  //       //   keys: ids\n  //       // })\n  //     }\n  //   }\n  // },\n  '_docs.create': {\n    call: {\n      handler: async ({ dbs, session, _Observable }, [ docs ]) => {\n        if (!Array.isArray(docs)) {\n          docs = [docs]\n        }\n        const result = await dbs.pouch.bulkDocs(docs.map(doc => {\n          if (!doc._id) {\n            // FIXME: uuid\n            doc._id = `${Math.floor(Math.random() * 1000)}:${Math.floor(Math.random() * 1000000000)}`\n          }\n          doc.changes = [{ userId: session.userId, action: 'created', date: Date.now() }]\n          return doc\n        }))\n\n        return result.map((_doc, i) => {\n          return { path: ['_docs', docs[i]._id], value: docs[i] } // { $type: 'atom', value:\n        })\n      }\n    }\n  },\n  // this route handles subkey upsert and subset key requests\n  // '_docs[{keys:ids}][{keys:keys}]': {\n  //   set: {\n  //     handler: async ({ _docs, db, _userId, keys, ids }) => {\n  //       console.log(_docs, keys, ids)\n  //       const result = await db.bulkDocs(Object.values(_docs).map(({value}) => {\n  //         if (!value.changes) {\n  //           value.changes = []\n  //         }\n  //         if (value.deleted) {\n  //           value.changes.push({ userId: session.userId, action: 'deleted',  date: Date.now() })\n  //         } else if (!value._rev) {\n  //           value.changes.push({ userId: session.userId, action: 'created',  date: Date.now() })\n  //         } else {\n  //           value.changes.push({ userId: session.userId, action: 'updated',  date: Date.now() })\n  //         }\n  //         return value\n  //       }))\n  //       result.forEach(res => {\n  //         if (res.ok) {\n  //           _docs[res.id].value._rev = res.rev\n  //         } else {\n  //           console.error('set doc error', res)\n  //         }\n  //       })\n  //       return  {\n  //         jsonGraph: {\n  //           _docs\n  //         }\n  //       }\n  //     }\n  //   },\n  //   get: {\n  //     handler: async ({ ids, keys, db }) => {\n  //       console.log( keys, ids)\n  //       const pouchRes = await db.allDocs({\n  //         include_docs: true,\n  //         conflicts: true,\n  //         keys: ids\n  //       })\n  //       // console.log(ids, pouchRes)\n  //       const missingIds = []\n  //       const _docs = {}\n  //       pouchRes.rows.forEach(row => {\n  //         if (row.error === 'not_found') {\n  //           missingIds.push(row.key)\n  //         } else if (!row.error) {\n  //           if (row.doc) {\n  //             _docs[row.key] = { $type: 'atom', value: row.doc }\n  //             if (row.doc.type) {\n  //               _docs[row.key].$schema = { $ref: row.doc.type }\n  //             } else if (row.doc.types?.length === 1) {\n  //               _docs[row.key].$schema = { $ref: row.doc.types[0].profile }\n  //             } else if (row.doc.types?.length > 1) {\n  //               _docs[row.key].$schema = { anyOf: _row.doc.types.map(type => {$ref: type.profile}) }\n  //             }\n  //           } else {\n  //             console.warn(row)\n  //           }\n  //         } else {\n  //           console.error(row)\n  //         }\n  //       })\n  //       return {\n  //         jsonGraph: {\n  //           _docs\n  //         }\n  //       }\n  //     }\n  //   }\n  // },\n\n  '_docs[{keys:ids}]': {\n    get: {\n      operationId: 'getDocs'\n    },\n    set: {\n      handler: async ({ _docs, dbs, session }) => {\n        console.log('set docs', _docs)\n        const result = await dbs.pouch.bulkDocs(Object.entries(_docs).map(([key, { value }]) => {\n          // FIXME: opt in to generic changes or namespacing?\n          // if (!value.changes) {\n          //   value.changes = []\n          // }\n          \n          if (!value._id) {\n            value._id = key\n          }\n\n          // if (value.changes.length > 12) {\n          //   value.changes.splice(2, value.changes.length - 4)\n          //   value.changes.push({ userId: session.userId, action: 'aggregated', date: Date.now() })\n          // }\n\n          // if (value.deleted) {\n          //   value.changes.push({ userId: session.userId, action: 'deleted', date: Date.now() })\n          // } else if (!value._rev) {\n          //   value.changes.push({ userId: session.userId, action: 'created', date: Date.now() })\n          // } else {\n          //   value.changes.push({ userId: session.userId, action: 'updated', date: Date.now() })\n          // }\n\n          return value\n        }))\n\n        // todo: handle errors\n        result.forEach(res => {\n          if (res.ok) {\n            _docs[res.id].value._rev = res.rev\n          } else {\n            console.error('set doc error', res)\n          }\n        })\n\n        return {\n          jsonGraph: {\n            _docs\n          }\n        }\n      }\n    }\n  }\n}\n", "export default {\n  '/(#/):_page(/:_subPage)(/*_)': {}\n}\n", "import falcorPaths from './falcor-paths.js'\nimport windowPaths from './window-paths.js'\n\nimport { addPathTags } from './helpers.js'\n\n//  TODO: normalize leading slashes warn or auto handle missing leading slashes\n// TODO: support * methods?\n\nexport default {\n  ...addPathTags(falcorPaths, 'falcor'),\n  ...addPathTags(windowPaths, 'window'),\n\n  '/*': {\n    get: {\n      tags: [ 'edge', 'service-worker' ],\n      operationId: '_ipfs'\n    }\n  },\n\n  // '/_debug': {\n  //   get: {\n  //     tags: [ 'edge' ],\n  //     operationId: '_debug'\n  //   }\n  // },\n  // codespace support TODO: remove\n  // '/signin*': {\n  //   get: {\n  //     operationId: '_bypass'\n  //   }\n  // },\n\n  // TODO: not required anymore?\n  // '/_ayu/accounts*': {\n  //   get: {\n  //     operationId: '_bypass' // '_accounts'\n  //   }\n  // },\n\n  // '/_api/_feed/*': {\n  //   get: {\n  //     tags: [ 'edge' ],\n  //     operationId: '_feed'\n  //   }\n  // },\n\n  '/_api/_session*': {\n    get: {\n      tags: [ 'edge' ],\n      operationId: '_session'\n    },\n    post: {\n      tags: [ 'edge' ],\n      operationId: '_session'\n    },\n    delete: {\n      tags: [ 'edge' ],\n      operationId: '_session'\n    }\n  },\n  '/_api/_couch/*': {\n    get: {\n      tags: [ 'edge' ],\n      operationId: '_couch'\n    },\n    put: {\n      tags: [ 'edge' ],\n      operationId: '_couch'\n    },\n    post: {\n      tags: [ 'edge' ],\n      operationId: '_couch'\n    },\n    options: {\n      tags: [ 'edge' ],\n      operationId: '_couch'\n    }\n  },\n  // cloudflare access support\n  '/cdn-cgi/access*': {\n    get: {\n      tags: [ 'service-worker' ],\n      operationId: '_bypass'\n    }\n  }\n}\n", "export function urlLogger ({ missing, continued, scope, method, url, origUrl, cached, corsConf, body, duration, res, richConsole = true, verbose }) {\n  let badgeColor = ''\n\n  // console.log(url, origUrl, scope)\n  if (!verbose) {\n    if (cached && !missing && method === 'GET' && scope === 'ipfs') {\n      return\n    }\n\n    if (continued) {\n      return\n    }\n  }\n\n  if (richConsole) {\n    badgeColor = 'grey'\n\n    if (cached) {\n      badgeColor = '#099009'\n    } else if (cached === false) {\n      badgeColor = 'orange'\n    }\n\n    if (method === 'POST' || method === 'SET' ) {\n      badgeColor = 'rgb(170, 90, 217)'\n    } else if (method === 'PUT') {\n      badgeColor = 'rgb(174, 12, 226)'\n    } else if (method === 'CALL') {\n      badgeColor = 'rgb(236 124 248)'\n    } else if (method === 'PRELOAD') {\n      badgeColor = '#6ad4f6'\n    }\n  }\n\n  // TODO: move format url her : if (location) {\n  //   url = url.replace(location.origin, '')\n  //   // url = url.split('/').join('/ ')\n  // }\n\n  let displayUrl = ''\n  try {\n    if (typeof location !== 'undefined' && location.origin) { // TODO: deno --location <href> or Deno check\n      displayUrl = url.replace(location.origin, '')\n    } else {\n      displayUrl = url\n    }\n  } catch (_e) {\n    displayUrl = url\n  }\n\n  const edgeWorker = scope?.endsWith('edge-worker')\n\n  /* eslint-disable no-console */\n  if (richConsole) {\n    console.groupCollapsed(\n      `${(scope && edgeWorker) ? scope + ': ' : ''}%c${missing ? 'route error' : ''}%c${missing ? ' ' : ''}%c${method}%c %c ${displayUrl}`,\n      richConsole && missing ? `background-color:red;border-radius:3px;color:black;font-weight:bold;padding-left:2px;padding-right:2px` : '',\n      richConsole ? 'color:grey' : '',\n      richConsole ? `background-color:${badgeColor};border-radius:3px;color:black;font-weight:bold;padding-left:2px;padding-right:2px` : '',\n      richConsole ? 'color:grey' : '',\n      richConsole ? 'color:grey' : ''\n    )\n  } else {\n    console.log(`${(scope && edgeWorker) ? scope + ': ' : ''} ${missing ? 'route error' : ''} ${missing ? ' ' : ''} ${method}    ${displayUrl}`)\n  }\n\n  if (!edgeWorker && scope) {\n    console.info(scope)\n  }\n\n  if (cached === true) {\n    console.info('cache-status: hit')\n  } else if (cached === false) {\n    console.info('cache-status: miss')\n  }\n\n  if (origUrl && (url !== origUrl)) {\n    console.info('rewritten from: ', origUrl)\n  }\n\n  if (corsConf && corsConf.mode === 'proxy') {\n    console.info('proxied through: ' + corsConf.server)\n  }\n\n  if (typeof duration !== 'undefined') {\n    console.log(`duration: ${duration}ms`)\n  }\n\n  if (continued) {\n    console.info('continued processing of previous request')\n  }\n\n  if (body) {\n    console.info(body)\n  }\n\n  if (richConsole) {\n    console.groupEnd()\n  }\n  /* eslint-enable no-console */\n}\n", "// TODO: warn Observable handlers cannot be async functions themselves\n// TODO: filter out changes of own set/ call operations ?\n\nlet changes\nfunction doSync (dbs, since, Observable, _model) {\n  let id\n  let i = 0\n  function schedule (action) {\n    if (i < 5) {\n      i++\n      if (id) {\n        clearTimeout(id)\n        id = null\n      }\n      id = setTimeout(action, 5)\n    }\n  }\n\n  return Observable.create(subscriber => {\n    //   const changes = db.changes({\n    //     since: since,\n    //     include_docs: true\n    //   })\n    //   const { results, last_seq } = await changes\n    //   not necesarry for single shot: changes.cancel()\n    //   if (results.length) {\n    //     subscriber.onNext([\n    //       { path: ['_seq'], value: { $type: 'atom', value: last_seq } },\n    //       ...results.map(change => ({ path: ['_docs', change.id], value: { $type: 'atom', value: change.doc } }))\n    //     ])\n    //     return () => {}\n    //   }\n\n    let catchupFeed = false\n    let usedFeed\n    if (!changes) {\n      console.log('creating pouch _sync changes feed', since)\n      changes = dbs.pouch.changes({\n        since: since || 'now',\n        live: true,\n        timeout: false,\n        include_docs: true\n      })\n\n      if (since !== undefined) {\n        changes.lastSeq = since\n      }\n\n      // dbs.pouch.info().then(info => {\n      //   changes.lastSeq = info.update_seq\n      // })\n      usedFeed = changes\n    } else {\n      if (since !== undefined && since !== null && changes.lastSeq > since) {\n        // TODO: catchup feed should be oneshot ?\n        catchupFeed = true\n        console.log('creating pouch _sync catchup feed for later client', since, changes.lastSeq)\n        usedFeed = dbs.pouch.changes({\n          since: since,\n          live: true,\n          timeout: false,\n          include_docs: true\n        })\n      } else {\n        usedFeed = changes\n      }\n    }\n\n    const complListener = _info => {\n      console.log(\"completeing change observable\")\n      subscriber.onCompleted()\n    }\n\n    const errListener = err => {\n      subscriber.onError({ path: ['_seq'], value: { $type: 'error', value: err }})\n    }\n\n    const changeListener = change => {\n      // FIXME: value: invalidated: true not working, and also jsong invalidations:\n      // [ ['todos'] ], invalidate: [ ['todos'] ], invalidated: [ ['todos'] ]\n\n      usedFeed.lastSeq = change.seq\n\n      const jsonGE = {\n        jsonGraph: {},\n        paths: []\n      }\n\n      if (change.doc.type === 'system:counter' && change.doc.path) {\n        const changePath = change.doc.path.split('.')\n        jsonGE.paths.push(changePath)\n\n        let target = jsonGE.jsonGraph\n        let i = 0\n        for (const key of changePath) {\n          i ++\n          if (!target[key]) {\n            target[key] = {}\n          }\n          if (i === changePath.length) {\n            target[key] = { value: change.doc.value, $type: 'atom' }\n          } else {\n            target = target[key]\n          }\n        }\n      } else {\n        jsonGE.paths.push(['_docs', change.id])\n        jsonGE.jsonGraph._docs = {\n          [change.id]: { $type: 'atom', value: change.doc, $expires: 1 }\n        }\n      }\n\n      jsonGE.paths.push(['_seq'])\n      jsonGE.jsonGraph._seq = { $type: 'atom', value: change.seq }\n\n      // TODO: fix router to forward before complete for long running observable!\n      subscriber.onNext(jsonGE)\n\n      schedule(() => {\n        if (!subscriber.isStopped) {\n          complListener()\n        }\n      })\n    }\n\n    // console.log('attaching change listeners')\n    usedFeed.on('change', changeListener)\n    usedFeed.on('error', errListener)\n    usedFeed.on('complete', complListener)\n\n    return () => {\n      // console.log('cleaning change listeners')\n      if (catchupFeed) {\n        // TODO: cancel changes when no active requests for a while,\n        console.log('killing catchup feed')\n        usedFeed.cancel()\n      }\n\n      usedFeed.removeListener('change', changeListener)\n      usedFeed.removeListener('error', errListener)\n      usedFeed.removeListener('complete', complListener)\n    }\n  })\n}\n\nexport const _sync = ({ dbs, Observable, model }, [ since ]) => {\n  return dbs && doSync(dbs, since, Observable, model)\n}\n\nexport async function getDocs ({ ids, dbs }) {\n  const docs = await dbs.sync.pullDocs(ids.filter(id => id), {includeDocs: true})\n\n  const _docs = {}\n\n  docs.forEach(doc => {\n    const envelope = { $type: 'atom', value: doc, $expires: 1 }\n\n    if (doc.type) {\n      envelope.$schema = { $ref: doc.type }\n    } else if (doc.types?.length === 1) {\n      envelope.$schema = { $ref: doc.types[0].profile }\n    } else if (doc.types?.length > 1) {\n      envelope.$schema = { anyOf: doc.types.map(type => ({ '$ref': type.profile })) }\n    }\n\n    _docs[doc._id] = envelope\n  })\n\n  return {\n    jsonGraph: {\n      _docs\n    }\n  }\n}\n\n// TODO: chan support\n// doc.chans?.forEach(chan => {\n//   paths.push(['contactsByChan', btoa(chan.href)])\n//   contactsByChan[btoa(chan.href)] = { $type: 'ref', value: ['byId', row.id] }\n// })\n", "// https://moment.github.io/luxon/es6/luxon.min.js\nclass t extends Error{}class z extends t{constructor(t){super(\"Invalid DateTime: \"+t.toMessage())}}class q extends t{constructor(t){super(\"Invalid Interval: \"+t.toMessage())}}class A extends t{constructor(t){super(\"Invalid Duration: \"+t.toMessage())}}class j extends t{}class _ extends t{constructor(t){super(\"Invalid unit \"+t)}}class o extends t{}class r extends t{constructor(){super(\"Zone is an abstract class\")}}var e=\"numeric\",n=\"short\",s=\"long\";const U={year:e,month:e,day:e},$={year:e,month:n,day:e},H={year:e,month:n,day:e,weekday:n},W={year:e,month:s,day:e},R={year:e,month:s,day:e,weekday:s},J={hour:e,minute:e},Y={hour:e,minute:e,second:e},P={hour:e,minute:e,second:e,timeZoneName:n},G={hour:e,minute:e,second:e,timeZoneName:s},B={hour:e,minute:e,hourCycle:\"h23\"},Q={hour:e,minute:e,second:e,hourCycle:\"h23\"},K={hour:e,minute:e,second:e,hourCycle:\"h23\",timeZoneName:n},X={hour:e,minute:e,second:e,hourCycle:\"h23\",timeZoneName:s},tt={year:e,month:e,day:e,hour:e,minute:e},et={year:e,month:e,day:e,hour:e,minute:e,second:e},rt={year:e,month:n,day:e,hour:e,minute:e},nt={year:e,month:n,day:e,hour:e,minute:e,second:e},st={year:e,month:n,day:e,weekday:n,hour:e,minute:e},it={year:e,month:s,day:e,hour:e,minute:e,timeZoneName:n},at={year:e,month:s,day:e,hour:e,minute:e,second:e,timeZoneName:n},ot={year:e,month:s,day:e,weekday:s,hour:e,minute:e,timeZoneName:s},ut={year:e,month:s,day:e,weekday:s,hour:e,minute:e,second:e,timeZoneName:s};function O(t){return void 0===t}function c(t){return\"number\"==typeof t}function lt(t){return\"number\"==typeof t&&t%1==0}function ct(t){return\"[object Date]\"===Object.prototype.toString.call(t)}function ht(){try{return\"undefined\"!=typeof Intl&&!!Intl.RelativeTimeFormat}catch(t){return!1}}function dt(t){return Array.isArray(t)?t:[t]}function mt(t,r,n){if(0!==t.length)return t.reduce((t,e)=>{e=[r(e),e];return t&&n(t[0],e[0])===t[0]?t:e},null)[1]}function h(t,e){return Object.prototype.hasOwnProperty.call(t,e)}function u(t,e,r){return lt(t)&&e<=t&&t<=r}function l(t,e=2){let r;return r=t<0?\"-\"+(\"\"+-t).padStart(e,\"0\"):(\"\"+t).padStart(e,\"0\")}function d(t){if(!O(t)&&null!==t&&\"\"!==t)return parseInt(t,10)}function m(t){if(!O(t)&&null!==t&&\"\"!==t)return parseFloat(t)}function ft(t){if(!O(t)&&null!==t&&\"\"!==t)return t=1e3*parseFloat(\"0.\"+t),Math.floor(t)}function yt(t,e,r=!1){const n=10**e,s=r?Math.trunc:Math.round;return s(t*n)/n}function gt(t){return t%4==0&&(t%100!=0||t%400==0)}function wt(t){return gt(t)?366:365}function vt(t,e){var r,n=(n=e-1)-(r=12)*Math.floor(n/r)+1;return 2==n?gt(t+(e-n)/12)?29:28:[31,null,31,30,31,30,31,31,30,31,30,31][n-1]}function pt(t){let e=Date.UTC(t.year,t.month-1,t.day,t.hour,t.minute,t.second,t.millisecond);return t.year<100&&0<=t.year&&(e=new Date(e)).setUTCFullYear(e.getUTCFullYear()-1900),+e}function Tt(t){var e=(t+Math.floor(t/4)-Math.floor(t/100)+Math.floor(t/400))%7,t=t-1,t=(t+Math.floor(t/4)-Math.floor(t/100)+Math.floor(t/400))%7;return 4==e||3==t?53:52}function St(t){return 99<t?t:60<t?1900+t:2e3+t}function Ot(t,e,r,n=null){const s=new Date(t),i={hourCycle:\"h23\",year:\"numeric\",month:\"2-digit\",day:\"2-digit\",hour:\"2-digit\",minute:\"2-digit\"};n&&(i.timeZone=n);t={timeZoneName:e,...i},n=new Intl.DateTimeFormat(r,t).formatToParts(s).find(t=>\"timezonename\"===t.type.toLowerCase());return n?n.value:null}function bt(t,e){let r=parseInt(t,10);Number.isNaN(r)&&(r=0);t=parseInt(e,10)||0,e=r<0||Object.is(r,-0)?-t:t;return 60*r+e}function kt(t){var e=Number(t);if(\"boolean\"==typeof t||\"\"===t||Number.isNaN(e))throw new o(\"Invalid unit value \"+t);return e}function Mt(t,e){const r={};for(const s in t){var n;!h(t,s)||null!=(n=t[s])&&(r[e(s)]=kt(n))}return r}function Nt(t,e){var r=Math.trunc(Math.abs(t/60)),n=Math.trunc(Math.abs(t%60)),s=0<=t?\"+\":\"-\";switch(e){case\"short\":return s+l(r,2)+\":\"+l(n,2);case\"narrow\":return s+r+(0<n?\":\"+n:\"\");case\"techie\":return s+l(r,2)+l(n,2);default:throw new RangeError(`Value format ${e} is out of range for property format`)}}function Dt(t){return r=t,[\"hour\",\"minute\",\"second\",\"millisecond\"].reduce((t,e)=>(t[e]=r[e],t),{});var r}n=/[A-Za-z_+-]{1,256}(?::?\\/[A-Za-z0-9_+-]{1,256}(?:\\/[A-Za-z0-9_+-]{1,256})?)?/;const Et=[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],Vt=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],xt=[\"J\",\"F\",\"M\",\"A\",\"M\",\"J\",\"J\",\"A\",\"S\",\"O\",\"N\",\"D\"];function It(t){switch(t){case\"narrow\":return[...xt];case\"short\":return[...Vt];case\"long\":return[...Et];case\"numeric\":return[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"];case\"2-digit\":return[\"01\",\"02\",\"03\",\"04\",\"05\",\"06\",\"07\",\"08\",\"09\",\"10\",\"11\",\"12\"];default:return null}}const Ct=[\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"],Ft=[\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\"],Zt=[\"M\",\"T\",\"W\",\"T\",\"F\",\"S\",\"S\"];function Lt(t){switch(t){case\"narrow\":return[...Zt];case\"short\":return[...Ft];case\"long\":return[...Ct];case\"numeric\":return[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\"];default:return null}}const zt=[\"AM\",\"PM\"],qt=[\"Before Christ\",\"Anno Domini\"],At=[\"BC\",\"AD\"],jt=[\"B\",\"A\"];function _t(t){switch(t){case\"narrow\":return[...jt];case\"short\":return[...At];case\"long\":return[...qt];default:return null}}function Ut(t){return zt[t.hour<12?0:1]}function $t(t,e){return Lt(e)[t.weekday-1]}function Ht(t,e){return It(e)[t.month-1]}function Wt(t,e){return _t(e)[t.year<0?0:1]}function Rt(t,e,r=\"always\",n=!1){var s={years:[\"year\",\"yr.\"],quarters:[\"quarter\",\"qtr.\"],months:[\"month\",\"mo.\"],weeks:[\"week\",\"wk.\"],days:[\"day\",\"day\",\"days\"],hours:[\"hour\",\"hr.\"],minutes:[\"minute\",\"min.\"],seconds:[\"second\",\"sec.\"]},i=-1===[\"hours\",\"minutes\",\"seconds\"].indexOf(t);if(\"auto\"===r&&i){var a=\"days\"===t;switch(e){case 1:return a?\"tomorrow\":\"next \"+s[t][0];case-1:return a?\"yesterday\":\"last \"+s[t][0];case 0:return a?\"today\":\"this \"+s[t][0]}}var r=Object.is(e,-0)||e<0,i=Math.abs(e),e=1===i,o=s[t],n=n?!e&&o[2]||o[1]:e?s[t][0]:t;return r?i+` ${n} ago`:`in ${i} `+n}function Jt(t,e){let r=\"\";for(const n of t)n.literal?r+=n.val:r+=e(n.val);return r}const Yt={D:U,DD:$,DDD:W,DDDD:R,t:J,tt:Y,ttt:P,tttt:G,T:B,TT:Q,TTT:K,TTTT:X,f:tt,ff:rt,fff:it,ffff:ot,F:et,FF:nt,FFF:at,FFFF:ut};class f{static create(t,e={}){return new f(t,e)}static parseFormat(e){let r=null,n=\"\",s=!1;const i=[];for(let t=0;t<e.length;t++){var a=e.charAt(t);\"'\"===a?(0<n.length&&i.push({literal:s,val:n}),r=null,n=\"\",s=!s):s||a===r?n+=a:(0<n.length&&i.push({literal:!1,val:n}),n=a,r=a)}return 0<n.length&&i.push({literal:s,val:n}),i}static macroTokenToFormatOpts(t){return Yt[t]}constructor(t,e){this.opts=e,this.loc=t,this.systemLoc=null}formatWithSystemDefault(t,e){null===this.systemLoc&&(this.systemLoc=this.loc.redefaultToSystem());const r=this.systemLoc.dtFormatter(t,{...this.opts,...e});return r.format()}formatDateTime(t,e={}){const r=this.loc.dtFormatter(t,{...this.opts,...e});return r.format()}formatDateTimeParts(t,e={}){const r=this.loc.dtFormatter(t,{...this.opts,...e});return r.formatToParts()}resolvedOptions(t,e={}){const r=this.loc.dtFormatter(t,{...this.opts,...e});return r.resolvedOptions()}num(t,e=0){if(this.opts.forceSimple)return l(t,e);const r={...this.opts};return 0<e&&(r.padTo=e),this.loc.numberFormatter(r).format(t)}formatDateTimeFromString(r,t){const n=\"en\"===this.loc.listingMode(),e=this.loc.outputCalendar&&\"gregory\"!==this.loc.outputCalendar,s=(t,e)=>this.loc.extract(r,t,e),i=t=>r.isOffsetFixed&&0===r.offset&&t.allowZ?\"Z\":r.isValid?r.zone.formatOffset(r.ts,t.format):\"\",a=()=>n?Ut(r):s({hour:\"numeric\",hourCycle:\"h12\"},\"dayperiod\"),o=(t,e)=>n?Ht(r,t):s(e?{month:t}:{month:t,day:\"numeric\"},\"month\"),u=(t,e)=>n?$t(r,t):s(e?{weekday:t}:{weekday:t,month:\"long\",day:\"numeric\"},\"weekday\"),l=t=>{var e=f.macroTokenToFormatOpts(t);return e?this.formatWithSystemDefault(r,e):t},c=t=>n?Wt(r,t):s({era:t},\"era\");return Jt(f.parseFormat(t),t=>{switch(t){case\"S\":return this.num(r.millisecond);case\"u\":case\"SSS\":return this.num(r.millisecond,3);case\"s\":return this.num(r.second);case\"ss\":return this.num(r.second,2);case\"uu\":return this.num(Math.floor(r.millisecond/10),2);case\"uuu\":return this.num(Math.floor(r.millisecond/100));case\"m\":return this.num(r.minute);case\"mm\":return this.num(r.minute,2);case\"h\":return this.num(r.hour%12==0?12:r.hour%12);case\"hh\":return this.num(r.hour%12==0?12:r.hour%12,2);case\"H\":return this.num(r.hour);case\"HH\":return this.num(r.hour,2);case\"Z\":return i({format:\"narrow\",allowZ:this.opts.allowZ});case\"ZZ\":return i({format:\"short\",allowZ:this.opts.allowZ});case\"ZZZ\":return i({format:\"techie\",allowZ:this.opts.allowZ});case\"ZZZZ\":return r.zone.offsetName(r.ts,{format:\"short\",locale:this.loc.locale});case\"ZZZZZ\":return r.zone.offsetName(r.ts,{format:\"long\",locale:this.loc.locale});case\"z\":return r.zoneName;case\"a\":return a();case\"d\":return e?s({day:\"numeric\"},\"day\"):this.num(r.day);case\"dd\":return e?s({day:\"2-digit\"},\"day\"):this.num(r.day,2);case\"c\":return this.num(r.weekday);case\"ccc\":return u(\"short\",!0);case\"cccc\":return u(\"long\",!0);case\"ccccc\":return u(\"narrow\",!0);case\"E\":return this.num(r.weekday);case\"EEE\":return u(\"short\",!1);case\"EEEE\":return u(\"long\",!1);case\"EEEEE\":return u(\"narrow\",!1);case\"L\":return e?s({month:\"numeric\",day:\"numeric\"},\"month\"):this.num(r.month);case\"LL\":return e?s({month:\"2-digit\",day:\"numeric\"},\"month\"):this.num(r.month,2);case\"LLL\":return o(\"short\",!0);case\"LLLL\":return o(\"long\",!0);case\"LLLLL\":return o(\"narrow\",!0);case\"M\":return e?s({month:\"numeric\"},\"month\"):this.num(r.month);case\"MM\":return e?s({month:\"2-digit\"},\"month\"):this.num(r.month,2);case\"MMM\":return o(\"short\",!1);case\"MMMM\":return o(\"long\",!1);case\"MMMMM\":return o(\"narrow\",!1);case\"y\":return e?s({year:\"numeric\"},\"year\"):this.num(r.year);case\"yy\":return e?s({year:\"2-digit\"},\"year\"):this.num(r.year.toString().slice(-2),2);case\"yyyy\":return e?s({year:\"numeric\"},\"year\"):this.num(r.year,4);case\"yyyyyy\":return e?s({year:\"numeric\"},\"year\"):this.num(r.year,6);case\"G\":return c(\"short\");case\"GG\":return c(\"long\");case\"GGGGG\":return c(\"narrow\");case\"kk\":return this.num(r.weekYear.toString().slice(-2),2);case\"kkkk\":return this.num(r.weekYear,4);case\"W\":return this.num(r.weekNumber);case\"WW\":return this.num(r.weekNumber,2);case\"o\":return this.num(r.ordinal);case\"ooo\":return this.num(r.ordinal,3);case\"q\":return this.num(r.quarter);case\"qq\":return this.num(r.quarter,2);case\"X\":return this.num(Math.floor(r.ts/1e3));case\"x\":return this.num(r.ts);default:return l(t)}})}formatDurationFromString(t,e){const r=t=>{switch(t[0]){case\"S\":return\"millisecond\";case\"s\":return\"second\";case\"m\":return\"minute\";case\"h\":return\"hour\";case\"d\":return\"day\";case\"w\":return\"week\";case\"M\":return\"month\";case\"y\":return\"year\";default:return null}},n=f.parseFormat(e),s=n.reduce((t,{literal:e,val:r})=>e?t:t.concat(r),[]),i=t.shiftTo(...s.map(r).filter(t=>t));return Jt(n,(a=i,t=>{var e=r(t);return e?this.num(a.get(e),t.length):t}));var a}}class y{constructor(t,e){this.reason=t,this.explanation=e}toMessage(){return this.explanation?this.reason+\": \"+this.explanation:this.reason}}class i{get type(){throw new r}get name(){throw new r}get ianaName(){return this.name}get isUniversal(){throw new r}offsetName(t,e){throw new r}formatOffset(t,e){throw new r}offset(t){throw new r}equals(t){throw new r}get isValid(){throw new r}}let Pt=null;class Gt extends i{static get instance(){return Pt=null===Pt?new Gt:Pt}get type(){return\"system\"}get name(){return(new Intl.DateTimeFormat).resolvedOptions().timeZone}get isUniversal(){return!1}offsetName(t,{format:e,locale:r}){return Ot(t,e,r)}formatOffset(t,e){return Nt(this.offset(t),e)}offset(t){return-new Date(t).getTimezoneOffset()}equals(t){return\"system\"===t.type}get isValid(){return!0}}let Bt={};function Qt(t){return Bt[t]||(Bt[t]=new Intl.DateTimeFormat(\"en-US\",{hour12:!1,timeZone:t,year:\"numeric\",month:\"2-digit\",day:\"2-digit\",hour:\"2-digit\",minute:\"2-digit\",second:\"2-digit\",era:\"short\"})),Bt[t]}const Kt={year:0,month:1,day:2,era:3,hour:4,minute:5,second:6};function Xt(t,e){var t=t.format(e).replace(/\\u200E/g,\"\"),[,e,t,r,n,s,i,a]=/(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(t);return[r,e,t,n,s,i,a]}function te(t,e){var r=t.formatToParts(e);const n=[];for(let t=0;t<r.length;t++){var{type:s,value:i}=r[t],a=Kt[s];\"era\"===s?n[a]=i:O(a)||(n[a]=parseInt(i,10))}return n}let ee={};class w extends i{static create(t){return ee[t]||(ee[t]=new w(t)),ee[t]}static resetCache(){ee={},Bt={}}static isValidSpecifier(t){return this.isValidZone(t)}static isValidZone(t){if(!t)return!1;try{return new Intl.DateTimeFormat(\"en-US\",{timeZone:t}).format(),!0}catch(t){return!1}}constructor(t){super(),this.zoneName=t,this.valid=w.isValidZone(t)}get type(){return\"iana\"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(t,{format:e,locale:r}){return Ot(t,e,r,this.name)}formatOffset(t,e){return Nt(this.offset(t),e)}offset(t){t=new Date(t);if(isNaN(t))return NaN;var e=Qt(this.name);let[r,n,s,i,a,o,u]=(e.formatToParts?te:Xt)(e,t);e=+t,t=e%1e3;return(pt({year:r=\"BC\"===i?1-Math.abs(r):r,month:n,day:s,hour:24===a?0:a,minute:o,second:u,millisecond:0})-(e-=0<=t?t:1e3+t))/6e4}equals(t){return\"iana\"===t.type&&t.name===this.name}get isValid(){return this.valid}}let re=null;class v extends i{static get utcInstance(){return re=null===re?new v(0):re}static instance(t){return 0===t?v.utcInstance:new v(t)}static parseSpecifier(t){if(t){t=t.match(/^utc(?:([+-]\\d{1,2})(?::(\\d{2}))?)?$/i);if(t)return new v(bt(t[1],t[2]))}return null}constructor(t){super(),this.fixed=t}get type(){return\"fixed\"}get name(){return 0===this.fixed?\"UTC\":\"UTC\"+Nt(this.fixed,\"narrow\")}get ianaName(){return 0===this.fixed?\"Etc/UTC\":\"Etc/GMT\"+Nt(-this.fixed,\"narrow\")}offsetName(){return this.name}formatOffset(t,e){return Nt(this.fixed,e)}get isUniversal(){return!0}offset(){return this.fixed}equals(t){return\"fixed\"===t.type&&t.fixed===this.fixed}get isValid(){return!0}}class ne extends i{constructor(t){super(),this.zoneName=t}get type(){return\"invalid\"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(){return null}formatOffset(){return\"\"}offset(){return NaN}equals(){return!1}get isValid(){return!1}}function b(t,e){var r;return O(t)||null===t?e:t instanceof i?t:\"string\"==typeof t?\"default\"===(r=t.toLowerCase())?e:\"local\"===r||\"system\"===r?Gt.instance:\"utc\"===r||\"gmt\"===r?v.utcInstance:v.parseSpecifier(r)||w.create(t):c(t)?v.instance(t):\"object\"==typeof t&&t.offset&&\"number\"==typeof t.offset?t:new ne(t)}let se=()=>Date.now(),ie=\"system\",ae=null,oe=null,ue=null,le;class k{static get now(){return se}static set now(t){se=t}static set defaultZone(t){ie=t}static get defaultZone(){return b(ie,Gt.instance)}static get defaultLocale(){return ae}static set defaultLocale(t){ae=t}static get defaultNumberingSystem(){return oe}static set defaultNumberingSystem(t){oe=t}static get defaultOutputCalendar(){return ue}static set defaultOutputCalendar(t){ue=t}static get throwOnInvalid(){return le}static set throwOnInvalid(t){le=t}static resetCaches(){M.resetCache(),w.resetCache()}}let ce={};function he(t,e={}){var r=JSON.stringify([t,e]);let n=ce[r];return n||(n=new Intl.ListFormat(t,e),ce[r]=n),n}let de={};function me(t,e={}){var r=JSON.stringify([t,e]);let n=de[r];return n||(n=new Intl.DateTimeFormat(t,e),de[r]=n),n}let fe={};function ye(t,e={}){var r=JSON.stringify([t,e]);let n=fe[r];return n||(n=new Intl.NumberFormat(t,e),fe[r]=n),n}let ge={};function we(t,e={}){const{base:r,...n}=e;var s=JSON.stringify([t,n]);let i=ge[s];return i||(i=new Intl.RelativeTimeFormat(t,e),ge[s]=i),i}let ve=null;function pe(){return ve=ve||(new Intl.DateTimeFormat).resolvedOptions().locale}function Te(t){var r=t.indexOf(\"-u-\");if(-1===r)return[t];{let e;r=t.substring(0,r);try{e=me(t).resolvedOptions()}catch(t){e=me(r).resolvedOptions()}var{numberingSystem:t,calendar:n}=e;return[r,t,n]}}function Se(t,e,r){return(r||e)&&(t+=\"-u\",r&&(t+=\"-ca-\"+r),e&&(t+=\"-nu-\"+e)),t}function Oe(e){const r=[];for(let t=1;t<=12;t++){var n=L.utc(2016,t,1);r.push(e(n))}return r}function be(e){const r=[];for(let t=1;t<=7;t++){var n=L.utc(2016,11,13+t);r.push(e(n))}return r}function ke(t,e,r,n,s){t=t.listingMode(r);return\"error\"===t?null:(\"en\"===t?n:s)(e)}function Me(t){return(!t.numberingSystem||\"latn\"===t.numberingSystem)&&(\"latn\"===t.numberingSystem||!t.locale||t.locale.startsWith(\"en\")||\"latn\"===new Intl.DateTimeFormat(t.intl).resolvedOptions().numberingSystem)}class Ne{constructor(t,e,r){this.padTo=r.padTo||0,this.floor=r.floor||!1;const{padTo:n,floor:s,...i}=r;if(!e||0<Object.keys(i).length){const a={useGrouping:!1,...r};0<r.padTo&&(a.minimumIntegerDigits=r.padTo),this.inf=ye(t,a)}}format(t){var e;return this.inf?(e=this.floor?Math.floor(t):t,this.inf.format(e)):l(this.floor?Math.floor(t):yt(t,3),this.padTo)}}class De{constructor(t,e,r){this.opts=r;let n;var s;t.zone.isUniversal?(s=0<=(s=t.offset/60*-1)?\"Etc/GMT+\"+s:\"Etc/GMT\"+s,0!==t.offset&&w.create(s).valid?(n=s,this.dt=t):(n=\"UTC\",r.timeZoneName?this.dt=t:this.dt=0===t.offset?t:L.fromMillis(t.ts+60*t.offset*1e3))):\"system\"===t.zone.type?this.dt=t:(this.dt=t,n=t.zone.name);const i={...this.opts};n&&(i.timeZone=n),this.dtf=me(e,i)}format(){return this.dtf.format(this.dt.toJSDate())}formatToParts(){return this.dtf.formatToParts(this.dt.toJSDate())}resolvedOptions(){return this.dtf.resolvedOptions()}}class Ee{constructor(t,e,r){this.opts={style:\"long\",...r},!e&&ht()&&(this.rtf=we(t,r))}format(t,e){return this.rtf?this.rtf.format(t,e):Rt(e,t,this.opts.numeric,\"long\"!==this.opts.style)}formatToParts(t,e){return this.rtf?this.rtf.formatToParts(t,e):[]}}class M{static fromOpts(t){return M.create(t.locale,t.numberingSystem,t.outputCalendar,t.defaultToEN)}static create(t,e,r,n=!1){t=t||k.defaultLocale,n=t||(n?\"en-US\":pe()),e=e||k.defaultNumberingSystem,r=r||k.defaultOutputCalendar;return new M(n,e,r,t)}static resetCache(){ve=null,de={},fe={},ge={}}static fromObject({locale:t,numberingSystem:e,outputCalendar:r}={}){return M.create(t,e,r)}constructor(t,e,r,n){var[t,s,i]=Te(t);this.locale=t,this.numberingSystem=e||s||null,this.outputCalendar=r||i||null,this.intl=Se(this.locale,this.numberingSystem,this.outputCalendar),this.weekdaysCache={format:{},standalone:{}},this.monthsCache={format:{},standalone:{}},this.meridiemCache=null,this.eraCache={},this.specifiedLocale=n,this.fastNumbersCached=null}get fastNumbers(){return null==this.fastNumbersCached&&(this.fastNumbersCached=Me(this)),this.fastNumbersCached}listingMode(){var t=this.isEnglish(),e=!(null!==this.numberingSystem&&\"latn\"!==this.numberingSystem||null!==this.outputCalendar&&\"gregory\"!==this.outputCalendar);return t&&e?\"en\":\"intl\"}clone(t){return t&&0!==Object.getOwnPropertyNames(t).length?M.create(t.locale||this.specifiedLocale,t.numberingSystem||this.numberingSystem,t.outputCalendar||this.outputCalendar,t.defaultToEN||!1):this}redefaultToEN(t={}){return this.clone({...t,defaultToEN:!0})}redefaultToSystem(t={}){return this.clone({...t,defaultToEN:!1})}months(r,n=!1,t=!0){return ke(this,r,t,It,()=>{const e=n?{month:r,day:\"numeric\"}:{month:r},t=n?\"format\":\"standalone\";return this.monthsCache[t][r]||(this.monthsCache[t][r]=Oe(t=>this.extract(t,e,\"month\"))),this.monthsCache[t][r]})}weekdays(r,n=!1,t=!0){return ke(this,r,t,Lt,()=>{const e=n?{weekday:r,year:\"numeric\",month:\"long\",day:\"numeric\"}:{weekday:r},t=n?\"format\":\"standalone\";return this.weekdaysCache[t][r]||(this.weekdaysCache[t][r]=be(t=>this.extract(t,e,\"weekday\"))),this.weekdaysCache[t][r]})}meridiems(t=!0){return ke(this,void 0,t,()=>zt,()=>{if(!this.meridiemCache){const e={hour:\"numeric\",hourCycle:\"h12\"};this.meridiemCache=[L.utc(2016,11,13,9),L.utc(2016,11,13,19)].map(t=>this.extract(t,e,\"dayperiod\"))}return this.meridiemCache})}eras(t,e=!0){return ke(this,t,e,_t,()=>{const e={era:t};return this.eraCache[t]||(this.eraCache[t]=[L.utc(-40,1,1),L.utc(2017,1,1)].map(t=>this.extract(t,e,\"era\"))),this.eraCache[t]})}extract(t,e,r){const n=this.dtFormatter(t,e),s=n.formatToParts(),i=s.find(t=>t.type.toLowerCase()===r);return i?i.value:null}numberFormatter(t={}){return new Ne(this.intl,t.forceSimple||this.fastNumbers,t)}dtFormatter(t,e={}){return new De(t,this.intl,e)}relFormatter(t={}){return new Ee(this.intl,this.isEnglish(),t)}listFormatter(t={}){return he(this.intl,t)}isEnglish(){return\"en\"===this.locale||\"en-us\"===this.locale.toLowerCase()||new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith(\"en-us\")}equals(t){return this.locale===t.locale&&this.numberingSystem===t.numberingSystem&&this.outputCalendar===t.outputCalendar}}function a(...t){t=t.reduce((t,e)=>t+e.source,\"\");return RegExp(`^${t}$`)}function g(...t){return i=>t.reduce(([t,e,r],n)=>{var[n,r,s]=n(i,r);return[{...t,...n},r||e,s]},[{},null,1]).slice(0,2)}function p(t,...e){if(null!=t)for(var[r,n]of e){r=r.exec(t);if(r)return n(r)}return[null,null]}function Ve(...s){return(t,e)=>{const r={};let n;for(n=0;n<s.length;n++)r[s[n]]=d(t[e+n]);return[r,null,e+n]}}var e=/(?:(Z)|([+-]\\d\\d)(?::?(\\d\\d))?)/,s=/(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:[.,](\\d{1,30}))?)?)?/,xe=RegExp(s.source+`(?:${e.source}?(?:\\\\[(${n.source})\\\\])?)?`),Ie=RegExp(`(?:T${xe.source})?`),Ce=Ve(\"weekYear\",\"weekNumber\",\"weekDay\"),Fe=Ve(\"year\",\"ordinal\"),e=RegExp(s.source+` ?(?:${e.source}|(${n.source}))?`),n=RegExp(`(?: ${e.source})?`);function T(t,e,r){t=t[e];return O(t)?r:d(t)}function S(t,e){return[{hours:T(t,e,0),minutes:T(t,e+1,0),seconds:T(t,e+2,0),milliseconds:ft(t[e+3])},null,e+4]}function Ze(t,e){var r=!t[e]&&!t[e+1],t=bt(t[e+1],t[e+2]);return[{},r?null:v.instance(t),e+3]}function Le(t,e){return[{},t[e]?w.create(t[e]):null,e+1]}const ze=RegExp(`^T?${s.source}$`),qe=/^-?P(?:(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)Y)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)W)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)D)?(?:T(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)H)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20})(?:[.,](-?\\d{1,20}))?S)?)?)$/;function Ae(t){var[t,e,r,n,s,i,a,o,u]=t;const l=\"-\"===t[0];var t=o&&\"-\"===o[0],c=(t,e=!1)=>void 0!==t&&(e||t&&l)?-t:t;return[{years:c(m(e)),months:c(m(r)),weeks:c(m(n)),days:c(m(s)),hours:c(m(i)),minutes:c(m(a)),seconds:c(m(o),\"-0\"===o),milliseconds:c(ft(u),t)}]}const je={GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function _e(t,e,r,n,s,i,a){const o={year:2===e.length?St(d(e)):d(e),month:Vt.indexOf(r)+1,day:d(n),hour:d(s),minute:d(i)};return a&&(o.second=d(a)),t&&(o.weekday=3<t.length?Ct.indexOf(t)+1:Ft.indexOf(t)+1),o}const Ue=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\\d\\d)(\\d\\d)))$/;function $e(t){var[,t,e,r,n,s,i,a,o,u,l,c]=t,t=_e(t,n,r,e,s,i,a);let h;return h=o?je[o]:u?0:bt(l,c),[t,new v(h)]}const He=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d\\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,We=/^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\\d\\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,Re=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \\d|\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) (\\d{4})$/;function Je(t){var[,t,e,r,n,s,i,a]=t;return[_e(t,n,r,e,s,i,a),v.utcInstance]}function Ye(t){var[,t,e,r,n,s,i,a]=t;return[_e(t,a,e,r,n,s,i),v.utcInstance]}const Pe=a(/([+-]\\d{6}|\\d{4})(?:-?(\\d\\d)(?:-?(\\d\\d))?)?/,Ie),Ge=a(/(\\d{4})-?W(\\d\\d)(?:-?(\\d))?/,Ie),Be=a(/(\\d{4})-?(\\d{3})/,Ie),Qe=a(xe),Ke=g(function(t,e){return[{year:T(t,e),month:T(t,e+1,1),day:T(t,e+2,1)},null,e+3]},S,Ze,Le),Xe=g(Ce,S,Ze,Le),tr=g(Fe,S,Ze,Le),er=g(S,Ze,Le);function rr(t){return p(t,[Pe,Ke],[Ge,Xe],[Be,tr],[Qe,er])}function nr(t){return p(t.replace(/\\([^)]*\\)|[\\n\\t]/g,\" \").replace(/(\\s\\s+)/g,\" \").trim(),[Ue,$e])}function sr(t){return p(t,[He,Je],[We,Je],[Re,Ye])}function ir(t){return p(t,[qe,Ae])}const ar=g(S);function or(t){return p(t,[ze,ar])}const ur=a(/(\\d{4})-(\\d\\d)-(\\d\\d)/,n),lr=a(e),cr=g(S,Ze,Le);function hr(t){return p(t,[ur,Ke],[lr,cr])}const dr={weeks:{days:7,hours:168,minutes:10080,seconds:604800,milliseconds:6048e5},days:{hours:24,minutes:1440,seconds:86400,milliseconds:864e5},hours:{minutes:60,seconds:3600,milliseconds:36e5},minutes:{seconds:60,milliseconds:6e4},seconds:{milliseconds:1e3}},mr={years:{quarters:4,months:12,weeks:52,days:365,hours:8760,minutes:525600,seconds:31536e3,milliseconds:31536e6},quarters:{months:3,weeks:13,days:91,hours:2184,minutes:131040,seconds:7862400,milliseconds:78624e5},months:{weeks:4,days:30,hours:720,minutes:43200,seconds:2592e3,milliseconds:2592e6},...dr},N=365.2425,fr=30.436875,yr={years:{quarters:4,months:12,weeks:N/7,days:N,hours:24*N,minutes:525949.2,seconds:525949.2*60,milliseconds:525949.2*60*1e3},quarters:{months:3,weeks:N/28,days:N/4,hours:24*N/4,minutes:131487.3,seconds:525949.2*60/4,milliseconds:7889237999.999999},months:{weeks:fr/7,days:fr,hours:24*fr,minutes:43829.1,seconds:2629746,milliseconds:2629746e3},...dr},D=[\"years\",\"quarters\",\"months\",\"weeks\",\"days\",\"hours\",\"minutes\",\"seconds\",\"milliseconds\"],gr=D.slice(0).reverse();function E(t,e,r=!1){r={values:r?e.values:{...t.values,...e.values||{}},loc:t.loc.clone(e.loc),conversionAccuracy:e.conversionAccuracy||t.conversionAccuracy,matrix:e.matrix||t.matrix};return new V(r)}function wr(t,e,r,n,s){var t=t[s][r],i=e[r]/t,a=!(Math.sign(i)===Math.sign(n[s]))&&0!==n[s]&&Math.abs(i)<=1?(a=i)<0?Math.floor(a):Math.ceil(a):Math.trunc(i);n[s]+=a,e[r]-=a*t}function vr(r,n){gr.reduce((t,e)=>O(n[e])?t:(t&&wr(r,n,t,n,e),e),null)}class V{constructor(t){var e=\"longterm\"===t.conversionAccuracy||!1;let r=e?yr:mr;t.matrix&&(r=t.matrix),this.values=t.values,this.loc=t.loc||M.create(),this.conversionAccuracy=e?\"longterm\":\"casual\",this.invalid=t.invalid||null,this.matrix=r,this.isLuxonDuration=!0}static fromMillis(t,e){return V.fromObject({milliseconds:t},e)}static fromObject(t,e={}){if(null==t||\"object\"!=typeof t)throw new o(\"Duration.fromObject: argument expected to be an object, got \"+(null===t?\"null\":typeof t));return new V({values:Mt(t,V.normalizeUnit),loc:M.fromObject(e),conversionAccuracy:e.conversionAccuracy,matrix:e.matrix})}static fromDurationLike(t){if(c(t))return V.fromMillis(t);if(V.isDuration(t))return t;if(\"object\"==typeof t)return V.fromObject(t);throw new o(`Unknown duration argument ${t} of type `+typeof t)}static fromISO(t,e){var[r]=ir(t);return r?V.fromObject(r,e):V.invalid(\"unparsable\",`the input \"${t}\" can't be parsed as ISO 8601`)}static fromISOTime(t,e){var[r]=or(t);return r?V.fromObject(r,e):V.invalid(\"unparsable\",`the input \"${t}\" can't be parsed as ISO 8601`)}static invalid(t,e=null){if(!t)throw new o(\"need to specify a reason the Duration is invalid\");t=t instanceof y?t:new y(t,e);if(k.throwOnInvalid)throw new A(t);return new V({invalid:t})}static normalizeUnit(t){var e={year:\"years\",years:\"years\",quarter:\"quarters\",quarters:\"quarters\",month:\"months\",months:\"months\",week:\"weeks\",weeks:\"weeks\",day:\"days\",days:\"days\",hour:\"hours\",hours:\"hours\",minute:\"minutes\",minutes:\"minutes\",second:\"seconds\",seconds:\"seconds\",millisecond:\"milliseconds\",milliseconds:\"milliseconds\"}[t&&t.toLowerCase()];if(e)return e;throw new _(t)}static isDuration(t){return t&&t.isLuxonDuration||!1}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}toFormat(t,e={}){e={...e,floor:!1!==e.round&&!1!==e.floor};return this.isValid?f.create(this.loc,e).formatDurationFromString(this,t):\"Invalid Duration\"}toHuman(r={}){var t=D.map(t=>{var e=this.values[t];return O(e)?null:this.loc.numberFormatter({style:\"unit\",unitDisplay:\"long\",...r,unit:t.slice(0,-1)}).format(e)}).filter(t=>t);return this.loc.listFormatter({type:\"conjunction\",style:r.listStyle||\"narrow\",...r}).format(t)}toObject(){return this.isValid?{...this.values}:{}}toISO(){if(!this.isValid)return null;let t=\"P\";return 0!==this.years&&(t+=this.years+\"Y\"),0===this.months&&0===this.quarters||(t+=this.months+3*this.quarters+\"M\"),0!==this.weeks&&(t+=this.weeks+\"W\"),0!==this.days&&(t+=this.days+\"D\"),0===this.hours&&0===this.minutes&&0===this.seconds&&0===this.milliseconds||(t+=\"T\"),0!==this.hours&&(t+=this.hours+\"H\"),0!==this.minutes&&(t+=this.minutes+\"M\"),0===this.seconds&&0===this.milliseconds||(t+=yt(this.seconds+this.milliseconds/1e3,3)+\"S\"),\"P\"===t&&(t+=\"T0S\"),t}toISOTime(t={}){if(!this.isValid)return null;var e=this.toMillis();if(e<0||864e5<=e)return null;t={suppressMilliseconds:!1,suppressSeconds:!1,includePrefix:!1,format:\"extended\",...t};const r=this.shiftTo(\"hours\",\"minutes\",\"seconds\",\"milliseconds\");let n=\"basic\"===t.format?\"hhmm\":\"hh:mm\",s=(t.suppressSeconds&&0===r.seconds&&0===r.milliseconds||(n+=\"basic\"===t.format?\"ss\":\":ss\",t.suppressMilliseconds&&0===r.milliseconds||(n+=\".SSS\")),r.toFormat(n));return s=t.includePrefix?\"T\"+s:s}toJSON(){return this.toISO()}toString(){return this.toISO()}toMillis(){return this.as(\"milliseconds\")}valueOf(){return this.toMillis()}plus(t){if(!this.isValid)return this;const e=V.fromDurationLike(t),r={};for(const n of D)(h(e.values,n)||h(this.values,n))&&(r[n]=e.get(n)+this.get(n));return E(this,{values:r},!0)}minus(t){if(!this.isValid)return this;const e=V.fromDurationLike(t);return this.plus(e.negate())}mapUnits(t){if(!this.isValid)return this;const e={};for(const r of Object.keys(this.values))e[r]=kt(t(this.values[r],r));return E(this,{values:e},!0)}get(t){return this[V.normalizeUnit(t)]}set(t){return this.isValid?E(this,{values:{...this.values,...Mt(t,V.normalizeUnit)}}):this}reconfigure({locale:t,numberingSystem:e,conversionAccuracy:r,matrix:n}={}){t=this.loc.clone({locale:t,numberingSystem:e});return E(this,{loc:t,matrix:n,conversionAccuracy:r})}as(t){return this.isValid?this.shiftTo(t).get(t):NaN}normalize(){if(!this.isValid)return this;var t=this.toObject();return vr(this.matrix,t),E(this,{values:t},!0)}shiftTo(...t){if(!this.isValid)return this;if(0===t.length)return this;t=t.map(t=>V.normalizeUnit(t));const e={},r={},n=this.toObject();let s;for(const a of D)if(0<=t.indexOf(a)){s=a;let t=0;for(const o in r)t+=this.matrix[o][a]*r[o],r[o]=0;c(n[a])&&(t+=n[a]);var i=Math.trunc(t);e[a]=i,r[a]=(1e3*t-1e3*i)/1e3;for(const u in n)D.indexOf(u)>D.indexOf(a)&&wr(this.matrix,n,u,e,a)}else c(n[a])&&(r[a]=n[a]);for(const l in r)0!==r[l]&&(e[s]+=l===s?r[l]:r[l]/this.matrix[s][l]);return E(this,{values:e},!0).normalize()}negate(){if(!this.isValid)return this;const t={};for(const e of Object.keys(this.values))t[e]=0===this.values[e]?0:-this.values[e];return E(this,{values:t},!0)}get years(){return this.isValid?this.values.years||0:NaN}get quarters(){return this.isValid?this.values.quarters||0:NaN}get months(){return this.isValid?this.values.months||0:NaN}get weeks(){return this.isValid?this.values.weeks||0:NaN}get days(){return this.isValid?this.values.days||0:NaN}get hours(){return this.isValid?this.values.hours||0:NaN}get minutes(){return this.isValid?this.values.minutes||0:NaN}get seconds(){return this.isValid?this.values.seconds||0:NaN}get milliseconds(){return this.isValid?this.values.milliseconds||0:NaN}get isValid(){return null===this.invalid}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}equals(t){if(!this.isValid||!t.isValid)return!1;if(!this.loc.equals(t.loc))return!1;for(const n of D)if(e=this.values[n],r=t.values[n],!(void 0===e||0===e?void 0===r||0===r:e===r))return!1;var e,r;return!0}}const pr=\"Invalid Interval\";function Tr(t,e){return t&&t.isValid?e&&e.isValid?e<t?x.invalid(\"end before start\",`The end of an interval must be after its start, but you had start=${t.toISO()} and end=`+e.toISO()):null:x.invalid(\"missing or invalid end\"):x.invalid(\"missing or invalid start\")}class x{constructor(t){this.s=t.start,this.e=t.end,this.invalid=t.invalid||null,this.isLuxonInterval=!0}static invalid(t,e=null){if(!t)throw new o(\"need to specify a reason the Interval is invalid\");t=t instanceof y?t:new y(t,e);if(k.throwOnInvalid)throw new q(t);return new x({invalid:t})}static fromDateTimes(t,e){var t=On(t),e=On(e),r=Tr(t,e);return null==r?new x({start:t,end:e}):r}static after(t,e){const r=V.fromDurationLike(e),n=On(t);return x.fromDateTimes(n,n.plus(r))}static before(t,e){const r=V.fromDurationLike(e),n=On(t);return x.fromDateTimes(n.minus(r),n)}static fromISO(t,s){var[i,a]=(t||\"\").split(\"/\",2);if(i&&a){let t,e;try{t=L.fromISO(i,s),e=t.isValid}catch(a){e=!1}let r,n;try{r=L.fromISO(a,s),n=r.isValid}catch(a){n=!1}if(e&&n)return x.fromDateTimes(t,r);if(e){var o=V.fromISO(a,s);if(o.isValid)return x.after(t,o)}else if(n){o=V.fromISO(i,s);if(o.isValid)return x.before(r,o)}}return x.invalid(\"unparsable\",`the input \"${t}\" can't be parsed as ISO 8601`)}static isInterval(t){return t&&t.isLuxonInterval||!1}get start(){return this.isValid?this.s:null}get end(){return this.isValid?this.e:null}get isValid(){return null===this.invalidReason}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}length(t=\"milliseconds\"){return this.isValid?this.toDuration(t).get(t):NaN}count(t=\"milliseconds\"){if(!this.isValid)return NaN;const e=this.start.startOf(t),r=this.end.startOf(t);return Math.floor(r.diff(e,t).get(t))+1}hasSame(t){return!!this.isValid&&(this.isEmpty()||this.e.minus(1).hasSame(this.s,t))}isEmpty(){return this.s.valueOf()===this.e.valueOf()}isAfter(t){return!!this.isValid&&this.s>t}isBefore(t){return!!this.isValid&&this.e<=t}contains(t){return!!this.isValid&&(this.s<=t&&this.e>t)}set({start:t,end:e}={}){return this.isValid?x.fromDateTimes(t||this.s,e||this.e):this}splitAt(...t){if(!this.isValid)return[];const e=t.map(On).filter(t=>this.contains(t)).sort(),r=[];let n=this[\"s\"],s=0;for(;n<this.e;){var i=e[s]||this.e,i=+i>+this.e?this.e:i;r.push(x.fromDateTimes(n,i)),n=i,s+=1}return r}splitBy(t){const e=V.fromDurationLike(t);if(!this.isValid||!e.isValid||0===e.as(\"milliseconds\"))return[];let r=this[\"s\"],n=1,s;const i=[];for(;r<this.e;){var a=this.start.plus(e.mapUnits(t=>t*n));s=+a>+this.e?this.e:a,i.push(x.fromDateTimes(r,s)),r=s,n+=1}return i}divideEqually(t){return this.isValid?this.splitBy(this.length()/t).slice(0,t):[]}overlaps(t){return this.e>t.s&&this.s<t.e}abutsStart(t){return!!this.isValid&&+this.e==+t.s}abutsEnd(t){return!!this.isValid&&+t.e==+this.s}engulfs(t){return!!this.isValid&&(this.s<=t.s&&this.e>=t.e)}equals(t){return!(!this.isValid||!t.isValid)&&(this.s.equals(t.s)&&this.e.equals(t.e))}intersection(t){if(!this.isValid)return this;var e=(this.s>t.s?this:t).s,t=(this.e<t.e?this:t).e;return t<=e?null:x.fromDateTimes(e,t)}union(t){if(!this.isValid)return this;var e=(this.s<t.s?this:t).s,t=(this.e>t.e?this:t).e;return x.fromDateTimes(e,t)}static merge(t){const[e,r]=t.sort((t,e)=>t.s-e.s).reduce(([t,e],r)=>e?e.overlaps(r)||e.abutsStart(r)?[t,e.union(r)]:[t.concat([e]),r]:[t,r],[[],null]);return r&&e.push(r),e}static xor(t){let e=null,r=0;const n=[],s=t.map(t=>[{time:t.s,type:\"s\"},{time:t.e,type:\"e\"}]),i=Array.prototype.concat(...s),a=i.sort((t,e)=>t.time-e.time);for(const o of a)r+=\"s\"===o.type?1:-1,e=1===r?o.time:(e&&+e!=+o.time&&n.push(x.fromDateTimes(e,o.time)),null);return x.merge(n)}difference(...t){return x.xor([this].concat(t)).map(t=>this.intersection(t)).filter(t=>t&&!t.isEmpty())}toString(){return this.isValid?`[${this.s.toISO()} \u2013 ${this.e.toISO()})`:pr}toISO(t){return this.isValid?this.s.toISO(t)+\"/\"+this.e.toISO(t):pr}toISODate(){return this.isValid?this.s.toISODate()+\"/\"+this.e.toISODate():pr}toISOTime(t){return this.isValid?this.s.toISOTime(t)+\"/\"+this.e.toISOTime(t):pr}toFormat(t,{separator:e=\" \u2013 \"}={}){return this.isValid?\"\"+this.s.toFormat(t)+e+this.e.toFormat(t):pr}toDuration(t,e){return this.isValid?this.e.diff(this.s,t,e):V.invalid(this.invalidReason)}mapEndpoints(t){return x.fromDateTimes(t(this.s),t(this.e))}}class Sr{static hasDST(t=k.defaultZone){const e=L.now().setZone(t).set({month:12});return!t.isUniversal&&e.offset!==e.set({month:6}).offset}static isValidIANAZone(t){return w.isValidZone(t)}static normalizeZone(t){return b(t,k.defaultZone)}static months(t=\"long\",{locale:e=null,numberingSystem:r=null,locObj:n=null,outputCalendar:s=\"gregory\"}={}){return(n||M.create(e,r,s)).months(t)}static monthsFormat(t=\"long\",{locale:e=null,numberingSystem:r=null,locObj:n=null,outputCalendar:s=\"gregory\"}={}){return(n||M.create(e,r,s)).months(t,!0)}static weekdays(t=\"long\",{locale:e=null,numberingSystem:r=null,locObj:n=null}={}){return(n||M.create(e,r,null)).weekdays(t)}static weekdaysFormat(t=\"long\",{locale:e=null,numberingSystem:r=null,locObj:n=null}={}){return(n||M.create(e,r,null)).weekdays(t,!0)}static meridiems({locale:t=null}={}){return M.create(t).meridiems()}static eras(t=\"short\",{locale:e=null}={}){return M.create(e,null,\"gregory\").eras(t)}static features(){return{relative:ht()}}}function Or(t,e){var r=t=>t.toUTC(0,{keepLocalTime:!0}).startOf(\"day\").valueOf(),e=r(e)-r(t);return Math.floor(V.fromMillis(e).as(\"days\"))}function br(t,e,r,n){let[s,i,a,o]=function(e,r,t){var n,s;const i={};let a,o;for([n,s]of[[\"years\",(t,e)=>e.year-t.year],[\"quarters\",(t,e)=>e.quarter-t.quarter],[\"months\",(t,e)=>e.month-t.month+12*(e.year-t.year)],[\"weeks\",(t,e)=>{t=Or(t,e);return(t-t%7)/7}],[\"days\",Or]])if(0<=t.indexOf(n)){a=n;let t=s(e,r);(o=e.plus({[n]:t}))>r?(e=e.plus({[n]:t-1}),--t):e=o,i[n]=t}return[e,i,o,a]}(t,e,r);t=e-s,r=r.filter(t=>0<=[\"hours\",\"minutes\",\"seconds\",\"milliseconds\"].indexOf(t)),0===r.length&&(a=a<e?s.plus({[o]:1}):a)!==s&&(i[o]=(i[o]||0)+t/(a-s)),e=V.fromObject(i,n);return 0<r.length?V.fromMillis(t,n).shiftTo(...r).plus(e):e}const kr={arab:\"[\u0660-\u0669]\",arabext:\"[\u06F0-\u06F9]\",bali:\"[\u1B50-\u1B59]\",beng:\"[\u09E6-\u09EF]\",deva:\"[\u0966-\u096F]\",fullwide:\"[\uFF10-\uFF19]\",gujr:\"[\u0AE6-\u0AEF]\",hanidec:\"[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]\",khmr:\"[\u17E0-\u17E9]\",knda:\"[\u0CE6-\u0CEF]\",laoo:\"[\u0ED0-\u0ED9]\",limb:\"[\u1946-\u194F]\",mlym:\"[\u0D66-\u0D6F]\",mong:\"[\u1810-\u1819]\",mymr:\"[\u1040-\u1049]\",orya:\"[\u0B66-\u0B6F]\",tamldec:\"[\u0BE6-\u0BEF]\",telu:\"[\u0C66-\u0C6F]\",thai:\"[\u0E50-\u0E59]\",tibt:\"[\u0F20-\u0F29]\",latn:\"\\\\d\"},Mr={arab:[1632,1641],arabext:[1776,1785],bali:[6992,7001],beng:[2534,2543],deva:[2406,2415],fullwide:[65296,65303],gujr:[2790,2799],khmr:[6112,6121],knda:[3302,3311],laoo:[3792,3801],limb:[6470,6479],mlym:[3430,3439],mong:[6160,6169],mymr:[4160,4169],orya:[2918,2927],tamldec:[3046,3055],telu:[3174,3183],thai:[3664,3673],tibt:[3872,3881]},Nr=kr.hanidec.replace(/[\\[|\\]]/g,\"\").split(\"\");function I({numberingSystem:t},e=\"\"){return new RegExp(\"\"+kr[t||\"latn\"]+e)}const Dr=\"missing Intl.DateTimeFormat.formatToParts support\";function C(t,e=t=>t){return{regex:t,deser:([t])=>e(function(e){let r=parseInt(e,10);if(isNaN(r)){r=\"\";for(let t=0;t<e.length;t++){var n=e.charCodeAt(t);if(-1!==e[t].search(kr.hanidec))r+=Nr.indexOf(e[t]);else for(const a in Mr){var[s,i]=Mr[a];s<=n&&n<=i&&(r+=n-s)}}return parseInt(r,10)}return r}(t))}}const Er=`[ ${String.fromCharCode(160)}]`,Vr=new RegExp(Er,\"g\");function xr(t){return t.replace(/\\./g,\"\\\\.?\").replace(Vr,Er)}function Ir(t){return t.replace(/\\./g,\"\").replace(Vr,\" \").toLowerCase()}function F(t,r){return null===t?null:{regex:RegExp(t.map(xr).join(\"|\")),deser:([e])=>t.findIndex(t=>Ir(e)===Ir(t))+r}}function Cr(t,e){return{regex:t,deser:([,t,e])=>bt(t,e),groups:e}}function Fr(t){return{regex:t,deser:([t])=>t}}const Zr={year:{\"2-digit\":\"yy\",numeric:\"yyyyy\"},month:{numeric:\"M\",\"2-digit\":\"MM\",short:\"MMM\",long:\"MMMM\"},day:{numeric:\"d\",\"2-digit\":\"dd\"},weekday:{short:\"EEE\",long:\"EEEE\"},dayperiod:\"a\",dayPeriod:\"a\",hour:{numeric:\"h\",\"2-digit\":\"hh\"},minute:{numeric:\"m\",\"2-digit\":\"mm\"},second:{numeric:\"s\",\"2-digit\":\"ss\"},timeZoneName:{long:\"ZZZZZ\",short:\"ZZZ\"}};let Lr=null;function zr(t,n){return Array.prototype.concat(...t.map(t=>{{var e=n;if(t.literal)return t;const r=jr(f.macroTokenToFormatOpts(t.val),e);return null==r||r.includes(void 0)?t:r}}))}function qr(g,t,e){const r=zr(f.parseFormat(e),g),n=r.map(t=>{{var e=t,r=g;const n=I(r),s=I(r,\"{2}\"),i=I(r,\"{3}\"),a=I(r,\"{4}\"),o=I(r,\"{6}\"),u=I(r,\"{1,2}\"),l=I(r,\"{1,3}\"),c=I(r,\"{1,6}\"),h=I(r,\"{1,9}\"),d=I(r,\"{2,4}\"),m=I(r,\"{4,6}\"),f=t=>({regex:RegExp(t.val.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g,\"\\\\$&\")),deser:([t])=>t,literal:!0}),y=(t=>{if(e.literal)return f(t);switch(t.val){case\"G\":return F(r.eras(\"short\",!1),0);case\"GG\":return F(r.eras(\"long\",!1),0);case\"y\":return C(c);case\"yy\":return C(d,St);case\"yyyy\":return C(a);case\"yyyyy\":return C(m);case\"yyyyyy\":return C(o);case\"M\":return C(u);case\"MM\":return C(s);case\"MMM\":return F(r.months(\"short\",!0,!1),1);case\"MMMM\":return F(r.months(\"long\",!0,!1),1);case\"L\":return C(u);case\"LL\":return C(s);case\"LLL\":return F(r.months(\"short\",!1,!1),1);case\"LLLL\":return F(r.months(\"long\",!1,!1),1);case\"d\":return C(u);case\"dd\":return C(s);case\"o\":return C(l);case\"ooo\":return C(i);case\"HH\":return C(s);case\"H\":return C(u);case\"hh\":return C(s);case\"h\":return C(u);case\"mm\":return C(s);case\"m\":case\"q\":return C(u);case\"qq\":return C(s);case\"s\":return C(u);case\"ss\":return C(s);case\"S\":return C(l);case\"SSS\":return C(i);case\"u\":return Fr(h);case\"uu\":return Fr(u);case\"uuu\":return C(n);case\"a\":return F(r.meridiems(),0);case\"kkkk\":return C(a);case\"kk\":return C(d,St);case\"W\":return C(u);case\"WW\":return C(s);case\"E\":case\"c\":return C(n);case\"EEE\":return F(r.weekdays(\"short\",!1,!1),1);case\"EEEE\":return F(r.weekdays(\"long\",!1,!1),1);case\"ccc\":return F(r.weekdays(\"short\",!0,!1),1);case\"cccc\":return F(r.weekdays(\"long\",!0,!1),1);case\"Z\":case\"ZZ\":return Cr(new RegExp(`([+-]${u.source})(?::(${s.source}))?`),2);case\"ZZZ\":return Cr(new RegExp(`([+-]${u.source})(${s.source})?`),2);case\"z\":return Fr(/[a-z_+-/]{1,256}?/i);default:return f(t)}})(e)||{invalidReason:Dr};return y.token=e,y}}),s=n.find(t=>t.invalidReason);if(s)return{input:t,tokens:r,invalidReason:s.invalidReason};var[e,i]=[`^${(e=n).map(t=>t.regex).reduce((t,e)=>`${t}(${e.source})`,\"\")}$`,e],e=RegExp(e,\"i\"),[i,a]=function(t,e,r){const n=t.match(e);if(n){const s={};let t=1;for(const i in r)if(h(r,i)){const a=r[i],o=a.groups?a.groups+1:1;!a.literal&&a.token&&(s[a.token.val[0]]=a.deser(n.slice(t,t+o))),t+=o}return[n,s]}return[n,{}]}(t,e,i),[o,u,l]=a?function(n){let t=null,e;return O(n.z)||(t=w.create(n.z)),O(n.Z)||(t=t||new v(n.Z),e=n.Z),O(n.q)||(n.M=3*(n.q-1)+1),O(n.h)||(n.h<12&&1===n.a?n.h+=12:12===n.h&&0===n.a&&(n.h=0)),0===n.G&&n.y&&(n.y=-n.y),O(n.u)||(n.S=ft(n.u)),[Object.keys(n).reduce((t,e)=>{var r=(t=>{switch(t){case\"S\":return\"millisecond\";case\"s\":return\"second\";case\"m\":return\"minute\";case\"h\":case\"H\":return\"hour\";case\"d\":return\"day\";case\"o\":return\"ordinal\";case\"L\":case\"M\":return\"month\";case\"y\":return\"year\";case\"E\":case\"c\":return\"weekday\";case\"W\":return\"weekNumber\";case\"k\":return\"weekYear\";case\"q\":return\"quarter\";default:return null}})(e);return r&&(t[r]=n[e]),t},{}),t,e]}(a):[null,null,void 0];if(h(a,\"a\")&&h(a,\"H\"))throw new j(\"Can't include meridiem when specifying 24-hour format\");return{input:t,tokens:r,regex:e,rawMatches:i,matches:a,result:o,zone:u,specificOffset:l}}function Ar(t,e,r){var{result:t,zone:e,specificOffset:r,invalidReason:n}=qr(t,e,r);return[t,e,r,n]}function jr(s,t){if(!s)return null;const e=f.create(t,s),r=e.formatDateTimeParts(Lr=Lr||L.fromMillis(1555555555555));return r.map(e=>{{var r=s,{type:e,value:n}=e;if(\"literal\"===e)return{literal:!0,val:n};n=r[e];let t=Zr[e];return(t=\"object\"==typeof t?t[n]:t)?{literal:!1,val:t}:void 0}})}const _r=[0,31,59,90,120,151,181,212,243,273,304,334],Ur=[0,31,60,91,121,152,182,213,244,274,305,335];function Z(t,e){return new y(\"unit out of range\",`you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`)}function $r(t,e,r){const n=new Date(Date.UTC(t,e-1,r));t<100&&0<=t&&n.setUTCFullYear(n.getUTCFullYear()-1900);e=n.getUTCDay();return 0===e?7:e}function Hr(t,e,r){return r+(gt(t)?Ur:_r)[e-1]}function Wr(t,e){const r=gt(t)?Ur:_r,n=r.findIndex(t=>t<e),s=e-r[n];return{month:n+1,day:s}}function Rr(t){var{year:e,month:r,day:n}=t,s=Hr(e,r,n),r=$r(e,r,n);let i=Math.floor((s-r+10)/7),a;return i<1?(a=e-1,i=Tt(a)):i>Tt(e)?(a=e+1,i=1):a=e,{weekYear:a,weekNumber:i,weekday:r,...Dt(t)}}function Jr(t){var{weekYear:e,weekNumber:r,weekday:n}=t,s=$r(e,1,4),i=wt(e);let a=7*r+n-s-3,o;a<1?(o=e-1,a+=wt(o)):a>i?(o=e+1,a-=wt(e)):o=e;var{month:r,day:n}=Wr(o,a);return{year:o,month:r,day:n,...Dt(t)}}function Yr(t){var{year:e,month:r,day:n}=t;return{year:e,ordinal:Hr(e,r,n),...Dt(t)}}function Pr(t){var{year:e,ordinal:r}=t,{month:r,day:n}=Wr(e,r);return{year:e,month:r,day:n,...Dt(t)}}function Gr(t){var e=lt(t.weekYear),r=u(t.weekNumber,1,Tt(t.weekYear)),n=u(t.weekday,1,7);return e?r?!n&&Z(\"weekday\",t.weekday):Z(\"week\",t.week):Z(\"weekYear\",t.weekYear)}function Br(t){var e=lt(t.year),r=u(t.ordinal,1,wt(t.year));return e?!r&&Z(\"ordinal\",t.ordinal):Z(\"year\",t.year)}function Qr(t){var e=lt(t.year),r=u(t.month,1,12),n=u(t.day,1,vt(t.year,t.month));return e?r?!n&&Z(\"day\",t.day):Z(\"month\",t.month):Z(\"year\",t.year)}function Kr(t){var{hour:t,minute:e,second:r,millisecond:n}=t,s=u(t,0,23)||24===t&&0===e&&0===r&&0===n,i=u(e,0,59),a=u(r,0,59),o=u(n,0,999);return s?i?a?!o&&Z(\"millisecond\",n):Z(\"second\",r):Z(\"minute\",e):Z(\"hour\",t)}const Xr=\"Invalid DateTime\";function tn(t){return new y(\"unsupported zone\",`the zone \"${t.name}\" is not supported`)}function en(t){return null===t.weekData&&(t.weekData=Rr(t.c)),t.weekData}function rn(t,e){t={ts:t.ts,zone:t.zone,c:t.c,o:t.o,loc:t.loc,invalid:t.invalid};return new L({...t,...e,old:t})}function nn(t,e,r){let n=t-60*e*1e3;var s=r.offset(n);if(e===s)return[n,e];n-=60*(s-e)*1e3;e=r.offset(n);return s===e?[n,s]:[t-60*Math.min(s,e)*1e3,Math.max(s,e)]}function sn(t,e){t+=60*e*1e3;const r=new Date(t);return{year:r.getUTCFullYear(),month:r.getUTCMonth()+1,day:r.getUTCDate(),hour:r.getUTCHours(),minute:r.getUTCMinutes(),second:r.getUTCSeconds(),millisecond:r.getUTCMilliseconds()}}function an(t,e,r){return nn(pt(t),e,r)}function on(t,e){var r=t.o,n=t.c.year+Math.trunc(e.years),s=t.c.month+Math.trunc(e.months)+3*Math.trunc(e.quarters),n={...t.c,year:n,month:s,day:Math.min(t.c.day,vt(n,s))+Math.trunc(e.days)+7*Math.trunc(e.weeks)},s=V.fromObject({years:e.years-Math.trunc(e.years),quarters:e.quarters-Math.trunc(e.quarters),months:e.months-Math.trunc(e.months),weeks:e.weeks-Math.trunc(e.weeks),days:e.days-Math.trunc(e.days),hours:e.hours,minutes:e.minutes,seconds:e.seconds,milliseconds:e.milliseconds}).as(\"milliseconds\");let[i,a]=nn(pt(n),r,t.zone);return 0!==s&&(i+=s,a=t.zone.offset(i)),{ts:i,o:a}}function un(t,e,r,n,s,i){var{setZone:a,zone:o}=r;if(t&&0!==Object.keys(t).length){const u=e||o,l=L.fromObject(t,{...r,zone:u,specificOffset:i});return a?l:l.setZone(o)}return L.invalid(new y(\"unparsable\",`the input \"${s}\" can't be parsed as `+n))}function ln(t,e,r=!0){return t.isValid?f.create(M.create(\"en-US\"),{allowZ:r,forceSimple:!0}).formatDateTimeFromString(t,e):null}function cn(t,e){var r=9999<t.c.year||t.c.year<0;let n=\"\";return r&&0<=t.c.year&&(n+=\"+\"),n+=l(t.c.year,r?6:4),n=e?(n=(n+=\"-\")+l(t.c.month)+\"-\")+l(t.c.day):(n+=l(t.c.month))+l(t.c.day)}function hn(t,e,r,n,s,i){let a=l(t.c.hour);return e?(a=(a+=\":\")+l(t.c.minute),0===t.c.second&&r||(a+=\":\")):a+=l(t.c.minute),0===t.c.second&&r||(a+=l(t.c.second),0===t.c.millisecond&&n||(a=(a+=\".\")+l(t.c.millisecond,3))),s&&(t.isOffsetFixed&&0===t.offset&&!i?a+=\"Z\":a=t.o<0?(a=(a+=\"-\")+l(Math.trunc(-t.o/60))+\":\")+l(Math.trunc(-t.o%60)):(a=(a+=\"+\")+l(Math.trunc(t.o/60))+\":\")+l(Math.trunc(t.o%60))),i&&(a+=\"[\"+t.zone.ianaName+\"]\"),a}const dn={month:1,day:1,hour:0,minute:0,second:0,millisecond:0},mn={weekNumber:1,weekday:1,hour:0,minute:0,second:0,millisecond:0},fn={ordinal:1,hour:0,minute:0,second:0,millisecond:0},yn=[\"year\",\"month\",\"day\",\"hour\",\"minute\",\"second\",\"millisecond\"],gn=[\"weekYear\",\"weekNumber\",\"weekday\",\"hour\",\"minute\",\"second\",\"millisecond\"],wn=[\"year\",\"ordinal\",\"hour\",\"minute\",\"second\",\"millisecond\"];function vn(t){var e={year:\"year\",years:\"year\",month:\"month\",months:\"month\",day:\"day\",days:\"day\",hour:\"hour\",hours:\"hour\",minute:\"minute\",minutes:\"minute\",quarter:\"quarter\",quarters:\"quarter\",second:\"second\",seconds:\"second\",millisecond:\"millisecond\",milliseconds:\"millisecond\",weekday:\"weekday\",weekdays:\"weekday\",weeknumber:\"weekNumber\",weeksnumber:\"weekNumber\",weeknumbers:\"weekNumber\",weekyear:\"weekYear\",weekyears:\"weekYear\",ordinal:\"ordinal\"}[t.toLowerCase()];if(e)return e;throw new _(t)}function pn(t,e){const r=b(e.zone,k.defaultZone),n=M.fromObject(e),s=k.now();let i,a;if(O(t.year))i=s;else{for(const o of yn)O(t[o])&&(t[o]=dn[o]);e=Qr(t)||Kr(t);if(e)return L.invalid(e);e=r.offset(s);[i,a]=an(t,e,r)}return new L({ts:i,zone:r,loc:n,o:a})}function Tn(e,n,s){const i=!!O(s.round)||s.round,t=(t,e)=>{t=yt(t,i||s.calendary?0:2,!0);const r=n.loc.clone(s).relFormatter(s);return r.format(t,e)},r=t=>s.calendary?n.hasSame(e,t)?0:n.startOf(t).diff(e.startOf(t),t).get(t):n.diff(e,t).get(t);if(s.unit)return t(r(s.unit),s.unit);for(const o of s.units){var a=r(o);if(1<=Math.abs(a))return t(a,o)}return t(n<e?-0:0,s.units[s.units.length-1])}function Sn(t){let e={},r;return r=0<t.length&&\"object\"==typeof t[t.length-1]?(e=t[t.length-1],Array.from(t).slice(0,t.length-1)):Array.from(t),[e,r]}class L{constructor(t){const e=t.zone||k.defaultZone;let r=t.invalid||(Number.isNaN(t.ts)?new y(\"invalid input\"):null)||(e.isValid?null:tn(e)),n=(this.ts=O(t.ts)?k.now():t.ts,null),s=null;var i;r||(t.old&&t.old.ts===this.ts&&t.old.zone.equals(e)?[n,s]=[t.old.c,t.old.o]:(i=e.offset(this.ts),n=sn(this.ts,i),r=Number.isNaN(n.year)?new y(\"invalid input\"):null,n=r?null:n,s=r?null:i)),this._zone=e,this.loc=t.loc||M.create(),this.invalid=r,this.weekData=null,this.c=n,this.o=s,this.isLuxonDateTime=!0}static now(){return new L({})}static local(){var[t,e]=Sn(arguments),[e,r,n,s,i,a,o]=e;return pn({year:e,month:r,day:n,hour:s,minute:i,second:a,millisecond:o},t)}static utc(){const[t,e]=Sn(arguments),[r,n,s,i,a,o,u]=e;return t.zone=v.utcInstance,pn({year:r,month:n,day:s,hour:i,minute:a,second:o,millisecond:u},t)}static fromJSDate(t,e={}){t=ct(t)?t.valueOf():NaN;if(Number.isNaN(t))return L.invalid(\"invalid input\");var r=b(e.zone,k.defaultZone);return r.isValid?new L({ts:t,zone:r,loc:M.fromObject(e)}):L.invalid(tn(r))}static fromMillis(t,e={}){if(c(t))return t<-864e13||864e13<t?L.invalid(\"Timestamp out of range\"):new L({ts:t,zone:b(e.zone,k.defaultZone),loc:M.fromObject(e)});throw new o(`fromMillis requires a numerical input, but received a ${typeof t} with value `+t)}static fromSeconds(t,e={}){if(c(t))return new L({ts:1e3*t,zone:b(e.zone,k.defaultZone),loc:M.fromObject(e)});throw new o(\"fromSeconds requires a numerical input\")}static fromObject(t,e={}){t=t||{};const r=b(e.zone,k.defaultZone);if(!r.isValid)return L.invalid(tn(r));const n=k.now(),s=O(e.specificOffset)?r.offset(n):e.specificOffset,i=Mt(t,vn),a=!O(i.ordinal),o=!O(i.year),u=!O(i.month)||!O(i.day),l=o||u,c=i.weekYear||i.weekNumber,h=M.fromObject(e);if((l||a)&&c)throw new j(\"Can't mix weekYear/weekNumber units with year/month/day or ordinals\");if(u&&a)throw new j(\"Can't mix ordinal dates with month/day\");e=c||i.weekday&&!l;let d,m,f=sn(n,s),y=(e?(d=gn,m=mn,f=Rr(f)):a?(d=wn,m=fn,f=Yr(f)):(d=yn,m=dn),!1);for(const S of d)O(i[S])?y?i[S]=m[S]:i[S]=f[S]:y=!0;var g=(e?Gr:a?Br:Qr)(i)||Kr(i);if(g)return L.invalid(g);const w=e?Jr(i):a?Pr(i):i,[v,p]=an(w,s,r),T=new L({ts:v,zone:r,o:p,loc:h});return i.weekday&&l&&t.weekday!==T.weekday?L.invalid(\"mismatched weekday\",`you can't specify both a weekday of ${i.weekday} and a date of `+T.toISO()):T}static fromISO(t,e={}){var[r,n]=rr(t);return un(r,n,e,\"ISO 8601\",t)}static fromRFC2822(t,e={}){var[r,n]=nr(t);return un(r,n,e,\"RFC 2822\",t)}static fromHTTP(t,e={}){var[t,r]=sr(t);return un(t,r,e,\"HTTP\",e)}static fromFormat(t,e,r={}){if(O(t)||O(e))throw new o(\"fromFormat requires an input string and a format\");var{locale:n=null,numberingSystem:s=null}=r,[n,s,i,a]=Ar(M.fromOpts({locale:n,numberingSystem:s,defaultToEN:!0}),t,e);return a?L.invalid(a):un(n,s,r,\"format \"+e,t,i)}static fromString(t,e,r={}){return L.fromFormat(t,e,r)}static fromSQL(t,e={}){var[r,n]=hr(t);return un(r,n,e,\"SQL\",t)}static invalid(t,e=null){if(!t)throw new o(\"need to specify a reason the DateTime is invalid\");t=t instanceof y?t:new y(t,e);if(k.throwOnInvalid)throw new z(t);return new L({invalid:t})}static isDateTime(t){return t&&t.isLuxonDateTime||!1}static parseFormatForOpts(t,e={}){const r=jr(t,M.fromObject(e));return r?r.map(t=>t?t.val:null).join(\"\"):null}static expandFormat(t,e={}){const r=zr(f.parseFormat(t),M.fromObject(e));return r.map(t=>t.val).join(\"\")}get(t){return this[t]}get isValid(){return null===this.invalid}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}get outputCalendar(){return this.isValid?this.loc.outputCalendar:null}get zone(){return this._zone}get zoneName(){return this.isValid?this.zone.name:null}get year(){return this.isValid?this.c.year:NaN}get quarter(){return this.isValid?Math.ceil(this.c.month/3):NaN}get month(){return this.isValid?this.c.month:NaN}get day(){return this.isValid?this.c.day:NaN}get hour(){return this.isValid?this.c.hour:NaN}get minute(){return this.isValid?this.c.minute:NaN}get second(){return this.isValid?this.c.second:NaN}get millisecond(){return this.isValid?this.c.millisecond:NaN}get weekYear(){return this.isValid?en(this).weekYear:NaN}get weekNumber(){return this.isValid?en(this).weekNumber:NaN}get weekday(){return this.isValid?en(this).weekday:NaN}get ordinal(){return this.isValid?Yr(this.c).ordinal:NaN}get monthShort(){return this.isValid?Sr.months(\"short\",{locObj:this.loc})[this.month-1]:null}get monthLong(){return this.isValid?Sr.months(\"long\",{locObj:this.loc})[this.month-1]:null}get weekdayShort(){return this.isValid?Sr.weekdays(\"short\",{locObj:this.loc})[this.weekday-1]:null}get weekdayLong(){return this.isValid?Sr.weekdays(\"long\",{locObj:this.loc})[this.weekday-1]:null}get offset(){return this.isValid?+this.o:NaN}get offsetNameShort(){return this.isValid?this.zone.offsetName(this.ts,{format:\"short\",locale:this.locale}):null}get offsetNameLong(){return this.isValid?this.zone.offsetName(this.ts,{format:\"long\",locale:this.locale}):null}get isOffsetFixed(){return this.isValid?this.zone.isUniversal:null}get isInDST(){return!this.isOffsetFixed&&(this.offset>this.set({month:1,day:1}).offset||this.offset>this.set({month:5}).offset)}get isInLeapYear(){return gt(this.year)}get daysInMonth(){return vt(this.year,this.month)}get daysInYear(){return this.isValid?wt(this.year):NaN}get weeksInWeekYear(){return this.isValid?Tt(this.weekYear):NaN}resolvedLocaleOptions(t={}){var{locale:t,numberingSystem:e,calendar:r}=f.create(this.loc.clone(t),t).resolvedOptions(this);return{locale:t,numberingSystem:e,outputCalendar:r}}toUTC(t=0,e={}){return this.setZone(v.instance(t),e)}toLocal(){return this.setZone(k.defaultZone)}setZone(e,{keepLocalTime:r=!1,keepCalendarTime:n=!1}={}){if((e=b(e,k.defaultZone)).equals(this.zone))return this;if(e.isValid){let t=this.ts;return(r||n)&&(r=e.offset(this.ts),n=this.toObject(),[t]=an(n,r,e)),rn(this,{ts:t,zone:e})}return L.invalid(tn(e))}reconfigure({locale:t,numberingSystem:e,outputCalendar:r}={}){t=this.loc.clone({locale:t,numberingSystem:e,outputCalendar:r});return rn(this,{loc:t})}setLocale(t){return this.reconfigure({locale:t})}set(t){if(!this.isValid)return this;var t=Mt(t,vn),e=!O(t.weekYear)||!O(t.weekNumber)||!O(t.weekday),r=!O(t.ordinal),n=!O(t.year),s=!O(t.month)||!O(t.day),i=t.weekYear||t.weekNumber;if((n||s||r)&&i)throw new j(\"Can't mix weekYear/weekNumber units with year/month/day or ordinals\");if(s&&r)throw new j(\"Can't mix ordinal dates with month/day\");let a;e?a=Jr({...Rr(this.c),...t}):O(t.ordinal)?(a={...this.toObject(),...t},O(t.day)&&(a.day=Math.min(vt(a.year,a.month),a.day))):a=Pr({...Yr(this.c),...t});var[n,i]=an(a,this.o,this.zone);return rn(this,{ts:n,o:i})}plus(t){return this.isValid?rn(this,on(this,V.fromDurationLike(t))):this}minus(t){return this.isValid?rn(this,on(this,V.fromDurationLike(t).negate())):this}startOf(t){if(!this.isValid)return this;const e={},r=V.normalizeUnit(t);switch(r){case\"years\":e.month=1;case\"quarters\":case\"months\":e.day=1;case\"weeks\":case\"days\":e.hour=0;case\"hours\":e.minute=0;case\"minutes\":e.second=0;case\"seconds\":e.millisecond=0}return\"weeks\"===r&&(e.weekday=1),\"quarters\"===r&&(t=Math.ceil(this.month/3),e.month=3*(t-1)+1),this.set(e)}endOf(t){return this.isValid?this.plus({[t]:1}).startOf(t).minus(1):this}toFormat(t,e={}){return this.isValid?f.create(this.loc.redefaultToEN(e)).formatDateTimeFromString(this,t):Xr}toLocaleString(t=U,e={}){return this.isValid?f.create(this.loc.clone(e),t).formatDateTime(this):Xr}toLocaleParts(t={}){return this.isValid?f.create(this.loc.clone(t),t).formatDateTimeParts(this):[]}toISO({format:t=\"extended\",suppressSeconds:e=!1,suppressMilliseconds:r=!1,includeOffset:n=!0,extendedZone:s=!1}={}){if(!this.isValid)return null;var t=\"extended\"===t,i=cn(this,t);return(i+=\"T\")+hn(this,t,e,r,n,s)}toISODate({format:t=\"extended\"}={}){return this.isValid?cn(this,\"extended\"===t):null}toISOWeekDate(){return ln(this,\"kkkk-'W'WW-c\")}toISOTime({suppressMilliseconds:t=!1,suppressSeconds:e=!1,includeOffset:r=!0,includePrefix:n=!1,extendedZone:s=!1,format:i=\"extended\"}={}){return this.isValid?(n?\"T\":\"\")+hn(this,\"extended\"===i,e,t,r,s):null}toRFC2822(){return ln(this,\"EEE, dd LLL yyyy HH:mm:ss ZZZ\",!1)}toHTTP(){return ln(this.toUTC(),\"EEE, dd LLL yyyy HH:mm:ss 'GMT'\")}toSQLDate(){return this.isValid?cn(this,!0):null}toSQLTime({includeOffset:t=!0,includeZone:e=!1,includeOffsetSpace:r=!0}={}){let n=\"HH:mm:ss.SSS\";return(e||t)&&(r&&(n+=\" \"),e?n+=\"z\":t&&(n+=\"ZZ\")),ln(this,n,!0)}toSQL(t={}){return this.isValid?this.toSQLDate()+\" \"+this.toSQLTime(t):null}toString(){return this.isValid?this.toISO():Xr}valueOf(){return this.toMillis()}toMillis(){return this.isValid?this.ts:NaN}toSeconds(){return this.isValid?this.ts/1e3:NaN}toUnixInteger(){return this.isValid?Math.floor(this.ts/1e3):NaN}toJSON(){return this.toISO()}toBSON(){return this.toJSDate()}toObject(t={}){if(!this.isValid)return{};const e={...this.c};return t.includeConfig&&(e.outputCalendar=this.outputCalendar,e.numberingSystem=this.loc.numberingSystem,e.locale=this.loc.locale),e}toJSDate(){return new Date(this.isValid?this.ts:NaN)}diff(t,e=\"milliseconds\",r={}){if(!this.isValid||!t.isValid)return V.invalid(\"created by diffing an invalid DateTime\");r={locale:this.locale,numberingSystem:this.numberingSystem,...r};const n=dt(e).map(V.normalizeUnit),s=t.valueOf()>this.valueOf(),i=s?this:t,a=s?t:this,o=br(i,a,n,r);return s?o.negate():o}diffNow(t=\"milliseconds\",e={}){return this.diff(L.now(),t,e)}until(t){return this.isValid?x.fromDateTimes(this,t):this}hasSame(t,e){if(!this.isValid)return!1;var r=t.valueOf();const n=this.setZone(t.zone,{keepLocalTime:!0});return n.startOf(e)<=r&&r<=n.endOf(e)}equals(t){return this.isValid&&t.isValid&&this.valueOf()===t.valueOf()&&this.zone.equals(t.zone)&&this.loc.equals(t.loc)}toRelative(t={}){if(!this.isValid)return null;var e=t.base||L.fromObject({},{zone:this.zone}),r=t.padding?this<e?-t.padding:t.padding:0;let n=[\"years\",\"months\",\"days\",\"hours\",\"minutes\",\"seconds\"],s=t.unit;return Array.isArray(t.unit)&&(n=t.unit,s=void 0),Tn(e,this.plus(r),{...t,numeric:\"always\",units:n,unit:s})}toRelativeCalendar(t={}){return this.isValid?Tn(t.base||L.fromObject({},{zone:this.zone}),this,{...t,numeric:\"auto\",units:[\"years\",\"months\",\"days\"],calendary:!0}):null}static min(...t){if(t.every(L.isDateTime))return mt(t,t=>t.valueOf(),Math.min);throw new o(\"min requires all arguments be DateTimes\")}static max(...t){if(t.every(L.isDateTime))return mt(t,t=>t.valueOf(),Math.max);throw new o(\"max requires all arguments be DateTimes\")}static fromFormatExplain(t,e,r={}){var{locale:r=null,numberingSystem:n=null}=r;return qr(M.fromOpts({locale:r,numberingSystem:n,defaultToEN:!0}),t,e)}static fromStringExplain(t,e,r={}){return L.fromFormatExplain(t,e,r)}static get DATE_SHORT(){return U}static get DATE_MED(){return $}static get DATE_MED_WITH_WEEKDAY(){return H}static get DATE_FULL(){return W}static get DATE_HUGE(){return R}static get TIME_SIMPLE(){return J}static get TIME_WITH_SECONDS(){return Y}static get TIME_WITH_SHORT_OFFSET(){return P}static get TIME_WITH_LONG_OFFSET(){return G}static get TIME_24_SIMPLE(){return B}static get TIME_24_WITH_SECONDS(){return Q}static get TIME_24_WITH_SHORT_OFFSET(){return K}static get TIME_24_WITH_LONG_OFFSET(){return X}static get DATETIME_SHORT(){return tt}static get DATETIME_SHORT_WITH_SECONDS(){return et}static get DATETIME_MED(){return rt}static get DATETIME_MED_WITH_SECONDS(){return nt}static get DATETIME_MED_WITH_WEEKDAY(){return st}static get DATETIME_FULL(){return it}static get DATETIME_FULL_WITH_SECONDS(){return at}static get DATETIME_HUGE(){return ot}static get DATETIME_HUGE_WITH_SECONDS(){return ut}}function On(t){if(L.isDateTime(t))return t;if(t&&t.valueOf&&c(t.valueOf()))return L.fromJSDate(t);if(t&&\"object\"==typeof t)return L.fromObject(t);throw new o(`Unknown datetime argument: ${t}, of type `+typeof t)}s=\"3.0.3\";export{L as DateTime,V as Duration,v as FixedOffsetZone,w as IANAZone,Sr as Info,x as Interval,ne as InvalidZone,k as Settings,Gt as SystemZone,s as VERSION,i as Zone};", "// eslint-disable-next-line no-restricted-imports\nimport { DateTime } from '../deps/luxon.js'\n\nexport const sleep = ms => new Promise(resolve => setTimeout(resolve, ms))\n// min, max are inclusive\nexport const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1) + min)\nexport const sleepRandom = () => {\n  const ms = randomInt(500, 1500)\n  return sleep(ms)\n}\n\nexport function escapeId (baseString, doc) {\n  let result = ''\n  let char = ''\n  let validTest\n  if (doc) {\n    validTest = RegExp(/[a-zA-Z0-9_$<>=\\-.!']/)\n  } else {\n    validTest = RegExp(/[a-z0-9_$+-]/)\n  }\n  for (let i = 0; i < baseString.length; i++) {\n    char = baseString.charAt(i)\n    if (!validTest.test(char)) {\n      result += '(' + char.codePointAt() + ')'\n    } else {\n      result += char\n    }\n  }\n  return result\n}\n\nexport function formatBytes (bytes, pad) {\n  if (!bytes && bytes !== 0) {\n    return ''\n  }\n  const units = [ 'B', 'KB', 'MB', 'GB', 'TB', 'PT' ]\n  let dim = 0\n  let n = parseInt(bytes, 10) || 0\n\n  while (n >= 1024 && ++dim) {\n    n = n / 1024\n  }\n  const number = n.toFixed(n < 10 && dim > 0 ? 1 : 0)\n  return (pad ? number.padEnd(pad, ' ') : (number + ' ')) + units[dim]\n}\n\nexport function fromNow (timestamp) {\n  return DateTime.fromMillis(timestamp).toRelative()\n}\n\nexport function formatTime (timestamp) {\n  return DateTime.fromMillis(timestamp).toFormat('HH:mm, dd.MM.y')\n}\n\nexport function getFlagEmoji (countryCode) {\n  const codePoints = countryCode\n    .toUpperCase()\n    .split('')\n    .map(char => 127397 + char.charCodeAt())\n  return String.fromCodePoint(...codePoints)\n}\n", "// import log from './log.js'\nimport { sleepRandom } from './helpers.js'\n\n// TODO: handle logout detection and service worker integration!!!\n// TODO: integrate base features with edge/lib/req.js\n\nconst cacheMap = new Map()\n// TODO: copy this dedupe logic to falcor req dedupe too\nconst pendingMap = new Map()\n\nexport default async function req (urlArg, {\n  method,\n  body,\n  cache,\n  cacheKey,\n  params: paramsArg,\n  headers: headersArg = {},\n  raw: rawArg,\n  retry = false,\n  redirect = 'manual',\n  fetch: customFetch = fetch\n} = {}) {\n  // TODO: ttl\n  // const { waitUntil, event } = getWait()\n  if (!method) {\n    method = body ? 'POST' : 'GET'\n  }\n\n  paramsArg && Object.entries(paramsArg).forEach(([key, value]) => {\n    if (value=== undefined) {\n      delete paramsArg[key]\n    }\n  })\n\n  const params = paramsArg && new URLSearchParams(paramsArg)\n\n  const url = params ? urlArg + `?${params}` : urlArg\n\n  const headers = new Headers(headersArg)\n\n  if (body && !headers.get('content-type')) {\n    headers.set('content-type', 'application/json')\n  }\n\n  headers.set('X-Requested-With', 'XMLHttpRequest')\n\n  if (body && headers.get('content-type').includes('application/json')) {\n    body = JSON.stringify(body)\n  }\n\n  let res\n  let kvs\n  if (cache) {\n    if (!cacheKey) {\n      cacheKey = url\n    }\n\n    if (pendingMap.has(cacheKey)) {\n      await pendingMap.get(cacheKey)\n    }\n\n    if (cacheMap.has(cacheKey)) {\n      const  {body: cachedBod, headers: cachedHead } = cacheMap.get(url)\n      cachedHead['cache-status'] = `edge-kv; hit`\n      res = new Response(cachedBod, { headers: cachedHead, ok: true, statusText: 'OK', status: 200, redirected: false })\n    }\n\n    // ${kvRes.metadata.expiration ? '; ttl=' + (kvRes.metadata.expiration - Math.floor(Date.now() / 1000)) : ''}\n    //   kvs = getKvStore(cache)\n    //   // TODO: streams are faster for non binaries\n    //   const kvRes = await kvs.getWithMetadata(cacheKey, { type: 'arrayBuffer', cacheTtl: 604800 }) //  1 week, TODO ttl for other?\n    //   if (kvRes?.value) {\n    //     res = new Response(kvRes.value, kvRes.metadata)\n    //   }\n  }\n\n  let retried\n  const reqStart = Date.now()\n  let finishLoad = null\n  const wasCached = !!res\n  if (!wasCached) {\n    const loadPromise = new Promise(resolve => { finishLoad = resolve })\n    pendingMap.set(url, loadPromise)\n\n    res = await customFetch(url, { method, body, headers, redirect }).catch(fetchError => ({ ok: false, error: fetchError }))\n\n    // FIXME: do not retry redirects etc that are also not ok\n    if (!res.ok && retry) {\n      retried = {\n        status: res.status,\n        statusText: res.statusText,\n        text: res.text ? await res.text() : undefined,\n        error: res.error,\n        redirect: res.redirected || res.type === 'opaqueredirect'\n      }\n      if (retried.redirect || res.status === 401) {\n        self.session?.refresh()\n        // FIXME: abort here\n      }\n      await sleepRandom()\n      res = await customFetch(url, { method, body, headers, redirect }).catch(fetchError => ({ ok: false, error: fetchError }))\n    }\n\n    if (res.ok && cache) {\n      res.clone().arrayBuffer().then(body => {\n        cacheMap.set(cacheKey, { body,  headers:  {\n          'content-type': res.headers.get('content-type'),\n          'content-length': res.headers.get('content-length'),\n          'last-modified': res.headers.get('last-modified')\n        }})\n        finishLoad()\n        pendingMap.delete(cacheKey)\n      })\n      //   waitUntil((async () => {\n      //     await kvs.put(cacheKey, body, {\n      //       expirationTtl: ttl, // s\n      //       metadata: {\n      //         expiration: ttl ? (Math.floor(Date.now() / 1000) + ttl) : undefined,\n      //          headers\n      //       }\n      //     })\n      //   })())\n    }\n  }\n  const duration = (Date.now() - reqStart)\n\n  let resHeaders\n  let json\n  let text\n  if (!rawArg && res.headers) {\n    resHeaders = Object.fromEntries(res.headers.entries())\n    if (!wasCached) {\n      let oldCacheStatus = res.headers.get('cache-status') || ''\n      if (oldCacheStatus) {\n        oldCacheStatus += ', '\n      }\n      resHeaders['cache-status'] = oldCacheStatus + 'edge-kv; miss' + (kvs ? '; stored' : '')\n    }\n\n    text = await res.text()\n    if (res.headers.get('content-type').includes('application/json')) {\n      json = JSON.parse(text)\n    }\n  }\n\n  const baseResponse = {\n    headers: resHeaders,\n\n    duration,\n    ok: res.ok,\n    redirect: res.redirected || res.type === 'opaqueredirect',\n    status: res.status,\n    statusText: res.statusText,\n    retried,\n    error: res.error\n  }\n\n  if (baseResponse.redirect || res.status === 401) {\n    self.session?.refresh()\n  }\n\n  // headers['referer'] = 'todo'\n  // headers['traceId'] = 'todo'\n  // headers['host'] = 'todo'\n  // if (!wasCached) {\n  //   waitUntil(log({\n  //     stats: event?.stats,\n  //     req: {\n  //       method,\n  //       url: new URL(url),\n  //       headers: Object.fromEntries(headers.entries())\n  //     },\n  //     res: { body: text, ...baseResponse},\n  //     body,\n  //     duration\n  //   }))\n  // }\n\n  return {\n    raw: res,\n    json,\n    text,\n    ...baseResponse\n  }\n}\n\nfunction get (url, opts = {}) {\n  opts.method = 'GET'\n  return req(url, opts)\n}\nfunction del (url, opts = {}) {\n  opts.method = 'DELETE'\n  return req(url, opts)\n}\n function put (url, opts = {}) {\n  opts.method = 'PUT'\n  return req(url, opts)\n}\nfunction post (url, opts = {}) {\n  opts.method = 'POST'\n  return req(url, opts)\n}\nfunction head (url, opts = {}) {\n  opts.method = 'HEAD'\n  return req(url, opts)\n}\nfunction options (url, opts = {}) {\n  opts.method = 'OPTIONS'\n  return req(url, opts)\n}\nfunction patch (url, opts = {}) {\n  opts.method = 'PATCH'\n  return req(url, opts)\n}\nfunction trace (url, opts = {}) {\n  opts.method = 'TRACE'\n  return req(url, opts)\n}\n\nexport { get, del, put, post, head, options, patch, trace }\n", "// eslint-disable-next-line no-restricted-imports\nimport { Observable } from '../../build/deps/falcor-observable.js' // @graphistry ?\n// eslint-disable-next-line no-restricted-imports\nimport { Router } from '../../build/deps/falcor-router.js' // @graphistry ?\nimport { addPathTags } from '../schema/helpers.js'\nimport defaultPaths from '../schema/default-routes.js'\n\nimport { urlLogger } from '../lib/url-logger.js'\nimport * as systemHandlers from '../schema/falcor-handlers/index.js'\nimport { get, del, put, post, head, patch } from '../lib/req.js'\n\nexport function falcorTags (routes) {\n  Object.keys(routes).forEach(key => {\n    Object.keys(routes[key]).forEach(method => {\n      if (typeof routes[key][method] === 'function') {\n        routes[key][method] = { handler: routes[key][method], tags: ['falcor'] }\n      } else {\n        const tags = routes[key][method].tags\n        routes[key][method].tags = tags ? tags : ['falcor'] // FIXME: how to best add to existing tags ? .push?.('falcor')\n      }\n    })\n  })\n\n  return routes\n}\n\nfunction withFetch (fn, customFetch) {\n  return function (url, opts) {\n    opts.fetch = customFetch\n    return fn(url, opts)\n  }\n}\n\nfunction maxRange (ranges) {\n  let from\n  let to\n  ranges.forEach(range => {\n    if (to === undefined) {\n      to = range.to\n    } else {\n      to = Math.max(to, range.to)\n    }\n\n    if (from === undefined) {\n      from = range.from\n    } else {\n      from = Math.min(from, range.from)\n    }\n  })\n\n  return { from, to }\n}\n\nexport function toFalcorRoutes (schema) {\n  // The first case in 13 years that the semicolon was actually necessary!! (but only due to the bundler) :D\n  const routes = [];\n\n  [...Object.entries(schema.paths)].forEach(([path, handlerArgs]) => {\n    const handlers = {}\n\n    Object.entries(handlerArgs).forEach(([handlerType, handlerConf]) => {\n      if (handlerConf.tags?.includes?.('falcor')) {\n        if (!['get', 'set', 'call'].includes(handlerType)) {\n          console.error('unsupported falcor handler type ' + handlerType)\n        }\n\n        const handler = handlerConf.handler || (handlerConf.operationId && systemHandlers[handlerConf.operationId])\n\n        handlers[handlerType] = function () {\n          /* eslint-disable functional/no-this-expression */\n          arguments[0].dbs = this.dbs\n          arguments[0].session = this.session\n          arguments[0].ctx = this.ctx\n          arguments[0].Observable = this.Observable\n\n          arguments[0].get = this.http_get\n          arguments[0].del = this.http_del\n          arguments[0].put = this.http_put\n          arguments[0].post = this.http_post\n          arguments[0].head = this.http_head\n          arguments[0].patch = this.http_patch\n\n          arguments[0].model = this.model\n\n          arguments[0].atom = this.model.constructor.atom\n          arguments[0].ref = this.model.constructor.ref\n          arguments[0].clientRef = (target) => ({ $type: 'atom', $meta: 'clientRef', value: target })\n          arguments[0].pathValue = this.model.constructor.pathValue\n          arguments[0].error = this.model.constructor.error\n          /* eslint-enable functional/no-this-expression */\n\n          arguments[0].maxRange = maxRange\n\n          let getRes = handler(...arguments)\n\n          if (handlerType === 'get') {\n            const pathArg = arguments[0]\n\n            const auoWrap = (paAr, res) => {\n              if (res.jsonGraph) {\n                return res\n              }\n              if (res?.length && res?.[0]?.path) {\n                return res\n              }\n              if (['boolean', 'undefined', 'number', 'string'].includes(typeof res) || (!res.value && !res.path)) {\n                res = { value: { $type: 'atom', value: res } }\n              }\n              if (res.$type) {\n                res = { value: res }\n              }\n              if (res.value !== undefined && !res.path) {\n                res.path = paAr.length ? [ ...paAr ] : [ paAr ]\n              }\n\n              return res\n            }\n\n            if (typeof getRes.then === 'function') {\n              getRes = getRes.then(res => {\n                return auoWrap(pathArg, res)\n              })\n            } else {\n              getRes = auoWrap(pathArg, getRes)\n            }\n          }\n\n          return getRes\n        }\n      }\n    })\n\n    if (Object.keys(handlers).length > 0) {\n      routes.push({\n        route: path,\n        ...handlers\n      })\n    }\n  })\n\n  return routes\n}\n\nexport function makeRouter ({ dataRoutes, schema }) {\n  // TODO: gobally precompile schema on build time\n  if (!dataRoutes && schema) {\n    if (typeof schema === 'function') {\n      schema = schema({ defaultPaths, addPathTags })\n    } else if (schema) {\n      // (allow omission of tags for falcor routes)\n      schema.paths = { ...defaultPaths, ...falcorTags(schema.paths) }\n    }\n\n    dataRoutes = toFalcorRoutes(schema)\n  }\n\n  // FIXME: why is logging not working?!\n\n  // TODO: precompile and reuse dataRoutes!\n  class AtreyuRouter extends Router.createClass(dataRoutes) { // eslint-disable-line functional/no-class\n    constructor ({ session, dbs, fetch: internalFetch, debug, ctx = {} }) {\n      super({\n        // FIXME: check why debug flag and path errors dont work!\n        debug,\n        // FIXME: route unhandled paths to error handler routeUnhandledPathsT!\n        hooks: {\n          pathError: err => {\n            console.error(err)\n          },\n          error: err => {\n            console.error(err)\n          },\n          methodSummary: e => {\n            // console.log(e)\n            if (!debug) {\n              // logging is quite expensive\n              return\n            }\n            const totalDuration = e.end - e.start\n\n            e.routes?.forEach((route, i) => {\n              let batchMarker = ''\n              if (e.routes.length > 1) {\n                if (i === 0) {\n                  batchMarker = ' (batched >'\n                } else if (i === e.routes.length - 1) {\n                  batchMarker = ' < batched)'\n                } else {\n                  batchMarker = ' ...'\n                }\n\n                const body = route.results?.map(res => res.value.jsonGraph || res.value)\n                const duration = route.end && route.start ? route.end - route.start : 0\n\n                urlLogger({\n                  method: e.method.toUpperCase() + batchMarker,\n                  url: `falcor://${JSON.stringify(route.pathSet)}`,\n                  duration,\n                  error: route.error,\n                  body\n                })\n              } else {\n                urlLogger({\n                  method: e.method.toUpperCase(),\n                  url: `falcor://${JSON.stringify(route.pathSet)}`,\n                  error: route.error,\n                  duration: totalDuration,\n                  body: e.results[i]?.value.jsonGraph || e.results[i]?.value.value\n                })\n              }\n            })\n\n            const reqPaths = [...(e.pathSets || []), ...(e.callPath ? [e.callPath] : []) , ...(e.jsonGraphEnvelope?.paths || [])]\n\n            // FIXME: remove me for fallback observable\n            if (reqPaths.length > (e.routes?.length || 0)) {\n              // console.log(e, reqPaths)\n\n              reqPaths.slice(e.routes.length).forEach(pathSet => {\n                urlLogger({\n                  missing: true,\n                  error: e.error,\n                  method: e.method.toUpperCase(),\n                  url: `falcor://${JSON.stringify(pathSet)}`,\n                  duration: totalDuration,\n                  args: e.args\n                })\n              })\n            }\n          }\n        }\n      })\n\n      /* eslint-disable functional/no-this-expression */\n      this.session = session\n      this.ctx = ctx\n      this.dbs = dbs\n\n      this.http_get = withFetch(get, internalFetch)\n      this.http_del = withFetch(del, internalFetch)\n      this.http_put = withFetch(put, internalFetch)\n      this.http_post = withFetch(post, internalFetch)\n      this.http_head = withFetch(head, internalFetch)\n      this.http_patch = withFetch(patch, internalFetch)\n\n      this.Observable = Observable\n\n      this._unhandled = {\n        call: (...args) => {\n          console.warn('Missing route for call: ' + JSON.stringify(args))\n        },\n        set: (...args) => {\n          console.warn('Missing route for set: ' + JSON.stringify(args))\n        },\n        get: (...args) => {\n          console.warn('Missing route for get: ' + JSON.stringify(args))\n        }\n      }\n      /* eslint-enable functional/no-this-expression */\n    }\n  }\n\n  return AtreyuRouter\n}\n"],
  "mappings": "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",
  "names": ["n", "a", "d", "root", "result", "Symbol", "e", "observable", "EsObservable", "BaseObservable", "Subscription", "getAugmentedNamespace", "n", "a", "d", "onRange", "onKey", "range", "i", "convertPathKeyTo", "convertPathToRoute", "slice", "tokenizer", "from", "quote", "routed", "t", "indexer", "head", "parser", "convertTypes", "prettifyRoute", "get", "set", "call", "isArray", "isObject", "pathsComplementFromTree", "pathsComplementFromLengthTree", "map", "toPaths", "toTree", "iterateKeySet", "CallNotFoundError", "specificMatcher", "pluckIntegers", "collapse", "isRoutedToken", "Observable", "Subscription", "isObject$1", "tryCatch", "e", "tryCatch$1", "UnsubscriptionError", "errors", "err", "tryCatch_1", "Subscription$1", "empty", "Symbol", "Subscriber", "SafeSubscriber", "observable", "Action", "AsyncAction", "QueueAction", "Scheduler", "AsyncScheduler", "QueueScheduler", "root", "InnerSubscriber", "result", "value", "iterator", "OuterSubscriber", "DeferObservable", "DeferSubscriber", "ScalarObservable", "EmptyObservable", "ArrayObservable", "PromiseObservable", "IteratorObservable", "StringIterator", "ArrayIterator", "ArrayLikeObservable", "Notification", "ObserveOnOperator", "ObserveOnSubscriber", "ObserveOnMessage", "FromObservable", "ErrorObservable", "mergeMap$1", "MergeMapOperator", "MergeMapSubscriber", "_do$1", "DoOperator", "DoSubscriber", "defaultIfEmpty$1", "DefaultIfEmptyOperator", "DefaultIfEmptySubscriber", "materialize", "MaterializeOperator", "MaterializeSubscriber", "expand$1", "ExpandOperator", "ExpandSubscriber", "reduce$1", "ReduceOperator", "ReduceSubscriber", "toArray$1", "ToArrayOperator", "ToArraySubscriber", "map$1", "MapOperator", "MapSubscriber", "filter$1", "FilterOperator", "FilterSubscriber", "_catch$1", "CatchOperator", "CatchSubscriber", "MergeAllOperator", "MergeAllSubscriber", "concat$1", "symbolObservablePonyfill", "es", "outputToObservable", "v", "isJSONG", "JSONGraphError", "errorToPathValue", "noteToJsongOrPV", "runGetAction", "match", "rangeToArray", "isNumber", "stripFromRange", "Keys", "stripFromArray", "strip", "catAndSlice", "stripPath", "isRange", "hasAtomIntersection", "hasIntersection", "pathUtils", "getExecutableMatches", "runByPrecedence", "followReference", "cloneArray", "$ref", "optimizePathSets", "$types", "optimizePathSet", "types", "clone", "jsongMerge", "pathValueMerge", "isMessage", "recurseMatchAndExecute", "normalize", "normalizePathSets", "MaxPathsExceededError", "rxNewToRxNewAndOld", "spreadPaths", "getValue", "hasIntersectionWithTree", "CallRequiresPathsError", "route", "r", "parseTree", "matcher", "noOp", "defaultNow", "a", "result", "i", "Observable", "i", "t", "t", "e", "r", "t", "t", "e", "t", "e", "r", "n", "s", "i", "t", "e", "r", "n", "s", "t", "e", "t", "e", "r", "n", "s", "i", "a", "t", "e", "i", "r", "n", "s", "s", "t", "e", "r", "n", "t", "e", "body", "get", "head", "from", "range", "e", "i", "get", "head"]
}
