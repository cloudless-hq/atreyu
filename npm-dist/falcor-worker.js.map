{
  "version": 3,
  "sources": ["../app/build/deps/pouchdb.js", "../app/src/service-worker/make-pouch.js", "../app/build/deps/falcor-observable.js", "../app/build/deps/falcor-router.js", "../app/src/lib/url-logger.js", "../app/src/schema/falcor-handlers/index.js", "../app/src/deps/luxon.js", "../app/src/lib/helpers.js", "../app/src/lib/req.js", "../app/src/service-worker/falcor-router.js", "../app/build/deps/falcor.js", "../app/src/store/helpers.js", "../app/src/service-worker/falcor-server.js", "../app/src/schema/helpers.js", "../app/src/schema/falcor-paths.js", "../app/src/schema/window-paths.js", "../app/src/schema/default-routes.js", "../app/src/service-worker/falcor-worker.js"],
  "sourcesContent": ["var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction getAugmentedNamespace(n) {\n  if (n.__esModule) return n;\n  var f = n.default;\n\tif (typeof f == \"function\") {\n\t\tvar a = function a () {\n\t\t\tif (this instanceof a) {\n        return Reflect.construct(f, arguments, this.constructor);\n\t\t\t}\n\t\t\treturn f.apply(this, arguments);\n\t\t};\n\t\ta.prototype = f.prototype;\n  } else a = {};\n  Object.defineProperty(a, '__esModule', {value: true});\n\tObject.keys(n).forEach(function (k) {\n\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn n[k];\n\t\t\t}\n\t\t});\n\t});\n\treturn a;\n}\n\nvar _nodeResolve_empty = {};\n\nvar _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tdefault: _nodeResolve_empty\n});\n\nvar require$$0 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);\n\nvar queueMicrotask = {};\n\nqueueMicrotask.test = function () {\n  return typeof commonjsGlobal.queueMicrotask === 'function';\n};\n\nqueueMicrotask.install = function (func) {\n  return function () {\n    commonjsGlobal.queueMicrotask(func);\n  };\n};\n\nvar mutation = {};\n\n//based off rsvp https://github.com/tildeio/rsvp.js\n//license https://github.com/tildeio/rsvp.js/blob/master/LICENSE\n//https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/asap.js\n\nvar Mutation = commonjsGlobal.MutationObserver || commonjsGlobal.WebKitMutationObserver;\n\nmutation.test = function () {\n  return Mutation;\n};\n\nmutation.install = function (handle) {\n  var called = 0;\n  var observer = new Mutation(handle);\n  var element = commonjsGlobal.document.createTextNode('');\n  observer.observe(element, {\n    characterData: true\n  });\n  return function () {\n    element.data = (called = ++called % 2);\n  };\n};\n\nvar messageChannel = {};\n\nmessageChannel.test = function () {\n  if (commonjsGlobal.setImmediate) {\n    // we can only get here in IE10\n    // which doesn't handel postMessage well\n    return false;\n  }\n  return typeof commonjsGlobal.MessageChannel !== 'undefined';\n};\n\nmessageChannel.install = function (func) {\n  var channel = new commonjsGlobal.MessageChannel();\n  channel.port1.onmessage = func;\n  return function () {\n    channel.port2.postMessage(0);\n  };\n};\n\nvar stateChange = {};\n\nstateChange.test = function () {\n  return 'document' in commonjsGlobal && 'onreadystatechange' in commonjsGlobal.document.createElement('script');\n};\n\nstateChange.install = function (handle) {\n  return function () {\n\n    // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n    // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n    var scriptEl = commonjsGlobal.document.createElement('script');\n    scriptEl.onreadystatechange = function () {\n      handle();\n\n      scriptEl.onreadystatechange = null;\n      scriptEl.parentNode.removeChild(scriptEl);\n      scriptEl = null;\n    };\n    commonjsGlobal.document.documentElement.appendChild(scriptEl);\n\n    return handle;\n  };\n};\n\nvar timeout = {};\n\ntimeout.test = function () {\n  return true;\n};\n\ntimeout.install = function (t) {\n  return function () {\n    setTimeout(t, 0);\n  };\n};\n\nvar types = [\n  require$$0,\n  queueMicrotask,\n  mutation,\n  messageChannel,\n  stateChange,\n  timeout\n];\nvar draining;\nvar currentQueue;\nvar queueIndex = -1;\nvar queue = [];\nvar scheduled = false;\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n  draining = false;\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n  if (queue.length) {\n    nextTick();\n  }\n}\n\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  if (draining) {\n    return;\n  }\n  scheduled = false;\n  draining = true;\n  var len = queue.length;\n  var timeout = setTimeout(cleanUpNextTick);\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n    while (currentQueue && ++queueIndex < len) {\n      currentQueue[queueIndex].run();\n    }\n    queueIndex = -1;\n    len = queue.length;\n  }\n  currentQueue = null;\n  queueIndex = -1;\n  draining = false;\n  clearTimeout(timeout);\n}\nvar scheduleDrain;\nvar i = -1;\nvar len = types.length;\nwhile (++i < len) {\n  if (types[i] && types[i].test && types[i].test()) {\n    scheduleDrain = types[i].install(nextTick);\n    break;\n  }\n}\n// v8 likes predictible objects\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\nItem.prototype.run = function () {\n  var fun = this.fun;\n  var array = this.array;\n  switch (array.length) {\n  case 0:\n    return fun();\n  case 1:\n    return fun(array[0]);\n  case 2:\n    return fun(array[0], array[1]);\n  case 3:\n    return fun(array[0], array[1], array[2]);\n  default:\n    return fun.apply(null, array);\n  }\n\n};\nvar lib = immediate;\nfunction immediate(task) {\n  var args = new Array(arguments.length - 1);\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n  queue.push(new Item(task, args));\n  if (!scheduled && !draining) {\n    scheduled = true;\n    scheduleDrain();\n  }\n}\n\nvar immediate$1 = /*@__PURE__*/getDefaultExportFromCjs(lib);\n\nvar sparkMd5 = {exports: {}};\n\n(function (module, exports) {\n\t(function (factory) {\n\t    {\n\t        // Node/CommonJS\n\t        module.exports = factory();\n\t    }\n\t}(function (undefined$1) {\n\n\t    /*\n\t     * Fastest md5 implementation around (JKM md5).\n\t     * Credits: Joseph Myers\n\t     *\n\t     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n\t     * @see http://jsperf.com/md5-shootout/7\n\t     */\n\n\t    /* this function is much faster,\n\t      so if possible we use it. Some IEs\n\t      are the only ones I know of that\n\t      need the idiotic second function,\n\t      generated by an if clause.  */\n\t    var hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\t    function md5cycle(x, k) {\n\t        var a = x[0],\n\t            b = x[1],\n\t            c = x[2],\n\t            d = x[3];\n\n\t        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\t        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\t        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\t        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\n\t        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\t        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\t        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\t        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\n\t        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\t        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\t        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\t        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\n\t        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n\t        b  = (b << 21 |b >>> 11) + c | 0;\n\t        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n\t        b  = (b << 21 |b >>> 11) + c | 0;\n\t        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n\t        b  = (b << 21 |b >>> 11) + c | 0;\n\t        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n\t        b  = (b << 21 | b >>> 11) + c | 0;\n\n\t        x[0] = a + x[0] | 0;\n\t        x[1] = b + x[1] | 0;\n\t        x[2] = c + x[2] | 0;\n\t        x[3] = d + x[3] | 0;\n\t    }\n\n\t    function md5blk(s) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n\t        }\n\t        return md5blks;\n\t    }\n\n\t    function md5blk_array(a) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n\t        }\n\t        return md5blks;\n\t    }\n\n\t    function md51(s) {\n\t        var n = s.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk(s.substring(i - 64, i)));\n\t        }\n\t        s = s.substring(i - 64);\n\t        length = s.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\n\t        md5cycle(state, tail);\n\t        return state;\n\t    }\n\n\t    function md51_array(a) {\n\t        var n = a.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n\t        }\n\n\t        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n\t        // containing the last element of the parent array if the sub array specified starts\n\t        // beyond the length of the parent array - weird.\n\t        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n\t        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n\t        length = a.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n\t        }\n\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\n\t        md5cycle(state, tail);\n\n\t        return state;\n\t    }\n\n\t    function rhex(n) {\n\t        var s = '',\n\t            j;\n\t        for (j = 0; j < 4; j += 1) {\n\t            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n\t        }\n\t        return s;\n\t    }\n\n\t    function hex(x) {\n\t        var i;\n\t        for (i = 0; i < x.length; i += 1) {\n\t            x[i] = rhex(x[i]);\n\t        }\n\t        return x.join('');\n\t    }\n\n\t    // In some cases the fast add32 function cannot be used..\n\t    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') ;\n\n\t    // ---------------------------------------------------\n\n\t    /**\n\t     * ArrayBuffer slice polyfill.\n\t     *\n\t     * @see https://github.com/ttaubert/node-arraybuffer-slice\n\t     */\n\n\t    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n\t        (function () {\n\t            function clamp(val, length) {\n\t                val = (val | 0) || 0;\n\n\t                if (val < 0) {\n\t                    return Math.max(val + length, 0);\n\t                }\n\n\t                return Math.min(val, length);\n\t            }\n\n\t            ArrayBuffer.prototype.slice = function (from, to) {\n\t                var length = this.byteLength,\n\t                    begin = clamp(from, length),\n\t                    end = length,\n\t                    num,\n\t                    target,\n\t                    targetArray,\n\t                    sourceArray;\n\n\t                if (to !== undefined$1) {\n\t                    end = clamp(to, length);\n\t                }\n\n\t                if (begin > end) {\n\t                    return new ArrayBuffer(0);\n\t                }\n\n\t                num = end - begin;\n\t                target = new ArrayBuffer(num);\n\t                targetArray = new Uint8Array(target);\n\n\t                sourceArray = new Uint8Array(this, begin, num);\n\t                targetArray.set(sourceArray);\n\n\t                return target;\n\t            };\n\t        })();\n\t    }\n\n\t    // ---------------------------------------------------\n\n\t    /**\n\t     * Helpers.\n\t     */\n\n\t    function toUtf8(str) {\n\t        if (/[\\u0080-\\uFFFF]/.test(str)) {\n\t            str = unescape(encodeURIComponent(str));\n\t        }\n\n\t        return str;\n\t    }\n\n\t    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n\t        var length = str.length,\n\t           buff = new ArrayBuffer(length),\n\t           arr = new Uint8Array(buff),\n\t           i;\n\n\t        for (i = 0; i < length; i += 1) {\n\t            arr[i] = str.charCodeAt(i);\n\t        }\n\n\t        return returnUInt8Array ? arr : buff;\n\t    }\n\n\t    function arrayBuffer2Utf8Str(buff) {\n\t        return String.fromCharCode.apply(null, new Uint8Array(buff));\n\t    }\n\n\t    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n\t        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n\t        result.set(new Uint8Array(first));\n\t        result.set(new Uint8Array(second), first.byteLength);\n\n\t        return returnUInt8Array ? result : result.buffer;\n\t    }\n\n\t    function hexToBinaryString(hex) {\n\t        var bytes = [],\n\t            length = hex.length,\n\t            x;\n\n\t        for (x = 0; x < length - 1; x += 2) {\n\t            bytes.push(parseInt(hex.substr(x, 2), 16));\n\t        }\n\n\t        return String.fromCharCode.apply(String, bytes);\n\t    }\n\n\t    // ---------------------------------------------------\n\n\t    /**\n\t     * SparkMD5 OOP implementation.\n\t     *\n\t     * Use this class to perform an incremental md5, otherwise use the\n\t     * static methods instead.\n\t     */\n\n\t    function SparkMD5() {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    }\n\n\t    /**\n\t     * Appends a string.\n\t     * A conversion will be applied if an utf8 string is detected.\n\t     *\n\t     * @param {String} str The string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.append = function (str) {\n\t        // Converts the string to utf8 bytes if necessary\n\t        // Then append as binary\n\t        this.appendBinary(toUtf8(str));\n\n\t        return this;\n\t    };\n\n\t    /**\n\t     * Appends a binary string.\n\t     *\n\t     * @param {String} contents The binary string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.appendBinary = function (contents) {\n\t        this._buff += contents;\n\t        this._length += contents.length;\n\n\t        var length = this._buff.length,\n\t            i;\n\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n\t        }\n\n\t        this._buff = this._buff.substring(i - 64);\n\n\t        return this;\n\t    };\n\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     *\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            i,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            ret;\n\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\n\t        this._finish(tail, length);\n\t        ret = hex(this._hash);\n\n\t        if (raw) {\n\t            ret = hexToBinaryString(ret);\n\t        }\n\n\t        this.reset();\n\n\t        return ret;\n\t    };\n\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.reset = function () {\n\t        this._buff = '';\n\t        this._length = 0;\n\t        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n\t        return this;\n\t    };\n\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @return {Object} The state\n\t     */\n\t    SparkMD5.prototype.getState = function () {\n\t        return {\n\t            buff: this._buff,\n\t            length: this._length,\n\t            hash: this._hash.slice()\n\t        };\n\t    };\n\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @param {Object} state The state\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.setState = function (state) {\n\t        this._buff = state.buff;\n\t        this._length = state.length;\n\t        this._hash = state.hash;\n\n\t        return this;\n\t    };\n\n\t    /**\n\t     * Releases memory used by the incremental buffer and other additional\n\t     * resources. If you plan to use the instance again, use reset instead.\n\t     */\n\t    SparkMD5.prototype.destroy = function () {\n\t        delete this._hash;\n\t        delete this._buff;\n\t        delete this._length;\n\t    };\n\n\t    /**\n\t     * Finish the final calculation based on the tail.\n\t     *\n\t     * @param {Array}  tail   The tail (will be modified)\n\t     * @param {Number} length The length of the remaining buffer\n\t     */\n\t    SparkMD5.prototype._finish = function (tail, length) {\n\t        var i = length,\n\t            tmp,\n\t            lo,\n\t            hi;\n\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(this._hash, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\n\t        // Do the final computation based on the tail and length\n\t        // Beware that the final length may not fit in 32 bits so we take care of that\n\t        tmp = this._length * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t        md5cycle(this._hash, tail);\n\t    };\n\n\t    /**\n\t     * Performs the md5 hash on a string.\n\t     * A conversion will be applied if utf8 string is detected.\n\t     *\n\t     * @param {String}  str The string\n\t     * @param {Boolean} [raw] True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.hash = function (str, raw) {\n\t        // Converts the string to utf8 bytes if necessary\n\t        // Then compute it using the binary function\n\t        return SparkMD5.hashBinary(toUtf8(str), raw);\n\t    };\n\n\t    /**\n\t     * Performs the md5 hash on a binary string.\n\t     *\n\t     * @param {String}  content The binary string\n\t     * @param {Boolean} [raw]     True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.hashBinary = function (content, raw) {\n\t        var hash = md51(content),\n\t            ret = hex(hash);\n\n\t        return raw ? hexToBinaryString(ret) : ret;\n\t    };\n\n\t    // ---------------------------------------------------\n\n\t    /**\n\t     * SparkMD5 OOP implementation for array buffers.\n\t     *\n\t     * Use this class to perform an incremental md5 ONLY for array buffers.\n\t     */\n\t    SparkMD5.ArrayBuffer = function () {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    };\n\n\t    /**\n\t     * Appends an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array to be appended\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n\t        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n\t            length = buff.length,\n\t            i;\n\n\t        this._length += arr.byteLength;\n\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n\t        }\n\n\t        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n\t        return this;\n\t    };\n\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     *\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            i,\n\t            ret;\n\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n\t        }\n\n\t        this._finish(tail, length);\n\t        ret = hex(this._hash);\n\n\t        if (raw) {\n\t            ret = hexToBinaryString(ret);\n\t        }\n\n\t        this.reset();\n\n\t        return ret;\n\t    };\n\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.reset = function () {\n\t        this._buff = new Uint8Array(0);\n\t        this._length = 0;\n\t        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n\t        return this;\n\t    };\n\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @return {Object} The state\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.getState = function () {\n\t        var state = SparkMD5.prototype.getState.call(this);\n\n\t        // Convert buffer to a string\n\t        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n\t        return state;\n\t    };\n\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @param {Object} state The state\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n\t        // Convert string to buffer\n\t        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n\t        return SparkMD5.prototype.setState.call(this, state);\n\t    };\n\n\t    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n\t    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n\t    /**\n\t     * Performs the md5 hash on an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array buffer\n\t     * @param {Boolean}     [raw] True to get the raw string, false to get the hex one\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n\t        var hash = md51_array(new Uint8Array(arr)),\n\t            ret = hex(hash);\n\n\t        return raw ? hexToBinaryString(ret) : ret;\n\t    };\n\n\t    return SparkMD5;\n\t})); \n} (sparkMd5));\n\nvar sparkMd5Exports = sparkMd5.exports;\nvar Md5 = /*@__PURE__*/getDefaultExportFromCjs(sparkMd5Exports);\n\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\n\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nvar native = {\n  randomUUID\n};\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nvar events = {exports: {}};\n\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  };\n\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nevents.exports = EventEmitter;\nevents.exports.once = once$1;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount$1.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount$1;\nfunction listenerCount$1(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once$1(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    }\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\nvar eventsExports = events.exports;\nvar EE = /*@__PURE__*/getDefaultExportFromCjs(eventsExports);\n\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.keys = function () {\n  return Object.keys(this._store).map(k => unmangle(k));\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else { // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date && isFinite(object)) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return function (...args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  };\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return function (...args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new Promise(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  };\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(\n        err ? ['error', err] : ['success', res]\n      );\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(function (...args) {\n    if (this._closed) {\n      return Promise.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return Promise.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new Promise(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  });\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new ExportedMap();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nvar hasLocal;\n\ntry {\n  localStorage.setItem('_pouch_check_localstorage', 1);\n  hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n} catch (e) {\n  hasLocal = false;\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n\nclass Changes extends EE {\n  constructor() {\n    super();\n    \n    this._listeners = {};\n    \n    if (hasLocalStorage()) {\n      addEventListener(\"storage\", (e) => {\n        this.emit(e.key);\n      });\n    }\n  }\n\n  addListener(dbName, id, db, opts) {\n    if (this._listeners[id]) {\n      return;\n    }\n    var inprogress = false;\n    var self = this;\n    function eventFunction() {\n      if (!self._listeners[id]) {\n        return;\n      }\n      if (inprogress) {\n        inprogress = 'waiting';\n        return;\n      }\n      inprogress = true;\n      var changesOpts = pick(opts, [\n        'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n        'doc_ids', 'view', 'since', 'query_params', 'binary', 'return_docs'\n      ]);\n  \n      function onError() {\n        inprogress = false;\n      }\n  \n      db.changes(changesOpts).on('change', function (c) {\n        if (c.seq > opts.since && !opts.cancelled) {\n          opts.since = c.seq;\n          opts.onChange(c);\n        }\n      }).on('complete', function () {\n        if (inprogress === 'waiting') {\n          immediate$1(eventFunction);\n        }\n        inprogress = false;\n      }).on('error', onError);\n    }\n    this._listeners[id] = eventFunction;\n    this.on(dbName, eventFunction);\n  }\n  \n  removeListener(dbName, id) {\n    if (!(id in this._listeners)) {\n      return;\n    }\n    super.removeListener(dbName, this._listeners[id]);\n    delete this._listeners[id];\n  }\n  \n  notifyLocalWindows(dbName) {\n    //do a useless change on a storage thing\n    //in order to get other windows's listeners to activate\n    if (hasLocalStorage()) {\n      localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n    }\n  }\n  \n  notify(dbName) {\n    this.emit(dbName);\n    this.notifyLocalWindows(dbName);\n  }\n}\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (typeof console !== 'undefined' && typeof console[method] === 'function') {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar $inject_Object_assign = assign;\n\nclass PouchError extends Error {\n  constructor(status, error, reason) {\n    super();\n    this.status = status;\n    this.name = error;\n    this.message = reason;\n    this.error = true;\n  }\n\n  toString() {\n    return JSON.stringify({\n      status: this.status,\n      name: this.name,\n      message: this.message,\n      reason: this.reason\n    });\n  }\n}\n\nnew PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nnew PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nnew PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nnew PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nnew PouchError(500, 'web_sql_went_bad', 'unknown');\nnew PouchError(500, 'levelDB_went_went_bad', 'unknown');\nnew PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nnew PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nnew PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    var names = Object.getOwnPropertyNames(error);\n    for (var i = 0, len = names.length; i < len; i++) {\n      if (typeof error[names[i]] !== 'function') {\n        this[names[i]] = error[names[i]];\n      }\n    }\n\n    if (this.stack === undefined) {\n      this.stack = (new Error()).stack;\n    }\n\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  if (!('stack' in err)) {\n    err.stack = (new Error()).stack;\n  }\n\n  return err;\n}\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(change.doc._attachments, att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn',\n      'db.type() is deprecated and will be removed in ' +\n      'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 EE.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* eslint no-useless-escape: 0 */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (Object.prototype.hasOwnProperty.call(scope, key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return db.get(docId)\n    .catch(function (err) {\n      /* istanbul ignore next */\n      if (err.status !== 404) {\n        throw err;\n      }\n      return {};\n    })\n    .then(function (doc) {\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return {updated: false, rev: docRev};\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      return tryAndPut(db, newDoc, diffFun);\n    });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\nvar thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\n\nvar setImmediateShim = self.setImmediate || self.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return thisBtoa(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  readAsArrayBuffer(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\n/**\n * Creates a new revision string that does NOT include the revision height\n * For example '56649f1b0506c6ca9fda0746eb0cacdf'\n */\nfunction rev$$1(doc, deterministic_revs) {\n  if (!deterministic_revs) {\n    return v4().replace(/-/g, '').toLowerCase();\n  }\n\n  var mutateableDoc = $inject_Object_assign({}, doc);\n  delete mutateableDoc._rev_tree;\n  return stringMd5(JSON.stringify(mutateableDoc));\n}\n\nvar uuid = v4; // mimic old import, only v4 is ever used elsewhere\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) { // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({pos: pos + 1, ids: branches[i]});\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n        winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx =\n      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                               revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// `findPathToLeaf()` returns an array of revs that goes from the specified\n// leaf rev to the root of that leaf\u2019s branch.\n//\n// eg. for this rev tree:\n// 1-9692 \u25B6 2-37aa \u25B6 3-df22 \u25B6 4-6e94 \u25B6 5-df4a \u25B6 6-6a3a \u25B6 7-57e5\n//          \u2503                 \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u25B6 5-8d8c \u25B6 6-65e0\n//          \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u25B6 3-43f6 \u25B6 4-a3b4\n//\n// For a `targetRev` of '7-57e5', `findPathToLeaf()` would return ['7-57e5', '6-6a3a', '5-df4a']\n// The `revs` arument has the same structure as what `revs_tree` has on e.g.\n// the IndexedDB representation of the rev tree datastructure. Please refer to\n// tests/unit/test.purge.js for examples of what these look like.\n//\n// This function will throw an error if:\n// - The requested revision does not exist\n// - The requested revision is not a leaf\nfunction findPathToLeaf(revs, targetRev) {\n  let path = [];\n  const toVisit = revs.slice();\n\n  let node;\n  while ((node = toVisit.pop())) {\n    const { pos, ids: tree } = node;\n    const rev = `${pos}-${tree[0]}`;\n    const branches = tree[2];\n\n    // just assuming we're already working on the path up towards our desired leaf.\n    path.push(rev);\n\n    // we've reached the leaf of our dreams, so return the computed path.\n    if (rev === targetRev) {\n      //\u2026unleeeeess\n      if (branches.length !== 0) {\n        throw new Error('The requested revision is not a leaf');\n      }\n      return path.reverse();\n    }\n\n    // this is based on the assumption that after we have a leaf (`branches.length == 0`), we handle the next\n    // branch. this is true for all branches other than the path leading to the winning rev (which is 7-57e5 in\n    // the example above. i've added a reset condition for branching nodes (`branches.length > 1`) as well.\n    if (branches.length === 0 || branches.length > 1) {\n      path = [];\n    }\n\n    // as a next step, we push the branches of this node to `toVisit` for visiting it during the next iteration\n    for (let i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({ pos: pos + 1, ids: branches[i] });\n    }\n  }\n  if (path.length === 0) {\n    throw new Error('The requested revision does not exist');\n  }\n  return path.reverse();\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      paths.push({pos: (pos + 1 - history.length), ids: history});\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n    }\n  }\n  return paths.reverse();\n}\n\n// for a better overview of what this is doing, read:\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status =\n        (tree1[1].status ===  'available' ||\n        tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var stemmedRevs;\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var node;\n    if (stemmed.length > depth) {\n      // only do the stemming work if we actually need to stem\n      if (!stemmedRevs) {\n        stemmedRevs = {}; // avoid allocating this object unnecessarily\n      }\n      var numStemmed = stemmed.length - depth;\n      node = {\n        pos: path.pos + numStemmed,\n        ids: pathToTree(stemmed, numStemmed)\n      };\n\n      for (var s = 0; s < numStemmed; s++) {\n        var rev = (path.pos + s) + '-' + stemmed[s].id;\n        stemmedRevs[rev] = true;\n      }\n    } else { // no need to actually stem\n      node = {\n        pos: path.pos,\n        ids: pathToTree(stemmed, 0)\n      };\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, node, true).tree;\n    } else {\n      result = [node];\n    }\n  }\n\n  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n  if (stemmedRevs) {\n    traverseRevTree(result, function (isLeaf, pos, revHash) {\n      // some revisions may have been removed in a branch but not in another\n      delete stemmedRevs[pos + '-' + revHash];\n    });\n  }\n\n  return {\n    tree: result,\n    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// this method removes a leaf from a rev tree, independent of its status.\n// e.g., by removing an available leaf, it could leave its predecessor as\n// a missing leaf and corrupting the tree.\nfunction removeLeafFromRevTree(tree, leafRev) {\n  return tree.flatMap((path) => {\n    path = removeLeafFromPath(path, leafRev);\n    return path ? [path] : [];\n  });\n}\n\nfunction removeLeafFromPath(path, leafRev) {\n  const tree = clone(path);\n  const toVisit = [tree];\n  let node;\n\n  while ((node = toVisit.pop())) {\n    const { pos, ids: [id, , branches], parent } = node;\n    const isLeaf = branches.length === 0;\n    const hash = `${pos}-${id}`;\n\n    if (isLeaf && hash === leafRev) {\n      if (!parent) {\n        // FIXME: we're facing the root, and probably shouldn't just return an empty array (object? null?).\n        return null;\n      }\n\n      parent.ids[2] = parent.ids[2].filter(function (branchNode) {\n        return branchNode[0] !== id;\n      });\n      return tree;\n    }\n\n    for (let i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({ pos: pos + 1, ids: branches[i], parent: node });\n    }\n  }\n  return tree;\n}\n\n// return true if a rev exists in the rev tree, false otherwise\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while ((tree = toVisit.pop())) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return (/^_local/).test(id);\n}\n\n// returns the current leaf node for a given revision\nfunction latest(rev, metadata) {\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, pos: pos, opts: opts});\n\n    if (isLeaf) {\n      for (var i = 0, len = history.length; i < len; i++) {\n        var historyNode = history[i];\n        var historyRev = historyNode.pos + '-' + historyNode.id;\n\n        if (historyRev === rev) {\n          // return the rev of this leaf\n          return pos + '-' + id;\n        }\n      }\n    }\n\n    for (var j = 0, l = branches.length; j < l; j++) {\n      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n}\n\nfunction tryCatchInChangeListener(self, change, pending, lastSeq) {\n  // isolate try/catches to avoid V8 deoptimizations\n  try {\n    self.emit('change', change, pending, lastSeq);\n  } catch (e) {\n    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n  }\n}\n\nfunction processChange(doc, metadata, opts) {\n  var changeList = [{rev: doc._rev}];\n  if (opts.style === 'all_docs') {\n    changeList = collectLeaves(metadata.rev_tree)\n    .map(function (x) { return {rev: x.rev}; });\n  }\n  var change = {\n    id: metadata.id,\n    changes: changeList,\n    doc: doc\n  };\n\n  if (isDeleted(metadata, doc._rev)) {\n    change.deleted = true;\n  }\n  if (opts.conflicts) {\n    change.doc._conflicts = collectConflicts(metadata);\n    if (!change.doc._conflicts.length) {\n      delete change.doc._conflicts;\n    }\n  }\n  return change;\n}\n\nclass Changes$1 extends EE {\n  constructor(db, opts, callback) {\n    super();\n    this.db = db;\n    opts = opts ? clone(opts) : {};\n    var complete = opts.complete = once((err, resp) => {\n      if (err) {\n        if (listenerCount(this, 'error') > 0) {\n          this.emit('error', err);\n        }\n      } else {\n        this.emit('complete', resp);\n      }\n      this.removeAllListeners();\n      db.removeListener('destroyed', onDestroy);\n    });\n    if (callback) {\n      this.on('complete', function (resp) {\n        callback(null, resp);\n      });\n      this.on('error', callback);\n    }\n    const onDestroy = () => {\n      this.cancel();\n    };\n    db.once('destroyed', onDestroy);\n  \n    opts.onChange = (change, pending, lastSeq) => {\n      /* istanbul ignore if */\n      if (this.isCancelled) {\n        return;\n      }\n      tryCatchInChangeListener(this, change, pending, lastSeq);\n    };\n  \n    var promise = new Promise(function (fulfill, reject) {\n      opts.complete = function (err, res) {\n        if (err) {\n          reject(err);\n        } else {\n          fulfill(res);\n        }\n      };\n    });\n    this.once('cancel', function () {\n      db.removeListener('destroyed', onDestroy);\n      opts.complete(null, {status: 'cancelled'});\n    });\n    this.then = promise.then.bind(promise);\n    this['catch'] = promise['catch'].bind(promise);\n    this.then(function (result) {\n      complete(null, result);\n    }, complete);\n  \n  \n  \n    if (!db.taskqueue.isReady) {\n      db.taskqueue.addTask((failed) => {\n        if (failed) {\n          opts.complete(failed);\n        } else if (this.isCancelled) {\n          this.emit('cancel');\n        } else {\n          this.validateChanges(opts);\n        }\n      });\n    } else {\n      this.validateChanges(opts);\n    }\n  }\n\n  cancel() {\n    this.isCancelled = true;\n    if (this.db.taskqueue.isReady) {\n      this.emit('cancel');\n    }\n  }\n\n  validateChanges(opts) {\n    var callback = opts.complete;\n  \n    /* istanbul ignore else */\n    if (PouchDB._changesFilterPlugin) {\n      PouchDB._changesFilterPlugin.validate(opts, (err) => {\n        if (err) {\n          return callback(err);\n        }\n        this.doChanges(opts);\n      });\n    } else {\n      this.doChanges(opts);\n    }\n  }\n\n  doChanges(opts) {\n    var callback = opts.complete;\n  \n    opts = clone(opts);\n    if ('live' in opts && !('continuous' in opts)) {\n      opts.continuous = opts.live;\n    }\n    opts.processChange = processChange;\n  \n    if (opts.since === 'latest') {\n      opts.since = 'now';\n    }\n    if (!opts.since) {\n      opts.since = 0;\n    }\n    if (opts.since === 'now') {\n      this.db.info().then((info) => {\n        /* istanbul ignore if */\n        if (this.isCancelled) {\n          callback(null, {status: 'cancelled'});\n          return;\n        }\n        opts.since = info.update_seq;\n        this.doChanges(opts);\n      }, callback);\n      return;\n    }\n  \n    /* istanbul ignore else */\n    if (PouchDB._changesFilterPlugin) {\n      PouchDB._changesFilterPlugin.normalize(opts);\n      if (PouchDB._changesFilterPlugin.shouldFilter(this, opts)) {\n        return PouchDB._changesFilterPlugin.filter(this, opts);\n      }\n    } else {\n      ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {\n        if (key in opts) {\n          guardedConsole('warn',\n            'The \"' + key + '\" option was passed in to changes/replicate, ' +\n            'but pouchdb-changes-filter plugin is not installed, so it ' +\n            'was ignored. Please install the plugin to enable filtering.'\n          );\n        }\n      });\n    }\n  \n    if (!('descending' in opts)) {\n      opts.descending = false;\n    }\n  \n    // 0 and 1 should return 1 document\n    opts.limit = opts.limit === 0 ? 1 : opts.limit;\n    opts.complete = callback;\n    var newPromise = this.db._changes(opts);\n    /* istanbul ignore else */\n    if (newPromise && typeof newPromise.cancel === 'function') {\n      const cancel = this.cancel;\n      this.cancel = (...args) => {\n        newPromise.cancel();\n        cancel.apply(this, args);\n      };\n    }\n  }\n}\n\n/*\n * A generic pouch adapter\n */\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback, docId) {\n  return function (err, results) {\n    if (err || (results[0] && results[0].error)) {\n      err = err || results[0];\n      err.docId = docId;\n      callback(err);\n    } else {\n      callback(null, results.length ? results[0]  : results);\n    }\n  };\n}\n\n// clean docs given to us by the user\nfunction cleanDocs(docs) {\n  for (var i = 0; i < docs.length; i++) {\n    var doc = docs[i];\n    if (doc._deleted) {\n      delete doc._attachments; // ignore atts for deleted docs\n    } else if (doc._attachments) {\n      // filter out extraneous keys from _attachments\n      var atts = Object.keys(doc._attachments);\n      for (var j = 0; j < atts.length; j++) {\n        var att = atts[j];\n        doc._attachments[att] = pick(doc._attachments[att],\n          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n      }\n    }\n  }\n}\n\n// compare two docs, first by _id then by _rev\nfunction compareByIdThenRev(a, b) {\n  var idCompare = compare(a._id, b._id);\n  if (idCompare !== 0) {\n    return idCompare;\n  }\n  var aStart = a._revisions ? a._revisions.start : 0;\n  var bStart = b._revisions ? b._revisions.start : 0;\n  return compare(aStart, bStart);\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev});\n    }\n    return rev;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nfunction allDocsKeysParse(opts) {\n  var keys =  ('limit' in opts) ?\n    opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n    (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n  opts.keys = keys;\n  opts.skip = 0;\n  delete opts.limit;\n  if (opts.descending) {\n    keys.reverse();\n    opts.descending = false;\n  }\n}\n\n// all compaction is done in a queue, to avoid attaching\n// too many listeners at once\nfunction doNextCompaction(self) {\n  var task = self._compactionQueue[0];\n  var opts = task.opts;\n  var callback = task.callback;\n  self.get('_local/compaction').catch(function () {\n    return false;\n  }).then(function (doc) {\n    if (doc && doc.last_seq) {\n      opts.last_seq = doc.last_seq;\n    }\n    self._compact(opts, function (err, res) {\n      /* istanbul ignore if */\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, res);\n      }\n      immediate$1(function () {\n        self._compactionQueue.shift();\n        if (self._compactionQueue.length) {\n          doNextCompaction(self);\n        }\n      });\n    });\n  });\n}\n\nfunction appendPurgeSeq(db, docId, rev) {\n  return db.get('_local/purges').then(function (doc) {\n    const purgeSeq = doc.purgeSeq + 1;\n    doc.purges.push({\n      docId,\n      rev,\n      purgeSeq,\n    });\n    if (doc.purges.length > self.purged_infos_limit) {\n      doc.purges.splice(0, doc.purges.length - self.purged_infos_limit);\n    }\n    doc.purgeSeq = purgeSeq;\n    return doc;\n  }).catch(function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return {\n      _id: '_local/purges',\n      purges: [{\n        docId,\n        rev,\n        purgeSeq: 0,\n      }],\n      purgeSeq: 0,\n    };\n  }).then(function (doc) {\n    return db.put(doc);\n  });\n}\n\nfunction attachmentNameError(name) {\n  if (name.charAt(0) === '_') {\n    return name + ' is not a valid attachment name, attachment ' +\n      'names cannot start with \\'_\\'';\n  }\n  return false;\n}\n\nclass AbstractPouchDB extends EE {\n  _setup() {\n    this.post = adapterFun('post', function (doc, opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      if (typeof doc !== 'object' || Array.isArray(doc)) {\n        return callback(createError(NOT_AN_OBJECT));\n      }\n      this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));\n    }).bind(this);\n\n    this.put = adapterFun('put', function (doc, opts, cb) {\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n      if (typeof doc !== 'object' || Array.isArray(doc)) {\n        return cb(createError(NOT_AN_OBJECT));\n      }\n      invalidIdError(doc._id);\n      if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n        if (doc._deleted) {\n          return this._removeLocal(doc, cb);\n        } else {\n          return this._putLocal(doc, cb);\n        }\n      }\n\n      const putDoc = (next) => {\n        if (typeof this._put === 'function' && opts.new_edits !== false) {\n          this._put(doc, opts, next);\n        } else {\n          this.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));\n        }\n      };\n\n      if (opts.force && doc._rev) {\n        transformForceOptionToNewEditsOption();\n        putDoc(function (err) {\n          var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};\n          cb(err, result);\n        });\n      } else {\n        putDoc(cb);\n      }\n\n      function transformForceOptionToNewEditsOption() {\n        var parts = doc._rev.split('-');\n        var oldRevId = parts[1];\n        var oldRevNum = parseInt(parts[0], 10);\n\n        var newRevNum = oldRevNum + 1;\n        var newRevId = rev$$1();\n\n        doc._revisions = {\n          start: newRevNum,\n          ids: [newRevId, oldRevId]\n        };\n        doc._rev = newRevNum + '-' + newRevId;\n        opts.new_edits = false;\n      }\n    }).bind(this);\n\n    this.putAttachment = adapterFun('putAttachment', function (docId, attachmentId, rev, blob, type) {\n      var api = this;\n      if (typeof type === 'function') {\n        type = blob;\n        blob = rev;\n        rev = null;\n      }\n      // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n      /* istanbul ignore if */\n      if (typeof type === 'undefined') {\n        type = blob;\n        blob = rev;\n        rev = null;\n      }\n      if (!type) {\n        guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n      }\n\n      function createAttachment(doc) {\n        var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n        doc._attachments = doc._attachments || {};\n        doc._attachments[attachmentId] = {\n          content_type: type,\n          data: blob,\n          revpos: ++prevrevpos\n        };\n        return api.put(doc);\n      }\n\n      return api.get(docId).then(function (doc) {\n        if (doc._rev !== rev) {\n          throw createError(REV_CONFLICT);\n        }\n\n        return createAttachment(doc);\n      }, function (err) {\n        // create new doc\n        /* istanbul ignore else */\n        if (err.reason === MISSING_DOC.message) {\n          return createAttachment({_id: docId});\n        } else {\n          throw err;\n        }\n      });\n    }).bind(this);\n\n    this.removeAttachment = adapterFun('removeAttachment', function (docId, attachmentId, rev, callback) {\n      this.get(docId, (err, obj) => {\n        /* istanbul ignore if */\n        if (err) {\n          callback(err);\n          return;\n        }\n        if (obj._rev !== rev) {\n          callback(createError(REV_CONFLICT));\n          return;\n        }\n        /* istanbul ignore if */\n        if (!obj._attachments) {\n          return callback();\n        }\n        delete obj._attachments[attachmentId];\n        if (Object.keys(obj._attachments).length === 0) {\n          delete obj._attachments;\n        }\n        this.put(obj, callback);\n      });\n    }).bind(this);\n\n    this.remove = adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n      var doc;\n      if (typeof optsOrRev === 'string') {\n        // id, rev, opts, callback style\n        doc = {\n          _id: docOrId,\n          _rev: optsOrRev\n        };\n        if (typeof opts === 'function') {\n          callback = opts;\n          opts = {};\n        }\n      } else {\n        // doc, opts, callback style\n        doc = docOrId;\n        if (typeof optsOrRev === 'function') {\n          callback = optsOrRev;\n          opts = {};\n        } else {\n          callback = opts;\n          opts = optsOrRev;\n        }\n      }\n      opts = opts || {};\n      opts.was_delete = true;\n      var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n      newDoc._deleted = true;\n      if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n        return this._removeLocal(doc, callback);\n      }\n      this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));\n    }).bind(this);\n\n    this.revsDiff = adapterFun('revsDiff', function (req, opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      var ids = Object.keys(req);\n\n      if (!ids.length) {\n        return callback(null, {});\n      }\n\n      var count = 0;\n      var missing = new ExportedMap();\n\n      function addToMissing(id, revId) {\n        if (!missing.has(id)) {\n          missing.set(id, {missing: []});\n        }\n        missing.get(id).missing.push(revId);\n      }\n\n      function processDoc(id, rev_tree) {\n        // Is this fast enough? Maybe we should switch to a set simulated by a map\n        var missingForId = req[id].slice(0);\n        traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n          opts) {\n            var rev = pos + '-' + revHash;\n            var idx = missingForId.indexOf(rev);\n            if (idx === -1) {\n              return;\n            }\n\n            missingForId.splice(idx, 1);\n            /* istanbul ignore if */\n            if (opts.status !== 'available') {\n              addToMissing(id, rev);\n            }\n          });\n\n        // Traversing the tree is synchronous, so now `missingForId` contains\n        // revisions that were not found in the tree\n        missingForId.forEach(function (rev) {\n          addToMissing(id, rev);\n        });\n      }\n\n      ids.map(function (id) {\n        this._getRevisionTree(id, function (err, rev_tree) {\n          if (err && err.status === 404 && err.message === 'missing') {\n            missing.set(id, {missing: req[id]});\n          } else if (err) {\n            /* istanbul ignore next */\n            return callback(err);\n          } else {\n            processDoc(id, rev_tree);\n          }\n\n          if (++count === ids.length) {\n            // convert LazyMap to object\n            var missingObj = {};\n            missing.forEach(function (value, key) {\n              missingObj[key] = value;\n            });\n            return callback(null, missingObj);\n          }\n        });\n      }, this);\n    }).bind(this);\n\n    // _bulk_get API for faster replication, as described in\n    // https://github.com/apache/couchdb-chttpd/pull/33\n    // At the \"abstract\" level, it will just run multiple get()s in\n    // parallel, because this isn't much of a performance cost\n    // for local databases (except the cost of multiple transactions, which is\n    // small). The http adapter overrides this in order\n    // to do a more efficient single HTTP request.\n    this.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n      bulkGet(this, opts, callback);\n    }).bind(this);\n\n    // compact one document and fire callback\n    // by compacting we mean removing all revisions which\n    // are further from the leaf in revision tree than max_height\n    this.compactDocument = adapterFun('compactDocument', function (docId, maxHeight, callback) {\n      this._getRevisionTree(docId, (err, revTree) => {\n        /* istanbul ignore if */\n        if (err) {\n          return callback(err);\n        }\n        var height = computeHeight(revTree);\n        var candidates = [];\n        var revs = [];\n        Object.keys(height).forEach(function (rev) {\n          if (height[rev] > maxHeight) {\n            candidates.push(rev);\n          }\n        });\n\n        traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n          var rev = pos + '-' + revHash;\n          if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {\n            revs.push(rev);\n          }\n        });\n        this._doCompaction(docId, revs, callback);\n      });\n    }).bind(this);\n\n    // compact the whole database using single document\n    // compaction\n    this.compact = adapterFun('compact', function (opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n\n      opts = opts || {};\n\n      this._compactionQueue = this._compactionQueue || [];\n      this._compactionQueue.push({opts: opts, callback: callback});\n      if (this._compactionQueue.length === 1) {\n        doNextCompaction(this);\n      }\n    }).bind(this);\n\n    /* Begin api wrappers. Specific functionality to storage belongs in the _[method] */\n    this.get = adapterFun('get', function (id, opts, cb) {\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n      if (typeof id !== 'string') {\n        return cb(createError(INVALID_ID));\n      }\n      if (isLocalId(id) && typeof this._getLocal === 'function') {\n        return this._getLocal(id, cb);\n      }\n      var leaves = [];\n\n      const finishOpenRevs = () => {\n        var result = [];\n        var count = leaves.length;\n        /* istanbul ignore if */\n        if (!count) {\n          return cb(null, result);\n        }\n\n        // order with open_revs is unspecified\n        leaves.forEach((leaf) => {\n          this.get(id, {\n            rev: leaf,\n            revs: opts.revs,\n            latest: opts.latest,\n            attachments: opts.attachments,\n            binary: opts.binary\n          }, function (err, doc) {\n            if (!err) {\n              // using latest=true can produce duplicates\n              var existing;\n              for (var i = 0, l = result.length; i < l; i++) {\n                if (result[i].ok && result[i].ok._rev === doc._rev) {\n                  existing = true;\n                  break;\n                }\n              }\n              if (!existing) {\n                result.push({ok: doc});\n              }\n            } else {\n              result.push({missing: leaf});\n            }\n            count--;\n            if (!count) {\n              cb(null, result);\n            }\n          });\n        });\n      };\n\n      if (opts.open_revs) {\n        if (opts.open_revs === \"all\") {\n          this._getRevisionTree(id, function (err, rev_tree) {\n            /* istanbul ignore if */\n            if (err) {\n              return cb(err);\n            }\n            leaves = collectLeaves(rev_tree).map(function (leaf) {\n              return leaf.rev;\n            });\n            finishOpenRevs();\n          });\n        } else {\n          if (Array.isArray(opts.open_revs)) {\n            leaves = opts.open_revs;\n            for (var i = 0; i < leaves.length; i++) {\n              var l = leaves[i];\n              // looks like it's the only thing couchdb checks\n              if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n                return cb(createError(INVALID_REV));\n              }\n            }\n            finishOpenRevs();\n          } else {\n            return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n          }\n        }\n        return; // open_revs does not like other options\n      }\n\n      return this._get(id, opts, (err, result) => {\n        if (err) {\n          err.docId = id;\n          return cb(err);\n        }\n\n        var doc = result.doc;\n        var metadata = result.metadata;\n        var ctx = result.ctx;\n\n        if (opts.conflicts) {\n          var conflicts = collectConflicts(metadata);\n          if (conflicts.length) {\n            doc._conflicts = conflicts;\n          }\n        }\n\n        if (isDeleted(metadata, doc._rev)) {\n          doc._deleted = true;\n        }\n\n        if (opts.revs || opts.revs_info) {\n          var splittedRev = doc._rev.split('-');\n          var revNo       = parseInt(splittedRev[0], 10);\n          var revHash     = splittedRev[1];\n\n          var paths = rootToLeaf(metadata.rev_tree);\n          var path = null;\n\n          for (var i = 0; i < paths.length; i++) {\n            var currentPath = paths[i];\n            var hashIndex = currentPath.ids.map(function (x) { return x.id; })\n              .indexOf(revHash);\n            var hashFoundAtRevPos = hashIndex === (revNo - 1);\n\n            if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {\n              path = currentPath;\n            }\n          }\n\n          /* istanbul ignore if */\n          if (!path) {\n            err = new Error('invalid rev tree');\n            err.docId = id;\n            return cb(err);\n          }\n\n          var indexOfRev = path.ids.map(function (x) { return x.id; })\n            .indexOf(doc._rev.split('-')[1]) + 1;\n          var howMany = path.ids.length - indexOfRev;\n          path.ids.splice(indexOfRev, howMany);\n          path.ids.reverse();\n\n          if (opts.revs) {\n            doc._revisions = {\n              start: (path.pos + path.ids.length) - 1,\n              ids: path.ids.map(function (rev) {\n                return rev.id;\n              })\n            };\n          }\n          if (opts.revs_info) {\n            var pos =  path.pos + path.ids.length;\n            doc._revs_info = path.ids.map(function (rev) {\n              pos--;\n              return {\n                rev: pos + '-' + rev.id,\n                status: rev.opts.status\n              };\n            });\n          }\n        }\n\n        if (opts.attachments && doc._attachments) {\n          var attachments = doc._attachments;\n          var count = Object.keys(attachments).length;\n          if (count === 0) {\n            return cb(null, doc);\n          }\n          Object.keys(attachments).forEach((key) => {\n            this._getAttachment(doc._id, key, attachments[key], {\n              // Previously the revision handling was done in adapter.js\n              // getAttachment, however since idb-next doesnt we need to\n              // pass the rev through\n              rev: doc._rev,\n              binary: opts.binary,\n              ctx: ctx\n            }, function (err, data) {\n              var att = doc._attachments[key];\n              att.data = data;\n              delete att.stub;\n              delete att.length;\n              if (!--count) {\n                cb(null, doc);\n              }\n            });\n          });\n        } else {\n          if (doc._attachments) {\n            for (var key in doc._attachments) {\n              /* istanbul ignore else */\n              if (Object.prototype.hasOwnProperty.call(doc._attachments, key)) {\n                doc._attachments[key].stub = true;\n              }\n            }\n          }\n          cb(null, doc);\n        }\n      });\n    }).bind(this);\n\n    // TODO: I dont like this, it forces an extra read for every\n    // attachment read and enforces a confusing api between\n    // adapter.js and the adapter implementation\n    this.getAttachment = adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n      if (opts instanceof Function) {\n        callback = opts;\n        opts = {};\n      }\n      this._get(docId, opts, (err, res) => {\n        if (err) {\n          return callback(err);\n        }\n        if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n          opts.ctx = res.ctx;\n          opts.binary = true;\n          this._getAttachment(docId, attachmentId,\n                              res.doc._attachments[attachmentId], opts, callback);\n        } else {\n          return callback(createError(MISSING_DOC));\n        }\n      });\n    }).bind(this);\n\n    this.allDocs = adapterFun('allDocs', function (opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n      if (opts.start_key) {\n        opts.startkey = opts.start_key;\n      }\n      if (opts.end_key) {\n        opts.endkey = opts.end_key;\n      }\n      if ('keys' in opts) {\n        if (!Array.isArray(opts.keys)) {\n          return callback(new TypeError('options.keys must be an array'));\n        }\n        var incompatibleOpt =\n          ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n          return incompatibleOpt in opts;\n        })[0];\n        if (incompatibleOpt) {\n          callback(createError(QUERY_PARSE_ERROR,\n            'Query parameter `' + incompatibleOpt +\n            '` is not compatible with multi-get'\n          ));\n          return;\n        }\n        if (!isRemote(this)) {\n          allDocsKeysParse(opts);\n          if (opts.keys.length === 0) {\n            return this._allDocs({limit: 0}, callback);\n          }\n        }\n      }\n\n      return this._allDocs(opts, callback);\n    }).bind(this);\n\n    this.close = adapterFun('close', function (callback) {\n      this._closed = true;\n      this.emit('closed');\n      return this._close(callback);\n    }).bind(this);\n\n    this.info = adapterFun('info', function (callback) {\n      this._info((err, info) => {\n        if (err) {\n          return callback(err);\n        }\n        // assume we know better than the adapter, unless it informs us\n        info.db_name = info.db_name || this.name;\n        info.auto_compaction = !!(this.auto_compaction && !isRemote(this));\n        info.adapter = this.adapter;\n        callback(null, info);\n      });\n    }).bind(this);\n\n    this.id = adapterFun('id', function (callback) {\n      return this._id(callback);\n    }).bind(this);\n\n    this.bulkDocs = adapterFun('bulkDocs', function (req, opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n\n      opts = opts || {};\n\n      if (Array.isArray(req)) {\n        req = {\n          docs: req\n        };\n      }\n\n      if (!req || !req.docs || !Array.isArray(req.docs)) {\n        return callback(createError(MISSING_BULK_DOCS));\n      }\n\n      for (var i = 0; i < req.docs.length; ++i) {\n        if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n          return callback(createError(NOT_AN_OBJECT));\n        }\n      }\n\n      var attachmentError;\n      req.docs.forEach(function (doc) {\n        if (doc._attachments) {\n          Object.keys(doc._attachments).forEach(function (name) {\n            attachmentError = attachmentError || attachmentNameError(name);\n            if (!doc._attachments[name].content_type) {\n              guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n            }\n          });\n        }\n      });\n\n      if (attachmentError) {\n        return callback(createError(BAD_REQUEST, attachmentError));\n      }\n\n      if (!('new_edits' in opts)) {\n        if ('new_edits' in req) {\n          opts.new_edits = req.new_edits;\n        } else {\n          opts.new_edits = true;\n        }\n      }\n\n      var adapter = this;\n      if (!opts.new_edits && !isRemote(adapter)) {\n        // ensure revisions of the same doc are sorted, so that\n        // the local adapter processes them correctly (#2935)\n        req.docs.sort(compareByIdThenRev);\n      }\n\n      cleanDocs(req.docs);\n\n      // in the case of conflicts, we want to return the _ids to the user\n      // however, the underlying adapter may destroy the docs array, so\n      // create a copy here\n      var ids = req.docs.map(function (doc) {\n        return doc._id;\n      });\n\n      this._bulkDocs(req, opts, function (err, res) {\n        if (err) {\n          return callback(err);\n        }\n        if (!opts.new_edits) {\n          // this is what couch does when new_edits is false\n          res = res.filter(function (x) {\n            return x.error;\n          });\n        }\n        // add ids for error/conflict responses (not required for CouchDB)\n        if (!isRemote(adapter)) {\n          for (var i = 0, l = res.length; i < l; i++) {\n            res[i].id = res[i].id || ids[i];\n          }\n        }\n\n        callback(null, res);\n      });\n    }).bind(this);\n\n    this.registerDependentDatabase = adapterFun('registerDependentDatabase', function (dependentDb, callback) {\n      var dbOptions = clone(this.__opts);\n      if (this.__opts.view_adapter) {\n        dbOptions.adapter = this.__opts.view_adapter;\n      }\n\n      var depDB = new this.constructor(dependentDb, dbOptions);\n\n      function diffFun(doc) {\n        doc.dependentDbs = doc.dependentDbs || {};\n        if (doc.dependentDbs[dependentDb]) {\n          return false; // no update required\n        }\n        doc.dependentDbs[dependentDb] = true;\n        return doc;\n      }\n      upsert(this, '_local/_pouch_dependentDbs', diffFun).then(function () {\n        callback(null, {db: depDB});\n      }).catch(callback);\n    }).bind(this);\n\n    this.destroy = adapterFun('destroy', function (opts, callback) {\n\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n\n      var usePrefix = 'use_prefix' in this ? this.use_prefix : true;\n\n      const destroyDb = () => {\n        // call destroy method of the particular adaptor\n        this._destroy(opts, (err, resp) => {\n          if (err) {\n            return callback(err);\n          }\n          this._destroyed = true;\n          this.emit('destroyed');\n          callback(null, resp || { 'ok': true });\n        });\n      };\n\n      if (isRemote(this)) {\n        // no need to check for dependent DBs if it's a remote DB\n        return destroyDb();\n      }\n\n      this.get('_local/_pouch_dependentDbs', (err, localDoc) => {\n        if (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            return callback(err);\n          } else { // no dependencies\n            return destroyDb();\n          }\n        }\n        var dependentDbs = localDoc.dependentDbs;\n        var PouchDB = this.constructor;\n        var deletedMap = Object.keys(dependentDbs).map((name) => {\n          // use_prefix is only false in the browser\n          /* istanbul ignore next */\n          var trueName = usePrefix ?\n            name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n          return new PouchDB(trueName, this.__opts).destroy();\n        });\n        Promise.all(deletedMap).then(destroyDb, callback);\n      });\n    }).bind(this);\n  }\n\n  _compact(opts, callback) {\n    var changesOpts = {\n      return_docs: false,\n      last_seq: opts.last_seq || 0\n    };\n    var promises = [];\n\n    var taskId;\n    var compactedDocs = 0;\n\n    const onChange = (row) => {\n      this.activeTasks.update(taskId, {\n        completed_items: ++compactedDocs\n      });\n      promises.push(this.compactDocument(row.id, 0));\n    };\n    const onError = (err) => {\n      this.activeTasks.remove(taskId, err);\n      callback(err);\n    };\n    const onComplete = (resp) => {\n      var lastSeq = resp.last_seq;\n      Promise.all(promises).then(() => {\n        return upsert(this, '_local/compaction', (doc) => {\n          if (!doc.last_seq || doc.last_seq < lastSeq) {\n            doc.last_seq = lastSeq;\n            return doc;\n          }\n          return false; // somebody else got here first, don't update\n        });\n      }).then(() => {\n        this.activeTasks.remove(taskId);\n        callback(null, {ok: true});\n      }).catch(onError);\n    };\n\n    this.info().then((info) => {\n      taskId = this.activeTasks.add({\n        name: 'database_compaction',\n        total_items: info.update_seq - changesOpts.last_seq,\n      });\n\n      this.changes(changesOpts)\n        .on('change', onChange)\n        .on('complete', onComplete)\n        .on('error', onError);\n    });\n  }\n\n  changes(opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    opts = opts || {};\n\n    // By default set return_docs to false if the caller has opts.live = true,\n    // this will prevent us from collecting the set of changes indefinitely\n    // resulting in growing memory\n    opts.return_docs = ('return_docs' in opts) ? opts.return_docs : !opts.live;\n\n    return new Changes$1(this, opts, callback);\n  }\n\n  type() {\n    return (typeof this._type === 'function') ? this._type() : this.adapter;\n  }\n}\n\n// The abstract purge implementation expects a doc id and the rev of a leaf node in that doc.\n// It will return errors if the rev doesn\u2019t exist or isn\u2019t a leaf.\nAbstractPouchDB.prototype.purge = adapterFun('_purge', function (docId, rev, callback) {\n  if (typeof this._purge === 'undefined') {\n    return callback(createError(UNKNOWN_ERROR, 'Purge is not implemented in the ' + this.adapter + ' adapter.'));\n  }\n  var self = this;\n\n  self._getRevisionTree(docId, (error, revs) => {\n    if (error) {\n      return callback(error);\n    }\n    if (!revs) {\n      return callback(createError(MISSING_DOC));\n    }\n    let path;\n    try {\n      path = findPathToLeaf(revs, rev);\n    } catch (error) {\n      return callback(error.message || error);\n    }\n    self._purge(docId, path, (error, result) => {\n      if (error) {\n        return callback(error);\n      } else {\n        appendPurgeSeq(self, docId, rev).then(function () {\n          return callback(null, result);\n        });\n      }\n    });\n  });\n});\n\nclass TaskQueue {\n  constructor() {\n    this.isReady = false;\n    this.failed = false;\n    this.queue = [];\n  }\n\n  execute() {\n    var fun;\n    if (this.failed) {\n      while ((fun = this.queue.shift())) {\n        fun(this.failed);\n      }\n    } else {\n      while ((fun = this.queue.shift())) {\n        fun();\n      }\n    }\n  }\n\n  fail(err) {\n    this.failed = err;\n    this.execute();\n  }\n\n  ready(db) {\n    this.isReady = true;\n    this.db = db;\n    this.execute();\n  }\n\n  addTask(fun) {\n    this.queue.push(fun);\n    if (this.failed) {\n      this.execute();\n    }\n  }\n}\n\nfunction parseAdapter(name, opts) {\n  var match = name.match(/([a-z-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    return {\n      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n      adapter: match[1]\n    };\n  }\n\n  var adapters = PouchDB.adapters;\n  var preferredAdapters = PouchDB.preferredAdapters;\n  var prefix = PouchDB.prefix;\n  var adapterName = opts.adapter;\n\n  if (!adapterName) { // automatically determine adapter\n    for (var i = 0; i < preferredAdapters.length; ++i) {\n      adapterName = preferredAdapters[i];\n      // check for browsers that have been upgraded from websql-only to websql+idb\n      /* istanbul ignore if */\n      if (adapterName === 'idb' && 'websql' in adapters &&\n          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n        // log it, because this can be confusing during development\n        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n          ' avoid data loss, because it was already opened with WebSQL.');\n        continue; // keep using websql to avoid user data loss\n      }\n      break;\n    }\n  }\n\n  var adapter = adapters[adapterName];\n\n  // if adapter is invalid, then an error will be thrown later\n  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n    adapter.use_prefix : true;\n\n  return {\n    name: usePrefix ? (prefix + name) : name,\n    adapter: adapterName\n  };\n}\n\nfunction inherits(A, B) {\n  A.prototype = Object.create(B.prototype, {\n    constructor: { value: A }\n  });\n}\n\nfunction createClass(parent, init) {\n  let klass = function (...args) {\n    if (!(this instanceof klass)) {\n      return new klass(...args);\n    }\n    init.apply(this, args);\n  };\n  inherits(klass, parent);\n  return klass;\n}\n\n// OK, so here's the deal. Consider this code:\n//     var db1 = new PouchDB('foo');\n//     var db2 = new PouchDB('foo');\n//     db1.destroy();\n// ^ these two both need to emit 'destroyed' events,\n// as well as the PouchDB constructor itself.\n// So we have one db object (whichever one got destroy() called on it)\n// responsible for emitting the initial event, which then gets emitted\n// by the constructor, which then broadcasts it to any other dbs\n// that may have been created with the same name.\nfunction prepareForDestruction(self) {\n\n  function onDestroyed(from_constructor) {\n    self.removeListener('closed', onClosed);\n    if (!from_constructor) {\n      self.constructor.emit('destroyed', self.name);\n    }\n  }\n\n  function onClosed() {\n    self.removeListener('destroyed', onDestroyed);\n    self.constructor.emit('unref', self);\n  }\n\n  self.once('destroyed', onDestroyed);\n  self.once('closed', onClosed);\n  self.constructor.emit('ref', self);\n}\n\nclass PouchInternal extends AbstractPouchDB {\n  constructor(name, opts) {\n    super();\n    this._setup(name, opts);\n  }\n\n  _setup(name, opts) {\n    super._setup();\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    if (opts.deterministic_revs === undefined) {\n      opts.deterministic_revs = true;\n    }\n\n    this.__opts = opts = clone(opts);\n\n    this.auto_compaction = opts.auto_compaction;\n    this.purged_infos_limit = opts.purged_infos_limit || 1000;\n    this.prefix = PouchDB.prefix;\n\n    if (typeof name !== 'string') {\n      throw new Error('Missing/invalid DB name');\n    }\n\n    var prefixedName = (opts.prefix || '') + name;\n    var backend = parseAdapter(prefixedName, opts);\n\n    opts.name = backend.name;\n    opts.adapter = opts.adapter || backend.adapter;\n\n    this.name = name;\n    this._adapter = opts.adapter;\n    PouchDB.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);\n\n    if (!PouchDB.adapters[opts.adapter] ||\n        !PouchDB.adapters[opts.adapter].valid()) {\n      throw new Error('Invalid Adapter: ' + opts.adapter);\n    }\n\n    if (opts.view_adapter) {\n      if (!PouchDB.adapters[opts.view_adapter] ||\n          !PouchDB.adapters[opts.view_adapter].valid()) {\n        throw new Error('Invalid View Adapter: ' + opts.view_adapter);\n      }\n    }\n\n    this.taskqueue = new TaskQueue();\n\n    this.adapter = opts.adapter;\n\n    PouchDB.adapters[opts.adapter].call(this, opts, (err) => {\n      if (err) {\n        return this.taskqueue.fail(err);\n      }\n      prepareForDestruction(this);\n\n      this.emit('created', this);\n      PouchDB.emit('created', this.name);\n      this.taskqueue.ready(this);\n    });\n  }\n}\n\nconst PouchDB = createClass(PouchInternal, function (name, opts) {\n  PouchInternal.prototype._setup.call(this, name, opts);\n});\n\n// AbortController was introduced quite a while after fetch and\n// isnt required for PouchDB to function so polyfill if needed\nvar a = (typeof AbortController !== 'undefined')\n    ? AbortController\n    : function () { return {abort: function () {}}; };\n\nvar f$1 = fetch;\nvar h = Headers;\n\nclass ActiveTasks {\n  constructor() {\n    this.tasks = {};\n  }\n\n  list() {\n    return Object.values(this.tasks);\n  }\n\n  add(task) {\n    const id = v4();\n    this.tasks[id] = {\n      id,\n      name: task.name,\n      total_items: task.total_items,\n      created_at: new Date().toJSON()\n    };\n    return id;\n  }\n\n  get(id) {\n    return this.tasks[id];\n  }\n\n  /* eslint-disable no-unused-vars */\n  remove(id, reason) {\n    delete this.tasks[id];\n    return this.tasks;\n  }\n\n  update(id, updatedTask) {\n    const task = this.tasks[id];\n    if (typeof task !== 'undefined') {\n      const mergedTask = {\n        id: task.id,\n        name: task.name,\n        created_at: task.created_at,\n        total_items: updatedTask.total_items || task.total_items,\n        completed_items: updatedTask.completed_items || task.completed_items,\n        updated_at: new Date().toJSON()\n      };\n      this.tasks[id] = mergedTask;\n    }\n    return this.tasks;\n  }\n}\n\nPouchDB.adapters = {};\nPouchDB.preferredAdapters = [];\n\nPouchDB.prefix = '_pouch_';\n\nvar eventEmitter = new EE();\n\nfunction setUpEventEmitter(Pouch) {\n  Object.keys(EE.prototype).forEach(function (key) {\n    if (typeof EE.prototype[key] === 'function') {\n      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n    }\n  });\n\n  // these are created in constructor.js, and allow us to notify each DB with\n  // the same name that it was destroyed, via the constructor object\n  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n\n  Pouch.on('ref', function onConstructorRef(db) {\n    if (!destructListeners.has(db.name)) {\n      destructListeners.set(db.name, []);\n    }\n    destructListeners.get(db.name).push(db);\n  });\n\n  Pouch.on('unref', function onConstructorUnref(db) {\n    if (!destructListeners.has(db.name)) {\n      return;\n    }\n    var dbList = destructListeners.get(db.name);\n    var pos = dbList.indexOf(db);\n    if (pos < 0) {\n      /* istanbul ignore next */\n      return;\n    }\n    dbList.splice(pos, 1);\n    if (dbList.length > 1) {\n      /* istanbul ignore next */\n      destructListeners.set(db.name, dbList);\n    } else {\n      destructListeners.delete(db.name);\n    }\n  });\n\n  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n    if (!destructListeners.has(name)) {\n      return;\n    }\n    var dbList = destructListeners.get(name);\n    destructListeners.delete(name);\n    dbList.forEach(function (db) {\n      db.emit('destroyed',true);\n    });\n  });\n}\n\nsetUpEventEmitter(PouchDB);\n\nPouchDB.adapter = function (id, obj, addToPreferredAdapters) {\n  /* istanbul ignore else */\n  if (obj.valid()) {\n    PouchDB.adapters[id] = obj;\n    if (addToPreferredAdapters) {\n      PouchDB.preferredAdapters.push(id);\n    }\n  }\n};\n\nPouchDB.plugin = function (obj) {\n  if (typeof obj === 'function') { // function style for plugins\n    obj(PouchDB);\n  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {\n    throw new Error('Invalid plugin: got \"' + obj + '\", expected an object or a function');\n  } else {\n    Object.keys(obj).forEach(function (id) { // object style for plugins\n      PouchDB.prototype[id] = obj[id];\n    });\n  }\n  if (this.__defaults) {\n    PouchDB.__defaults = $inject_Object_assign({}, this.__defaults);\n  }\n  return PouchDB;\n};\n\nPouchDB.defaults = function (defaultOpts) {\n  let PouchWithDefaults = createClass(PouchDB, function (name, opts) {\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    opts = $inject_Object_assign({}, PouchWithDefaults.__defaults, opts);\n    PouchDB.call(this, name, opts);\n  });\n\n  PouchWithDefaults.preferredAdapters = PouchDB.preferredAdapters.slice();\n  Object.keys(PouchDB).forEach(function (key) {\n    if (!(key in PouchWithDefaults)) {\n      PouchWithDefaults[key] = PouchDB[key];\n    }\n  });\n\n  // make default options transitive\n  // https://github.com/pouchdb/pouchdb/issues/5922\n  PouchWithDefaults.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);\n\n  return PouchWithDefaults;\n};\n\nPouchDB.fetch = function (url, opts) {\n  return f$1(url, opts);\n};\n\nPouchDB.prototype.activeTasks = PouchDB.activeTasks = new ActiveTasks();\n\n// managed automatically by set-version.js\nvar version = \"7.0.0-prerelease\";\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction compare$1(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (i > 0 && fieldName[i - 1] === '\\\\' && (ch === '$' || ch === '.')) {\n      // escaped delimiter\n      current = current.substring(0, current.length - 1) + ch;\n    } else if (ch === '.') {\n      // When `.` is not escaped (above), it is a field delimiter\n      fields.push(current);\n      current = '';\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n  var first = {$or: true, $nor: true};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        // or, nor\n        if (matcher instanceof Array) {\n          if (first[field]) {\n            first[field] = false;\n            res[field] = matcher;\n            return;\n          }\n\n          var entries = [];\n          res[field].forEach(function (existing) {\n            Object.keys(matcher).forEach(function (key) {\n              var m = matcher[key];\n              var longest = Math.max(Object.keys(existing).length, Object.keys(m).length);\n              var merged = mergeAndedSelectors([existing, m]);\n              if (Object.keys(merged).length <= longest) {\n                // we have a situation like: (a :{$eq :1} || ...) && (a {$eq: 2} || ...)\n                // merging would produce a $eq 2 when actually we shouldn't ever match against these merged conditions\n                // merged should always contain more values to be valid\n                return;\n              }\n              entries.push(merged);\n            });\n          });\n          res[field] = entries;\n        } else {\n          // not\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          } else if (operator === \"$regex\") {\n            return mergeRegex(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n// combine $regex values into one array\nfunction mergeRegex(value, fieldMatchers) {\n  if ('$regex' in fieldMatchers) {\n    // a value could match multiple regexes\n    fieldMatchers.$regex.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$regex = [value];\n  }\n}\n\n//#7458: execute function mergeAndedSelectors on nested $and\nfunction mergeAndedSelectorsNested(obj) {\n    for (var prop in obj) {\n        if (Array.isArray(obj)) {\n            for (var i in obj) {\n                if (obj[i]['$and']) {\n                    obj[i] = mergeAndedSelectors(obj[i]['$and']);\n                }\n            }\n        }\n        var value = obj[prop];\n        if (typeof value === 'object') {\n            mergeAndedSelectorsNested(value); // <- recursive call\n        }\n    }\n    return obj;\n}\n\n//#7458: determine id $and is present in selector (at any level)\nfunction isAndInSelector(obj, isAnd) {\n    for (var prop in obj) {\n        if (prop === '$and') {\n            isAnd = true;\n        }\n        var value = obj[prop];\n        if (typeof value === 'object') {\n            isAnd = isAndInSelector(value, isAnd); // <- recursive call\n        }\n    }\n    return isAnd;\n}\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n\n  //#7458: if $and is present in selector (at any level) merge nested $and\n  if (isAndInSelector(result, false)) {\n    result = mergeAndedSelectorsNested(result);\n    if ('$and' in result) {\n      result = mergeAndedSelectors(result['$and']);\n    }\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    }\n    result[field] = matcher;\n  }\n\n  normalizeArrayOperators(result);\n\n  return result;\n}\n\n//\n// The $ne and $regex values must be placed in an array because these operators can be used multiple times on the same field.\n// When $and is used, mergeAndedSelectors takes care of putting some of them into arrays, otherwise it's done here.\n//\nfunction normalizeArrayOperators(selector) {\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n\n    if (Array.isArray(matcher)) {\n      matcher.forEach(function (matcherItem) {\n        if (matcherItem && typeof matcherItem === 'object') {\n          normalizeArrayOperators(matcherItem);\n        }\n      });\n    } else if (field === '$ne') {\n      selector.$ne = [matcher];\n    } else if (field === '$regex') {\n      selector.$regex = [matcher];\n    } else if (matcher && typeof matcher === 'object') {\n      normalizeArrayOperators(matcher);\n    }\n  });\n}\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging\n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (Object.prototype.hasOwnProperty.call(origKey, k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        /* eslint-disable no-control-regex */\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n        /* eslint-enable no-control-regex */\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        /* eslint-disable no-control-regex */\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        /* eslint-enable no-control-regex */\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare$1(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  // is matcher an object, if so continue recursion\n  if (typeof matcher === 'object') {\n    return Object.keys(matcher).every(function (maybeUserOperator) {\n      var userValue = matcher[ maybeUserOperator ];\n      // explicit operator\n      if (maybeUserOperator.indexOf(\"$\") === 0) {\n        return match(maybeUserOperator, doc, userValue, parsedField, docFieldValue);\n      } else {\n        var subParsedField = parseField(maybeUserOperator);\n\n        if (\n          docFieldValue === undefined &&\n          typeof userValue !== \"object\" &&\n          subParsedField.length > 0\n        ) {\n          // the field does not exist, return or getFieldFromDoc will throw\n          return false;\n        }\n\n        var subDocFieldValue = getFieldFromDoc(docFieldValue, subParsedField);\n\n        if (typeof userValue === \"object\") {\n          // field value is an object that might contain more operators\n          return matchSelector(userValue, doc, parsedField, subDocFieldValue);\n        }\n\n        // implicit operator\n        return match(\"$eq\", doc, userValue, subParsedField, subDocFieldValue);\n      }\n    });\n  }\n\n  // no more depth, No need to recurse further\n  return matcher === docFieldValue;\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    /* istanbul ignore next */\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  if (typeof docFieldValue !== \"number\" ||\n    parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  var divisor = userValue[0];\n  var mod = userValue[1];\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.some(function (docFieldValueItem) {\n        return collate(val, docFieldValueItem) === 0;\n      });\n    }\n\n    return collate(val, docFieldValue) === 0;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.some(function (docFieldValueItem) {\n      return collate(val, docFieldValueItem) === 0;\n    });\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object' &&  docFieldValue[0] !== null) {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object' &&  docFieldValue[0] !== null) {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) &&\n      Array.isArray(docFieldValue) &&\n      arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) &&\n      typeof docFieldValue == \"string\" &&\n      userValue.every(function (regexValue) {\n        return regexMatch(docFieldValue, regexValue);\n      });\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nfunction evalFilter(input) {\n  return scopeEval('\"use strict\";\\nreturn ' + input + ';', {});\n}\n\nfunction evalView(input) {\n  var code = [\n    'return function(doc) {',\n    '  \"use strict\";',\n    '  var emitted = false;',\n    '  var emit = function (a, b) {',\n    '    emitted = true;',\n    '  };',\n    '  var view = ' + input + ';',\n    '  view(doc);',\n    '  if (emitted) {',\n    '    return true;',\n    '  }',\n    '};'\n  ].join('\\n');\n\n  return scopeEval(code, {});\n}\n\nfunction validate(opts, callback) {\n  if (opts.selector) {\n    if (opts.filter && opts.filter !== '_selector') {\n      var filterName = typeof opts.filter === 'string' ?\n        opts.filter : 'function';\n      return callback(new Error('selector invalid for filter \"' + filterName + '\"'));\n    }\n  }\n  callback();\n}\n\nfunction normalize(opts) {\n  if (opts.view && !opts.filter) {\n    opts.filter = '_view';\n  }\n\n  if (opts.selector && !opts.filter) {\n    opts.filter = '_selector';\n  }\n\n  if (opts.filter && typeof opts.filter === 'string') {\n    if (opts.filter === '_view') {\n      opts.view = normalizeDesignDocFunctionName(opts.view);\n    } else {\n      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n    }\n  }\n}\n\nfunction shouldFilter(changesHandler, opts) {\n  return opts.filter && typeof opts.filter === 'string' &&\n    !opts.doc_ids && !isRemote(changesHandler.db);\n}\n\nfunction filter(changesHandler, opts) {\n  var callback = opts.complete;\n  if (opts.filter === '_view') {\n    if (!opts.view || typeof opts.view !== 'string') {\n      var err = createError(BAD_REQUEST,\n        '`view` filter parameter not found or invalid.');\n      return callback(err);\n    }\n    // fetch a view from a design doc, make it behave like a filter\n    var viewName = parseDesignDocFunctionName(opts.view);\n    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n        ddoc.views[viewName[1]].map;\n      if (!mapFun) {\n        return callback(createError(MISSING_DOC,\n          (ddoc.views ? 'missing json key: ' + viewName[1] :\n            'missing json key: views')));\n      }\n      opts.filter = evalView(mapFun);\n      changesHandler.doChanges(opts);\n    });\n  } else if (opts.selector) {\n    opts.filter = function (doc) {\n      return matchesSelector(doc, opts.selector);\n    };\n    changesHandler.doChanges(opts);\n  } else {\n    // fetch a filter from a design doc\n    var filterName = parseDesignDocFunctionName(opts.filter);\n    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n      if (!filterFun) {\n        return callback(createError(MISSING_DOC,\n          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n            : 'missing json key: filters')));\n      }\n      opts.filter = evalFilter(filterFun);\n      changesHandler.doChanges(opts);\n    });\n  }\n}\n\nfunction applyChangesFilterPlugin(PouchDB) {\n  PouchDB._changesFilterPlugin = {\n    validate: validate,\n    normalize: normalize,\n    shouldFilter: shouldFilter,\n    filter: filter\n  };\n}\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB.plugin(applyChangesFilterPlugin);\n\nPouchDB.version = version;\n\nvar IDB_NULL = Number.MIN_SAFE_INTEGER;\nvar IDB_FALSE = Number.MIN_SAFE_INTEGER + 1;\nvar IDB_TRUE = Number.MIN_SAFE_INTEGER + 2;\n\n// These are the same as bellow but without the global flag\n// we want to use RegExp.test because it's really fast, but the global flag\n// makes the regex const stateful (seriously) as it walked through all instances\nvar TEST_KEY_INVALID = /^[^a-zA-Z_$]|[^a-zA-Z0-9_$]+/;\nvar TEST_PATH_INVALID = /\\\\.|(^|\\.)[^a-zA-Z_$]|[^a-zA-Z0-9_$.]+/;\nfunction needsSanitise(name, isPath) {\n  if (isPath) {\n    return TEST_PATH_INVALID.test(name);\n  } else {\n    return TEST_KEY_INVALID.test(name);\n  }\n}\n\n//\n// IndexedDB only allows valid JS names in its index paths, whereas JSON allows\n// for any string at all. This converts invalid JS names to valid ones, to allow\n// for them to be indexed.\n//\n// For example, \"foo-bar\" is a valid JSON key, but cannot be a valid JS name\n// (because that would be read as foo minus bar).\n//\n// Very high level rules for valid JS names are:\n//  - First character cannot start with a number\n//  - Otherwise all characters must be be a-z, A-Z, 0-9, $ or _.\n//  - We allow . unless the name represents a single field, as that represents\n//    a deep index path.\n//\n// This is more aggressive than it needs to be, but also simpler.\n//\nvar KEY_INVALID = new RegExp(TEST_KEY_INVALID.source, 'g');\nvar PATH_INVALID = new RegExp(TEST_PATH_INVALID.source, 'g');\nvar SLASH = '\\\\'.charCodeAt(0);\nconst IS_DOT = '.'.charCodeAt(0);\n\nfunction sanitise(name, isPath) {\n  var correctCharacters = function (match) {\n    var good = '';\n    for (var i = 0; i < match.length; i++) {\n      var code = match.charCodeAt(i);\n      // If you're sanitising a path, a slash character is there to be interpreted\n      // by whatever parses the path later as \"escape the next thing\".\n      //\n      // e.g., if you want to index THIS string:\n      //   {\"foo\": {\"bar.baz\": \"THIS\"}}\n      // Your index path would be \"foo.bar\\.baz\".\n\n      if (code === IS_DOT && isPath && i === 0) {\n        good += '.';\n      } else if (code === SLASH && isPath) {\n        continue;\n      } else {\n        good += '_c' + code + '_';\n      }\n    }\n    return good;\n  };\n\n  if (isPath) {\n    return name.replace(PATH_INVALID, correctCharacters);\n  } else {\n    return name.replace(KEY_INVALID, correctCharacters);\n  }\n}\n\nfunction needsRewrite(data) {\n  for (var key of Object.keys(data)) {\n    if (needsSanitise(key)) {\n      return true;\n    } else if (data[key] === null || typeof data[key] === 'boolean') {\n      return true;\n    } else if (typeof data[key] === 'object') {\n      return needsRewrite(data[key]);\n    }\n  }\n}\n\nfunction rewrite(data) {\n  if (!needsRewrite(data)) {\n    return false;\n  }\n\n  var isArray = Array.isArray(data);\n  var clone = isArray\n    ? []\n    : {};\n\n  Object.keys(data).forEach(function (key) {\n    var safeKey = isArray ? key : sanitise(key);\n\n    if (data[key] === null) {\n      clone[safeKey] = IDB_NULL;\n    } else if (typeof data[key] === 'boolean') {\n      clone[safeKey] = data[key] ? IDB_TRUE : IDB_FALSE;\n    } else if (typeof data[key] === 'object') {\n      clone[safeKey] = rewrite(data[key]);\n    } else {\n      clone[safeKey] = data[key];\n    }\n  });\n\n  return clone;\n}\n\nvar DOC_STORE = 'docs';\nvar META_STORE = 'meta';\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\nfunction processAttachment(name, src, doc, isBinary) {\n\n  delete doc._attachments[name].stub;\n\n  if (isBinary) {\n    doc._attachments[name].data =\n      src.attachments[doc._attachments[name].digest].data;\n    return Promise.resolve();\n  }\n\n  return new Promise(function (resolve) {\n    var data = src.attachments[doc._attachments[name].digest].data;\n    readAsBinaryString(data, function (binString) {\n      doc._attachments[name].data = thisBtoa(binString);\n      delete doc._attachments[name].length;\n      resolve();\n    });\n  });\n}\n\nfunction rawIndexFields(ddoc, viewName) {\n  // fields are an array of either the string name of the field, or a key value\n  var fields = ddoc.views[viewName].options &&\n               ddoc.views[viewName].options.def &&\n               ddoc.views[viewName].options.def.fields || [];\n\n  // Either ['foo'] or [{'foo': 'desc'}]\n  return fields.map(function (field) {\n    if (typeof field === 'string') {\n      return field;\n    } else {\n      return Object.keys(field)[0];\n    }\n  });\n}\n\n/**\n * true if the view is has a \"partial_filter_selector\".\n */\nfunction isPartialFilterView(ddoc, viewName) {\n  return viewName in ddoc.views &&\n    ddoc.views[viewName].options &&\n    ddoc.views[viewName].options.def &&\n    ddoc.views[viewName].options.def.partial_filter_selector;\n}\n\nfunction naturalIndexName(fields) {\n  return '_find_idx/' + fields.join('/');\n}\n\n/**\n * Convert the fields the user gave us in the view and convert them to work for\n * indexeddb.\n *\n * fields is an array of field strings. A field string could be one field:\n *   'foo'\n * Or it could be a json path:\n *   'foo.bar'\n */\nfunction correctIndexFields(fields) {\n  // Every index has to have deleted at the front, because when we do a query\n  // we need to filter out deleted documents.\n  return ['deleted'].concat(\n    fields.map(function (field) {\n      if (['_id', '_rev', '_deleted', '_attachments'].includes(field)) {\n        // These properties are stored at the top level without the underscore\n        return field.substr(1);\n      } else {\n        // The custom document fields are inside the `data` property\n        return 'data.' + sanitise(field, true);\n      }\n    })\n  );\n}\n\n//\n// Core PouchDB schema version. Increment this if we, as a library, want to make\n// schema changes in indexeddb. See upgradePouchDbSchema()\n//\nvar POUCHDB_IDB_VERSION = 1;\n\n//\n// Functions that manage a combinate indexeddb version, by combining the current\n// time in millis that represents user migrations with a large multiplier that\n// represents PouchDB system migrations.\n//\n// This lets us use the idb version number to both represent\n// PouchDB-library-level migrations as well as \"user migrations\" required for\n// when design documents trigger the addition or removal of native indexes.\n//\n// Given that Number.MAX_SAFE_INTEGER = 9007199254740991\n//\n// We can easily use the largest 2-3 digits and either allow:\n//  - 900 system migrations up to 2198/02/18\n//  - or 89 system migrations up to 5050/02/14\n//\n// This impl does the former. If this code still exists after 2198 someone send my\n// decendents a Spacebook message congratulating them on their impressive genes.\n//\n// 9007199254740991 <- MAX_SAFE_INTEGER\n//   10000000000000 <- 10^13\n//    7199254740991 <- 2198-02-18T16:59:00.991Z\n//\nvar versionMultiplier = Math.pow(10, 13);\nfunction createIdbVersion() {\n  return (versionMultiplier * POUCHDB_IDB_VERSION) + new Date().getTime();\n}\nfunction getPouchDbVersion(version) {\n  return Math.floor(version / versionMultiplier);\n}\n\nfunction maintainNativeIndexes(openReq, reject) {\n  var docStore = openReq.transaction.objectStore(DOC_STORE);\n  var ddocsReq = docStore.getAll(IDBKeyRange.bound('_design/', '_design/\\uffff'));\n\n  ddocsReq.onsuccess = function (e) {\n    var results = e.target.result;\n    var existingIndexNames = Array.from(docStore.indexNames);\n\n    // NB: the only thing we're supporting here is the declared indexing\n    // fields nothing more.\n    var expectedIndexes = results.filter(function (row) {\n      return row.deleted === 0 && row.revs[row.rev].data.views;\n    }).map(function (row) {\n      return row.revs[row.rev].data;\n    }).reduce(function (indexes, ddoc) {\n      return Object.keys(ddoc.views).reduce(function (acc, viewName) {\n        var fields = rawIndexFields(ddoc, viewName);\n\n        if (fields && fields.length > 0) {\n          acc[naturalIndexName(fields)] = correctIndexFields(fields);\n        }\n\n        return acc;\n      }, indexes);\n    }, {});\n\n    var expectedIndexNames = Object.keys(expectedIndexes);\n\n    // Delete any indexes that aren't system indexes or expected\n    var systemIndexNames = ['seq'];\n    existingIndexNames.forEach(function (index) {\n      if (systemIndexNames.indexOf(index) === -1  && expectedIndexNames.indexOf(index) === -1) {\n        docStore.deleteIndex(index);\n      }\n    });\n\n    // Work out which indexes are missing and create them\n    var newIndexNames = expectedIndexNames.filter(function (ei) {\n      return existingIndexNames.indexOf(ei) === -1;\n    });\n\n    try {\n      newIndexNames.forEach(function (indexName) {\n        docStore.createIndex(indexName, expectedIndexes[indexName]);\n      });\n    } catch (err) {\n      reject(err);\n    }\n  };\n}\n\nfunction upgradePouchDbSchema(db, pouchdbVersion) {\n  if (pouchdbVersion < 1) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    docStore.createIndex('seq', 'seq', {unique: true});\n\n    db.createObjectStore(META_STORE, {keyPath: 'id'});\n  }\n\n  // Declare more PouchDB schema changes here\n  // if (pouchdbVersion < 2) { .. }\n}\n\nfunction openDatabase(openDatabases, api, opts, resolve, reject) {\n  var openReq = opts.versionchanged ?\n    indexedDB.open(opts.name) :\n    indexedDB.open(opts.name, createIdbVersion());\n\n  openReq.onupgradeneeded = function (e) {\n    if (e.oldVersion > 0 && e.oldVersion < versionMultiplier) {\n      // This DB was created with the \"idb\" adapter, **not** this one.\n      // For now we're going to just error out here: users must manually\n      // migrate between the two. In the future, dependent on performance tests,\n      // we might silently migrate\n      throw new Error('Incorrect adapter: you should specify the \"idb\" adapter to open this DB');\n    } else if (e.oldVersion === 0 && e.newVersion < versionMultiplier) {\n      // Firefox still creates the database with version=1 even if we throw,\n      // so we need to be sure to destroy the empty database before throwing\n      indexedDB.deleteDatabase(opts.name);\n      throw new Error('Database was deleted while open');\n    }\n\n    var db = e.target.result;\n\n    var pouchdbVersion = getPouchDbVersion(e.oldVersion);\n    upgradePouchDbSchema(db, pouchdbVersion);\n    maintainNativeIndexes(openReq, reject);\n  };\n\n  openReq.onblocked = function (e) {\n      // AFAICT this only occurs if, after sending `onversionchange` events to\n      // all other open DBs (ie in different tabs), there are still open\n      // connections to the DB. In this code we should never see this because we\n      // close our DBs on these events, and all DB interactions are wrapped in\n      // safely re-opening the DB.\n      console.error('onblocked, this should never happen', e);\n  };\n\n  openReq.onsuccess = function (e) {\n    var idb = e.target.result;\n\n    idb.onabort = function (e) {\n      console.error('Database has a global failure', e.target.error);\n      delete openDatabases[opts.name];\n      idb.close();\n    };\n\n    idb.onversionchange = function () {\n      console.log('Database was made stale, closing handle');\n      openDatabases[opts.name].versionchanged = true;\n      idb.close();\n    };\n\n    idb.onclose = function () {\n      console.log('Database was made stale, closing handle');\n      if (opts.name in openDatabases) {\n        openDatabases[opts.name].versionchanged = true;\n      }\n    };\n\n    var metadata = {id: META_STORE};\n    var txn = idb.transaction([META_STORE], 'readwrite');\n\n    txn.oncomplete = function () {\n      resolve({idb: idb, metadata: metadata});\n    };\n\n    var metaStore = txn.objectStore(META_STORE);\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metadata = e.target.result || metadata;\n      var changed = false;\n\n      if (!('doc_count' in metadata)) {\n        changed = true;\n        metadata.doc_count = 0;\n      }\n\n      if (!('seq' in metadata)) {\n        changed = true;\n        metadata.seq = 0;\n      }\n\n      if (!('db_uuid' in metadata)) {\n        changed = true;\n        metadata.db_uuid = uuid();\n      }\n\n      if (changed) {\n        metaStore.put(metadata);\n      }\n    };\n  };\n\n  openReq.onerror = function (e) {\n    reject(e.target.error);\n  };\n}\n\nfunction setup (openDatabases, api, opts) {\n  if (!openDatabases[opts.name] || openDatabases[opts.name].versionchanged) {\n    opts.versionchanged = openDatabases[opts.name] &&\n                          openDatabases[opts.name].versionchanged;\n\n    openDatabases[opts.name] = new Promise(function (resolve, reject) {\n      openDatabase(openDatabases, api, opts, resolve, reject);\n    });\n  }\n\n  return openDatabases[opts.name];\n}\n\nfunction info (metadata, callback) {\n  callback(null, {\n    doc_count: metadata.doc_count,\n    update_seq: metadata.seq\n  });\n}\n\nfunction get (txn, id, opts, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  txn.txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n    var doc = e.target.result;\n    var rev;\n    if (!opts.rev) {\n      rev = (doc && doc.rev);\n    } else {\n      rev = opts.latest ? latest(opts.rev, doc) : opts.rev;\n    }\n\n    if (!doc || (doc.deleted && !opts.rev) || !(rev in doc.revs)) {\n      callback(createError(MISSING_DOC, 'missing'));\n      return;\n    }\n\n    var result = doc.revs[rev].data;\n    result._id = doc.id;\n    result._rev = rev;\n\n    // WARNING: expecting possible old format\n    // TODO: why are we passing the transaction in the context?\n    //       It's not clear we ever thread these txns usefully\n    callback(null, {\n      doc: result,\n      metadata: doc,\n      ctx: txn\n    });\n  };\n}\n\nfunction parseAttachment(attachment, opts, cb) {\n  if (opts.binary) {\n    return cb(null, attachment);\n  } else {\n    readAsBinaryString(attachment, function (binString) {\n      cb(null, thisBtoa(binString));\n    });\n  }\n}\n\nfunction getAttachment(txn, docId, attachId, _, opts, cb) {\n  if (txn.error) {\n    return cb(txn.error);\n  }\n\n  var attachment;\n\n  txn.txn.objectStore(DOC_STORE).get(docId).onsuccess = function (e) {\n    var doc = e.target.result;\n    var rev = doc.revs[opts.rev || doc.rev].data;\n    var digest = rev._attachments[attachId].digest;\n    attachment = doc.attachments[digest].data;\n  };\n\n  txn.txn.oncomplete = function () {\n    parseAttachment(attachment, opts, cb);\n  };\n\n  txn.txn.onabort = cb;\n}\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject([\n  '_id',\n  '_rev',\n  '_access',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree',\n  // replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats',\n  // Specific to Couchbase Sync Gateway\n  '_removed'\n]);\n\n// List of reserved words that should end up in the document\nvar dataWords = toObject([\n  '_access',\n  '_attachments',\n  // replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats'\n]);\n\nfunction parseRevisionInfo(rev) {\n  if (!/^\\d+-/.test(rev)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev.indexOf('-');\n  var left = rev.substring(0, idx);\n  var right = rev.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits, dbOpts) {\n  if (!dbOpts) {\n    dbOpts = {\n      deterministic_revs: true\n    };\n  }\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = rev$$1(doc, dbOpts.deterministic_revs);\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = {metadata : {}, data : {}};\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\nfunction bulkDocs (api, req, opts, metadata, dbOpts, idbChanges, callback) {\n\n  var txn;\n\n  // TODO: I would prefer to get rid of these globals\n  var error;\n  var results = [];\n  var docs = [];\n  var lastWriteIndex;\n\n  var revsLimit = dbOpts.revs_limit || 1000;\n  var rewriteEnabled = dbOpts.name.indexOf(\"-mrview-\") === -1;\n  const autoCompaction = dbOpts.auto_compaction;\n\n  // We only need to track 1 revision for local documents\n  function docsRevsLimit(doc) {\n    return /^_local/.test(doc.id) ? 1 : revsLimit;\n  }\n\n  function rootIsMissing(doc) {\n    return doc.rev_tree[0].ids[1].status === 'missing';\n  }\n\n  function parseBase64(data) {\n    try {\n      return atob(data);\n    } catch (e) {\n      return {\n        error: createError(BAD_ARG, 'Attachment is not a valid base64 string')\n      };\n    }\n  }\n\n  // Reads the original doc from the store if available\n  // As in allDocs with keys option using multiple get calls is the fastest way\n  function fetchExistingDocs(txn, docs) {\n    var fetched = 0;\n    var oldDocs = {};\n\n    function readDone(e) {\n      if (e.target.result) {\n        oldDocs[e.target.result.id] = e.target.result;\n      }\n      if (++fetched === docs.length) {\n        processDocs$$1(txn, docs, oldDocs);\n      }\n    }\n\n    docs.forEach(function (doc) {\n      txn.objectStore(DOC_STORE).get(doc.id).onsuccess = readDone;\n    });\n  }\n\n  function revHasAttachment(doc, rev, digest) {\n    return doc.revs[rev] &&\n      doc.revs[rev].data._attachments &&\n      Object.values(doc.revs[rev].data._attachments).find(function (att) {\n        return att.digest === digest;\n      });\n  }\n\n  function processDocs$$1(txn, docs, oldDocs) {\n\n    docs.forEach(function (doc, i) {\n      var newDoc;\n\n      // The first document write cannot be a deletion\n      if ('was_delete' in opts && !(Object.prototype.hasOwnProperty.call(oldDocs, doc.id))) {\n        newDoc = createError(MISSING_DOC, 'deleted');\n\n      // The first write of a document cannot specify a revision\n      } else if (opts.new_edits &&\n                 !Object.prototype.hasOwnProperty.call(oldDocs, doc.id) &&\n                 rootIsMissing(doc)) {\n        newDoc = createError(REV_CONFLICT);\n\n      // Update the existing document\n      } else if (Object.prototype.hasOwnProperty.call(oldDocs, doc.id)) {\n        newDoc = update(txn, doc, oldDocs[doc.id]);\n        // The update can be rejected if it is an update to an existing\n        // revision, if so skip it\n        if (newDoc == false) {\n          return;\n        }\n\n      // New document\n      } else {\n        // Ensure new documents are also stemmed\n        var merged = merge([], doc.rev_tree[0], docsRevsLimit(doc));\n        doc.rev_tree = merged.tree;\n        doc.stemmedRevs = merged.stemmedRevs;\n        newDoc = doc;\n        newDoc.isNewDoc = true;\n        newDoc.wasDeleted = doc.revs[doc.rev].deleted ? 1 : 0;\n      }\n\n      if (newDoc.error) {\n        results[i] = newDoc;\n      } else {\n        oldDocs[newDoc.id] = newDoc;\n        lastWriteIndex = i;\n        write(txn, newDoc, i);\n      }\n    });\n  }\n\n  // Converts from the format returned by parseDoc into the new format\n  // we use to store\n  function convertDocFormat(doc) {\n\n    var newDoc = {\n      id: doc.metadata.id,\n      rev: doc.metadata.rev,\n      rev_tree: doc.metadata.rev_tree,\n      revs: doc.metadata.revs || {}\n    };\n\n    newDoc.revs[newDoc.rev] = {\n      data: doc.data,\n      deleted: doc.metadata.deleted\n    };\n\n    return newDoc;\n  }\n\n  function update(txn, doc, oldDoc) {\n\n    // Ignore updates to existing revisions\n    if ((doc.rev in oldDoc.revs) && !opts.new_edits) {\n      return false;\n    }\n\n    var isRoot = /^1-/.test(doc.rev);\n\n    // Reattach first writes after a deletion to last deleted tree\n    if (oldDoc.deleted && !doc.deleted && opts.new_edits && isRoot) {\n      var tmp = doc.revs[doc.rev].data;\n      tmp._rev = oldDoc.rev;\n      tmp._id = oldDoc.id;\n      doc = convertDocFormat(parseDoc(tmp, opts.new_edits, dbOpts));\n    }\n\n    var merged = merge(oldDoc.rev_tree, doc.rev_tree[0], docsRevsLimit(doc));\n    doc.stemmedRevs = merged.stemmedRevs;\n    doc.rev_tree = merged.tree;\n\n    // Merge the old and new rev data\n    var revs = oldDoc.revs;\n    revs[doc.rev] = doc.revs[doc.rev];\n    doc.revs = revs;\n\n    doc.attachments = oldDoc.attachments;\n\n    var inConflict = opts.new_edits && (((oldDoc.deleted && doc.deleted) ||\n       (!oldDoc.deleted && merged.conflicts !== 'new_leaf') ||\n       (oldDoc.deleted && !doc.deleted && merged.conflicts === 'new_branch') ||\n       (oldDoc.rev === doc.rev)));\n\n    if (inConflict) {\n      return createError(REV_CONFLICT);\n    }\n\n    doc.wasDeleted = oldDoc.deleted;\n\n    return doc;\n  }\n\n  function write(txn, doc, i) {\n\n    // We copy the data from the winning revision into the root\n    // of the document so that it can be indexed\n    var winningRev$$1 = winningRev(doc);\n    // rev of new doc for attachments and to return it\n    var writtenRev = doc.rev;\n    var isLocal = /^_local/.test(doc.id);\n\n    var theDoc = doc.revs[winningRev$$1].data;\n\n    const isNewDoc = doc.isNewDoc;\n\n    if (rewriteEnabled) {\n      // doc.data is what we index, so we need to clone and rewrite it, and clean\n      // it up for indexability\n      var result = rewrite(theDoc);\n      if (result) {\n        doc.data = result;\n        delete doc.data._attachments;\n      } else {\n        doc.data = theDoc;\n      }\n    } else {\n      doc.data = theDoc;\n    }\n\n    doc.rev = winningRev$$1;\n    // .deleted needs to be an int for indexing\n    doc.deleted = doc.revs[winningRev$$1].deleted ? 1 : 0;\n\n    // Bump the seq for every new (non local) revision written\n    // TODO: index expects a unique seq, not sure if ignoring local will\n    // work\n    if (!isLocal) {\n      doc.seq = ++metadata.seq;\n\n      var delta = 0;\n      // If its a new document, we wont decrement if deleted\n      if (doc.isNewDoc) {\n        delta = doc.deleted ? 0 : 1;\n      } else if (doc.wasDeleted !== doc.deleted) {\n        delta = doc.deleted ? -1 : 1;\n      }\n      metadata.doc_count += delta;\n    }\n    delete doc.isNewDoc;\n    delete doc.wasDeleted;\n\n    // If there have been revisions stemmed when merging trees,\n    // delete their data\n    let revsToDelete = doc.stemmedRevs || [];\n\n    if (autoCompaction && !isNewDoc) {\n      const result = compactTree(doc);\n      if (result.length) {\n        revsToDelete = revsToDelete.concat(result);\n      }\n    }\n\n    if (revsToDelete.length) {\n      revsToDelete.forEach(function (rev) { delete doc.revs[rev]; });\n    }\n\n    delete doc.stemmedRevs;\n\n    if (!('attachments' in doc)) {\n      doc.attachments = {};\n    }\n\n    if (theDoc._attachments) {\n      for (var k in theDoc._attachments) {\n        var attachment = theDoc._attachments[k];\n        if (attachment.stub) {\n          if (!(attachment.digest in doc.attachments)) {\n            error = createError(MISSING_STUB);\n            // TODO: Not sure how safe this manual abort is, seeing\n            // console issues\n            txn.abort();\n            return;\n          }\n\n          if (revHasAttachment(doc, writtenRev, attachment.digest)) {\n            doc.attachments[attachment.digest].revs[writtenRev] = true;\n          }\n\n        } else {\n\n          doc.attachments[attachment.digest] = attachment;\n          doc.attachments[attachment.digest].revs = {};\n          doc.attachments[attachment.digest].revs[writtenRev] = true;\n\n          theDoc._attachments[k] = {\n            stub: true,\n            digest: attachment.digest,\n            content_type: attachment.content_type,\n            length: attachment.length,\n            revpos: parseInt(writtenRev, 10)\n          };\n        }\n      }\n    }\n\n    // Local documents have different revision handling\n    if (isLocal && doc.deleted) {\n      txn.objectStore(DOC_STORE).delete(doc.id).onsuccess = function () {\n        results[i] = {\n          ok: true,\n          id: doc.id,\n          rev: '0-0'\n        };\n      };\n      updateSeq(i);\n      return;\n    }\n\n    txn.objectStore(DOC_STORE).put(doc).onsuccess = function () {\n      results[i] = {\n        ok: true,\n        id: doc.id,\n        rev: writtenRev\n      };\n      updateSeq(i);\n    };\n  }\n\n  function updateSeq(i) {\n    if (i === lastWriteIndex) {\n      txn.objectStore(META_STORE).put(metadata);\n    }\n  }\n\n  function preProcessAttachment(attachment) {\n    if (attachment.stub) {\n      return Promise.resolve(attachment);\n    }\n\n    var binData;\n    if (typeof attachment.data === 'string') {\n      binData = parseBase64(attachment.data);\n      if (binData.error) {\n        return Promise.reject(binData.error);\n      }\n      attachment.data = binStringToBluffer(binData, attachment.content_type);\n    } else {\n      binData = attachment.data;\n    }\n\n    return new Promise(function (resolve) {\n      binaryMd5(binData, function (result) {\n        attachment.digest = 'md5-' + result;\n        attachment.length = binData.size || binData.length || 0;\n        resolve(attachment);\n      });\n    });\n  }\n\n  function preProcessAttachments() {\n    var promises = docs.map(function (doc) {\n      var data = doc.revs[doc.rev].data;\n      if (!data._attachments) {\n        return Promise.resolve(data);\n      }\n      var attachments = Object.keys(data._attachments).map(function (k) {\n        data._attachments[k].name = k;\n        return preProcessAttachment(data._attachments[k]);\n      });\n\n      return Promise.all(attachments).then(function (newAttachments) {\n        var processed = {};\n        newAttachments.forEach(function (attachment) {\n          processed[attachment.name] = attachment;\n          delete attachment.name;\n        });\n        data._attachments = processed;\n        return data;\n      });\n    });\n    return Promise.all(promises);\n  }\n\n  for (var i = 0, len = req.docs.length; i < len; i++) {\n    var result;\n    // TODO: We should get rid of throwing for invalid docs, also not sure\n    // why this is needed in idb-next and not idb\n    try {\n      result = parseDoc(req.docs[i], opts.new_edits, dbOpts);\n    } catch (err) {\n      result = err;\n    }\n    if (result.error) {\n      return callback(result);\n    }\n\n    // Ideally parseDoc would return data in this format, but it is currently\n    // shared so we need to convert\n    docs.push(convertDocFormat(result));\n  }\n\n  preProcessAttachments().then(function () {\n    api._openTransactionSafely([DOC_STORE, META_STORE], 'readwrite', function (err, _txn) {\n      if (err) {\n        return callback(err);\n      }\n\n      txn = _txn;\n\n      txn.onabort = function () {\n        callback(error || createError(UNKNOWN_ERROR, 'transaction was aborted'));\n      };\n      txn.ontimeout = idbError(callback);\n\n      txn.oncomplete = function () {\n        idbChanges.notify(dbOpts.name);\n        callback(null, results);\n      };\n\n      // We would like to use promises here, but idb sucks\n      fetchExistingDocs(txn, docs);\n    });\n  }).catch(function (err) {\n    callback(err);\n  });\n}\n\nfunction allDocsKeys(keys, docStore, allDocsInner) {\n  // It's not guaranted to be returned in right order\n  var valuesBatch = new Array(keys.length);\n  var count = 0;\n  keys.forEach(function (key, index) {\n    docStore.get(key).onsuccess = function (event) {\n      if (event.target.result) {\n      valuesBatch[index] = event.target.result;\n      } else {\n        valuesBatch[index] = {key: key, error: 'not_found'};\n      }\n      count++;\n      if (count === keys.length) {\n        valuesBatch.forEach(function (doc) {\n            allDocsInner(doc);\n        });\n      }\n    };\n  });\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction handleKeyRangeError(opts, metadata, err, callback) {\n  if (err.name === \"DataError\" && err.code === 0) {\n    // data error, start is less than end\n    var returnVal = {\n      total_rows: metadata.doc_count,\n      offset: opts.skip,\n      rows: []\n    };\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      returnVal.update_seq = metadata.seq;\n    }\n    return callback(null, returnVal);\n  }\n  callback(createError(IDB_ERROR, err.name, err.message));\n}\n\nfunction allDocs (txn, metadata, opts, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  // TODO: Weird hack, I dont like it\n  if (opts.limit === 0) {\n    var returnVal = {\n      total_rows: metadata.doc_count,\n      offset: opts.skip,\n      rows: []\n    };\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      returnVal.update_seq = metadata.seq;\n    }\n    return callback(null, returnVal);\n  }\n\n  var results = [];\n  var processing = [];\n\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var keys = 'keys' in opts ? opts.keys : false;\n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n  var descending = 'descending' in opts && opts.descending ? 'prev' : null;\n\n  var keyRange;\n  if (!keys) {\n    keyRange = createKeyRange(start, end, inclusiveEnd, key, descending);\n    if (keyRange && keyRange.error) {\n      return handleKeyRangeError(opts, metadata, keyRange.error, callback);\n    }\n  }\n\n  var docStore = txn.txn.objectStore(DOC_STORE);\n\n  txn.txn.oncomplete = onTxnComplete;\n\n  if (keys) {\n    return allDocsKeys(opts.keys, docStore, allDocsInner);\n  }\n\n  function include_doc(row, doc) {\n    var docData = doc.revs[doc.rev].data;\n\n    row.doc = docData;\n    row.doc._id = doc.id;\n    row.doc._rev = doc.rev;\n    if (opts.conflicts) {\n      var conflicts = collectConflicts(doc);\n      if (conflicts.length) {\n        row.doc._conflicts = conflicts;\n      }\n    }\n    if (opts.attachments && docData._attachments) {\n      for (var name in docData._attachments) {\n        processing.push(processAttachment(name, doc, row.doc, opts.binary));\n      }\n    }\n  }\n\n  function allDocsInner(doc) {\n    if (doc.error && keys) {\n      // key was not found with \"keys\" requests\n      results.push(doc);\n      return true;\n    }\n\n    var row = {\n      id: doc.id,\n      key: doc.id,\n      value: {\n        rev: doc.rev\n      }\n    };\n\n    var deleted = doc.deleted;\n    if (deleted) {\n      if (keys) {\n        results.push(row);\n        row.value.deleted = true;\n        row.doc = null;\n      }\n    } else if (skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        include_doc(row, doc);\n      }\n      if (--limit === 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function onTxnComplete() {\n    Promise.all(processing).then(function () {\n      var returnVal = {\n        total_rows: metadata.doc_count,\n        offset: 0,\n        rows: results\n      };\n\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        returnVal.update_seq = metadata.seq;\n      }\n      callback(null, returnVal);\n    });\n  }\n\n  var cursor = descending ?\n    docStore.openCursor(keyRange, descending) :\n    docStore.openCursor(keyRange);\n\n  cursor.onsuccess = function (e) {\n\n    var doc = e.target.result && e.target.result.value;\n\n    // Happens if opts does not have limit,\n    // because cursor will end normally then,\n    // when all docs are retrieved.\n    // Would not be needed, if getAll() optimization was used like in #6059\n    if (!doc) { return; }\n\n    // Skip local docs\n    if (/^_local/.test(doc.id)) {\n      return e.target.result.continue();\n    }\n\n    var continueCursor = allDocsInner(doc);\n    if (continueCursor) {\n      e.target.result.continue();\n    }\n  };\n\n}\n\nfunction changes (txn, idbChanges, api, dbOpts, opts) {\n  if (txn.error) {\n    return opts.complete(txn.error);\n  }\n\n  if (opts.continuous) {\n    var id = dbOpts.name + ':' + uuid();\n    idbChanges.addListener(dbOpts.name, id, api, opts);\n    idbChanges.notify(dbOpts.name);\n    return {\n      cancel: function () {\n        idbChanges.removeListener(dbOpts.name, id);\n      }\n    };\n  }\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1;\n  }\n\n  var store = txn.txn.objectStore(DOC_STORE).index('seq');\n\n  var filter = filterChange(opts);\n  var received = 0;\n\n  var lastSeq = opts.since || 0;\n  var results = [];\n\n  var processing = [];\n\n  function onReqSuccess(e) {\n    if (!e.target.result) { return; }\n    var cursor = e.target.result;\n    var doc = cursor.value;\n    // Overwrite doc.data, which may have been rewritten (see rewrite.js) with\n    // the clean version for that rev\n    doc.data = doc.revs[doc.rev].data;\n    doc.data._id = doc.id;\n    doc.data._rev = doc.rev;\n    if (doc.deleted) {\n      doc.data._deleted = true;\n    }\n\n    if (opts.doc_ids && opts.doc_ids.indexOf(doc.id) === -1) {\n      return cursor.continue();\n    }\n\n    // WARNING: expecting possible old format\n    var change = opts.processChange(doc.data, doc, opts);\n    change.seq = doc.seq;\n    lastSeq = doc.seq;\n    var filtered = filter(change);\n\n    // If its an error\n    if (typeof filtered === 'object') {\n      return opts.complete(filtered);\n    }\n\n    if (filtered) {\n      received++;\n      if (opts.return_docs) {\n        results.push(change);\n      }\n\n      if (opts.include_docs && opts.attachments && doc.data._attachments) {\n        var promises = [];\n        for (var name in doc.data._attachments) {\n          var p = processAttachment(name, doc, change.doc, opts.binary);\n          // We add the processing promise to 2 arrays, one tracks all\n          // the promises needed before we fire onChange, the other\n          // ensure we process all attachments before onComplete\n          promises.push(p);\n          processing.push(p);\n        }\n\n        Promise.all(promises).then(function () {\n          opts.onChange(change);\n        });\n      } else {\n        opts.onChange(change);\n      }\n    }\n    if (received !== limit) {\n      cursor.continue();\n    }\n  }\n\n  function onTxnComplete() {\n    Promise.all(processing).then(function () {\n      opts.complete(null, {\n        results: results,\n        last_seq: lastSeq\n      });\n    });\n  }\n\n  var req;\n  if (opts.descending) {\n    req = store.openCursor(null, 'prev');\n  } else {\n    req = store.openCursor(IDBKeyRange.lowerBound(opts.since, true));\n  }\n\n  txn.txn.oncomplete = onTxnComplete;\n  req.onsuccess = onReqSuccess;\n}\n\nfunction getRevisionTree (txn, id, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  var req = txn.txn.objectStore(DOC_STORE).get(id);\n  req.onsuccess = function (e) {\n    if (!e.target.result) {\n      callback(createError(MISSING_DOC));\n    } else {\n      callback(null, e.target.result.rev_tree);\n    }\n  };\n}\n\nfunction doCompaction (txn, id, revs, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  var docStore = txn.txn.objectStore(DOC_STORE);\n\n  docStore.get(id).onsuccess = function (e) {\n    var doc = e.target.result;\n\n    traverseRevTree(doc.rev_tree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev = pos + '-' + revHash;\n      if (revs.indexOf(rev) !== -1) {\n        opts.status = 'missing';\n      }\n    });\n\n    var attachments = [];\n\n    revs.forEach(function (rev) {\n      if (rev in doc.revs) {\n        // Make a list of attachments that are used by the revisions being\n        // deleted\n        if (doc.revs[rev].data._attachments) {\n          for (var k in doc.revs[rev].data._attachments) {\n            attachments.push(doc.revs[rev].data._attachments[k].digest);\n          }\n        }\n        delete doc.revs[rev];\n      }\n    });\n\n    // Attachments have a list of revisions that are using them, when\n    // that list becomes empty we can delete the attachment.\n    attachments.forEach(function (digest) {\n      revs.forEach(function (rev) {\n        delete doc.attachments[digest].revs[rev];\n      });\n      if (!Object.keys(doc.attachments[digest].revs).length) {\n        delete doc.attachments[digest];\n      }\n    });\n\n    docStore.put(doc);\n  };\n\n  txn.txn.oncomplete = function () {\n    callback();\n  };\n}\n\nfunction destroy (dbOpts, openDatabases, idbChanges, callback) {\n\n  idbChanges.removeAllListeners(dbOpts.name);\n\n  function doDestroy() {\n    var req = indexedDB.deleteDatabase(dbOpts.name);\n    req.onsuccess = function () {\n      delete openDatabases[dbOpts.name];\n      callback(null, {ok: true});\n    };\n  }\n\n  // If the database is open we need to close it\n  if (dbOpts.name in openDatabases) {\n    openDatabases[dbOpts.name].then(function (res) {\n      res.idb.close();\n      doDestroy();\n    });\n  } else {\n    doDestroy();\n  }\n\n}\n\n// Adapted from\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-find/src/adapters/local/find/query-planner.js#L20-L24\n// This could change / improve in the future?\nvar COUCH_COLLATE_LO = null;\nvar COUCH_COLLATE_HI = '\\uffff'; // actually used as {\"\\uffff\": {}}\n\n// Adapted from: https://www.w3.org/TR/IndexedDB/#compare-two-keys\n// Importantly, *there is no upper bound possible* in idb. The ideal data\n// structure an infintely deep array:\n//   var IDB_COLLATE_HI = []; IDB_COLLATE_HI.push(IDB_COLLATE_HI)\n// But IDBKeyRange is not a fan of shenanigans, so I've just gone with 12 layers\n// because it looks nice and surely that's enough!\nvar IDB_COLLATE_LO = Number.NEGATIVE_INFINITY;\nvar IDB_COLLATE_HI = [[[[[[[[[[[[]]]]]]]]]]]];\n\n//\n// TODO: this should be made offical somewhere and used by AllDocs / get /\n// changes etc as well.\n//\nfunction externaliseRecord(idbDoc) {\n  var doc = idbDoc.revs[idbDoc.rev].data;\n  doc._id = idbDoc.id;\n  doc._rev = idbDoc.rev;\n  if (idbDoc.deleted) {\n    doc._deleted = true;\n  }\n\n  return doc;\n}\n\n/**\n * Generates a keyrange based on the opts passed to query\n *\n * The first key is always 0, as that's how we're filtering out deleted entries.\n */\nfunction generateKeyRange(opts) {\n  function defined(obj, k) {\n    return obj[k] !== void 0;\n  }\n\n  // Converts a valid CouchDB key into a valid IndexedDB one\n  function convert(key, exact) {\n    // The first item in every native index is doc.deleted, and we always want\n    // to only search documents that are not deleted.\n    // \"foo\" -> [0, \"foo\"]\n    var filterDeleted = [0].concat(key);\n\n    return filterDeleted.map(function (k) {\n      // null, true and false are not indexable by indexeddb. When we write\n      // these values we convert them to these constants, and so when we\n      // query for them we need to convert the query also.\n      if (k === null && exact) {\n        // for non-exact queries we treat null as a collate property\n        // see `if (!exact)` block below\n        return IDB_NULL;\n      } else if (k === true) {\n        return IDB_TRUE;\n      } else if (k === false) {\n        return IDB_FALSE;\n      }\n\n      if (!exact) {\n        // We get passed CouchDB's collate low and high values, so for non-exact\n        // ranged queries we're going to convert them to our IDB equivalents\n        if (k === COUCH_COLLATE_LO) {\n          return IDB_COLLATE_LO;\n        } else if (Object.prototype.hasOwnProperty.call(k, COUCH_COLLATE_HI)) {\n          return IDB_COLLATE_HI;\n        }\n      }\n\n      return k;\n    });\n  }\n\n  // CouchDB and so PouchdB defaults to true. We need to make this explicit as\n  // we invert these later for IndexedDB.\n  if (!defined(opts, 'inclusive_end')) {\n    opts.inclusive_end = true;\n  }\n  if (!defined(opts, 'inclusive_start')) {\n    opts.inclusive_start = true;\n  }\n\n  if (opts.descending) {\n    // Flip before generating. We'll check descending again later when performing\n    // an index request\n    var realEndkey = opts.startkey,\n        realInclusiveEnd = opts.inclusive_start;\n\n    opts.startkey = opts.endkey;\n    opts.endkey = realEndkey;\n    opts.inclusive_start = opts.inclusive_end;\n    opts.inclusive_end = realInclusiveEnd;\n  }\n\n  try {\n    if (defined(opts, 'key')) {\n      return IDBKeyRange.only(convert(opts.key, true));\n    }\n\n    if (defined(opts, 'startkey') && !defined(opts, 'endkey')) {\n      // lowerBound, but without the deleted docs.\n      // [1] is the start of the deleted doc range, and we don't want to include then.\n      return IDBKeyRange.bound(\n        convert(opts.startkey), [1],\n        !opts.inclusive_start, true\n      );\n    }\n\n    if (!defined(opts, 'startkey') && defined(opts, 'endkey')) {\n      return IDBKeyRange.upperBound(convert(opts.endkey), !opts.inclusive_end);\n    }\n\n    if (defined(opts, 'startkey') && defined(opts, 'endkey')) {\n      return IDBKeyRange.bound(\n        convert(opts.startkey),    convert(opts.endkey),\n        !opts.inclusive_start, !opts.inclusive_end\n      );\n    }\n\n    return IDBKeyRange.only([0]);\n  } catch (err) {\n    console.error('Could not generate keyRange', err, opts);\n    throw Error('Could not generate key range with ' + JSON.stringify(opts));\n  }\n}\n\nfunction getIndexHandle(pdb, fields, reject) {\n  var indexName = naturalIndexName(fields);\n\n  return new Promise(function (resolve) {\n    pdb._openTransactionSafely([DOC_STORE], 'readonly', function (err, txn) {\n      if (err) {\n        return idbError(reject)(err);\n      }\n\n      txn.onabort = idbError(reject);\n      txn.ontimeout = idbError(reject);\n\n      var existingIndexNames = Array.from(txn.objectStore(DOC_STORE).indexNames);\n\n      if (existingIndexNames.indexOf(indexName) === -1) {\n        // The index is missing, force a db restart and try again\n        pdb._freshen()\n          .then(function () { return getIndexHandle(pdb, fields, reject); })\n          .then(resolve);\n      } else {\n        resolve(txn.objectStore(DOC_STORE).index(indexName));\n      }\n    });\n  });\n}\n\n// In theory we should return something like the doc example below, but find\n// only needs rows: [{doc: {...}}], so I think we can just not bother for now\n// {\n//   \"offset\" : 0,\n//   \"rows\": [{\n//     \"id\": \"doc3\",\n//     \"key\": \"Lisa Says\",\n//     \"value\": null,\n//     \"doc\": {\n//       \"_id\": \"doc3\",\n//       \"_rev\": \"1-z\",\n//       \"title\": \"Lisa Says\"\n//     }\n//   }],\n//   \"total_rows\" : 4\n// }\nfunction query(idb, signature, opts, fallback) {\n  // At this stage, in the current implementation, find has already gone through\n  // and determined if the index already exists from PouchDB's perspective (eg\n  // there is a design doc for it).\n  //\n  // If we find that the index doesn't exist this means we have to close and\n  // re-open the DB to correct indexes before proceeding, at which point the\n  // index should exist.\n\n  var pdb = this;\n\n  // Assumption, there will be only one /, between the design document name\n  // and the view name.\n  var parts = signature.split('/');\n\n  return new Promise(function (resolve, reject) {\n    pdb.get('_design/' + parts[0]).then(function (ddoc) {\n      if (isPartialFilterView(ddoc, parts[1])) {\n        // Fix for #8522\n        // An IndexedDB index is always over all entries. And there is no way to filter them.\n        // Therefore the normal findAbstractMapper will be used\n        // for indexes with partial_filter_selector.\n        return fallback(signature, opts).then(resolve, reject);\n      }\n\n      var fields = rawIndexFields(ddoc, parts[1]);\n      if (!fields) {\n        throw new Error('ddoc ' + ddoc._id +' with view ' + parts[1] +\n          ' does not have map.options.def.fields defined.');\n      }\n\n      var skip = opts.skip;\n      var limit = Number.isInteger(opts.limit) && opts.limit;\n\n      return getIndexHandle(pdb, fields, reject)\n        .then(function (indexHandle) {\n          var keyRange = generateKeyRange(opts);\n          var req = indexHandle.openCursor(keyRange, opts.descending ? 'prev' : 'next');\n\n          var rows = [];\n          req.onerror = idbError(reject);\n          req.onsuccess = function (e) {\n            var cursor = e.target.result;\n\n            if (!cursor || limit === 0) {\n              return resolve({\n                rows: rows\n              });\n            }\n\n            if (skip) {\n              cursor.advance(skip);\n              skip = false;\n              return;\n            }\n\n            if (limit) {\n              limit = limit - 1;\n            }\n\n            rows.push({doc: externaliseRecord(cursor.value)});\n            cursor.continue();\n          };\n        });\n      })\n      .catch(reject);\n  });\n\n}\n\nfunction viewCleanup(idb, fallback) {\n  // I'm not sure we have to do anything here.\n  //\n  // One option is to just close and re-open the DB, which performs the same\n  // action. The only reason you'd want to call this is if you deleted a bunch\n  // of indexes and wanted the space back immediately.\n  //\n  // Otherwise index cleanup happens when:\n  //  - A DB is opened\n  //  - A find query is performed against an index that doesn't exist but should\n\n  // Fix for #8522\n  // On views with partial_filter_selector the standard find-abstract-mapper is used.\n  // Its indexes must be cleaned up.\n  // Fallback is the standard viewCleanup.\n  return fallback();\n}\n\nfunction purgeAttachments(doc, revs) {\n  if (!doc.attachments) {\n    // If there are no attachments, doc.attachments is an empty object\n    return {};\n  }\n\n  // Iterate over all attachments and remove the respective revs\n  for (let key in doc.attachments) {\n    const attachment = doc.attachments[key];\n\n    for (let rev of revs) {\n      if (attachment.revs[rev]) {\n        delete attachment.revs[rev];\n      }\n    }\n\n    if (Object.keys(attachment.revs).length === 0) {\n      delete doc.attachments[key];\n    }\n  }\n\n  return doc.attachments;\n}\n\n// `purge()` expects a path of revisions in its revs argument that:\n// - starts with a leaf rev\n// - continues sequentially with the remaining revs of that leaf\u2019s branch\n//\n// eg. for this rev tree:\n// 1-9692 \u25B6 2-37aa \u25B6 3-df22 \u25B6 4-6e94 \u25B6 5-df4a \u25B6 6-6a3a \u25B6 7-57e5\n//          \u2503                 \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u25B6 5-8d8c \u25B6 6-65e0\n//          \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u25B6 3-43f6 \u25B6 4-a3b4\n//\n// \u2026if you wanted to purge '7-57e5', you would provide ['7-57e5', '6-6a3a', '5-df4a']\n//\n// The purge adapter implementation in `pouchdb-core` uses the helper function `findPathToLeaf`\n// from `pouchdb-merge` to construct this array correctly. Since this purge implementation is\n// only ever called from there, we do no additional checks here as to whether `revs` actually\n// fulfills the criteria above, since `findPathToLeaf` already does these.\nfunction purge(txn, docId, revs, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  const docStore = txn.txn.objectStore(DOC_STORE);\n  const deletedRevs = [];\n  let documentWasRemovedCompletely = false;\n  docStore.get(docId).onsuccess = (e) => {\n    const doc = e.target.result;\n\n    // we could do a dry run here to check if revs is a proper path towards a leaf in the rev tree\n\n    for (const rev of revs) {\n      // purge rev from tree\n      doc.rev_tree = removeLeafFromRevTree(doc.rev_tree, rev);\n\n      // assign new revs\n      delete doc.revs[rev];\n      deletedRevs.push(rev);\n    }\n\n    if (doc.rev_tree.length === 0) {\n      // if the rev tree is empty, we can delete the entire document\n      docStore.delete(doc.id);\n      documentWasRemovedCompletely = true;\n      return;\n    }\n\n    // find new winning rev\n    doc.rev = winningRev(doc);\n    doc.data = doc.revs[doc.rev].data;\n    doc.attachments = purgeAttachments(doc, revs);\n\n    // finally, write the purged doc\n    docStore.put(doc);\n  };\n\n  txn.txn.oncomplete = function () {\n    callback(null, {\n      ok: true,\n      deletedRevs,\n      documentWasRemovedCompletely\n    });\n  };\n}\n\nvar ADAPTER_NAME = 'indexeddb';\n\n// TODO: Constructor should be capitalised\nvar idbChanges = new Changes();\n\n// A shared list of database handles\nvar openDatabases = {};\n\nfunction IdbPouch(dbOpts, callback) {\n\n  if (dbOpts.view_adapter) {\n    console.log('Please note that the indexeddb adapter manages _find indexes itself, therefore it is not using your specified view_adapter');\n  }\n  \n  var api = this;\n  var metadata = {};\n\n  // Wrapper that gives you an active DB handle. You probably want $t.\n  var $ = function (fun) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      setup(openDatabases, api, dbOpts).then(function (res) {\n        metadata = res.metadata;\n        args.unshift(res.idb);\n        fun.apply(api, args);\n      }).catch(function (err) {\n        var last = args.pop();\n        if (typeof last === 'function') {\n          last(err);\n        } else {\n          console.error(err);\n        }\n      });\n    };\n  };\n  // the promise version of $\n  var $p = function (fun) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n\n      return setup(openDatabases, api, dbOpts).then(function (res) {\n        metadata = res.metadata;\n        args.unshift(res.idb);\n\n        return fun.apply(api, args);\n      });\n    };\n  };\n  // Wrapper that gives you a safe transaction handle. It's important to use\n  // this instead of opening your own transaction from a db handle got from $,\n  // because in the time between getting the db handle and opening the\n  // transaction it may have been invalidated by index changes.\n  var $t = function (fun, stores, mode, changes$$1) {\n    stores = stores || [DOC_STORE];\n    mode = mode || 'readonly';\n\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      var txn = {};\n      const prom = setup(openDatabases, api, dbOpts).then(function (res) {\n        metadata = res.metadata;\n        txn.txn = res.idb.transaction(stores, mode);\n      }).catch(function (err) {\n        console.error('Failed to establish transaction safely');\n        console.error(err);\n        txn.error = err;\n      }).then(function () {\n        args.unshift(txn);\n        return fun.apply(api, args);\n      });\n\n      if (changes$$1) {\n        prom.cancel = () => {\n          prom.then(res => {\n            if (res && typeof res.cancel === 'function') {\n              res.cancel();\n            }\n          });\n        };\n        return prom\n      }\n    };\n  };\n\n  api._openTransactionSafely = function (stores, mode, callback) {\n    $t(function (txn, callback) {\n      callback(txn.error, txn.txn);\n    }, stores, mode)(callback);\n  };\n\n  api._remote = false;\n  api.type = function () { return ADAPTER_NAME; };\n\n  api._id = $(function (_, cb) {\n    cb(null, metadata.db_uuid);\n  });\n\n  api._info = $(function (_, cb) {\n    return info(metadata, cb);\n  });\n\n  api._get = $t(get);\n\n  api._bulkDocs = $(function (_, req, opts, callback) {\n    bulkDocs(api, req, opts, metadata, dbOpts, idbChanges, callback);\n  });\n\n  api._allDocs = $t(function (txn, opts, cb) {\n    allDocs(txn, metadata, opts, cb);\n  });\n\n  api._getAttachment = $t(getAttachment);\n\n  api._changes = $t(function (txn, opts) {\n    return changes(txn, idbChanges, api, dbOpts, opts);\n  }, null, null, true);\n\n  api._getRevisionTree = $t(getRevisionTree);\n  api._doCompaction = $t(doCompaction, [DOC_STORE], 'readwrite');\n\n  api._customFindAbstractMapper = {\n    query: $p(query),\n    viewCleanup: $p(viewCleanup)\n  };\n\n  api._destroy = function (opts, callback) {\n    return destroy(dbOpts, openDatabases, idbChanges, callback);\n  };\n\n  api._close = $(function (db, cb) {\n    delete openDatabases[dbOpts.name];\n    db.close();\n    cb();\n  });\n\n  // Closing and re-opening the DB re-generates native indexes\n  api._freshen = function () {\n    return new Promise(function (resolve) {\n      api._close(function () {\n        $(resolve)();\n      });\n    });\n  };\n\n  api._purge = $t(purge, [DOC_STORE], 'readwrite');\n\n  // TODO: this setTimeout seems nasty, if its needed lets\n  // figure out / explain why\n  setTimeout(function () {\n    callback(null, api);\n  });\n}\n\n// TODO: this isnt really valid permanently, just being lazy to start\nIdbPouch.valid = function () {\n  return true;\n};\n\nfunction IndexedDbPouch (PouchDB) {\n  PouchDB.adapter(ADAPTER_NAME, IdbPouch, true);\n}\n\n// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n// but much smaller in code size. limits the number of concurrent promises that are executed\n\n\nfunction pool(promiseFactories, limit) {\n  return new Promise(function (resolve, reject) {\n    var running = 0;\n    var current = 0;\n    var done = 0;\n    var len = promiseFactories.length;\n    var err;\n\n    function runNext() {\n      running++;\n      promiseFactories[current++]().then(onSuccess, onError);\n    }\n\n    function doNext() {\n      if (++done === len) {\n        /* istanbul ignore if */\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      } else {\n        runNextBatch();\n      }\n    }\n\n    function onSuccess() {\n      running--;\n      doNext();\n    }\n\n    /* istanbul ignore next */\n    function onError(thisErr) {\n      running--;\n      err = err || thisErr;\n      doNext();\n    }\n\n    function runNextBatch() {\n      while (running < limit && current < len) {\n        runNext();\n      }\n    }\n\n    runNextBatch();\n  });\n}\n\nconst CHANGES_BATCH_SIZE = 25;\nconst MAX_SIMULTANEOUS_REVS = 50;\nconst CHANGES_TIMEOUT_BUFFER = 5000;\nconst DEFAULT_HEARTBEAT = 10000;\n\nconst supportsBulkGetMap = {};\n\nconst sse = new ExportedSet();\n\nfunction readAttachmentsAsBlobOrBuffer(row) {\n  const doc = row.doc || row.ok;\n  const atts = doc && doc._attachments;\n  if (!atts) {\n    return;\n  }\n  Object.keys(atts).forEach(function (filename) {\n    const att = atts[filename];\n    att.data = b64ToBluffer(att.data, att.content_type);\n  });\n}\n\nfunction encodeDocId(id) {\n  if (/^_design/.test(id)) {\n    return '_design/' + encodeURIComponent(id.slice(8));\n  }\n  if (/^_local/.test(id)) {\n    return '_local/' + encodeURIComponent(id.slice(7));\n  }\n  return encodeURIComponent(id);\n}\n\nfunction preprocessAttachments$1(doc) {\n  if (!doc._attachments || !Object.keys(doc._attachments)) {\n    return Promise.resolve();\n  }\n\n  return Promise.all(Object.keys(doc._attachments).map(function (key) {\n    const attachment = doc._attachments[key];\n    if (attachment.data && typeof attachment.data !== 'string') {\n      return new Promise(function (resolve) {\n        blobToBase64(attachment.data, resolve);\n      }).then(function (b64) {\n        attachment.data = b64;\n      });\n    }\n  }));\n}\n\nfunction hasUrlPrefix(opts) {\n  if (!opts.prefix) {\n    return false;\n  }\n  const protocol = parseUri(opts.prefix).protocol;\n  return protocol === 'http' || protocol === 'https';\n}\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name, opts) {\n  // encode db name if opts.prefix is a url (#5574)\n  if (hasUrlPrefix(opts)) {\n    const dbName = opts.name.substr(opts.prefix.length);\n    // Ensure prefix has a trailing slash\n    const prefix = opts.prefix.replace(/\\/?$/, '/');\n    name = prefix + encodeURIComponent(dbName);\n  }\n\n  const uri = parseUri(name);\n  if (uri.user || uri.password) {\n    uri.auth = {username: uri.user, password: uri.password};\n  }\n\n  // Split the path part of the URI into parts using '/' as the delimiter\n  // after removing any leading '/' and any trailing '/'\n  const parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n  uri.db = parts.pop();\n  // Prevent double encoding of URI component\n  if (uri.db.indexOf('%') === -1) {\n    uri.db = encodeURIComponent(uri.db);\n  }\n\n  uri.path = parts.join('/');\n\n  return uri;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  return genUrl(opts, opts.db + '/' + path);\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  const pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host +\n         (opts.port ? (':' + opts.port) : '') +\n         '/' + opts.path + pathDel + path;\n}\n\nfunction paramsToStr(params) {\n  const paramKeys = Object.keys(params);\n  if (paramKeys.length === 0) {\n    return '';\n  }\n\n  return '?' + paramKeys.map(key => key + '=' + encodeURIComponent(params[key])).join('&');\n}\n\nfunction shouldCacheBust(opts) {\n  const ua = (typeof navigator !== 'undefined' && navigator.userAgent) ?\n      navigator.userAgent.toLowerCase() : '';\n  const isIE = ua.indexOf('msie') !== -1;\n  const isTrident = ua.indexOf('trident') !== -1;\n  const isEdge = ua.indexOf('edge') !== -1;\n  const isGET = !('method' in opts) || opts.method === 'GET';\n  return (isIE || isTrident || isEdge) && isGET;\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n\n  // The functions that will be publicly available for HttpPouch\n  const api = this;\n\n  const host = getHost(opts.name, opts);\n  const dbUrl = genDBUrl(host, '');\n  let dbId;\n\n  opts = clone(opts);\n\n  const ourFetch = function (url, options) {\n    options = options || {};\n    options.headers = options.headers || new h();\n\n    options.credentials = 'include';\n\n    if (opts.auth || host.auth) {\n      const nAuth = opts.auth || host.auth;\n      const str = nAuth.username + ':' + nAuth.password;\n      const token = thisBtoa(unescape(encodeURIComponent(str)));\n      options.headers.set('Authorization', 'Basic ' + token);\n    }\n\n    const headers = opts.headers || {};\n    Object.keys(headers).forEach(function (key) {\n      options.headers.append(key, headers[key]);\n    });\n\n    /* istanbul ignore if */\n    if (shouldCacheBust(options)) {\n      url += (url.indexOf('?') === -1 ? '?' : '&') + '_nonce=' + Date.now();\n    }\n\n    const fetchFun = opts.fetch || f$1;\n    return fetchFun(url, options);\n  };\n\n  function adapterFun$$1(name, fun) {\n    return adapterFun(name, function (...args) {\n      setup().then(function () {\n        return fun.apply(this, args);\n      }).catch(function (e) {\n        const callback = args.pop();\n        callback(e);\n      });\n    }).bind(api);\n  }\n\n  function fetchJSON(url, options, callback) {\n    const result = {};\n\n    options = options || {};\n    options.headers = options.headers || new h();\n\n    if (!options.headers.get('Content-Type')) {\n      options.headers.set('Content-Type', 'application/json');\n    }\n    if (!options.headers.get('Accept')) {\n      options.headers.set('Accept', 'application/json');\n    }\n\n    return ourFetch(url, options).then(function (response) {\n      result.ok = response.ok;\n      result.status = response.status;\n      return response.json();\n    }).then(function (json) {\n      result.data = json;\n      if (!result.ok) {\n        result.data.status = result.status;\n        const err = generateErrorFromResponse(result.data);\n        if (callback) {\n          return callback(err);\n        } else {\n          throw err;\n        }\n      }\n\n      if (Array.isArray(result.data)) {\n        result.data = result.data.map(function (v) {\n          if (v.error || v.missing) {\n            return generateErrorFromResponse(v);\n          } else {\n            return v;\n          }\n        });\n      }\n\n      if (callback) {\n        callback(null, result.data);\n      } else {\n        return result;\n      }\n    });\n  }\n\n  let setupPromise;\n\n  function setup() {\n    if (opts.skip_setup) {\n      return Promise.resolve();\n    }\n\n    // If there is a setup in process or previous successful setup\n    // done then we will use that\n    // If previous setups have been rejected we will try again\n    if (setupPromise) {\n      return setupPromise;\n    }\n\n    setupPromise = fetchJSON(dbUrl)\n      .catch(err => {\n        if (err && err.status && err.status === 404) {\n          // Doesnt exist, create it\n          explainError(404, 'PouchDB is just detecting if the remote exists.');\n          return fetchJSON(dbUrl, {method: 'PUT'});\n        } else {\n          return Promise.reject(err);\n        }\n      })\n      .catch(err => {\n        // If we try to create a database that already exists, skipped in\n        // istanbul since its catching a race condition.\n        /* istanbul ignore if */\n        if (err && err.status && err.status === 412) {\n          return true;\n        }\n        return Promise.reject(err);\n      });\n\n    setupPromise.catch(() => {\n      setupPromise = null;\n    });\n\n    return setupPromise;\n  }\n\n  immediate$1(function () {\n    callback(null, api);\n  });\n\n  api._remote = true;\n\n  /* istanbul ignore next */\n  api.type = function () {\n    return 'http';\n  };\n\n  let pendingDbId;\n  api.id = adapterFun$$1('id', callback => {\n    if (pendingDbId) {\n      pendingDbId.then(() => {\n        callback(null, dbId);\n      });\n    } else if (dbId) {\n      callback(null, dbId);\n    } else {\n      pendingDbId = ourFetch(genUrl(host, ''))\n        .then(res => res.json())\n        .catch(() => ({}))\n        .then(result => {\n          // Bad response or missing `uuid` should not prevent ID generation.\n          dbId = (result && result.uuid) ? (result.uuid + host.db) : dbUrl;\n          pendingDbId = null;\n          callback(null, dbId);\n        });\n    }\n  });\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = adapterFun$$1('compact', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    fetchJSON(genDBUrl(host, '_compact'), {method: 'POST'}).then(function () {\n      function ping() {\n        api.info(function (err, res) {\n          // CouchDB may send a \"compact_running:true\" if it's\n          // already compacting. PouchDB Server doesn't.\n          /* istanbul ignore else */\n          if (res && !res.compact_running) {\n            callback(null, {ok: true});\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      ping();\n    });\n  });\n\n  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n    const self = this;\n\n    function doBulkGet(cb) {\n      const params = {};\n      if (opts.revs) {\n        params.revs = true;\n      }\n      if (opts.attachments) {\n        /* istanbul ignore next */\n        params.attachments = true;\n      }\n      if (opts.latest) {\n        params.latest = true;\n      }\n      fetchJSON(genDBUrl(host, '_bulk_get' + paramsToStr(params)), {\n        method: 'POST',\n        body: JSON.stringify({ docs: opts.docs})\n      }).then(function (result) {\n        if (opts.attachments && opts.binary) {\n          result.data.results.forEach(function (res) {\n            res.docs.forEach(readAttachmentsAsBlobOrBuffer);\n          });\n        }\n        cb(null, result.data);\n      }).catch(cb);\n    }\n\n    /* istanbul ignore next */\n    function doBulkGetShim() {\n      // avoid \"url too long error\" by splitting up into multiple requests\n      let batchSize = MAX_SIMULTANEOUS_REVS;\n      let numBatches = Math.ceil(opts.docs.length / batchSize);\n      let numDone = 0;\n      let results = new Array(numBatches);\n\n      function onResult(batchNum) {\n        return function (err, res) {\n          // err is impossible because shim returns a list of errs in that case\n          results[batchNum] = res.results;\n          if (++numDone === numBatches) {\n            callback(null, {results: flatten(results)});\n          }\n        };\n      }\n\n      for (let i = 0; i < numBatches; i++) {\n        const subOpts = pick(opts, ['revs', 'attachments', 'binary', 'latest']);\n        subOpts.docs = opts.docs.slice(i * batchSize,\n          Math.min(opts.docs.length, (i + 1) * batchSize));\n        bulkGet(self, subOpts, onResult(i));\n      }\n    }\n\n    // mark the whole database as either supporting or not supporting _bulk_get\n    const dbUrl = genUrl(host, '');\n    const supportsBulkGet = supportsBulkGetMap[dbUrl];\n\n    /* istanbul ignore next */\n    if (typeof supportsBulkGet !== 'boolean') {\n      // check if this database supports _bulk_get\n      doBulkGet(function (err, res) {\n        if (err) {\n          supportsBulkGetMap[dbUrl] = false;\n          explainError(\n            err.status,\n            'PouchDB is just detecting if the remote ' +\n            'supports the _bulk_get API.'\n          );\n          doBulkGetShim();\n        } else {\n          supportsBulkGetMap[dbUrl] = true;\n          callback(null, res);\n        }\n      });\n    } else if (supportsBulkGet) {\n      doBulkGet(callback);\n    } else {\n      doBulkGetShim();\n    }\n  });\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api._info = function (callback) {\n    setup().then(function () {\n      return ourFetch(genDBUrl(host, ''));\n    }).then(function (response) {\n      return response.json();\n    }).then(function (info) {\n      info.host = genDBUrl(host, '');\n      callback(null, info);\n    }).catch(callback);\n  };\n\n  api.fetch = function (path, options) {\n    return setup().then(function () {\n      let url = path.substring(0, 1) === '/' ?\n        genUrl(host, path.substring(1)) :\n        genDBUrl(host, path);\n      return ourFetch(url, options);\n    });\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = adapterFun$$1('get', function (id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    const params = {};\n\n    if (opts.revs) {\n      params.revs = true;\n    }\n\n    if (opts.revs_info) {\n      params.revs_info = true;\n    }\n\n    if (opts.latest) {\n      params.latest = true;\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.open_revs = opts.open_revs;\n    }\n\n    if (opts.rev) {\n      params.rev = opts.rev;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = opts.conflicts;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = opts.update_seq;\n    }\n\n    id = encodeDocId(id);\n\n    function fetchAttachments(doc) {\n      const atts = doc._attachments;\n      const filenames = atts && Object.keys(atts);\n      if (!atts || !filenames.length) {\n        return;\n      }\n      // we fetch these manually in separate XHRs, because\n      // Sync Gateway would normally send it back as multipart/mixed,\n      // which we cannot parse. Also, this is more efficient than\n      // receiving attachments as base64-encoded strings.\n      function fetchData(filename) {\n        const att = atts[filename];\n        const path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n            '?rev=' + doc._rev;\n        return ourFetch(genDBUrl(host, path)).then(function (response) {\n          if ('buffer' in response) {\n            return response.buffer();\n          } else {\n            /* istanbul ignore next */\n            return response.blob();\n          }\n        }).then(function (blob) {\n          if (opts.binary) {\n            const typeFieldDescriptor = Object.getOwnPropertyDescriptor(blob.__proto__, 'type');\n            if (!typeFieldDescriptor || typeFieldDescriptor.set) {\n              blob.type = att.content_type;\n            }\n            return blob;\n          }\n          return new Promise(function (resolve) {\n            blobToBase64(blob, resolve);\n          });\n        }).then(function (data) {\n          delete att.stub;\n          delete att.length;\n          att.data = data;\n        });\n      }\n\n      const promiseFactories = filenames.map(function (filename) {\n        return function () {\n          return fetchData(filename);\n        };\n      });\n\n      // This limits the number of parallel xhr requests to 5 any time\n      // to avoid issues with maximum browser request limits\n      return pool(promiseFactories, 5);\n    }\n\n    function fetchAllAttachments(docOrDocs) {\n      if (Array.isArray(docOrDocs)) {\n        return Promise.all(docOrDocs.map(function (doc) {\n          if (doc.ok) {\n            return fetchAttachments(doc.ok);\n          }\n        }));\n      }\n      return fetchAttachments(docOrDocs);\n    }\n\n    const url = genDBUrl(host, id + paramsToStr(params));\n    fetchJSON(url).then(function (res) {\n      return Promise.resolve().then(function () {\n        if (opts.attachments) {\n          return fetchAllAttachments(res.data);\n        }\n      }).then(function () {\n        callback(null, res.data);\n      });\n    }).catch(function (e) {\n      e.docId = id;\n      callback(e);\n    });\n  });\n\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = adapterFun$$1('remove', function (docOrId, optsOrRev, opts, cb) {\n    let doc;\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n    } else {\n      // doc, opts, callback style\n      doc = docOrId;\n      if (typeof optsOrRev === 'function') {\n        cb = optsOrRev;\n        opts = {};\n      } else {\n        cb = opts;\n        opts = optsOrRev;\n      }\n    }\n\n    const rev = (doc._rev || opts.rev);\n    const url = genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev;\n\n    fetchJSON(url, {method: 'DELETE'}, cb).catch(cb);\n  });\n\n  function encodeAttachmentId(attachmentId) {\n    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n  }\n\n  // Get the attachment\n  api.getAttachment = adapterFun$$1('getAttachment', function (docId, attachmentId,\n                                                            opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    const params = opts.rev ? ('?rev=' + opts.rev) : '';\n    const url = genDBUrl(host, encodeDocId(docId)) + '/' +\n        encodeAttachmentId(attachmentId) + params;\n    let contentType;\n    ourFetch(url, {method: 'GET'}).then(function (response) {\n      contentType = response.headers.get('content-type');\n      if (!response.ok) {\n        throw response;\n      } else {\n        if (typeof process !== 'undefined' && !process.browser && typeof response.buffer === 'function') {\n          return response.buffer();\n        } else {\n          /* istanbul ignore next */\n          return response.blob();\n        }\n      }\n    }).then(function (blob) {\n      // TODO: also remove\n      if (typeof process !== 'undefined' && !process.browser) {\n        const typeFieldDescriptor = Object.getOwnPropertyDescriptor(blob.__proto__, 'type');\n        if (!typeFieldDescriptor || typeFieldDescriptor.set) {\n          blob.type = contentType;\n        }\n      }\n      callback(null, blob);\n    }).catch(function (err) {\n      callback(err);\n    });\n  });\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment =  adapterFun$$1('removeAttachment', function (docId,\n                                                                   attachmentId,\n                                                                   rev,\n                                                                   callback) {\n    const url = genDBUrl(host, encodeDocId(docId) + '/' +\n                       encodeAttachmentId(attachmentId)) + '?rev=' + rev;\n    fetchJSON(url, {method: 'DELETE'}, callback).catch(callback);\n  });\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment = adapterFun$$1('putAttachment', function (docId, attachmentId,\n                                                            rev, blob,\n                                                            type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    const id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n    let url = genDBUrl(host, id);\n    if (rev) {\n      url += '?rev=' + rev;\n    }\n\n    if (typeof blob === 'string') {\n      // input is assumed to be a base64 string\n      let binary;\n      try {\n        binary = thisAtob(blob);\n      } catch (err) {\n        return callback(createError(BAD_ARG,\n                        'Attachment is not a valid base64 string'));\n      }\n      blob = binary ? binStringToBluffer(binary, type) : '';\n    }\n\n    // Add the attachment\n    fetchJSON(url, {\n      headers: new h({'Content-Type': type}),\n      method: 'PUT',\n      body: blob\n    }, callback).catch(callback);\n  });\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api._bulkDocs = function (req, opts, callback) {\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    req.new_edits = opts.new_edits;\n\n    setup().then(function () {\n      return Promise.all(req.docs.map(preprocessAttachments$1));\n    }).then(function () {\n      // Update/create the documents\n      return fetchJSON(genDBUrl(host, '_bulk_docs'), {\n        method: 'POST',\n        body: JSON.stringify(req)\n      }, callback);\n    }).catch(callback);\n  };\n\n\n  // Update/create document\n  api._put = function (doc, opts, callback) {\n    setup().then(function () {\n      return preprocessAttachments$1(doc);\n    }).then(function () {\n      return fetchJSON(genDBUrl(host, encodeDocId(doc._id)), {\n        method: 'PUT',\n        body: JSON.stringify(doc)\n      });\n    }).then(function (result) {\n      callback(null, result.data);\n    }).catch(function (err) {\n      err.docId = doc && doc._id;\n      callback(err);\n    });\n  };\n\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    const params = {};\n    let body;\n    let method = 'GET';\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.include_docs) {\n      params.include_docs = true;\n    }\n\n    // added in CouchDB 1.6.0\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.key) {\n      params.key = JSON.stringify(opts.key);\n    }\n\n    if (opts.start_key) {\n      opts.startkey = opts.start_key;\n    }\n\n    if (opts.startkey) {\n      params.startkey = JSON.stringify(opts.startkey);\n    }\n\n    if (opts.end_key) {\n      opts.endkey = opts.end_key;\n    }\n\n    if (opts.endkey) {\n      params.endkey = JSON.stringify(opts.endkey);\n    }\n\n    if (typeof opts.inclusive_end !== 'undefined') {\n      params.inclusive_end = !!opts.inclusive_end;\n    }\n\n    if (typeof opts.limit !== 'undefined') {\n      params.limit = opts.limit;\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.skip = opts.skip;\n    }\n\n    const paramStr = paramsToStr(params);\n\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = {keys: opts.keys};\n    }\n\n    fetchJSON(genDBUrl(host, '_all_docs' + paramStr), {\n       method: method,\n      body: JSON.stringify(body)\n    }).then(function (result) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        result.data.rows.forEach(readAttachmentsAsBlobOrBuffer);\n      }\n      callback(null, result.data);\n    }).catch(callback);\n  });\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api._changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    const batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\n    opts = clone(opts);\n\n    if (opts.continuous && !('heartbeat' in opts)) {\n      opts.heartbeat = DEFAULT_HEARTBEAT;\n    }\n\n    let requestTimeout = ('timeout' in opts) ? opts.timeout : 30 * 1000;\n\n    // ensure CHANGES_TIMEOUT_BUFFER applies\n    if ('timeout' in opts && opts.timeout &&\n      (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    /* istanbul ignore if */\n    if ('heartbeat' in opts && opts.heartbeat &&\n       (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    const params = {};\n    if ('timeout' in opts && opts.timeout) {\n      params.timeout = opts.timeout;\n    }\n\n    const limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n    let leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.continuous) {\n      if (opts.sse && typeof EventSource === 'undefined') {\n        console.error('option sse but EventSource is undefined, maybe you need to polyfill');\n      }\n      params.feed = opts.sse ? 'eventsource' : 'longpoll';\n    }\n\n    if (opts.seq_interval) {\n      params.seq_interval = opts.seq_interval;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = true;\n    }\n\n    if ('heartbeat' in opts) {\n      // If the heartbeat value is false, it disables the default heartbeat\n      if (opts.heartbeat) {\n        params.heartbeat = opts.heartbeat;\n      }\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n    }\n\n    if (opts.view && typeof opts.view === 'string') {\n      params.filter = '_view';\n      params.view = opts.view;\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (const param_name in opts.query_params) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(opts.query_params, param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    let method = 'GET';\n    let body;\n\n    if (opts.doc_ids) {\n      // set this automagically for the user; it's annoying that couchdb\n      // requires both a \"filter\" and a \"doc_ids\" param.\n      params.filter = '_doc_ids';\n      method = 'POST';\n      body = {doc_ids: opts.doc_ids };\n    }\n    /* istanbul ignore next */\n    else if (opts.selector) {\n      // set this automagically for the user, similar to above\n      params.filter = '_selector';\n      method = 'POST';\n      body = {selector: opts.selector };\n    }\n\n    const controller = new a();\n    let lastFetchedSeq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    const fetchData = function (since, callback) {\n      if (opts.aborted) {\n        return;\n      }\n      params.since = since;\n      // \"since\" can be any kind of json object in Cloudant/CouchDB 2.x\n      /* istanbul ignore next */\n      if (typeof params.since === \"object\") {\n        params.since = JSON.stringify(params.since);\n      }\n\n      if (opts.descending) {\n        if (limit) {\n          params.limit = leftToFetch;\n        }\n      } else {\n        params.limit = (!limit || leftToFetch > batchSize) ?\n          batchSize : leftToFetch;\n      }\n\n      // Set the options for the ajax call\n      const url = genDBUrl(host, '_changes' + paramsToStr(params));\n      const fetchOpts = {\n        signal: controller.signal,\n        method: method,\n        body: JSON.stringify(body)\n      };\n      lastFetchedSeq = since;\n\n      /* istanbul ignore if */\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      if (opts.continuous && opts.sse) {\n        setup().then(function () {\n          // TODO: conflicts=true\n          // &style=all_docs\n          // &seq_interval=1`\n\n          const changes = new EventSource(url, { withCredentials: true });\n\n          sse.add(changes);\n\n          let connectionLost = false;\n          function setupTimeout () {\n            return setTimeout(() => {\n              if (!connectionLost) {\n                connectionLost = true;\n                console.warn('db connection lost!', { online: navigator.onLine, changes, sse });\n              }\n              hbTimeout = setupTimeout();\n            }, opts.heartbeat * 2)\n          }\n\n          let hbTimeout = setupTimeout();\n\n          function resetTimer () {\n            clearTimeout(hbTimeout);\n            hbTimeout = setupTimeout();\n            if (connectionLost) {\n              connectionLost = false;\n              console.info('db connection resumed!', { online: navigator.onLine, changes, sse });\n            }\n          }\n\n          changes.addEventListener('heartbeat', resetTimer);\n\n          changes.addEventListener('error', callback);\n\n          changes.addEventListener('message', e => {\n            resetTimer();\n            const change = JSON.parse(e.data);\n            callback(null, { results: [change], last_seq: change.seq });\n          });\n          fetchOpts.signal.addEventListener('abort', () => {\n            sse.delete(changes);\n            clearTimeout(hbTimeout);\n            changes.close();\n          });\n        }).catch(callback);\n      } else {\n        setup().then(function () {\n          return fetchJSON(url, fetchOpts, callback);\n        }).catch(callback);\n      }\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    const results = {results: []};\n\n    const fetched = function (err, res) {\n      if (opts.aborted) {\n        return;\n      }\n      let raw_results_length = 0;\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        raw_results_length = res.results.length;\n        results.last_seq = res.last_seq;\n        let pending = null;\n        let lastSeq = null;\n        // Attach 'pending' property if server supports it (CouchDB 2.0+)\n        /* istanbul ignore if */\n        if (typeof res.pending === 'number') {\n          pending = res.pending;\n        }\n        if (typeof results.last_seq === 'string' || typeof results.last_seq === 'number') {\n          lastSeq = results.last_seq;\n        }\n        opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          const ret = filterChange(opts)(c);\n          if (ret) {\n            if (opts.include_docs && opts.attachments && opts.binary) {\n              readAttachmentsAsBlobOrBuffer(c);\n            }\n            if (opts.return_docs) {\n              results.results.push(c);\n            }\n            opts.onChange(c, pending, lastSeq);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call\n        // opts.complete\n        opts.aborted = true;\n        opts.complete(err);\n        return;\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      const finished = (limit && leftToFetch <= 0) ||\n        (res && raw_results_length < batchSize) ||\n        (opts.descending);\n\n      if ((opts.continuous && opts.sse && !(limit && leftToFetch <= 0)) || !finished) ; else if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n        // Queue a call to fetch again with the newest sequence number\n        immediate$1(function () { fetchData(lastFetchedSeq, fetched); });\n      } else {\n        // We're done, call the callback\n        opts.complete(null, results);\n      }\n    };\n\n    fetchData(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function () {\n        opts.aborted = true;\n        controller.abort();\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    fetchJSON(genDBUrl(host, '_revs_diff'), {\n      method: 'POST',\n      body: JSON.stringify(req)\n    }, callback).catch(callback);\n  });\n\n  api._close = function (callback) {\n    callback();\n  };\n\n  api._destroy = function (options, callback) {\n    fetchJSON(genDBUrl(host, ''), {method: 'DELETE'}).then(function (json) {\n      callback(null, json);\n    }).catch(function (err) {\n      /* istanbul ignore if */\n      if (err.status === 404) {\n        callback(null, {ok: true});\n      } else {\n        callback(err);\n      }\n    });\n  };\n}\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nfunction HttpPouch$1 (PouchDB) {\n  PouchDB.adapter('http', HttpPouch, false);\n  PouchDB.adapter('https', HttpPouch, false);\n}\n\nclass QueryParseError extends Error {\n  constructor(message) {\n    super();\n    this.status = 400;\n    this.name = 'query_parse_error';\n    this.message = message;\n    this.error = true;\n    try {\n      Error.captureStackTrace(this, QueryParseError);\n    } catch (e) {}\n  }\n}\n\nclass NotFoundError extends Error {\n  constructor(message) {\n    super();\n    this.status = 404;\n    this.name = 'not_found';\n    this.message = message;\n    this.error = true;\n    try {\n      Error.captureStackTrace(this, NotFoundError);\n    } catch (e) {}\n  }\n}\n\nclass BuiltInError extends Error {\n  constructor(message) {\n    super();\n    this.status = 500;\n    this.name = 'invalid_value';\n    this.message = message;\n    this.error = true;\n    try {\n      Error.captureStackTrace(this, BuiltInError);\n    } catch (e) {}\n  }\n}\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      immediate$1(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      immediate$1(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return function (...args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  };\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new ExportedSet(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nfunction createBuiltInError(name) {\n  var message = 'builtin ' + name +\n    ' function requires map values to be numbers' +\n    ' or number arrays';\n  return new BuiltInError(message);\n}\n\nfunction sum(values) {\n  var result = 0;\n  for (var i = 0, len = values.length; i < len; i++) {\n    var num = values[i];\n    if (typeof num !== 'number') {\n      if (Array.isArray(num)) {\n        // lists of numbers are also allowed, sum them separately\n        result = typeof result === 'number' ? [result] : result;\n        for (var j = 0, jLen = num.length; j < jLen; j++) {\n          var jNum = num[j];\n          if (typeof jNum !== 'number') {\n            throw createBuiltInError('_sum');\n          } else if (typeof result[j] === 'undefined') {\n            result.push(jNum);\n          } else {\n            result[j] += jNum;\n          }\n        }\n      } else { // not array/number\n        throw createBuiltInError('_sum');\n      }\n    } else if (typeof result === 'number') {\n      result += num;\n    } else { // add number to array\n      result[0] += num;\n    }\n  }\n  return result;\n}\n\nvar log = guardedConsole.bind(null, 'log');\nvar isArray = Array.isArray;\nvar toJSON = JSON.parse;\n\nfunction evalFunctionWithEval(func, emit) {\n  return scopeEval(\n    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n    {\n      emit: emit,\n      sum: sum,\n      log: log,\n      isArray: isArray,\n      toJSON: toJSON\n    }\n  );\n}\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nclass TaskQueue$1 {\n  constructor() {\n    this.promise = new Promise(function (fulfill) {fulfill(); });\n  }\n\n  add(promiseFactory) {\n    this.promise = this.promise.catch(function () {\n      // just recover\n    }).then(function () {\n      return promiseFactory();\n    });\n    return this.promise;\n  }\n\n  finish() {\n    return this.promise;\n  }\n}\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nasync function createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  const viewSignature = createViewSignature(mapFun, reduceFun);\n\n  let cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  const promiseForView = sourceDB.info().then(async function (info) {\n    const depDbName = info.db_name + '-mrview-' +\n    (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      let fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      const depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    await upsert(sourceDB, '_local/' + localDocName, diffFunction);\n    const res = await sourceDB.registerDependentDatabase(depDbName);\n    const db = res.db;\n    db.auto_compaction = true;\n    const view = {\n      name: depDbName,\n      db: db,\n      sourceDB: sourceDB,\n      adapter: sourceDB.adapter,\n      mapFun: mapFun,\n      reduceFun: reduceFun\n    };\n\n    let lastSeqDoc;\n    try {\n      lastSeqDoc = await view.db.get('_local/lastSeq');\n    } catch (err) {\n        /* istanbul ignore if */\n      if (err.status !== 404) {\n        throw err;\n      }\n    }\n\n    view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n    if (cachedViews) {\n      view.db.once('destroyed', function () {\n        delete cachedViews[viewSignature];\n      });\n    }\n    return view;\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue$1();\nvar CHANGES_BATCH_SIZE$1 = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e, data) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e, data);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e, {fun: fun, doc: doc});\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e, {fun: fun, keys: keys, values: values, rereduce: rereduce});\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    const keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    const val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    const docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      const atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        const att = atts[filename];\n        atts[filename].data = b64ToBluffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    let val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      const asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError(`Invalid value for integer: \"${number}\"`);\n      }\n      if (number < 0) {\n        return new QueryParseError(`Invalid value for positive integer: \"${number}\"`);\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    const startkeyName = options.descending ? 'endkey' : 'startkey';\n    const endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      const error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  async function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    let params = [];\n    let body;\n    let method = 'GET';\n    let ok;\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n    addHttpParam('update_seq', opts, params);\n    addHttpParam('partition', opts, params);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      const MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      const keysAsString = `keys=${encodeURIComponent(JSON.stringify(opts.keys))}`;\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      const parts = parseViewName(fun);\n\n      const response = await db.fetch('_design/' + parts[0] + '/_view/' + parts[1] + params, {\n        headers: new h({'Content-Type': 'application/json'}),\n        method: method,\n        body: JSON.stringify(body)\n      });\n      ok = response.ok;\n      // status = response.status;\n      const result = await response.json();\n\n      if (!ok) {\n        result.status = response.status;\n        throw generateErrorFromResponse(result);\n      }\n\n      // fail the entire request if the result contains an error\n      result.rows.forEach(function (row) {\n        /* istanbul ignore if */\n        if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n          throw new Error(row.reason);\n        }\n      });\n\n      return new Promise(function (resolve) {\n        resolve(result);\n      }).then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n\n    const response = await db.fetch('_temp_view' + params, {\n      headers: new h({'Content-Type': 'application/json'}),\n      method: 'POST',\n      body: JSON.stringify(body)\n    });\n\n    ok = response.ok;\n    // status = response.status;\n    const result = await response.json();\n    if (!ok) {\n      result.status = response.status;\n      throw generateErrorFromResponse(result);\n    }\n\n    return new Promise(function (resolve) {\n      resolve(result);\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new Promise(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new Promise(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  async function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    const metaDocId = '_local/doc_' + docId;\n    const defaultMetaDoc = {_id: metaDocId, keys: []};\n    const docData = docIdsToChangesAndEmits.get(docId);\n    const indexableKeysToKeyValues = docData[0];\n    const changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return Promise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return Promise.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      const kvDocs = [];\n      const oldKeys = new ExportedSet();\n\n      for (let i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        const row = kvDocsRes.rows[i];\n        const doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          const keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      const newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          const kvDoc = {\n            _id: key\n          };\n          const keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    const metaDoc = await getMetaDoc();\n    const keyValueDocs = await getKeyValueDocs(metaDoc);\n    return processKeyValueDocs(metaDoc, keyValueDocs);\n  }\n\n  function updatePurgeSeq(view) {\n    // with this approach, we just assume to have processed all missing purges and write the latest\n    // purgeSeq into the _local/purgeSeq doc.\n    return view.sourceDB.get('_local/purges').then(function (res) {\n      const purgeSeq = res.purgeSeq;\n      return view.db.get('_local/purgeSeq').then(function (res) {\n        return res._rev;\n      }).catch(function (err) {\n        if (err.status !== 404) {\n          throw err;\n        }\n        return undefined;\n      }).then(function (rev) {\n        return view.db.put({\n          _id: '_local/purgeSeq',\n          _rev: rev,\n          purgeSeq,\n        });\n      });\n    }).catch(function (err) {\n      if (err.status !== 404) {\n        throw err;\n      }\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return Promise.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        })\n          // TODO: this should be placed somewhere else, probably? we're querying both docs twice\n          //   (first time when getting the actual purges).\n          .then(() => updatePurgeSeq(view));\n      });\n  }\n\n  function getQueue(view) {\n    const viewName = typeof view === 'string' ? view : view.name;\n    let queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue$1();\n    }\n    return queue;\n  }\n\n  async function updateView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view, opts);\n    })();\n  }\n\n  async function updateViewInQueue(view, opts) {\n    // bind the emit function once\n    let mapResults;\n    let doc;\n    let taskId;\n\n    function emit(key, value) {\n      const output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    const mapFun = mapper(view.mapFun, emit);\n\n    let currentSeq = view.seq || 0;\n\n    function createTask() {\n      return view.sourceDB.info().then(function (info) {\n        taskId = view.sourceDB.activeTasks.add({\n          name: 'view_indexing',\n          total_items: info.update_seq - currentSeq,\n        });\n      });\n    }\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    let indexed_docs = 0;\n    const progress = {\n      view: view.name,\n      indexed_docs: indexed_docs\n    };\n    view.sourceDB.emit('indexing', progress);\n\n    const queue = new TaskQueue$1();\n\n    async function processNextBatch() {\n      const response = await view.sourceDB.changes({\n        return_docs: true,\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: opts.changes_batch_size\n      });\n      const purges = await getRecentPurges();\n      return processBatch(response, purges);\n    }\n\n    function getRecentPurges() {\n      return view.db.get('_local/purgeSeq').then(function (res) {\n        return res.purgeSeq;\n      }).catch(function (err) {\n        if (err && err.status !== 404) {\n          throw err;\n        }\n        return -1;\n      }).then(function (purgeSeq) {\n        return view.sourceDB.get('_local/purges').then(function (res) {\n          const recentPurges = res.purges.filter(function (purge, index) {\n            return index > purgeSeq;\n          }).map((purge) => purge.docId);\n\n          const uniquePurges = recentPurges.filter(function (docId, index) {\n            return recentPurges.indexOf(docId) === index;\n          });\n\n          return Promise.all(uniquePurges.map(function (docId) {\n            return view.sourceDB.get(docId).then(function (doc) {\n              return { docId, doc };\n            }).catch(function (err) {\n              if (err.status !== 404) {\n                throw err;\n              }\n              return { docId };\n            });\n          }));\n        }).catch(function (err) {\n          if (err && err.status !== 404) {\n            throw err;\n          }\n          return [];\n        });\n      });\n    }\n\n    function processBatch(response, purges) {\n      var results = response.results;\n      if (!results.length && !purges.length) {\n        return;\n      }\n\n      for (let purge of purges) {\n        const index = results.findIndex(function (change) {\n          return change.id === purge.docId;\n        });\n        if (index < 0) {\n          // mimic a db.remove() on the changes feed\n          const entry = {\n            _id: purge.docId,\n            doc: {\n              _id: purge.docId,\n              _deleted: 1,\n            },\n            changes: [],\n          };\n\n          if (purge.doc) {\n            // update with new winning rev after purge\n            entry.doc = purge.doc;\n            entry.changes.push({ rev: purge.doc._rev });\n          }\n\n          results.push(entry);\n        }\n      }\n\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n\n      indexed_docs = indexed_docs + results.length;\n      const progress = {\n        view: view.name,\n        last_seq: response.last_seq,\n        results_count: results.length,\n        indexed_docs: indexed_docs\n      };\n      view.sourceDB.emit('indexing', progress);\n      view.sourceDB.activeTasks.update(taskId, {completed_items: indexed_docs});\n\n      if (results.length < opts.changes_batch_size) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      const docIdsToChangesAndEmits = new ExportedMap();\n      for (let i = 0, len = results.length; i < len; i++) {\n        const change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          const indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      const indexableKeysToKeyValues = new ExportedMap();\n      let lastKey;\n      for (let i = 0, len = mapResults.length; i < len; i++) {\n        const emittedKeyValue = mapResults[i];\n        const complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    try {\n      await createTask();\n      await processNextBatch();\n      await queue.finish();\n      view.seq = currentSeq;\n      view.sourceDB.activeTasks.remove(taskId);\n    } catch (error) {\n      view.sourceDB.activeTasks.remove(taskId, error);\n    }\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    const shouldGroup = options.group || options.group_level;\n\n    const reduceFun = reducer(view.reduceFun);\n\n    const groups = [];\n    const lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      const last = groups[groups.length - 1];\n      let groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (let i = 0, len = groups.length; i < len; i++) {\n      const e = groups[i];\n      const reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  async function queryViewInQueue(view, opts) {\n    let totalRows;\n    const shouldReduce = view.reduceFun && opts.reduce !== false;\n    const skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    async function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      const res = await view.db.allDocs(viewOpts);\n      totalRows = res.total_rows;\n\n      return res.rows.map(function (result) {\n        // implicit migration - in older versions of PouchDB,\n        // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n        // this is tested in a migration test\n        /* istanbul ignore next */\n        if ('value' in result.doc && typeof result.doc.value === 'object' &&\n          result.doc.value !== null) {\n          const keys = Object.keys(result.doc.value).sort();\n          // this detection method is not perfect, but it's unlikely the user\n          // emitted a value which was an object with these 3 exact keys\n          const expectedKeys = ['id', 'key', 'value'];\n          if (!(keys < expectedKeys || keys > expectedKeys)) {\n            return result.doc.value;\n          }\n        }\n\n        const parsedKeyAndDocId = parseIndexableString(result.doc._id);\n        return {\n          key: parsedKeyAndDocId[0],\n          id: parsedKeyAndDocId[1],\n          value: ('value' in result.doc ? result.doc.value : null)\n        };\n      });\n    }\n\n    async function onMapResultsReady(rows) {\n      let finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else if (typeof opts.keys === 'undefined') {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      } else {\n        // support limit, skip for keys query\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: sliceResults(rows,opts.limit,opts.skip)\n        };\n      }\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        finalResults.update_seq = view.seq;\n      }\n      if (opts.include_docs) {\n        const docIds = uniq(rows.map(rowToDocId));\n\n        const allDocsRes = await view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        });\n        var docIdsToDocs = new ExportedMap();\n        allDocsRes.rows.forEach(function (row) {\n          docIdsToDocs.set(row.id, row.doc);\n        });\n        rows.forEach(function (row) {\n          var docId = rowToDocId(row);\n          var doc = docIdsToDocs.get(docId);\n          if (doc) {\n            row.doc = doc;\n          }\n        });\n        return finalResults;\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      const keys = opts.keys;\n      const fetchPromises = keys.map(function (key) {\n        const viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        /* istanbul ignore if */\n        if (opts.update_seq) {\n          viewOpts.update_seq = true;\n        }\n        return fetchFromView(viewOpts);\n      });\n      const result = await Promise.all(fetchPromises);\n      const flattenedResult = flatten(result);\n      return onMapResultsReady(flattenedResult);\n    } else { // normal query, no 'keys'\n      const viewOpts = {\n        descending : opts.descending\n      };\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        viewOpts.update_seq = true;\n      }\n      let startkey;\n      let endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        let inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        const keyStart = toIndexableString([opts.key]);\n        const keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n\n      const result = await fetchFromView(viewOpts);\n      return onMapResultsReady(result);\n    }\n  }\n\n  async function httpViewCleanup(db) {\n    const response = await db.fetch('_view_cleanup', {\n      headers: new h({'Content-Type': 'application/json'}),\n      method: 'POST'\n    });\n    return response.json();\n  }\n\n  async function localViewCleanup(db) {\n    try {\n      const metaDoc = await db.get('_local/' + localDocName);\n      const docsToViews = new ExportedMap();\n\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        const parts = parseViewName(fullViewName);\n        const designDocName = '_design/' + parts[0];\n        const viewName = parts[1];\n        let views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new ExportedSet();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      const opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n\n      const res = await db.allDocs(opts);\n      const viewsToStatus = {};\n      res.rows.forEach(function (row) {\n        const ddocName = row.key.substring(8); // cuts off '_design/'\n        docsToViews.get(row.key).forEach(function (viewName) {\n          let fullViewName = ddocName + '/' + viewName;\n          /* istanbul ignore if */\n          if (!metaDoc.views[fullViewName]) {\n            // new format, without slashes, to support PouchDB 2.2.0\n            // migration test in pouchdb's browser.migration.js verifies this\n            fullViewName = viewName;\n          }\n          const viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n          // design doc deleted, or view function nonexistent\n          const statusIsGood = row.doc && row.doc.views &&\n            row.doc.views[viewName];\n          viewDBNames.forEach(function (viewDBName) {\n            viewsToStatus[viewDBName] =\n              viewsToStatus[viewDBName] || statusIsGood;\n          });\n        });\n      });\n\n      const dbsToDelete = Object.keys(viewsToStatus)\n        .filter(function (viewDBName) { return !viewsToStatus[viewDBName]; });\n\n      const destroyPromises = dbsToDelete.map(function (viewDBName) {\n        return sequentialize(getQueue(viewDBName), function () {\n          return new db.constructor(viewDBName, db.__opts).destroy();\n        })();\n      });\n\n      return Promise.all(destroyPromises).then(function () {\n        return {ok: true};\n      });\n    } catch (err) {\n      if (err.status === 404) {\n        return {ok: true};\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  async function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    const updateViewOpts = {\n      changes_batch_size: db.__opts.view_update_changes_batch_size || CHANGES_BATCH_SIZE$1\n    };\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(async function () {\n        const view = await createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n\n        return fin(updateView(view, updateViewOpts).then(\n          function () { return queryView(view, opts); }),\n          function () { return view.db.destroy(); }\n        );\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      const fullViewName = fun;\n      const parts = parseViewName(fullViewName);\n      const designDocName = parts[0];\n      const viewName = parts[1];\n\n      const doc = await db.get('_design/' + designDocName);\n      fun = doc.views && doc.views[viewName];\n\n      if (!fun) {\n        // basic validator; it's assumed that every subclass would want this\n        throw new NotFoundError(`ddoc ${doc._id} has no view named ${viewName}`);\n      }\n\n      ddocValidator(doc, viewName);\n      checkQueryParseError(opts, fun);\n\n      const view = await createView(\n        /* sourceDB */ db,\n        /* viewName */ fullViewName,\n        /* mapFun */ fun.map,\n        /* reduceFun */ fun.reduce,\n        /* temporary */ false,\n        /* localDocName */ localDocName);\n\n      if (opts.stale === 'ok' || opts.stale === 'update_after') {\n        if (opts.stale === 'update_after') {\n          immediate$1(function () {\n            updateView(view, updateViewOpts);\n          });\n        }\n        return queryView(view, opts);\n      } else { // stale not ok\n        await updateView(view, updateViewOpts);\n        return queryView(view, opts);\n      }\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    const db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    const promise = Promise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  const abstractViewCleanup = callbackify(function () {\n    const db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nvar builtInReduce = {\n  _sum: function (keys, values) {\n    return sum(values);\n  },\n\n  _count: function (keys, values) {\n    return values.length;\n  },\n\n  _stats: function (keys, values) {\n    // no need to implement rereduce=true, because Pouch\n    // will never call it\n    function sumsqr(values) {\n      var _sumsqr = 0;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var num = values[i];\n        _sumsqr += (num * num);\n      }\n      return _sumsqr;\n    }\n    return {\n      sum     : sum(values),\n      min     : Math.min.apply(null, values),\n      max     : Math.max.apply(null, values),\n      count   : values.length,\n      sumsqr : sumsqr(values)\n    };\n  }\n};\n\nfunction getBuiltIn(reduceFunString) {\n  if (/^_sum/.test(reduceFunString)) {\n    return builtInReduce._sum;\n  } else if (/^_count/.test(reduceFunString)) {\n    return builtInReduce._count;\n  } else if (/^_stats/.test(reduceFunString)) {\n    return builtInReduce._stats;\n  } else if (/^_/.test(reduceFunString)) {\n    throw new Error(reduceFunString + ' is not a supported reduce function.');\n  }\n}\n\nfunction mapper(mapFun, emit) {\n  // for temp_views one can use emit(doc, emit), see #38\n  if (typeof mapFun === \"function\" && mapFun.length === 2) {\n    var origMap = mapFun;\n    return function (doc) {\n      return origMap(doc, emit);\n    };\n  } else {\n    return evalFunctionWithEval(mapFun.toString(), emit);\n  }\n}\n\nfunction reducer(reduceFun) {\n  var reduceFunString = reduceFun.toString();\n  var builtIn = getBuiltIn(reduceFunString);\n  if (builtIn) {\n    return builtIn;\n  } else {\n    return evalFunctionWithEval(reduceFunString);\n  }\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var fun = ddoc.views && ddoc.views[viewName];\n  if (typeof fun.map !== 'string') {\n    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +\n      viewName + ', instead found object of type: ' + typeof fun.map);\n  }\n}\n\nvar localDocName = 'mrviews';\nvar abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);\n\nfunction query$1(fun, opts, callback) {\n  return abstract.query.call(this, fun, opts, callback);\n}\n\nfunction viewCleanup$1(callback) {\n  return abstract.viewCleanup.call(this, callback);\n}\n\nvar mapreduce = {\n  query: query$1,\n  viewCleanup: viewCleanup$1\n};\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments ||\n         !localDoc._attachments[filename] ||\n         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return Promise.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return Promise.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  }).catch(function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true,\n    latest: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      return Promise.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return Promise.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)\n                   .then(function (attachments) {\n                           var filenames = Object.keys(remoteDoc._attachments);\n                           attachments\n                             .forEach(function (attachment, i) {\n                                        var att = remoteDoc._attachments[filenames[i]];\n                                        delete att.stub;\n                                        delete att.length;\n                                        att.data = attachment;\n                                      });\n\n                                      return remoteDoc;\n                                    });\n        }));\n      }))\n\n      .then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function returnResult() {\n    return { ok:ok, docs:resultDocs };\n  }\n\n  return Promise.resolve()\n    .then(getAllDocs)\n    .then(returnResult);\n}\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id).catch(function (err) {\n    if (err.status === 404) {\n      if (db.adapter === 'http' || db.adapter === 'https') {\n        explainError(\n          404, 'PouchDB is just checking if a remote checkpoint exists.'\n        );\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n\n    // if the checkpoint has not changed, do not update\n    if (doc.last_seq === checkpoint) {\n      return;\n    }\n\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc).catch(function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nclass CheckpointerInternal {\n  constructor(src, target, id, returnValue, opts) {\n    this.src = src;\n    this.target = target;\n    this.id = id;\n    this.returnValue = returnValue;\n    this.opts = opts || {};\n  }\n\n  writeCheckpoint(checkpoint, session) {\n    var self = this;\n    return this.updateTarget(checkpoint, session).then(function () {\n      return self.updateSource(checkpoint, session);\n    });\n  }\n\n  updateTarget(checkpoint, session) {\n    if (this.opts.writeTargetCheckpoint) {\n      return updateCheckpoint(this.target, this.id, checkpoint,\n        session, this.returnValue);\n    } else {\n      return Promise.resolve(true);\n    }\n  }\n\n  updateSource(checkpoint, session) {\n    if (this.opts.writeSourceCheckpoint) {\n      var self = this;\n      return updateCheckpoint(this.src, this.id, checkpoint,\n        session, this.returnValue)\n        .catch(function (err) {\n          if (isForbiddenError(err)) {\n            self.opts.writeSourceCheckpoint = false;\n            return true;\n          }\n          throw err;\n        });\n    } else {\n      return Promise.resolve(true);\n    }\n  }\n\n  getCheckpoint() {\n    var self = this;\n    var since = self.opts.since || LOWEST_SEQ;\n\n    if (self.opts && self.opts.writeSourceCheckpoint && !self.opts.writeTargetCheckpoint) {\n      return self.src.get(self.id).then(function (sourceDoc) {\n        return sourceDoc.last_seq || since;\n      }).catch(function (err) {\n        /* istanbul ignore if */\n        if (err.status !== 404) {\n          throw err;\n        }\n        return since;\n      });\n    }\n\n    return self.target.get(self.id).then(function (targetDoc) {\n      if (self.opts && self.opts.writeTargetCheckpoint && !self.opts.writeSourceCheckpoint) {\n        return targetDoc.last_seq || since;\n      }\n\n      return self.src.get(self.id).then(function (sourceDoc) {\n        // Since we can't migrate an old version doc to a new one\n        // (no session id), we just go with the lowest seq in this case\n        /* istanbul ignore if */\n        if (targetDoc.version !== sourceDoc.version) {\n          return since;\n        }\n\n        var version;\n        if (targetDoc.version) {\n          version = targetDoc.version.toString();\n        } else {\n          version = \"undefined\";\n        }\n\n        if (version in comparisons) {\n          return comparisons[version](targetDoc, sourceDoc, since);\n        }\n        /* istanbul ignore next */\n        return since;\n      }, function (err) {\n        if (err.status === 404 && targetDoc.last_seq) {\n          return self.src.put({\n            _id: self.id,\n            last_seq: since\n          }).then(function () {\n            return since;\n          }, function (err) {\n            if (isForbiddenError(err)) {\n              self.opts.writeSourceCheckpoint = false;\n              return targetDoc.last_seq;\n            }\n            /* istanbul ignore next */\n            return since;\n          });\n        }\n        throw err;\n      });\n    }).catch(function (err) {\n      if (err.status !== 404) {\n        throw err;\n      }\n      return since;\n    });\n  }\n}\n\nvar comparisons = {\n  \"undefined\": function (targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function (targetDoc, sourceDoc, since) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc, since).last_seq;\n  }\n};\n\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs(srcDoc, tgtDoc, since) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history, since);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory, since) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: since,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest, since);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nfunction Checkpointer(src, target, id, returnValue, opts) {\n  if (!(this instanceof CheckpointerInternal)) {\n    return new CheckpointerInternal(src, target, id, returnValue, opts);\n  }\n  return Checkpointer;\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  /* istanbul ignore if */\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction sortObjectPropertiesByKey(queryParams) {\n  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n    result[key] = queryParams[key];\n    return result;\n  }, {});\n}\n\n// Generate a unique id particular to this replication.\n// Not guaranteed to align perfectly with CouchDB's rep ids.\nfunction generateReplicationId(src, target, opts) {\n  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  var queryParams = '';\n  var filterViewName =  '';\n  var selector = '';\n\n  // possibility for checkpoints to be lost here as behaviour of\n  // JSON.stringify is not stable (see #6226)\n  /* istanbul ignore if */\n  if (opts.selector) {\n    selector = JSON.stringify(opts.selector);\n  }\n\n  if (opts.filter && opts.query_params) {\n    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n  }\n\n  if (opts.filter && opts.filter === '_view') {\n    filterViewName = opts.view.toString();\n  }\n\n  return Promise.all([src.id(), target.id()]).then(function (res) {\n    var queryData = res[0] + res[1] + filterFun + filterViewName +\n      queryParams + docIds + selector;\n    return new Promise(function (resolve) {\n      binaryMd5(queryData, resolve);\n    });\n  }).then(function (md5sum) {\n    // can't use straight-up md5 alphabet, because\n    // the char '/' is interpreted as being for attachments,\n    // and + is also not url-safe\n    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n    return '_local/' + md5sum;\n  });\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = [];               // list of batches to be processed\n  var currentBatch;               // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false;  // true while checkpoint is being written\n  var changesCompleted = false;   // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  // initial_last_seq is the state of the source db before\n  // replication started, and it is _not_ updated during\n  // replication or used anywhere else, as opposed to last_seq\n  var initial_last_seq = 0;\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var style = opts.style || 'all_docs';\n  var changesPending = false;     // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var selector = opts.selector;\n  var repId;\n  var checkpointer;\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n  var taskId;\n\n  result = result || {\n    ok: true,\n    start_time: new Date().toISOString(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return Promise.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      returnValue.replicationId = repId = res;\n\n      var checkpointOpts = {};\n      if (opts.checkpoint === false) {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false, since: opts.since };\n      } else if (opts.checkpoint === 'source') {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false, since: opts.since };\n      } else if (opts.checkpoint === 'target') {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true, since: opts.since };\n      } else {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true, since: opts.since };\n      }\n\n      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    var bulkOpts = {timeout: opts.timeout};\n    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      // `res` doesn't include full documents (which live in `docs`), so we create a map of\n      // (id -> error), and check for errors while iterating over `docs`\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          result.errors.push(error);\n          // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n          var errorName = (error.name || '').toLowerCase();\n          if (errorName === 'unauthorized' || errorName === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  async function finishBatch () {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      // Attach 'pending' property if server supports it (CouchDB 2.0+)\n      /* istanbul ignore if */\n      if (typeof currentBatch.pending === 'number') {\n        outResult.pending = currentBatch.pending;\n        delete currentBatch.pending;\n      }\n      returnValue.emit('change', outResult);\n    }\n\n    writingCheckpoint = true;\n\n    var task = src.activeTasks.get(taskId);\n    if (!currentBatch || !task) {\n      return;\n    }\n\n    var completed = task.completed_items || 0;\n\n    let total_items;\n    if (typeof initial_last_seq === 'number') {\n      const info = await src.info();\n      if (typeof info.update_seq === 'number') {\n        total_items = info.update_seq - initial_last_seq;\n      }\n    }\n\n    src.activeTasks.update(taskId, {\n      completed_items: completed + currentBatch.changes.length,\n      total_items\n    });\n\n    return checkpointer.writeCheckpoint(currentBatch.seq, session).then(() => {\n      returnValue.emit('checkpoint', { 'checkpoint': currentBatch.seq });\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    }).catch(function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      returnValue.emit('checkpoint', { 'revs_diff': change });\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    returnValue.emit('checkpoint', { 'start_next_batch': currentBatch.seq });\n    getDiffs()\n      .then(getBatchDocs)\n      .then(writeDocs)\n      .then(finishBatch)\n      .then(startNextBatch)\n      .catch(function (err) {\n        abortReplication('batch processing terminated with error', err);\n      });\n  }\n\n\n  function processPendingBatch(immediate$$1) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if ((continuous && changesOpts.live) || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (\n      immediate$$1 ||\n      changesCompleted ||\n      pendingBatch.changes.length >= batch_size\n    ) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date().toISOString();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    src.activeTasks.remove(taskId, fatalError);\n\n    if (fatalError) {\n      // need to extend the error because Firefox considers \".result\" read-only\n      fatalError = createError(fatalError);\n      fatalError.result = result;\n\n      // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n      var errorName = (fatalError.name || '').toLowerCase();\n      if (errorName === 'unauthorized' || errorName === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n  function onChange(change, pending, lastSeq) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    // Attach 'pending' property if server supports it (CouchDB 2.0+)\n    /* istanbul ignore if */\n    if (typeof pending === 'number') {\n      pendingBatch.pending = pending;\n    }\n\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      // update processed items count by 1\n      var task = src.activeTasks.get(taskId);\n      if (task) {\n        // we can assume that task exists here? shouldn't be deleted by here.\n        var completed = task.completed_items || 0;\n        src.activeTasks.update(taskId, {completed_items: ++completed});\n      }\n      return;\n    }\n    pendingBatch.seq = change.seq || lastSeq;\n    pendingBatch.changes.push(change);\n    returnValue.emit('checkpoint', { 'pending_batch': pendingBatch.seq });\n    immediate$1(function () {\n      processPendingBatch(batches.length === 0 && changesOpts.live);\n    });\n  }\n\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    const done = changes.results.length < batch_size;\n\n    if (!done) {\n      changesOpts.since = changes.results[changes.results.length - 1].seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n      // process the last partial batch\n      if (changes.results.length) {\n        changesOpts.since = changes.results[changes.results.length - 1].seq;\n        processPendingBatch(true);\n      }\n      var complete = function () {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n        processPendingBatch(true);\n      };\n\n      // update the checkpoint so we start from the right seq next time\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq, session).then(() => {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          complete();\n        })\n        .catch(onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n\n  function getChanges() {\n    if (!(\n      !changesPending &&\n      !changesCompleted &&\n      batches.length < batches_limit\n      )) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) { // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts)\n      .on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete)\n      .catch(onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n  async function createTask (checkpoint) {\n    const info = await src.info();\n\n    let total_items;\n    if (typeof info.update_seq === 'number') {\n      total_items = typeof opts.since === 'undefined' ?\n      info.update_seq - checkpoint :\n      info.update_seq;\n    }\n\n    taskId = src.activeTasks.add({\n      name: `${continuous ? 'continuous ' : ''}replication from ${info.db_name}` ,\n      total_items,\n    });\n\n    return checkpoint;\n  }\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(createTask).then((checkpoint) => {\n        last_seq = checkpoint;\n        initial_last_seq = checkpoint;\n        changesOpts = {\n          live: opts.sse && opts.skipInitialBatch,\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: style,\n          doc_ids: doc_ids,\n          selector: selector,\n          return_docs: true // required so we know when we're done\n        };\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else { // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if (opts.sse) {\n          changesOpts.sse = opts.sse;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    }).catch(function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) { // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  startChanges();\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\nclass Replication extends EE {\n  constructor() {\n    super();\n    this.cancelled = false;\n    this.state = 'pending';\n    const promise = new Promise((fulfill, reject) => {\n      this.once('complete', fulfill);\n      this.once('error', reject);\n    });\n    this.then = function (resolve, reject) {\n      return promise.then(resolve, reject);\n    };\n    this.catch = function (reject) {\n      return promise.catch(reject);\n    };\n    // As we allow error handling via \"error\" event as well,\n    // put a stub in here so that rejecting never throws UnhandledError.\n    this.catch(function () {});\n  }\n\n  cancel() {\n    this.cancelled = true;\n    this.state = 'cancelled';\n    this.emit('cancel');\n  }\n\n  ready(src, target) {\n    if (this._readyCalled) {\n      return;\n    }\n    this._readyCalled = true;\n  \n    const onDestroy = () => {\n      this.cancel();\n    };\n    src.once('destroyed', onDestroy);\n    target.once('destroyed', onDestroy);\n    function cleanup() {\n      src.removeListener('destroyed', onDestroy);\n      target.removeListener('destroyed', onDestroy);\n    }\n    this.once('complete', cleanup);\n    this.once('error', cleanup);\n  }\n}\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST,\n                       \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = ('retry' in opts) ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\nfunction sync(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nclass Sync extends EE {\n  constructor(src, target, opts, callback) {\n    super();\n    this.canceled = false;\n\n    const optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;\n    const optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;\n\n    this.push = replicateWrapper(src, target, optsPush);\n    this.pull = replicateWrapper(target, src, optsPull);\n\n    this.pushPaused = true;\n    this.pullPaused = true;\n\n    const pullChange = (change) => {\n      this.emit('change', {\n        direction: 'pull',\n        change: change\n      });\n    };\n    const pushChange = (change) => {\n      this.emit('change', {\n        direction: 'push',\n        change: change\n      });\n    };\n    const pushDenied = (doc) => {\n      this.emit('denied', {\n        direction: 'push',\n        doc: doc\n      });\n    };\n    const pullDenied = (doc) => {\n      this.emit('denied', {\n        direction: 'pull',\n        doc: doc\n      });\n    };\n    const pushPaused = () => {\n      this.pushPaused = true;\n      /* istanbul ignore if */\n      if (this.pullPaused) {\n        this.emit('paused');\n      }\n    };\n    const pullPaused = () => {\n      this.pullPaused = true;\n      /* istanbul ignore if */\n      if (this.pushPaused) {\n        this.emit('paused');\n      }\n    };\n    const pushActive = () => {\n      this.pushPaused = false;\n      /* istanbul ignore if */\n      if (this.pullPaused) {\n        this.emit('active', {\n          direction: 'push'\n        });\n      }\n    };\n    const pullActive = () => {\n      this.pullPaused = false;\n      /* istanbul ignore if */\n      if (this.pushPaused) {\n        this.emit('active', {\n          direction: 'pull'\n        });\n      }\n    };\n\n    let removed = {};\n\n    const removeAll = (type) => { // type is 'push' or 'pull'\n      return (event, func) => {\n        const isChange = event === 'change' &&\n          (func === pullChange || func === pushChange);\n        const isDenied = event === 'denied' &&\n          (func === pullDenied || func === pushDenied);\n        const isPaused = event === 'paused' &&\n          (func === pullPaused || func === pushPaused);\n        const isActive = event === 'active' &&\n          (func === pullActive || func === pushActive);\n\n        if (isChange || isDenied || isPaused || isActive) {\n          if (!(event in removed)) {\n            removed[event] = {};\n          }\n          removed[event][type] = true;\n          if (Object.keys(removed[event]).length === 2) {\n            // both push and pull have asked to be removed\n            this.removeAllListeners(event);\n          }\n        }\n      };\n    };\n\n    if (opts.live) {\n      this.push.on('complete', this.pull.cancel.bind(this.pull));\n      this.pull.on('complete', this.push.cancel.bind(this.push));\n    }\n\n    function addOneListener(ee, event, listener) {\n      if (ee.listeners(event).indexOf(listener) == -1) {\n        ee.on(event, listener);\n      }\n    }\n\n    this.on('newListener', function (event) {\n      if (event === 'change') {\n        addOneListener(this.pull, 'change', pullChange);\n        addOneListener(this.push, 'change', pushChange);\n      } else if (event === 'denied') {\n        addOneListener(this.pull, 'denied', pullDenied);\n        addOneListener(this.push, 'denied', pushDenied);\n      } else if (event === 'active') {\n        addOneListener(this.pull, 'active', pullActive);\n        addOneListener(this.push, 'active', pushActive);\n      } else if (event === 'paused') {\n        addOneListener(this.pull, 'paused', pullPaused);\n        addOneListener(this.push, 'paused', pushPaused);\n      }\n    });\n\n    this.on('removeListener', function (event) {\n      if (event === 'change') {\n        this.pull.removeListener('change', pullChange);\n        this.push.removeListener('change', pushChange);\n      } else if (event === 'denied') {\n        this.pull.removeListener('denied', pullDenied);\n        this.push.removeListener('denied', pushDenied);\n      } else if (event === 'active') {\n        this.pull.removeListener('active', pullActive);\n        this.push.removeListener('active', pushActive);\n      } else if (event === 'paused') {\n        this.pull.removeListener('paused', pullPaused);\n        this.push.removeListener('paused', pushPaused);\n      }\n    });\n\n    this.pull.on('removeListener', removeAll('pull'));\n    this.push.on('removeListener', removeAll('push'));\n\n    const promise = Promise.all([\n      this.push,\n      this.pull\n    ]).then((resp) => {\n      const out = {\n        push: resp[0],\n        pull: resp[1]\n      };\n      this.emit('complete', out);\n      if (callback) {\n        callback(null, out);\n      }\n      this.removeAllListeners();\n      return out;\n    }, (err) => {\n      this.cancel();\n      if (callback) {\n        // if there's a callback, then the callback can receive\n        // the error event\n        callback(err);\n      } else {\n        // if there's no callback, then we're safe to emit an error\n        // event, which would otherwise throw an unhandled error\n        // due to 'error' being a special event in EventEmitters\n        this.emit('error', err);\n      }\n      this.removeAllListeners();\n      if (callback) {\n        // no sense throwing if we're already emitting an 'error' event\n        throw err;\n      }\n    });\n\n    this.then = function (success, err) {\n      return promise.then(success, err);\n    };\n\n    this.catch = function (err) {\n      return promise.catch(err);\n    };\n  }\n\n  cancel() {\n    if (!this.canceled) {\n      this.canceled = true;\n      this.push.cancel();\n      this.pull.cancel();\n    }\n  }\n}\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicateWrapper;\n  PouchDB.sync = sync;\n\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function () {\n      var self = this;\n      if (typeof this.replicateMethods === 'undefined') {\n        this.replicateMethods = {\n          from: function (other, opts, callback) {\n            return self.constructor.replicate(other, self, opts, callback);\n          },\n          to: function (other, opts, callback) {\n            return self.constructor.replicate(self, other, opts, callback);\n          }\n        };\n      }\n      return this.replicateMethods;\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nPouchDB.plugin(IndexedDbPouch)\n  .plugin(HttpPouch$1)\n  .plugin(mapreduce)\n  .plugin(replication);\n\nexport { PouchDB as default };\n", "// eslint-disable-next-line no-restricted-imports\nimport PouchDB from '../../build/deps/pouchdb.js'\n// import findPlugin from 'pouchdb-find'; PouchDB.plugin(findPlugin)\n// import req from '../lib/req.js'\n\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms))\n\nconst awaitableApis = ['/_view/', '/_search/', '/_all_docs', '/_design_docs', '/_find']\nlet activePush\nlet pushResolver\n\nasync function rateRetryFetch (url, opts, awaitable, count = 1) {\n  if (activePush && awaitable) {\n    await activePush\n  }\n\n  const res = await PouchDB.fetch(url, opts)\n\n  if (res.status === 429 && count < 4) {\n    console.warn('rate limited, retry no ' + count)\n    await sleep(count * 800)\n    return rateRetryFetch(url, opts, awaitable, count++)\n  }\n  return res\n}\n\n// since we know how our checkpoint docs work and they can only be from\n// pouch to couch we can cache all GETS and save 2 get requests per sync checkpoint vs normal pouchdb default\n\nexport default async function ({\n  clientDbName,\n  serverDbName,\n  clientDbSeeds,\n  sessionId,\n  preload\n}) {\n  PouchDB.prefix = '_ayu_'\n  // PouchDB.plugin({ bulkDocs: function () { return { self:this, args: arguments }; }})\n  // PouchDB.plugin({ test: function () { return { self:this, args: arguments }; }})\n  const pouch = new PouchDB(clientDbName, { revs_limit: 200, auto_compaction: true, deterministic_revs: true })\n  let couch\n  let sync\n  // console.log(pouch)\n  // console.log(pouch.test())\n  const checkpointCache = new Map()\n  const viewCache = new Map()\n  const pulledIds = new Set\n  const hasCouch = !sessionId.startsWith('ephemeral:')\n  let initResolver\n  let inited\n\n  await pouch.bulkDocs([ { _id: '_local/ayu', sessionId }, ...(clientDbSeeds || []) ]).catch(() => {})\n\n  if (hasCouch) {\n    couch = new PouchDB(`${location.origin}/_api/_couch/${serverDbName}`, {\n      fetch: async (url, opts) => {\n        opts.redirect = 'error'\n        opts.headers.set('X-Requested-With', 'XMLHttpRequest')\n\n        const awaitable = awaitableApis.some(elem => url.includes(elem))\n        let viewReqKey = null\n        if (awaitable && (opts.method === 'GET' || !opts.method)) {\n          const pUrl = new URL(url)\n          viewReqKey = pUrl.pathname +[...(new URLSearchParams(pUrl.search))].sort().join('_')\n\n          if (activePush) {\n            await activePush\n          }\n\n          const maybeCached = viewCache.get(viewReqKey)\n          if (maybeCached) {\n            // console.log(viewReqKey, '< cached')\n            return Promise.resolve(new Response(maybeCached, { headers: { 'content-type': 'application/json' }}))\n          }\n          // console.log(viewReqKey)\n        }\n\n        let checkpointReqKey = null\n        const [_, idSuffix] = url.split('/_local/')\n\n        if (idSuffix) {\n          const checkpointDocId = '_local/' + decodeURIComponent(idSuffix)\n          // console.log(opts.method, {checkpointDocId, checkpointCache})\n          if (checkpointDocId === sync.pull.replicationId || checkpointDocId === sync.push.replicationId) {\n            checkpointReqKey = checkpointDocId\n\n            if (opts.method === 'GET' || !opts.method) {\n              const maybeCached = checkpointCache.get(checkpointDocId)\n              if (maybeCached) {\n                // FIXME: add etag?\n                if (maybeCached._status === 404) {\n                  return Promise.resolve(new Response('{}', { status: 404, headers: { 'content-type': 'application/json' }}))\n                }\n                return Promise.resolve(new Response(JSON.stringify(maybeCached), { headers: { 'content-type': 'application/json' }}))\n              }\n            }\n          }\n        }\n\n        return rateRetryFetch(url, opts, awaitable).then(async res => {\n          if (res.status === 401 || res.redirected || res.type === 'opaqueredirect') {\n            self.session?.refresh()\n          }\n\n          if (checkpointReqKey) {\n            if (res.ok || res.status === 404) {\n              if (res.status === 404) {\n                checkpointCache.set(checkpointReqKey, { _status: 404 })\n              } else {\n                const json = await res.clone().json()\n\n                if ((opts.method === 'GET' || !opts.method) && json._rev) {\n                  checkpointCache.set(checkpointReqKey, json)\n                } else if (opts.method === 'PUT' && json.ok) {\n                  const newCheckpoint = JSON.parse(opts.body)\n                  newCheckpoint._rev = json.rev\n                  checkpointCache.set(checkpointReqKey, newCheckpoint)\n                }\n              }\n            } else {\n              checkpointCache.delete(checkpointReqKey)\n            }\n          } else if (viewReqKey) {\n            if (res.ok) {\n              viewCache.set(viewReqKey, await res.clone().text())\n            } else {\n              viewCache.delete(viewReqKey)\n            }\n          }\n\n          return res\n        })\n        // .catch(error => {\n        //   console.error({error})\n        //   return Promise.reject(error)\n        // })\n      },\n      skip_setup: true\n    })\n\n    const pullDocs = async function (ids, { includeDocs = false } = {}) {\n      // TODO: skip this and assume not there? // dont pullDocs from queries but only set references there?\n      const pouchRes = await pouch.allDocs({\n        include_docs: includeDocs,\n        conflicts: false,\n        keys: ids\n      })\n\n      const docs = []\n      const missingIds = []\n      pouchRes?.rows?.forEach(row => {\n        if (row.error || !row.value) {\n          if (row.error !== 'not_found') {\n            console.error(row)\n          }\n\n          missingIds.push(row.key)\n        } else if (row.doc) {\n          docs.push(row.doc)\n        }\n      })\n\n      if (hasCouch && missingIds.length > 0) {\n        const freshRows = await couch.allDocs({ keys: missingIds, conflicts: true, include_docs: true, attachments: true })\n        // await req(couch.name + '/_all_docs?include_docs=true&attachments=true&conflicts=true', {\n        //   body: { 'keys': missingIds }\n        // })\n\n        const freshDocs = freshRows.rows?.filter(row => !!row.doc).map(row => {\n          pulledIds.add(row.doc._id)\n          if (includeDocs) {\n            docs.push(row.doc)\n          }\n          return row.doc\n        })\n\n        freshDocs?.length && pouch.bulkDocs(freshDocs, {\n          new_edits: false\n        })\n      }\n\n      return includeDocs ? docs : true\n    }\n\n    const [ sessionDoc ] = await pullDocs([sessionId], { includeDocs: true }) // await couch.get(sessionId)\n\n    if (!sessionDoc.replications) {\n      if (preload?.length > 0) {\n        // TODO: handle updates\n        // Use batch instead\n        console.log('preloading docs to new pouch...', preload)\n        await PouchDB.replicate(couch, pouch, { doc_ids: preload })\n      }\n\n      inited = new Promise((resolve) => { initResolver = resolve })\n    }\n\n    if (!sessionDoc.startSeq) {\n      console.warn('missing session doc start seq, fallback to fullsync', sessionDoc)\n    }\n\n    sync = PouchDB.sync(pouch, couch, {\n      live: true,\n      sse: true,\n      skipInitialBatch: true, // TODO: setup depending on time since last login?\n      retry: true,\n      heartbeat: 2500,\n      batch_size: 50,\n      conflicts: true, // TODO\n      pull: {\n        since: sessionDoc.startSeq,\n        filter: (doc, _opts) => {\n          if (doc._conflicts) {\n            console.warn(doc._conflicts)\n          }\n\n          // design docs have to always be installed via client seeds, never sync push or pull\n          if (doc._id.startsWith('_design/')) {\n            return false\n          }\n\n          if (doc.type !== 'session') {\n            // console.log('getting couch change', doc)\n            viewCache.clear()\n          }\n\n          return true\n        }\n      },\n      push: {\n        filter: (doc, _opts) => {\n          if (doc._conflicts) {\n            console.warn(doc._conflicts)\n          }\n\n          if (doc._id.startsWith('count_')) {\n            return false\n          }\n\n          if (pulledIds.has(doc._id)) {\n            pulledIds.delete(doc._id)\n            // console.log('pull doc only change')\n            return false\n          }\n\n          if (doc._id.startsWith('_design/')) {\n            return false\n          }\n\n          if (doc.type !== 'session') {\n            // console.log('pushing doc change', doc)\n            viewCache.clear()\n          }\n\n          return true\n        }\n      }\n      // back_off_function: delay => { return 1000 } // TODO integrate online/offline\n    })\n      .on('denied', err => {\n        console.error('denied', err)\n      })\n      .on('error', err => {\n        console.error(err)\n      })\n      .on('paused', () => {\n        pushResolver?.()\n        activePush = null\n        pushResolver = null\n        console.info('replication paused')\n        initResolver?.()\n        initResolver = null\n      })\n      .on('active', ({ direction }) => {\n        if (direction === 'push') {\n          // TODO: add timeout?\n          activePush = new Promise((resolve) => { pushResolver = resolve })\n        }\n        // console.info('replication active', direction)\n        init?.()\n      })\n\n    let init = async () => {\n      init = null\n      // console.log('initting changes session doc')\n      if (sync.pull.replicationId && sync.push.replicationId) {\n        let updateReplications = false\n        if (sessionDoc.replications) {\n          if (sessionDoc.replications.pull !== sync.pull.replicationId) {\n            console.error('pull replication id cahnged', sessionDoc, sync.pull)\n            // TODO: remove old doc\n            updateReplications = true\n          }\n          if (sessionDoc.replications.push !== sync.push.replicationId) {\n            console.error('push replication id cahnged', sessionDoc, sync.push)\n            // TODO: remove old doc\n            updateReplications = true\n          }\n        }\n\n        if (!sessionDoc.replications || updateReplications) {\n          // console.log('writing replications to session...')\n          sessionDoc.replications = {\n            pull: sync.pull.replicationId,\n            push: sync.push.replicationId\n          }\n          await pouch.put(sessionDoc)\n        }\n      }\n    }\n\n    sync.pullDocs = pullDocs\n  }\n\n  function clear () {\n    if (hasCouch) {\n      sync.cancel()\n      couch.close()\n      checkpointCache.clear()\n    }\n    pouch.close()\n  }\n\n  if (inited) {\n    await inited\n  }\n\n  return { pouch, couch, sync, clear }\n}\n", "function getAugmentedNamespace(n) {\n  if (n.__esModule) return n;\n  var f = n.default;\n\tif (typeof f == \"function\") {\n\t\tvar a = function a () {\n\t\t\tif (this instanceof a) {\n        return Reflect.construct(f, arguments, this.constructor);\n\t\t\t}\n\t\t\treturn f.apply(this, arguments);\n\t\t};\n\t\ta.prototype = f.prototype;\n  } else a = {};\n  Object.defineProperty(a, '__esModule', {value: true});\n\tObject.keys(n).forEach(function (k) {\n\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn n[k];\n\t\t\t}\n\t\t});\n\t});\n\treturn a;\n}\n\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n}\n\n/* global window */\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = symbolObservablePonyfill(root);\n\nvar es = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tdefault: result\n});\n\nvar require$$0 = /*@__PURE__*/getAugmentedNamespace(es);\n\nconst symbolError$1 = Symbol(\"try-catch-error\");\nlet lastError                = null;\n\nfunction popError$1()        {\n  if (!lastError) {\n    throw new Error(\"popError may only be called once\");\n  }\n  const { e } = lastError;\n  lastError = null;\n  return e;\n}\n\nlet tryCatch$1                             \n                                          \n                                                         \n                                                                      ;\n\nlet tryCatchResult$1                                               \n                                                            \n                                                                           \n                \n                               \n         \n         \n        \n                              ;\n\n{\n  const throwError = (e       ) => {\n    throw e;\n  };\n\n  tryCatch$1 = (function doTryCatch(f, ...args) {\n    try {\n      f.call(this, ...args);\n    } catch (e) {\n      // See https://github.com/ReactiveX/rxjs/issues/3004#issuecomment-339720668\n      setTimeout(() => { throwError(e); }, 0);\n    }\n  }     );\n\n  tryCatchResult$1 = (function doTryCatchResult(f, ...args) {\n    try {\n      return f.call(this, ...args);\n    } catch (e) {\n      lastError = { e };\n      return symbolError$1;\n    }\n  }     );\n}\n\nvar tryCatch_1 = { tryCatch: tryCatch$1, tryCatchResult: tryCatchResult$1, symbolError: symbolError$1, popError: popError$1 };\n\nconst symbolObservable = require$$0.default;\nconst {\n  tryCatch,\n  tryCatchResult,\n  symbolError,\n  popError\n} = tryCatch_1;\n             \n                     \n                               \n             \n                              \n\n                                                      \n                       \n                             \n                   \n                   \n \n\n                                \n                      \n                   \n \n\n                                                            \n\n                                                \n                                       \n             \n\n                                             \n                                      \n             \n\n                                      \n                                                  \n                              \n                                    \n                         \n  \n\n                                                    \n                                           \n                                           \n \n                                  \n                                                                                \n \n                                           \n                             \n                            \n              \n                \n\n                                                                              \n            \n                                                             \n                                      \n                           \n                   \n \n\n                                                 \n                    \n                        \n\n// Functions to be called within tryCatch().\n\nfunction callNext      (observer                , value   )       {\n  const { next } = observer;\n  if (typeof next === \"function\") {\n    next.call(observer, value);\n  }\n}\n\nfunction callError      (observer                , errorValue   )       {\n  const { error } = observer;\n  if (typeof error === \"function\") {\n    error.call(observer, errorValue);\n  }\n}\n\nfunction callComplete      (observer                )       {\n  const { complete } = observer;\n  if (typeof complete === \"function\") {\n    complete.call(observer);\n  }\n}\n\nfunction callStart      (\n  observer                ,\n  subscription                    \n)       {\n  const { start } = observer;\n  if (typeof start === \"function\") {\n    start.call(observer, subscription);\n  }\n}\n\nfunction callCleanup      (subscription                    ) {\n  const cleanup = subscription._cleanup;\n  if (typeof cleanup === \"function\") {\n    subscription._cleanup = undefined;\n    cleanup();\n  } else if (typeof cleanup === \"object\" && cleanup !== null) {\n    subscription._cleanup = undefined;\n    cleanup.unsubscribe();\n  }\n}\n\nclass SubscriptionObserver              \n                                                                                   {\n                                    \n\n  constructor(subscription                    )       {\n    this._subscription = subscription;\n  }\n\n  next(value   )       {\n    const subscription = this._subscription;\n    const observer = subscription._observer;\n    if (typeof observer === \"undefined\") {\n      return;\n    }\n    tryCatch(callNext, observer, value);\n  }\n\n  error(errorValue   )       {\n    const subscription = this._subscription;\n    const observer = subscription._observer;\n    if (typeof observer === \"undefined\") {\n      return;\n    }\n    subscription._observer = undefined;\n    tryCatch(callError, observer, errorValue);\n    tryCatch(callCleanup, subscription);\n  }\n\n  complete()       {\n    const subscription = this._subscription;\n    const observer = subscription._observer;\n    if (typeof observer === \"undefined\") {\n      return;\n    }\n    subscription._observer = undefined;\n    tryCatch(callComplete, observer);\n    tryCatch(callCleanup, subscription);\n  }\n\n  get closed()          {\n    return typeof this._subscription._observer === \"undefined\";\n  }\n\n  onNext(value   )       {\n    this.next(value);\n  }\n  onError(errorValue   )       {\n    this.error(errorValue);\n  }\n  onCompleted()       {\n    this.complete();\n  }\n  get isStopped()          {\n    return this.closed;\n  }\n}\n\nlet Subscription$1 = class Subscription                                                     {\n                                   \n                    \n\n  constructor(\n    subscriber                              ,\n    observer                \n  )       {\n    this._observer = observer;\n    tryCatch(callStart, observer, this);\n    if (typeof this._observer === \"undefined\") {\n      return;\n    }\n    const subscriptionObserver = new SubscriptionObserver(this);\n    const subscriberResult = tryCatchResult(subscriber, subscriptionObserver);\n    if (subscriberResult === symbolError) {\n      // XXX implies E must always be Error.\n      subscriptionObserver.error((popError()     ));\n      return;\n    }\n    const cleanup          = subscriberResult;\n    if (cleanup === null || typeof cleanup === \"undefined\") {\n      return;\n    }\n    if (typeof cleanup !== \"function\" && typeof cleanup !== \"object\") {\n      throw new TypeError(\n        \"unexpected subscriber result type \" + typeof cleanup\n      );\n    }\n    if (\n      typeof cleanup === \"object\" &&\n      typeof cleanup.unsubscribe !== \"function\"\n    ) {\n      throw new TypeError(\"expected unsubscribe property to be a function\");\n    }\n    this._cleanup = cleanup;\n    if (typeof this._observer === \"undefined\") {\n      tryCatch(callCleanup, this);\n    }\n  }\n\n  unsubscribe()       {\n    const observer = this._observer;\n    if (typeof observer === \"undefined\") {\n      return;\n    }\n    this._observer = undefined;\n    tryCatch(callCleanup, this);\n  }\n\n  get closed()          {\n    return typeof this._observer === \"undefined\";\n  }\n\n  dispose()       {\n    this.unsubscribe();\n  }\n  get isDisposed()          {\n    return this.closed;\n  }\n};\n\nlet EsObservable;\n\nlet BaseObservable$1 = class BaseObservable                                                    {\n                                            \n\n  constructor(subscriber                              )       {\n    if (typeof subscriber !== \"function\") {\n      throw new TypeError(\"Function expected\");\n    }\n    this._subscriber = subscriber;\n  }\n\n  // $FlowFixMe: No symbol or computed property support.\n  [symbolObservable]()                    {\n    return new EsObservable(this._subscriber);\n  }\n\n  // Flow doesn't support returning a differently parameterized this type so\n  // specify types on subclasses instead.\n  pipe(...operators       )      {\n    return this.constructor.from(\n      // $FlowFixMe: No symbol support.\n      operators.reduce((acc, curr) => curr(acc), this[symbolObservable]())\n    );\n  }\n\n  static of(...values     )       {\n    return new this(observer => {\n      for (const value of values) {\n        observer.next(value);\n      }\n      observer.complete();\n    });\n  }\n\n  static from(input                       )       {\n    if (typeof input === \"undefined\" || input === null) {\n      throw new TypeError();\n    }\n\n    if (typeof input === \"object\") {\n      const observableProp                           =\n        // $FlowFixMe: No symbol support.\n        input[symbolObservable];\n      if (typeof observableProp === \"function\") {\n        const observable = observableProp.call(input);\n        if (typeof observable !== \"object\" || observable === null) {\n          throw new TypeError();\n        }\n        if ((observable     ).constructor === this) {\n          return (observable     );\n        }\n        // Avoid additional wrapping between compatible observable implementations.\n        if (observable instanceof BaseObservable) {\n          return new this(observable._subscriber);\n        }\n        return new this(observer => observable.subscribe(observer));\n      }\n      if (typeof input.subscribe === \"function\") {\n        // Not part of ES Observable spec\n        const classic                           = (input     );\n        return new this(observer => {\n          const disposable = classic.subscribe(observer);\n          return () => disposable.dispose();\n        });\n      }\n      if (typeof input.then === \"function\") {\n        // Not part of ES Observable spec\n        const promiseLike                  = (input     );\n        return new this(observer => {\n          promiseLike.then(\n            value => {\n              observer.next(value);\n              observer.complete();\n            },\n            errorValue => {\n              observer.error(errorValue);\n            }\n          );\n        });\n      }\n    }\n\n    // $FlowFixMe: No symbol support.\n    if (typeof input[Symbol.iterator] === \"function\") {\n      return new this(observer => {\n        // $FlowFixMe: No symbol support.\n        for (const value of (input             )) {\n          observer.next(value);\n        }\n        observer.complete();\n      });\n    }\n\n    throw new TypeError();\n  }\n\n  static fromClassicObservable(classic                          )       {\n    return this.from(classic);\n  }\n\n  static empty()       {\n    return new this(observer => {\n      observer.complete();\n    });\n  }\n\n  static throw(errorValue   )       {\n    return new this(observer => {\n      observer.error(errorValue);\n    });\n  }\n\n  static defer(factory                             )       {\n    return new this(observer => {\n      const result = factory();\n      const obs = this.from(result);\n      return new Subscription$1(obs._subscriber, observer);\n    });\n  }\n};\n\n// eslint-disable-next-line no-shadow\nEsObservable = class EsObservable               extends BaseObservable$1      \n                               {\n  subscribe(\n    observerOrOnNext                                        ,\n    onError                          ,\n    onComplete             \n  )                {\n    const observer =\n      typeof observerOrOnNext === \"object\" && observerOrOnNext !== null\n        ? observerOrOnNext\n        : {\n            next: observerOrOnNext,\n            error: onError,\n            complete: onComplete\n          };\n    return new Subscription$1(this._subscriber, observer);\n  }\n\n  // $FlowFixMe: No symbol or computed property support.\n  [symbolObservable]()       {\n    return this;\n  }\n\n  // To pass ES Observable tests these static functions must work without this.\n  static of(...values     )       {\n    const C = typeof this === \"function\" ? this : (EsObservable     );\n    return super.of.call(C, ...values);\n  }\n\n  static from(input                       )       {\n    const C = typeof this === \"function\" ? this : (EsObservable     );\n    return super.from.call(C, input);\n  }\n\n                                    \n                                                                 \n              \n                                      \n                                      \n                               \n                  \n                                      \n                                       \n                                      \n                               \n                      \n                                      \n                                       \n                                       \n                                      \n                               \n                          \n                                      \n                                       \n                                       \n                                       \n                                      \n                               \n                              \n                                      \n                                       \n                                       \n                                       \n                                       \n                                      \n                               \n                                  \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                      \n                               \n                                      \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                      \n                               \n                                          \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                      \n                               \n                                               \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                        \n                                \n                                                                           \n};\n\nvar esObservable = {\n  BaseObservable: BaseObservable$1,\n  Observable: EsObservable,\n  Subscription: Subscription$1\n};\n\nconst { BaseObservable, Subscription } = esObservable;\n\n                                                        \n\n                              \n                  \n                       \n \n\n                                                             \n                         \n                          \n                      \n                      \n \n\n                                             \n                               \n                                \n                           \n  \n\n                                                   \n            \n                                                          \n                                 \n                            \n                 \n \n\n                                                               \n\n                                                       \n                                              \n                    \n\nclass EsFromClassicObserver               {\n                                   \n  constructor(observer                       )       {\n    this._observer = observer;\n  }\n  next(value   )       {\n    const observer = this._observer;\n    const { onNext } = observer;\n    if (typeof onNext === \"function\") {\n      onNext.call(observer, value);\n    }\n  }\n  error(errorValue   )       {\n    const observer = this._observer;\n    const { onError } = observer;\n    if (typeof onError === \"function\") {\n      onError.call(observer, errorValue);\n    }\n  }\n  complete()       {\n    const observer = this._observer;\n    const { onCompleted } = observer;\n    if (typeof onCompleted === \"function\") {\n      onCompleted.call(observer);\n    }\n  }\n}\n\nclass ClassicObservable               extends BaseObservable      \n                                      {\n  subscribe(\n    observerOrOnNext                                               ,\n    onError                     ,\n    onCompleted             \n  )              {\n    const observer =\n      typeof observerOrOnNext === \"object\" && observerOrOnNext !== null\n        ? new EsFromClassicObserver(observerOrOnNext)\n        : {\n            next: observerOrOnNext,\n            error: onError,\n            complete: onCompleted\n          };\n    return new Subscription(this._subscriber, observer);\n  }\n\n  static create(subscriber                                 )       {\n    const C = typeof this === \"function\" ? this : (ClassicObservable     );\n    if (typeof subscriber !== \"function\") {\n      throw new TypeError(\"Function expected\");\n    }\n    return new C(observer => {\n      const cleanup = subscriber(observer);\n      if (typeof cleanup !== \"object\" || cleanup === null) {\n        return cleanup;\n      }\n      if (typeof cleanup.dispose === \"function\") {\n        return () => {\n          cleanup.dispose();\n        };\n      }\n      // Will cause constructor to throw\n      return ({ unsubscribe: cleanup.dispose }     );\n    });\n  }\n\n                                         \n                                                                      \n              \n                                      \n                                      \n                                    \n                  \n                                      \n                                       \n                                      \n                                    \n                      \n                                      \n                                       \n                                       \n                                      \n                                    \n                          \n                                      \n                                       \n                                       \n                                       \n                                      \n                                    \n                              \n                                      \n                                       \n                                       \n                                       \n                                       \n                                      \n                                    \n                                  \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                      \n                                    \n                                      \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                      \n                                    \n                                          \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                      \n                                    \n                                               \n                                      \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                       \n                                        \n                                     \n                                                                                \n}\n\nvar classicObservable = { Observable: ClassicObservable };\n\nvar Observable = classicObservable.Observable;\n\nexport { Observable };\n", "var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction getAugmentedNamespace(n) {\n  if (n.__esModule) return n;\n  var f = n.default;\n\tif (typeof f == \"function\") {\n\t\tvar a = function a () {\n\t\t\tif (this instanceof a) {\n        return Reflect.construct(f, arguments, this.constructor);\n\t\t\t}\n\t\t\treturn f.apply(this, arguments);\n\t\t};\n\t\ta.prototype = f.prototype;\n  } else a = {};\n  Object.defineProperty(a, '__esModule', {value: true});\n\tObject.keys(n).forEach(function (k) {\n\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn n[k];\n\t\t\t}\n\t\t});\n\t});\n\treturn a;\n}\n\nvar prefix$1 = String.fromCharCode(30);\n\nvar prefix = prefix$1;\nvar Keys$6 = {\n    ranges: prefix + 'ranges',\n    integers: prefix + 'integers',\n    keys: prefix + 'keys',\n    named: prefix + 'named',\n    name: prefix + 'name',\n    match: prefix + 'match'\n};\n\nvar Keys_1 = Keys$6;\n\nvar isArray$4 = Array.isArray;\nvar convertPathKeyTo$3 = function convertPathKeyTo(onRange, onKey) {\n    return function converter(keySet) {\n        var isKeySet = typeof keySet === 'object';\n        var out = [];\n\n        // The keySet we determine what type is this keyset.\n        if (isKeySet) {\n            if (isArray$4(keySet)) {\n                var reducer = null;\n                keySet.forEach(function(key) {\n                    if (typeof key === 'object') {\n                        reducer = onRange(out, key, reducer);\n                    }\n                    else {\n                        reducer = onKey(out, key, reducer);\n                    }\n                });\n            }\n\n            // What passed in is a range.\n            else {\n                onRange(out, keySet);\n            }\n        }\n\n        // simple value for keyset.\n        else {\n            onKey(out, keySet);\n        }\n\n        return out;\n    };\n};\n\n/**\n * Will determine of the argument is a number.\n *\n * '1' returns true\n * 1 returns true\n * [1] returns false\n * null returns false\n * @param {*} x\n */\n\nvar isNumber$2 = function(x) {\n    return String(Number(x)) === String(x) && typeof x !== 'object';\n};\n\nvar convertPathKeyTo$2 = convertPathKeyTo$3;\nvar isNumber$1 = isNumber$2;\n\nfunction onRange$2(out, range) {\n    out[out.length] = range;\n}\n\n/**\n * @param {Number|String} key must be a number\n */\nfunction keyReduce(out, key, range) {\n    if (!isNumber$1(key)) {\n        return range;\n    }\n\n    /* eslint-disable no-param-reassign */\n    key = +key;\n    if (range) {\n        if (key - 1 === range.to) {\n            range.to = key;\n        }\n\n        else if (key + 1 === range.from) {\n            range.from = key;\n        }\n\n        else {\n            range = null;\n        }\n    }\n\n    if (!range) {\n        range = {to: key, from: key};\n        out[out.length] = range;\n    }\n    /* eslint-enable no-param-reassign */\n\n    return range;\n}\n\nvar convertPathKeyToRange$1 = convertPathKeyTo$2(onRange$2, keyReduce);\n\nvar rangeToArray$2 = function onRange(range) {\n    var out = [];\n    var i = range.from;\n    var to = range.to;\n    var outIdx = out.length;\n    for (; i <= to; ++i, ++outIdx) {\n        out[outIdx] = i;\n    }\n\n    return out;\n};\n\nvar convertPathKeyTo$1 = convertPathKeyTo$3;\nvar isNumber = isNumber$2;\nvar rangeToArray$1 = rangeToArray$2;\n\nfunction onRange$1(out, range) {\n    var len = out.length - 1;\n    rangeToArray$1(range).forEach(function(el) {\n        out[++len] = el;\n    });\n}\n\nfunction onKey$1(out, key) {\n    if (isNumber(key)) {\n        out[out.length] = key;\n    }\n}\n\n/**\n * will attempt to get integers from the key\n * or keySet provided. assumes everything passed in is an integer\n * or range of integers.\n */\nvar convertPathKeyToIntegers$1 = convertPathKeyTo$1(onRange$1, onKey$1);\n\nvar convertPathKeyTo = convertPathKeyTo$3;\nvar rangeToArray = rangeToArray$2;\n\nfunction onKey(out, key) {\n    out[out.length] = key;\n}\n\nfunction onRange(out, range) {\n    var len = out.length - 1;\n    rangeToArray(range).forEach(function(el) {\n        out[++len] = el;\n    });\n}\n\n/**\n * will attempt to get integers from the key\n * or keySet provided. assumes everything passed in is an integer\n * or range of integers.\n */\nvar convertPathKeyToKeys$1 = convertPathKeyTo(onRange, onKey);\n\n// Disable eslint for import statements\n/* eslint-disable max-len */\nvar Keys$5 = Keys_1;\nvar convertPathKeyToRange = convertPathKeyToRange$1;\nvar convertPathKeyToIntegers = convertPathKeyToIntegers$1;\nvar convertPathKeyToKeys = convertPathKeyToKeys$1;\nvar isArray$3 = Array.isArray;\n/* eslint-enable max-len */\n\n/**\n * takes the path that was matched and converts it to the\n * virtual path.\n */\nvar convertPathToRoute$1 = function convertPathToRoute(path, route) {\n    var matched = [];\n    // Always use virtual path since path can be longer since\n    // it contains suffixes.\n    for (var i = 0, len = route.length; i < len; ++i) {\n\n        if (route[i].type) {\n            var virt = route[i];\n            switch (virt.type) {\n                case Keys$5.ranges:\n                    matched[i] =\n                        convertPathKeyToRange(path[i]);\n                    break;\n                case Keys$5.integers:\n                    matched[i] =\n                        convertPathKeyToIntegers(path[i]);\n                    break;\n                case Keys$5.keys:\n                    matched[i] =\n                        convertPathKeyToKeys(path[i]);\n                    break;\n                default:\n                    var err = new Error('Unknown route type.');\n                    err.throwToNext = true;\n                    break;\n            }\n            if (virt.named) {\n                matched[virt.name] = matched[matched.length - 1];\n            }\n        }\n\n        // Dealing with specific keys or array of specific keys.\n        // If route has an array at this position, arrayify the\n        // path[i] element.\n        else {\n            if (isArray$3(route[i]) && !isArray$3(path[i])) {\n                matched[matched.length] = [path[i]];\n            }\n\n            else {\n                matched[matched.length] = path[i];\n            }\n        }\n    }\n\n    return matched;\n};\n\nvar isPathValue$1 = function(x) {\n    return x.hasOwnProperty('path') && x.hasOwnProperty('value');\n};\n\nvar slice$1 = function slice(args, index) {\n    var len = args.length;\n    var out = [];\n    var j = 0;\n    var i = index;\n    while (i < len) {\n        out[j] = args[i];\n        ++i;\n        ++j;\n    }\n    return out;\n};\n\nvar convertPathToRoute = convertPathToRoute$1;\nvar isPathValue = isPathValue$1;\nvar slice = slice$1;\nvar isArray$2 = Array.isArray;\n\n/**\n *   Creates the named variables and coerces it into its\n * virtual type.\n *\n * @param {Array} route - The route that produced this action wrapper\n * @private\n */\nfunction createNamedVariables(route, action) {\n    return function innerCreateNamedVariables(matchedPath) {\n        var convertedArguments;\n        var len = -1;\n        var restOfArgs = slice(arguments, 1);\n        var isJSONObject = !isArray$2(matchedPath);\n\n        // A set uses a json object\n        if (isJSONObject) {\n            restOfArgs = [];\n            convertedArguments = matchedPath;\n        }\n\n        // Could be an array of pathValues for a set operation.\n        else if (isPathValue(matchedPath[0])) {\n            convertedArguments = [];\n\n            matchedPath.forEach(function(pV) {\n                pV.path = convertPathToRoute(pV.path, route);\n                convertedArguments[++len] = pV;\n            });\n        }\n\n        // else just convert and assign\n        else {\n            convertedArguments =\n                convertPathToRoute(matchedPath, route);\n        }\n        return action.apply(this, [convertedArguments].concat(restOfArgs));\n    };\n}\nvar actionWrapper$1 = createNamedVariables;\n\nvar tokenizer = {exports: {}};\n\nvar TokenTypes$6 = {\n    token: 'token',\n    dotSeparator: '.',\n    commaSeparator: ',',\n    openingBracket: '[',\n    closingBracket: ']',\n    openingBrace: '{',\n    closingBrace: '}',\n    escape: '\\\\',\n    space: ' ',\n    colon: ':',\n    quote: 'quote',\n    unknown: 'unknown'\n};\n\nvar TokenTypes_1 = TokenTypes$6;\n\nvar TokenTypes$5 = TokenTypes_1;\nvar DOT_SEPARATOR = '.';\nvar COMMA_SEPARATOR = ',';\nvar OPENING_BRACKET = '[';\nvar CLOSING_BRACKET = ']';\nvar OPENING_BRACE = '{';\nvar CLOSING_BRACE = '}';\nvar COLON = ':';\nvar ESCAPE = '\\\\';\nvar DOUBLE_OUOTES = '\"';\nvar SINGE_OUOTES = \"'\";\nvar SPACE = \" \";\nvar SPECIAL_CHARACTERS = '\\\\\\'\"[]., ';\nvar EXT_SPECIAL_CHARACTERS = '\\\\{}\\'\"[]., :';\n\nvar Tokenizer$2 = tokenizer.exports = function(string, ext) {\n    this._string = string;\n    this._idx = -1;\n    this._extended = ext;\n    this.parseString = '';\n};\n\nTokenizer$2.prototype = {\n    /**\n     * grabs the next token either from the peek operation or generates the\n     * next token.\n     */\n    next: function() {\n        var nextToken = this._nextToken ?\n            this._nextToken : getNext(this._string, this._idx, this._extended);\n\n        this._idx = nextToken.idx;\n        this._nextToken = false;\n        this.parseString += nextToken.token.token;\n\n        return nextToken.token;\n    },\n\n    /**\n     * will peak but not increment the tokenizer\n     */\n    peek: function() {\n        var nextToken = this._nextToken ?\n            this._nextToken : getNext(this._string, this._idx, this._extended);\n        this._nextToken = nextToken;\n\n        return nextToken.token;\n    }\n};\n\nTokenizer$2.toNumber = function toNumber(x) {\n    if (!isNaN(+x)) {\n        return +x;\n    }\n    return NaN;\n};\n\nfunction toOutput(token, type, done) {\n    return {\n        token: token,\n        done: done,\n        type: type\n    };\n}\n\nfunction getNext(string, idx, ext) {\n    var output = false;\n    var token = '';\n    var specialChars = ext ?\n        EXT_SPECIAL_CHARACTERS : SPECIAL_CHARACTERS;\n    var done;\n\n    do {\n\n        done = idx + 1 >= string.length;\n        if (done) {\n            break;\n        }\n\n        // we have to peek at the next token\n        var character = string[idx + 1];\n\n        if (character !== undefined &&\n            specialChars.indexOf(character) === -1) {\n\n            token += character;\n            ++idx;\n            continue;\n        }\n\n        // The token to delimiting character transition.\n        else if (token.length) {\n            break;\n        }\n\n        ++idx;\n        var type;\n        switch (character) {\n            case DOT_SEPARATOR:\n                type = TokenTypes$5.dotSeparator;\n                break;\n            case COMMA_SEPARATOR:\n                type = TokenTypes$5.commaSeparator;\n                break;\n            case OPENING_BRACKET:\n                type = TokenTypes$5.openingBracket;\n                break;\n            case CLOSING_BRACKET:\n                type = TokenTypes$5.closingBracket;\n                break;\n            case OPENING_BRACE:\n                type = TokenTypes$5.openingBrace;\n                break;\n            case CLOSING_BRACE:\n                type = TokenTypes$5.closingBrace;\n                break;\n            case SPACE:\n                type = TokenTypes$5.space;\n                break;\n            case DOUBLE_OUOTES:\n            case SINGE_OUOTES:\n                type = TokenTypes$5.quote;\n                break;\n            case ESCAPE:\n                type = TokenTypes$5.escape;\n                break;\n            case COLON:\n                type = TokenTypes$5.colon;\n                break;\n            default:\n                type = TokenTypes$5.unknown;\n                break;\n        }\n        output = toOutput(character, type, false);\n        break;\n    } while (!done);\n\n    if (!output && token.length) {\n        output = toOutput(token, TokenTypes$5.token, false);\n    }\n\n    if (!output) {\n        output = {done: true};\n    }\n\n    return {\n        token: output,\n        idx: idx\n    };\n}\n\nvar tokenizerExports = tokenizer.exports;\n\nvar exceptions$1 = {\n    indexer: {\n        nested: 'Indexers cannot be nested.',\n        needQuotes: 'unquoted indexers must be numeric.',\n        empty: 'cannot have empty indexers.',\n        leadingDot: 'Indexers cannot have leading dots.',\n        leadingComma: 'Indexers cannot have leading comma.',\n        requiresComma: 'Indexers require commas between indexer args.',\n        routedTokens: 'Only one token can be used per indexer when specifying routed tokens.'\n    },\n    range: {\n        precedingNaN: 'ranges must be preceded by numbers.',\n        suceedingNaN: 'ranges must be suceeded by numbers.'\n    },\n    routed: {\n        invalid: 'Invalid routed token.  only integers|ranges|keys are supported.'\n    },\n    quote: {\n        empty: 'cannot have empty quoted keys.',\n        illegalEscape: 'Invalid escape character.  Only quotes are escapable.'\n    },\n    unexpectedToken: 'Unexpected token.',\n    invalidIdentifier: 'Invalid Identifier.',\n    invalidPath: 'Please provide a valid path.',\n    throwError: function(err, tokenizer, token) {\n        if (token) {\n            throw err + ' -- ' + tokenizer.parseString + ' with next token: ' + token;\n        }\n        throw err + ' -- ' + tokenizer.parseString;\n    }\n};\n\nvar Tokenizer$1 = tokenizerExports;\nvar TokenTypes$4 = TokenTypes_1;\nvar E$4 = exceptions$1;\n\n/**\n * The indexer is all the logic that happens in between\n * the '[', opening bracket, and ']' closing bracket.\n */\nvar range$1 = function range(tokenizer, openingToken, state, out) {\n    var token = tokenizer.peek();\n    var dotCount = 1;\n    var done = false;\n    var inclusive = true;\n\n    // Grab the last token off the stack.  Must be an integer.\n    var idx = state.indexer.length - 1;\n    var from = Tokenizer$1.toNumber(state.indexer[idx]);\n    var to;\n\n    if (isNaN(from)) {\n        E$4.throwError(E$4.range.precedingNaN, tokenizer);\n    }\n\n    // Why is number checking so difficult in javascript.\n\n    while (!done && !token.done) {\n\n        switch (token.type) {\n\n            // dotSeparators at the top level have no meaning\n            case TokenTypes$4.dotSeparator:\n                if (dotCount === 3) {\n                    E$4.throwError(E$4.unexpectedToken, tokenizer);\n                }\n                ++dotCount;\n\n                if (dotCount === 3) {\n                    inclusive = false;\n                }\n                break;\n\n            case TokenTypes$4.token:\n                // move the tokenizer forward and save to.\n                to = Tokenizer$1.toNumber(tokenizer.next().token);\n\n                // throw potential error.\n                if (isNaN(to)) {\n                    E$4.throwError(E$4.range.suceedingNaN, tokenizer);\n                }\n\n                done = true;\n                break;\n\n            default:\n                done = true;\n                break;\n        }\n\n        // Keep cycling through the tokenizer.  But ranges have to peek\n        // before they go to the next token since there is no 'terminating'\n        // character.\n        if (!done) {\n            tokenizer.next();\n\n            // go to the next token without consuming.\n            token = tokenizer.peek();\n        }\n\n        // break and remove state information.\n        else {\n            break;\n        }\n    }\n\n    state.indexer[idx] = {from: from, to: inclusive ? to : to - 1};\n};\n\nvar TokenTypes$3 = TokenTypes_1;\nvar E$3 = exceptions$1;\nvar quoteE = E$3.quote;\n\n/**\n * quote is all the parse tree in between quotes.  This includes the only\n * escaping logic.\n *\n * parse-tree:\n * <opening-quote>(.|(<escape><opening-quote>))*<opening-quote>\n */\nvar quote$1 = function quote(tokenizer, openingToken, state, out) {\n    var token = tokenizer.next();\n    var innerToken = '';\n    var openingQuote = openingToken.token;\n    var escaping = false;\n    var done = false;\n\n    while (!token.done) {\n\n        switch (token.type) {\n            case TokenTypes$3.token:\n            case TokenTypes$3.space:\n\n            case TokenTypes$3.dotSeparator:\n            case TokenTypes$3.commaSeparator:\n\n            case TokenTypes$3.openingBracket:\n            case TokenTypes$3.closingBracket:\n            case TokenTypes$3.openingBrace:\n            case TokenTypes$3.closingBrace:\n                if (escaping) {\n                    E$3.throwError(quoteE.illegalEscape, tokenizer);\n                }\n\n                innerToken += token.token;\n                break;\n\n\n            case TokenTypes$3.quote:\n                // the simple case.  We are escaping\n                if (escaping) {\n                    innerToken += token.token;\n                    escaping = false;\n                }\n\n                // its not a quote that is the opening quote\n                else if (token.token !== openingQuote) {\n                    innerToken += token.token;\n                }\n\n                // last thing left.  Its a quote that is the opening quote\n                // therefore we must produce the inner token of the indexer.\n                else {\n                    done = true;\n                }\n\n                break;\n            case TokenTypes$3.escape:\n                escaping = true;\n                break;\n\n            default:\n                E$3.throwError(E$3.unexpectedToken, tokenizer);\n        }\n\n        // If done, leave loop\n        if (done) {\n            break;\n        }\n\n        // Keep cycling through the tokenizer.\n        token = tokenizer.next();\n    }\n\n    if (innerToken.length === 0) {\n        E$3.throwError(quoteE.empty, tokenizer);\n    }\n\n    state.indexer[state.indexer.length] = innerToken;\n};\n\nvar RoutedTokens$2 = {\n    integers: 'integers',\n    ranges: 'ranges',\n    keys: 'keys'\n};\n\nvar TokenTypes$2 = TokenTypes_1;\nvar RoutedTokens$1 = RoutedTokens$2;\nvar E$2 = exceptions$1;\nvar routedE = E$2.routed;\n\n/**\n * The routing logic.\n *\n * parse-tree:\n * <opening-brace><routed-token>(:<token>)<closing-brace>\n */\nvar routed$1 = function routed(tokenizer, openingToken, state, out) {\n    var routeToken = tokenizer.next();\n    var named = false;\n    var name = '';\n\n    // ensure the routed token is a valid ident.\n    switch (routeToken.token) {\n        case RoutedTokens$1.integers:\n        case RoutedTokens$1.ranges:\n        case RoutedTokens$1.keys:\n            //valid\n            break;\n        default:\n            E$2.throwError(routedE.invalid, tokenizer);\n            break;\n    }\n\n    // Now its time for colon or ending brace.\n    var next = tokenizer.next();\n\n    // we are parsing a named identifier.\n    if (next.type === TokenTypes$2.colon) {\n        named = true;\n\n        // Get the token name.\n        next = tokenizer.next();\n        if (next.type !== TokenTypes$2.token) {\n            E$2.throwError(routedE.invalid, tokenizer);\n        }\n        name = next.token;\n\n        // move to the closing brace.\n        next = tokenizer.next();\n    }\n\n    // must close with a brace.\n\n    if (next.type === TokenTypes$2.closingBrace) {\n        var outputToken = {\n            type: routeToken.token,\n            named: named,\n            name: name\n        };\n        state.indexer[state.indexer.length] = outputToken;\n    }\n\n    // closing brace expected\n    else {\n        E$2.throwError(routedE.invalid, tokenizer);\n    }\n\n};\n\nvar TokenTypes$1 = TokenTypes_1;\nvar E$1 = exceptions$1;\nvar idxE = E$1.indexer;\nvar range = range$1;\nvar quote = quote$1;\nvar routed = routed$1;\n\n/**\n * The indexer is all the logic that happens in between\n * the '[', opening bracket, and ']' closing bracket.\n */\nvar indexer$1 = function indexer(tokenizer, openingToken, state, out) {\n    var token = tokenizer.next();\n    var done = false;\n    var allowedMaxLength = 1;\n    var routedIndexer = false;\n\n    // State variables\n    state.indexer = [];\n\n    while (!token.done) {\n\n        switch (token.type) {\n            case TokenTypes$1.token:\n            case TokenTypes$1.quote:\n\n                // ensures that token adders are properly delimited.\n                if (state.indexer.length === allowedMaxLength) {\n                    E$1.throwError(idxE.requiresComma, tokenizer);\n                }\n                break;\n        }\n\n        switch (token.type) {\n            // Extended syntax case\n            case TokenTypes$1.openingBrace:\n                routedIndexer = true;\n                routed(tokenizer, token, state);\n                break;\n\n\n            case TokenTypes$1.token:\n                var t = +token.token;\n                if (isNaN(t)) {\n                    E$1.throwError(idxE.needQuotes, tokenizer);\n                }\n                state.indexer[state.indexer.length] = t;\n                break;\n\n            // dotSeparators at the top level have no meaning\n            case TokenTypes$1.dotSeparator:\n                if (!state.indexer.length) {\n                    E$1.throwError(idxE.leadingDot, tokenizer);\n                }\n                range(tokenizer, token, state);\n                break;\n\n            // Spaces do nothing.\n            case TokenTypes$1.space:\n                break;\n\n            case TokenTypes$1.closingBracket:\n                done = true;\n                break;\n\n\n            // The quotes require their own tree due to what can be in it.\n            case TokenTypes$1.quote:\n                quote(tokenizer, token, state);\n                break;\n\n\n            // Its time to decend the parse tree.\n            case TokenTypes$1.openingBracket:\n                E$1.throwError(idxE.nested, tokenizer);\n                break;\n\n            case TokenTypes$1.commaSeparator:\n                ++allowedMaxLength;\n                break;\n\n            default:\n                E$1.throwError(E$1.unexpectedToken, tokenizer);\n                break;\n        }\n\n        // If done, leave loop\n        if (done) {\n            break;\n        }\n\n        // Keep cycling through the tokenizer.\n        token = tokenizer.next();\n    }\n\n    if (state.indexer.length === 0) {\n        E$1.throwError(idxE.empty, tokenizer);\n    }\n\n    if (state.indexer.length > 1 && routedIndexer) {\n        E$1.throwError(idxE.routedTokens, tokenizer);\n    }\n\n    // Remember, if an array of 1, keySets will be generated.\n    if (state.indexer.length === 1) {\n        state.indexer = state.indexer[0];\n    }\n\n    out[out.length] = state.indexer;\n\n    // Clean state.\n    state.indexer = undefined;\n};\n\nvar TokenTypes = TokenTypes_1;\nvar E = exceptions$1;\nvar indexer = indexer$1;\n\n/**\n * The top level of the parse tree.  This returns the generated path\n * from the tokenizer.\n */\nvar head$1 = function head(tokenizer) {\n    var token = tokenizer.next();\n    var state = {};\n    var out = [];\n\n    while (!token.done) {\n\n        switch (token.type) {\n            case TokenTypes.token:\n                var first = +token.token[0];\n                if (!isNaN(first)) {\n                    E.throwError(E.invalidIdentifier, tokenizer);\n                }\n                out[out.length] = token.token;\n                break;\n\n            // dotSeparators at the top level have no meaning\n            case TokenTypes.dotSeparator:\n                if (out.length === 0) {\n                    E.throwError(E.unexpectedToken, tokenizer);\n                }\n                break;\n\n            // Spaces do nothing.\n            case TokenTypes.space:\n                // NOTE: Spaces at the top level are allowed.\n                // titlesById  .summary is a valid path.\n                break;\n\n\n            // Its time to decend the parse tree.\n            case TokenTypes.openingBracket:\n                indexer(tokenizer, token, state, out);\n                break;\n\n            default:\n                E.throwError(E.unexpectedToken, tokenizer);\n                break;\n        }\n\n        // Keep cycling through the tokenizer.\n        token = tokenizer.next();\n    }\n\n    if (out.length === 0) {\n        E.throwError(E.invalidPath, tokenizer);\n    }\n\n    return out;\n};\n\nvar Tokenizer = tokenizerExports;\nvar head = head$1;\nvar RoutedTokens = RoutedTokens$2;\n\nvar parser = function parser(string, extendedRules) {\n    return head(new Tokenizer(string, extendedRules));\n};\n\nvar src = parser;\n\n// Constructs the paths from paths / pathValues that have strings.\n// If it does not have a string, just moves the value into the return\n// results.\nparser.fromPathsOrPathValues = function(paths, ext) {\n    if (!paths) {\n        return [];\n    }\n\n    var out = [];\n    for (var i = 0, len = paths.length; i < len; i++) {\n\n        // Is the path a string\n        if (typeof paths[i] === 'string') {\n            out[i] = parser(paths[i], ext);\n        }\n\n        // is the path a path value with a string value.\n        else if (typeof paths[i].path === 'string') {\n            out[i] = {\n                path: parser(paths[i].path, ext), value: paths[i].value\n            };\n        }\n\n        // just copy it over.\n        else {\n            out[i] = paths[i];\n        }\n    }\n\n    return out;\n};\n\n// If the argument is a string, this with convert, else just return\n// the path provided.\nparser.fromPath = function(path, ext) {\n    if (!path) {\n        return [];\n    }\n\n    if (typeof path === 'string') {\n        return parser(path, ext);\n    }\n\n    return path;\n};\n\n// Potential routed tokens.\nparser.RoutedTokens = RoutedTokens;\n\nvar Keys$4 = Keys_1;\nvar convertTypes$1 = function convertTypes(virtualPath) {\n    virtualPath.route = virtualPath.route.map(function(key) {\n        if (typeof key === 'object') {\n            switch (key.type) {\n                case 'keys':\n                    key.type = Keys$4.keys;\n                    break;\n                case 'integers':\n                    key.type = Keys$4.integers;\n                    break;\n                case 'ranges':\n                    key.type = Keys$4.ranges;\n                    break;\n                default:\n                    var err = new Error('Unknown route type.');\n                    err.throwToNext = true;\n                    break;\n            }\n        }\n        return key;\n    });\n};\n\nvar Keys$3 = Keys_1;\n\n/**\n * beautify the virtual path, meaning paths with virtual keys will\n * not be displayed as a stringified object but instead as a string.\n *\n * @param {Array} route -\n */\nvar prettifyRoute$1 = function prettifyRoute(route) {\n    var length = 0;\n    var str = [];\n    for (var i = 0, len = route.length; i < len; ++i, ++length) {\n        var value = route[i];\n        if (typeof value === 'object') {\n            value = value.type;\n        }\n\n        if (value === Keys$3.integers) {\n            str[length] = 'integers';\n        }\n\n        else if (value === Keys$3.ranges) {\n            str[length] = 'ranges';\n        }\n\n        else if (value === Keys$3.keys) {\n            str[length] = 'keys';\n        }\n\n        else {\n            if (Array.isArray(value)) {\n                str[length] = JSON.stringify(value);\n            }\n\n            else {\n                str[length] = value;\n            }\n        }\n    }\n\n    return str;\n};\n\n/*eslint-disable*/\n\nvar exceptions = {\n    innerReferences: 'References with inner references are not allowed.',\n    unknown: 'Unknown Error',\n    routeWithSamePrecedence: 'Two routes cannot have the same precedence or path.',\n    circularReference: 'There appears to be a circular reference, maximum reference following exceeded.'\n};\n\nfunction cloneArray$2(arr, index) {\n    var a = [];\n    var len = arr.length;\n    for (var i = index || 0; i < len; i++) {\n        a[i] = arr[i];\n    }\n    return a;\n}\n\nvar cloneArray_1$1 = cloneArray$2;\n\nvar Keys$2 = Keys_1;\nvar actionWrapper = actionWrapper$1;\nvar pathSyntax = src;\nvar convertTypes = convertTypes$1;\nvar prettifyRoute = prettifyRoute$1;\nvar errors$1 = exceptions;\nvar cloneArray$1 = cloneArray_1$1;\nvar ROUTE_ID = -3;\n\nvar parseTree$1 = function parseTree(routes) {\n    var pTree = {};\n    var parseMap = {};\n    routes.forEach(function forEachRoute(route) {\n        // converts the virtual string path to a real path with\n        // extended syntax on.\n        if (typeof route.route === 'string') {\n            route.prettyRoute = route.route;\n            route.route = pathSyntax(route.route, true);\n            convertTypes(route);\n        }\n        if (route.get) {\n            route.getId = ++ROUTE_ID;\n        }\n        if (route.set) {\n            route.setId = ++ROUTE_ID;\n        }\n        if (route.call) {\n            route.callId = ++ROUTE_ID;\n        }\n\n        setHashOrThrowError(parseMap, route);\n        buildParseTree(pTree, route, 0);\n    });\n    return pTree;\n};\n\nfunction buildParseTree(node, routeObject, depth) {\n\n    var route = routeObject.route;\n    var get = routeObject.get;\n    var set = routeObject.set;\n    var call = routeObject.call;\n    var el = route[depth];\n\n    el = !isNaN(+el) && +el || el;\n    var isArray = Array.isArray(el);\n    var i = 0;\n\n    do {\n        var value = el;\n        var next;\n        if (isArray) {\n            value = value[i];\n        }\n\n        // There is a ranged token in this location with / without name.\n        // only happens from parsed path-syntax paths.\n        if (typeof value === 'object') {\n            var routeType = value.type;\n            next = decendTreeByRoutedToken(node, routeType, value);\n        }\n\n        // This is just a simple key.  Could be a ranged key.\n        else {\n            next = decendTreeByRoutedToken(node, value);\n\n            // we have to create a falcor-router virtual object\n            // so that the rest of the algorithm can match and coerse\n            // when needed.\n            if (next) {\n                route[depth] = {type: value, named: false};\n            }\n            else {\n                if (!node[value]) {\n                    node[value] = {};\n                }\n                next = node[value];\n            }\n        }\n\n        // Continue to recurse or put get/set.\n        if (depth + 1 === route.length) {\n\n            // Insert match into routeSyntaxTree\n            var matchObject = next[Keys$2.match] || {};\n            if (!next[Keys$2.match]) {\n                next[Keys$2.match] = matchObject;\n            }\n\n            matchObject.prettyRoute = routeObject.prettyRoute;\n\n            if (get) {\n                matchObject.get = actionWrapper(route, get);\n                matchObject.getId = routeObject.getId;\n            }\n            if (set) {\n                matchObject.set = actionWrapper(route, set);\n                matchObject.setId = routeObject.setId;\n            }\n            if (call) {\n                matchObject.call = actionWrapper(route, call);\n                matchObject.callId = routeObject.callId;\n            }\n        } else {\n            buildParseTree(next, routeObject, depth + 1);\n        }\n\n    } while (isArray && ++i < el.length);\n}\n\n/**\n * ensure that two routes of the same precedence do not get\n * set in.\n */\nfunction setHashOrThrowError(parseMap, routeObject) {\n    var route = routeObject.route;\n    var get = routeObject.get;\n    var set = routeObject.set;\n    var call = routeObject.call;\n\n    getHashesFromRoute(route).\n        map(function mapHashToString(hash) { return hash.join(','); }).\n        forEach(function forEachRouteHash(hash) {\n            if (get && parseMap[hash + 'get'] ||\n                set && parseMap[hash + 'set'] ||\n                    call && parseMap[hash + 'call']) {\n                throw new Error(errors$1.routeWithSamePrecedence + ' ' +\n                               prettifyRoute(route));\n            }\n            if (get) {\n                parseMap[hash + 'get'] = true;\n            }\n            if (set) {\n                parseMap[hash + 'set'] = true;\n            }\n            if (call) {\n                parseMap[hash + 'call'] = true;\n            }\n        });\n}\n\n/**\n * decends the rst and fills in any naming information at the node.\n * if what is passed in is not a routed token identifier, then the return\n * value will be null\n */\nfunction decendTreeByRoutedToken(node, value, routeToken) {\n    var next = null;\n    switch (value) {\n        case Keys$2.keys:\n        case Keys$2.integers:\n        case Keys$2.ranges:\n            next = node[value];\n            if (!next) {\n                next = node[value] = {};\n            }\n            break;\n    }\n    if (next && routeToken) {\n        // matches the naming information on the node.\n        next[Keys$2.named] = routeToken.named;\n        next[Keys$2.name] = routeToken.name;\n    }\n\n    return next;\n}\n\n/**\n * creates a hash of the virtual path where integers and ranges\n * will collide but everything else is unique.\n */\nfunction getHashesFromRoute(route, depth, hashes, hash) {\n    /*eslint-disable no-func-assign, no-param-reassign*/\n    depth = depth || 0;\n    hashes = hashes || [];\n    hash = hash || [];\n    /*eslint-enable no-func-assign, no-param-reassign*/\n\n    var routeValue = route[depth];\n    var isArray = Array.isArray(routeValue);\n    var length = isArray && routeValue.length || 0;\n    var idx = 0;\n    var value;\n\n    if (typeof routeValue === 'object' && !isArray) {\n        value = routeValue.type;\n    }\n\n    else if (!isArray) {\n        value = routeValue;\n    }\n\n    do {\n        if (isArray) {\n            value = routeValue[idx];\n        }\n\n        if (value === Keys$2.integers || value === Keys$2.ranges) {\n            hash[depth] = '__I__';\n        }\n\n        else if (value === Keys$2.keys) {\n            hash[depth] ='__K__';\n        }\n\n        else {\n            hash[depth] = value;\n        }\n\n        // recurse down the routed token\n        if (depth + 1 !== route.length) {\n            getHashesFromRoute(route, depth + 1, hashes, hash);\n        }\n\n        // Or just add it to hashes\n        else {\n            hashes.push(cloneArray$1(hash));\n        }\n    } while (isArray && ++idx < length);\n\n    return hashes;\n}\n\nvar Precedence$1 = {\n    specific: 4,\n    ranges: 2,\n    integers: 2,\n    keys: 1\n};\nvar Precedence_1 = Precedence$1;\n\nvar iterateKeySet$1;\nvar hasRequiredIterateKeySet;\n\nfunction requireIterateKeySet () {\n\tif (hasRequiredIterateKeySet) return iterateKeySet$1;\n\thasRequiredIterateKeySet = 1;\n\tvar isArray = Array.isArray;\n\n\t/**\n\t * Takes in a keySet and a note attempts to iterate over it.\n\t * If the value is a primitive, the key will be returned and the note will\n\t * be marked done\n\t * If the value is an object, then each value of the range will be returned\n\t * and when finished the note will be marked done.\n\t * If the value is an array, each value will be iterated over, if any of the\n\t * inner values are ranges, those will be iterated over.  When fully done,\n\t * the note will be marked done.\n\t *\n\t * @param {Object|Array|String|Number} keySet -\n\t * @param {Object} note - The non filled note\n\t * @returns {String|Number|undefined} - The current iteration value.\n\t * If undefined, then the keySet is empty\n\t * @public\n\t */\n\titerateKeySet$1 = function iterateKeySet(keySet, note) {\n\t    if (note.isArray === undefined) {\n\t        initializeNote(keySet, note);\n\t    }\n\n\t    // Array iteration\n\t    if (note.isArray) {\n\t        var nextValue;\n\n\t        // Cycle through the array and pluck out the next value.\n\t        do {\n\t            if (note.loaded && note.rangeOffset > note.to) {\n\t                ++note.arrayOffset;\n\t                note.loaded = false;\n\t            }\n\n\t            var idx = note.arrayOffset, length = keySet.length;\n\t            if (idx >= length) {\n\t                note.done = true;\n\t                break;\n\t            }\n\n\t            var el = keySet[note.arrayOffset];\n\t            var type = typeof el;\n\n\t            // Inner range iteration.\n\t            if (type === 'object') {\n\t                if (!note.loaded) {\n\t                    initializeRange(el, note);\n\t                }\n\n\t                // Empty to/from\n\t                if (note.empty) {\n\t                    continue;\n\t                }\n\n\t                nextValue = note.rangeOffset++;\n\t            }\n\n\t            // Primitive iteration in array.\n\t            else {\n\t                ++note.arrayOffset;\n\t                nextValue = el;\n\t            }\n\t        } while (nextValue === undefined);\n\n\t        return nextValue;\n\t    }\n\n\t    // Range iteration\n\t    else if (note.isObject) {\n\t        if (!note.loaded) {\n\t            initializeRange(keySet, note);\n\t        }\n\t        if (note.rangeOffset > note.to) {\n\t            note.done = true;\n\t            return undefined;\n\t        }\n\n\t        return note.rangeOffset++;\n\t    }\n\n\t    // Primitive value\n\t    else {\n\t        note.done = true;\n\t        return keySet;\n\t    }\n\t};\n\n\tfunction initializeRange(key, memo) {\n\t    var from = memo.from = key.from || 0;\n\t    var to = memo.to = key.to ||\n\t        (typeof key.length === 'number' &&\n\t        memo.from + key.length - 1 || 0);\n\t    memo.rangeOffset = memo.from;\n\t    memo.loaded = true;\n\t    if (from > to) {\n\t        memo.empty = true;\n\t    }\n\t}\n\n\tfunction initializeNote(key, note) {\n\t    note.done = false;\n\t    var isObject = note.isObject = !!(key && typeof key === 'object');\n\t    note.isArray = isObject && isArray(key);\n\t    note.arrayOffset = 0;\n\t}\n\treturn iterateKeySet$1;\n}\n\nvar toTree;\nvar hasRequiredToTree;\n\nfunction requireToTree () {\n\tif (hasRequiredToTree) return toTree;\n\thasRequiredToTree = 1;\n\tvar iterateKeySet = requireIterateKeySet();\n\n\t/**\n\t * @param {Array} paths -\n\t * @returns {Object} -\n\t */\n\ttoTree = function toTree(paths) {\n\t    return paths.reduce(function(acc, path) {\n\t        innerToTree(acc, path, 0);\n\t        return acc;\n\t    }, {});\n\t};\n\n\tfunction innerToTree(seed, path, depth) {\n\n\t    var keySet = path[depth];\n\t    var iteratorNote = {};\n\t    var key;\n\t    var nextDepth = depth + 1;\n\n\t    key = iterateKeySet(keySet, iteratorNote);\n\n\t    do {\n\n\t        var next = seed[key];\n\t        if (!next) {\n\t            if (nextDepth === path.length) {\n\t                seed[key] = null;\n\t            } else {\n\t                next = seed[key] = {};\n\t            }\n\t        }\n\n\t        if (nextDepth < path.length) {\n\t            innerToTree(next, path, nextDepth);\n\t        }\n\n\t        if (!iteratorNote.done) {\n\t            key = iterateKeySet(keySet, iteratorNote);\n\t        }\n\t    } while (!iteratorNote.done);\n\t}\n\treturn toTree;\n}\n\nvar hasIntersection$1;\nvar hasRequiredHasIntersection$1;\n\nfunction requireHasIntersection$1 () {\n\tif (hasRequiredHasIntersection$1) return hasIntersection$1;\n\thasRequiredHasIntersection$1 = 1;\n\tvar iterateKeySet = requireIterateKeySet();\n\n\t/**\n\t * Tests to see if the intersection should be stripped from the\n\t * total paths.  The only way this happens currently is if the entirety\n\t * of the path is contained in the tree.\n\t * @private\n\t */\n\thasIntersection$1 = function hasIntersection(tree, path, depth) {\n\t    var current = tree;\n\t    var intersects = true;\n\n\t    // Continue iteratively going down a path until a complex key is\n\t    // encountered, then recurse.\n\t    for (;intersects && depth < path.length; ++depth) {\n\t        var key = path[depth];\n\t        var keyType = typeof key;\n\n\t        // We have to iterate key set\n\t        if (key && keyType === 'object') {\n\t            var note = {};\n\t            var innerKey = iterateKeySet(key, note);\n\t            var nextDepth = depth + 1;\n\n\t            // Loop through the innerKeys setting the intersects flag\n\t            // to each result.  Break out on false.\n\t            do {\n\t                var next = current[innerKey];\n\t                intersects = next !== undefined;\n\n\t                if (intersects) {\n\t                    intersects = hasIntersection(next, path, nextDepth);\n\t                }\n\t                innerKey = iterateKeySet(key, note);\n\t            } while (intersects && !note.done);\n\n\t            // Since we recursed, we shall not pass any further!\n\t            break;\n\t        }\n\n\t        // Its a simple key, just move forward with the testing.\n\t        current = current[key];\n\t        intersects = current !== undefined;\n\t    }\n\n\t    return intersects;\n\t};\n\treturn hasIntersection$1;\n}\n\nvar pathsComplementFromTree;\nvar hasRequiredPathsComplementFromTree;\n\nfunction requirePathsComplementFromTree () {\n\tif (hasRequiredPathsComplementFromTree) return pathsComplementFromTree;\n\thasRequiredPathsComplementFromTree = 1;\n\tvar hasIntersection = requireHasIntersection$1();\n\n\t/**\n\t * Compares the paths passed in with the tree.  Any of the paths that are in\n\t * the tree will be stripped from the paths.\n\t *\n\t * **Does not mutate** the incoming paths object.\n\t * **Proper subset** only matching.\n\t *\n\t * @param {Array} paths - A list of paths (complex or simple) to strip the\n\t * intersection\n\t * @param {Object} tree -\n\t * @public\n\t */\n\tpathsComplementFromTree = function pathsComplementFromTree(paths, tree) {\n\t    var out = [];\n\t    var outLength = -1;\n\n\t    for (var i = 0, len = paths.length; i < len; ++i) {\n\t        // If this does not intersect then add it to the output.\n\t        if (!hasIntersection(tree, paths[i], 0)) {\n\t            out[++outLength] = paths[i];\n\t        }\n\t    }\n\t    return out;\n\t};\n\treturn pathsComplementFromTree;\n}\n\nvar pathsComplementFromLengthTree;\nvar hasRequiredPathsComplementFromLengthTree;\n\nfunction requirePathsComplementFromLengthTree () {\n\tif (hasRequiredPathsComplementFromLengthTree) return pathsComplementFromLengthTree;\n\thasRequiredPathsComplementFromLengthTree = 1;\n\tvar hasIntersection = requireHasIntersection$1();\n\n\t/**\n\t * Compares the paths passed in with the tree.  Any of the paths that are in\n\t * the tree will be stripped from the paths.\n\t *\n\t * **Does not mutate** the incoming paths object.\n\t * **Proper subset** only matching.\n\t *\n\t * @param {Array} paths - A list of paths (complex or simple) to strip the\n\t * intersection\n\t * @param {Object} tree -\n\t * @public\n\t */\n\tpathsComplementFromLengthTree = function pathsComplementFromLengthTree(paths, tree) {\n\t    var out = [];\n\t    var outLength = -1;\n\n\t    for (var i = 0, len = paths.length; i < len; ++i) {\n\t        // If this does not intersect then add it to the output.\n\t        var path = paths[i];\n\t        if (!hasIntersection(tree[path.length], path, 0)) {\n\t            out[++outLength] = path;\n\t        }\n\t    }\n\t    return out;\n\t};\n\treturn pathsComplementFromLengthTree;\n}\n\nvar toPaths = {exports: {}};\n\nvar hasRequiredToPaths;\n\nfunction requireToPaths () {\n\tif (hasRequiredToPaths) return toPaths.exports;\n\thasRequiredToPaths = 1;\n\tvar isArray = Array.isArray;\n\tvar typeOfObject = \"object\";\n\tvar typeOfString = \"string\";\n\tvar typeOfNumber = \"number\";\n\tvar MAX_SAFE_INTEGER = 9007199254740991; // Number.MAX_SAFE_INTEGER in es6\n\tvar MAX_SAFE_INTEGER_DIGITS = 16; // String(Number.MAX_SAFE_INTEGER).length\n\tvar MIN_SAFE_INTEGER_DIGITS = 17; // String(Number.MIN_SAFE_INTEGER).length (including sign)\n\tvar abs = Math.abs;\n\tvar safeNumberRegEx = /^(0|(\\-?[1-9][0-9]*))$/;\n\n\t/* jshint forin: false */\n\ttoPaths.exports = function toPaths(lengths) {\n\t    var pathmap;\n\t    var allPaths = [];\n\t    var allPathsLength = 0;\n\t    for (var length in lengths) {\n\t        if (isSafeNumber(length) && isObject(pathmap = lengths[length])) {\n\t            var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;\n\t            var pathsIndex = -1;\n\t            var pathsCount = paths.length;\n\t            while (++pathsIndex < pathsCount) {\n\t                allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);\n\t            }\n\t        }\n\t    }\n\t    return allPaths;\n\t};\n\n\tfunction isObject(value) {\n\t    return value !== null && typeof value === typeOfObject;\n\t}\n\n\tfunction collapsePathMap(pathmap, depth, length) {\n\n\t    var key;\n\t    var code = getHashCode(String(depth));\n\t    var subs = Object.create(null);\n\n\t    var codes = [];\n\t    var codesIndex = -1;\n\t    var codesCount = 0;\n\n\t    var pathsets = [];\n\t    var pathsetsCount = 0;\n\n\t    var subPath, subCode,\n\t        subKeys, subKeysIndex, subKeysCount,\n\t        subSets, subSetsIndex, subSetsCount,\n\t        pathset, pathsetIndex, pathsetCount,\n\t        firstSubKey, pathsetClone;\n\n\t    subKeys = [];\n\t    subKeysIndex = -1;\n\n\t    if (depth < length - 1) {\n\n\t        subKeysCount = getSortedKeys(pathmap, subKeys);\n\n\t        while (++subKeysIndex < subKeysCount) {\n\t            key = subKeys[subKeysIndex];\n\t            subPath = collapsePathMap(pathmap[key], depth + 1, length);\n\t            subCode = subPath.code;\n\t            if(subs[subCode]) {\n\t                subPath = subs[subCode];\n\t            } else {\n\t                codes[codesCount++] = subCode;\n\t                subPath = subs[subCode] = {\n\t                    keys: [],\n\t                    sets: subPath.sets\n\t                };\n\t            }\n\t            code = getHashCode(code + key + subCode);\n\n\t            isSafeNumber(key) &&\n\t                subPath.keys.push(parseInt(key, 10)) ||\n\t                subPath.keys.push(key);\n\t        }\n\n\t        while(++codesIndex < codesCount) {\n\n\t            key = codes[codesIndex];\n\t            subPath = subs[key];\n\t            subKeys = subPath.keys;\n\t            subKeysCount = subKeys.length;\n\n\t            if (subKeysCount > 0) {\n\n\t                subSets = subPath.sets;\n\t                subSetsIndex = -1;\n\t                subSetsCount = subSets.length;\n\t                firstSubKey = subKeys[0];\n\n\t                while (++subSetsIndex < subSetsCount) {\n\n\t                    pathset = subSets[subSetsIndex];\n\t                    pathsetIndex = -1;\n\t                    pathsetCount = pathset.length;\n\t                    pathsetClone = new Array(pathsetCount + 1);\n\t                    pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;\n\n\t                    while (++pathsetIndex < pathsetCount) {\n\t                        pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];\n\t                    }\n\n\t                    pathsets[pathsetsCount++] = pathsetClone;\n\t                }\n\t            }\n\t        }\n\t    } else {\n\t        subKeysCount = getSortedKeys(pathmap, subKeys);\n\t        if (subKeysCount > 1) {\n\t            pathsets[pathsetsCount++] = [subKeys];\n\t        } else {\n\t            pathsets[pathsetsCount++] = subKeys;\n\t        }\n\t        while (++subKeysIndex < subKeysCount) {\n\t            code = getHashCode(code + subKeys[subKeysIndex]);\n\t        }\n\t    }\n\n\t    return {\n\t        code: code,\n\t        sets: pathsets\n\t    };\n\t}\n\n\tfunction collapsePathSetIndexes(pathset) {\n\n\t    var keysetIndex = -1;\n\t    var keysetCount = pathset.length;\n\n\t    while (++keysetIndex < keysetCount) {\n\t        var keyset = pathset[keysetIndex];\n\t        if (isArray(keyset)) {\n\t            pathset[keysetIndex] = collapseIndex(keyset);\n\t        }\n\t    }\n\n\t    return pathset;\n\t}\n\n\t/**\n\t * Collapse range indexers, e.g. when there is a continuous\n\t * range in an array, turn it into an object instead:\n\t *\n\t * [1,2,3,4,5,6] => {\"from\":1, \"to\":6}\n\t *\n\t * @private\n\t */\n\tfunction collapseIndex(keyset) {\n\n\t    // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?\n\t    // var hash = {};\n\t    var keyIndex = -1;\n\t    var keyCount = keyset.length - 1;\n\t    var isSparseRange = keyCount > 0;\n\n\t    while (++keyIndex <= keyCount) {\n\n\t        var key = keyset[keyIndex];\n\n\t        if (!isSafeNumber(key) /* || hash[key] === true*/ ) {\n\t            isSparseRange = false;\n\t            break;\n\t        }\n\t        // hash[key] = true;\n\t        // Cast number indexes to integers.\n\t        keyset[keyIndex] = parseInt(key, 10);\n\t    }\n\n\t    if (isSparseRange === true) {\n\n\t        keyset.sort(sortListAscending);\n\n\t        var from = keyset[0];\n\t        var to = keyset[keyCount];\n\n\t        // If we re-introduce deduped integer indexers, change this comparson to \"===\".\n\t        if (to - from <= keyCount) {\n\t            return {\n\t                from: from,\n\t                to: to\n\t            };\n\t        }\n\t    }\n\n\t    return keyset;\n\t}\n\n\tfunction sortListAscending(a, b) {\n\t    return a - b;\n\t}\n\n\t/* jshint forin: false */\n\tfunction getSortedKeys(map, keys, sort) {\n\t    var len = 0;\n\t    for (var key in map) {\n\t        keys[len++] = key;\n\t    }\n\t    if (len > 1) {\n\t        keys.sort(sort);\n\t    }\n\t    return len;\n\t}\n\n\tfunction getHashCode(key) {\n\t    var code = 5381;\n\t    var index = -1;\n\t    var count = key.length;\n\t    while (++index < count) {\n\t        code = (code << 5) + code + key.charCodeAt(index);\n\t    }\n\t    return String(code);\n\t}\n\n\t/**\n\t * Return true if argument is a number or can be cast to a number which\n\t * roundtrips to the same string.\n\t * @private\n\t */\n\tfunction isSafeNumber(val) {\n\t    var num = val;\n\t    var type = typeof val;\n\t    if (type === typeOfString) {\n\t        var length = val.length;\n\t        // Number.MIN_SAFE_INTEGER is 17 digits including the sign.\n\t        // Anything longer cannot be safe.\n\t        if (length === 0 || length > MIN_SAFE_INTEGER_DIGITS) {\n\t            return false;\n\t        }\n\t        if (!safeNumberRegEx.test(val)) {\n\t            return false;\n\t        }\n\t        // Number.MAX_SAFE_INTEGER is 16 digits.\n\t        // Anything shorter must be safe.\n\t        if (length < MAX_SAFE_INTEGER_DIGITS) {\n\t            return true;\n\t        }\n\t        num = +val;\n\t    } else if (type !== typeOfNumber) {\n\t        return false;\n\t    }\n\t    // Number.isSafeInteger(num) in es6.\n\t    return num % 1 === 0 && abs(num) <= MAX_SAFE_INTEGER;\n\t}\n\n\t// export for testing\n\ttoPaths.exports._isSafeNumber = isSafeNumber;\n\treturn toPaths.exports;\n}\n\nvar collapse$1;\nvar hasRequiredCollapse;\n\nfunction requireCollapse () {\n\tif (hasRequiredCollapse) return collapse$1;\n\thasRequiredCollapse = 1;\n\tvar toPaths = requireToPaths();\n\tvar toTree = requireToTree();\n\n\tcollapse$1 = function collapse(paths) {\n\t    var collapseMap = paths.\n\t        reduce(function(acc, path) {\n\t            var len = path.length;\n\t            if (!acc[len]) {\n\t                acc[len] = [];\n\t            }\n\t            acc[len].push(path);\n\t            return acc;\n\t        }, {});\n\n\t    Object.\n\t        keys(collapseMap).\n\t        forEach(function(collapseKey) {\n\t            collapseMap[collapseKey] = toTree(collapseMap[collapseKey]);\n\t        });\n\n\t    return toPaths(collapseMap);\n\t};\n\treturn collapse$1;\n}\n\nvar cloneArray_1;\nvar hasRequiredCloneArray;\n\nfunction requireCloneArray () {\n\tif (hasRequiredCloneArray) return cloneArray_1;\n\thasRequiredCloneArray = 1;\n\tfunction cloneArray(arr, index) {\n\t    var a = [];\n\t    var len = arr.length;\n\t    for (var i = index || 0; i < len; i++) {\n\t        a[i] = arr[i];\n\t    }\n\t    return a;\n\t}\n\n\tcloneArray_1 = cloneArray;\n\treturn cloneArray_1;\n}\n\nvar catAndSlice$1;\nvar hasRequiredCatAndSlice$1;\n\nfunction requireCatAndSlice$1 () {\n\tif (hasRequiredCatAndSlice$1) return catAndSlice$1;\n\thasRequiredCatAndSlice$1 = 1;\n\tcatAndSlice$1 = function catAndSlice(a, b, slice) {\n\t    var next = [], i, j, len;\n\t    for (i = 0, len = a.length; i < len; ++i) {\n\t        next[i] = a[i];\n\t    }\n\n\t    for (j = slice || 0, len = b.length; j < len; ++j, ++i) {\n\t        next[i] = b[j];\n\t    }\n\n\t    return next;\n\t};\n\treturn catAndSlice$1;\n}\n\nvar types$1;\nvar hasRequiredTypes$1;\n\nfunction requireTypes$1 () {\n\tif (hasRequiredTypes$1) return types$1;\n\thasRequiredTypes$1 = 1;\n\ttypes$1 = {\n\t    $ref: 'ref',\n\t    $atom: 'atom',\n\t    $error: 'error'\n\t};\n\treturn types$1;\n}\n\n/*eslint-disable*/\n\nvar errors;\nvar hasRequiredErrors;\n\nfunction requireErrors () {\n\tif (hasRequiredErrors) return errors;\n\thasRequiredErrors = 1;\n\terrors = {\n\t    innerReferences: 'References with inner references are not allowed.',\n\t    circularReference: 'There appears to be a circular reference, maximum reference following exceeded.'\n\t};\n\treturn errors;\n}\n\nvar followReference$1;\nvar hasRequiredFollowReference$1;\n\nfunction requireFollowReference$1 () {\n\tif (hasRequiredFollowReference$1) return followReference$1;\n\thasRequiredFollowReference$1 = 1;\n\tvar cloneArray = requireCloneArray();\n\tvar $ref = requireTypes$1().$ref;\n\tvar errors = requireErrors();\n\n\t/**\n\t * performs the simplified cache reference follow.  This\n\t * differs from get as there is just following and reporting,\n\t * not much else.\n\t *\n\t * @param {Object} cacheRoot\n\t * @param {Array} ref\n\t */\n\tfollowReference$1 = function followReference(cacheRoot, ref, maxRefFollow) {\n\t    var current = cacheRoot;\n\t    var refPath = ref;\n\t    var depth = -1;\n\t    var length = refPath.length;\n\t    var key, next, type;\n\t    var referenceCount = 0;\n\n\t    while (++depth < length) {\n\t        key = refPath[depth];\n\t        next = current[key];\n\t        type = next && next.$type;\n\n\t        if (!next || type && type !== $ref) {\n\t            current = next;\n\t            break;\n\t        }\n\n\t        // Show stopper exception.  This route is malformed.\n\t        if (type && type === $ref && depth + 1 < length) {\n\t            var err = new Error(errors.innerReferences);\n\t            err.throwToNext = true;\n\t            throw err;\n\t        }\n\n\t        // potentially follow reference\n\t        if (depth + 1 === length) {\n\t            if (type === $ref) {\n\t                depth = -1;\n\t                refPath = next.value;\n\t                length = refPath.length;\n\t                next = cacheRoot;\n\t                referenceCount++;\n\t            }\n\n\t            if (referenceCount > maxRefFollow) {\n\t                throw new Error(errors.circularReference);\n\t            }\n\t        }\n\t        current = next;\n\t    }\n\n\t    return [current, cloneArray(refPath)];\n\t};\n\treturn followReference$1;\n}\n\nvar optimizePathSets$1;\nvar hasRequiredOptimizePathSets$1;\n\nfunction requireOptimizePathSets$1 () {\n\tif (hasRequiredOptimizePathSets$1) return optimizePathSets$1;\n\thasRequiredOptimizePathSets$1 = 1;\n\tvar iterateKeySet = requireIterateKeySet();\n\tvar cloneArray = requireCloneArray();\n\tvar catAndSlice = requireCatAndSlice$1();\n\tvar $types = requireTypes$1();\n\tvar $ref = $types.$ref;\n\tvar followReference = requireFollowReference$1();\n\n\t/**\n\t * The fastest possible optimize of paths.\n\t *\n\t * What it does:\n\t * - Any atom short-circuit / found value will be removed from the path.\n\t * - All paths will be exploded which means that collapse will need to be\n\t *   ran afterwords.\n\t * - Any missing path will be optimized as much as possible.\n\t */\n\toptimizePathSets$1 = function optimizePathSets(cache, paths, maxRefFollow) {\n\t    var optimized = [];\n\t    paths.forEach(function(p) {\n\t        optimizePathSet(cache, cache, p, 0, optimized, [], maxRefFollow);\n\t    });\n\n\t    return optimized;\n\t};\n\n\n\t/**\n\t * optimizes one pathSet at a time.\n\t */\n\tfunction optimizePathSet(cache, cacheRoot, pathSet,\n\t                         depth, out, optimizedPath, maxRefFollow) {\n\n\t    // at missing, report optimized path.\n\t    if (cache === undefined) {\n\t        out[out.length] = catAndSlice(optimizedPath, pathSet, depth);\n\t        return;\n\t    }\n\n\t    // all other sentinels are short circuited.\n\t    // Or we found a primitive (which includes null)\n\t    if (cache === null || (cache.$type && cache.$type !== $ref) ||\n\t            (typeof cache !== 'object')) {\n\t        return;\n\t    }\n\n\t    // If the reference is the last item in the path then do not\n\t    // continue to search it.\n\t    if (cache.$type === $ref && depth === pathSet.length) {\n\t        return;\n\t    }\n\n\t    var keySet = pathSet[depth];\n\t    var isKeySet = typeof keySet === 'object';\n\t    var nextDepth = depth + 1;\n\t    var iteratorNote = false;\n\t    var key = keySet;\n\t    if (isKeySet) {\n\t        iteratorNote = {};\n\t        key = iterateKeySet(keySet, iteratorNote);\n\t    }\n\t    var next, nextOptimized;\n\t    do {\n\t        next = cache[key];\n\t        var optimizedPathLength = optimizedPath.length;\n\t        if (key !== null) {\n\t            optimizedPath[optimizedPathLength] = key;\n\t        }\n\n\t        if (next && next.$type === $ref && nextDepth < pathSet.length) {\n\t            var refResults =\n\t                followReference(cacheRoot, next.value, maxRefFollow);\n\t            next = refResults[0];\n\n\t            // must clone to avoid the mutation from above destroying the cache.\n\t            nextOptimized = cloneArray(refResults[1]);\n\t        } else {\n\t            nextOptimized = optimizedPath;\n\t        }\n\n\t        optimizePathSet(next, cacheRoot, pathSet, nextDepth,\n\t                        out, nextOptimized, maxRefFollow);\n\t        optimizedPath.length = optimizedPathLength;\n\n\t        if (iteratorNote && !iteratorNote.done) {\n\t            key = iterateKeySet(keySet, iteratorNote);\n\t        }\n\t    } while (iteratorNote && !iteratorNote.done);\n\t}\n\treturn optimizePathSets$1;\n}\n\nvar pathCount;\nvar hasRequiredPathCount;\n\nfunction requirePathCount () {\n\tif (hasRequiredPathCount) return pathCount;\n\thasRequiredPathCount = 1;\n\n\t/**\n\t * Helper for getPathCount. Used to determine the size of a key or range.\n\t * @function\n\t * @param {Object} rangeOrKey\n\t * @return The size of the key or range passed in.\n\t */\n\tfunction getRangeOrKeySize(rangeOrKey) {\n\t    if (rangeOrKey == null) {\n\t        return 1;\n\t    } else if (Array.isArray(rangeOrKey)) {\n\t        throw new Error(\"Unexpected Array found in keySet: \" + JSON.stringify(rangeOrKey));\n\t    } else if (typeof rangeOrKey === \"object\") {\n\t        return getRangeSize(rangeOrKey);\n\t    } else {\n\t        return 1;\n\t    }\n\t}\n\n\t/**\n\t * Returns the size (number of items) in a Range,\n\t * @function\n\t * @param {Object} range The Range with both \"from\" and \"to\", or just \"to\"\n\t * @return The number of items in the range.\n\t */\n\tfunction getRangeSize(range) {\n\n\t    var to = range.to;\n\t    var length = range.length;\n\n\t    if (to != null) {\n\t        if (isNaN(to) || parseInt(to, 10) !== to) {\n\t            throw new Error(\"Invalid range, 'to' is not an integer: \" + JSON.stringify(range));\n\t        }\n\t        var from = range.from || 0;\n\t        if (isNaN(from) || parseInt(from, 10) !== from) {\n\t            throw new Error(\"Invalid range, 'from' is not an integer: \" + JSON.stringify(range));\n\t        }\n\t        if (from <= to) {\n\t            return (to - from) + 1;\n\t        } else {\n\t            return 0;\n\t        }\n\t    } else if (length != null) {\n\t        if (isNaN(length) || parseInt(length, 10) !== length) {\n\t            throw new Error(\"Invalid range, 'length' is not an integer: \" + JSON.stringify(range));\n\t        } else {\n\t            return length;\n\t        }\n\t    } else {\n\t        throw new Error(\"Invalid range, expected 'to' or 'length': \" + JSON.stringify(range));\n\t    }\n\t}\n\n\t/**\n\t * Returns a count of the number of paths this pathset\n\t * represents.\n\t *\n\t * For example, [\"foo\", {\"from\":0, \"to\":10}, \"bar\"],\n\t * would represent 11 paths (0 to 10, inclusive), and\n\t * [\"foo, [\"baz\", \"boo\"], \"bar\"] would represent 2 paths.\n\t *\n\t * @function\n\t * @param {Object[]} pathSet the path set.\n\t *\n\t * @return The number of paths this represents\n\t */\n\tfunction getPathCount(pathSet) {\n\t    if (pathSet.length === 0) {\n\t        throw new Error(\"All paths must have length larger than zero.\");\n\t    }\n\n\t    var numPaths = 1;\n\n\t    for (var i = 0; i < pathSet.length; i++) {\n\t        var segment = pathSet[i];\n\n\t        if (Array.isArray(segment)) {\n\n\t            var numKeys = 0;\n\n\t            for (var j = 0; j < segment.length; j++) {\n\t                var keySet = segment[j];\n\n\t                numKeys += getRangeOrKeySize(keySet);\n\t            }\n\n\t            numPaths *= numKeys;\n\n\t        } else {\n\t            numPaths *= getRangeOrKeySize(segment);\n\t        }\n\t    }\n\n\t    return numPaths;\n\t}\n\n\n\tpathCount = getPathCount;\n\treturn pathCount;\n}\n\nvar lib;\nvar hasRequiredLib;\n\nfunction requireLib () {\n\tif (hasRequiredLib) return lib;\n\thasRequiredLib = 1;\n\tlib = {\n\t    iterateKeySet: requireIterateKeySet(),\n\t    toTree: requireToTree(),\n\t    pathsComplementFromTree: requirePathsComplementFromTree(),\n\t    pathsComplementFromLengthTree: requirePathsComplementFromLengthTree(),\n\t    hasIntersection: requireHasIntersection$1(),\n\t    toPaths: requireToPaths(),\n\t    collapse: requireCollapse(),\n\t    optimizePathSets: requireOptimizePathSets$1(),\n\t    pathCount: requirePathCount()\n\t};\n\treturn lib;\n}\n\nvar iterateKeySet = requireLib().iterateKeySet;\n\nvar specific = function specificMatcher(keySet, currentNode) {\n    // --------------------------------------\n    // Specific key\n    // --------------------------------------\n    var iteratorNote = {};\n    var nexts = [];\n\n    var key = iterateKeySet(keySet, iteratorNote);\n    do {\n\n        if (currentNode[key]) {\n            nexts[nexts.length] = key;\n        }\n\n        if (!iteratorNote.done) {\n            key = iterateKeySet(keySet, iteratorNote);\n        }\n    } while (!iteratorNote.done);\n\n    return nexts;\n};\n\nvar isArray$1 = Array.isArray;\n/**\n * plucks any integers from the path key.  Makes no effort\n * to convert the key into any specific format.\n */\nvar pluckIntergers = function pluckIntegers(keySet) {\n    var ints = [];\n\n    if (typeof keySet === 'object') {\n        if (isArray$1(keySet)) {\n            keySet.forEach(function(key) {\n                // Range case\n                if (typeof key === 'object') {\n                    ints[ints.length] = key;\n                }\n\n                else if (!isNaN(+key)) {\n                    ints[ints.length] = +key;\n                }\n            });\n        }\n        // Range case\n        else {\n            ints[ints.length] = keySet;\n        }\n    }\n\n    else if (!isNaN(+keySet)) {\n        ints[ints.length] = +keySet;\n    }\n\n    return ints;\n};\n\n/**\n * Determines if the object is a routed token by hasOwnProperty\n * of type and named\n */\n\nvar isRoutedToken$1 = function isRoutedToken(obj) {\n    return obj.hasOwnProperty('type') && obj.hasOwnProperty('named');\n};\n\nvar CallNotFoundError$1 = {exports: {}};\n\nvar hasRequiredCallNotFoundError;\n\nfunction requireCallNotFoundError () {\n\tif (hasRequiredCallNotFoundError) return CallNotFoundError$1.exports;\n\thasRequiredCallNotFoundError = 1;\n\tvar MESSAGE = 'function does not exist.';\n\tvar CallNotFoundError = CallNotFoundError$1.exports = function CallNotFoundError() {\n\t    this.message = MESSAGE;\n\t    this.stack = (new Error()).stack;\n\t};\n\n\tCallNotFoundError.prototype = new Error();\n\treturn CallNotFoundError$1.exports;\n}\n\nvar Keys$1 = Keys_1;\nvar Precedence = Precedence_1;\nvar cloneArray = cloneArray_1$1;\nvar specificMatcher = specific;\nvar pluckIntegers = pluckIntergers;\nvar pathUtils = requireLib();\nvar collapse = pathUtils.collapse;\nvar isRoutedToken = isRoutedToken$1;\nvar CallNotFoundError = requireCallNotFoundError();\n\nvar intTypes = [{\n        type: Keys$1.ranges,\n        precedence: Precedence.ranges\n    }, {\n        type: Keys$1.integers,\n        precedence: Precedence.integers\n    }];\nvar keyTypes = [{\n        type: Keys$1.keys,\n        precedence: Precedence.keys\n    }];\nvar allTypes = intTypes.concat(keyTypes);\nvar get = 'get';\nvar set = 'set';\nvar call = 'call';\n\n/**\n * Creates a custom matching function for the match tree.\n * @param Object rst The routed syntax tree\n * @param String method the method to call at the end of the path.\n * @return {matched: Array.<Match>, missingPaths: Array.<Array>}\n */\nvar matcher$1 = function matcher(rst) {\n    /**\n     * This is where the matching is done.  Will recursively\n     * match the paths until it has found all the matchable\n     * functions.\n     * @param {[]} paths\n     */\n    return function innerMatcher(method, paths) {\n        var matched = [];\n        var missing = [];\n        match(rst, paths, method, matched, missing);\n\n        // We are at the end of the path but there is no match and its a\n        // call.  Therefore we are going to throw an informative error.\n        if (method === call && matched.length === 0) {\n            var err = new CallNotFoundError();\n            err.throwToNext = true;\n\n            throw err;\n        }\n\n        // Reduce into groups multiple matched routes into route sets where\n        // each match matches the same route endpoint.  From here we can reduce\n        // the matched paths into the most optimal pathSet with collapse.\n        var reducedMatched = matched.reduce(function(acc, matchedRoute) {\n            if (!acc[matchedRoute.id]) {\n                acc[matchedRoute.id] = [];\n            }\n            acc[matchedRoute.id].push(matchedRoute);\n\n            return acc;\n        }, {});\n\n        var collapsedMatched = [];\n\n        // For every set of matched routes, collapse and reduce its matched set\n        // down to the minimal amount of collapsed sets.\n        Object.\n            keys(reducedMatched).\n            forEach(function(k) {\n                var reducedMatch = reducedMatched[k];\n\n                // If the reduced match is of length one then there is no\n                // need to perform collapsing, as there is nothing to collapse\n                // over.\n                if (reducedMatch.length === 1) {\n                    collapsedMatched.push(reducedMatch[0]);\n                    return;\n                }\n\n                // Since there are more than 1 routes, we need to see if\n                // they can collapse and alter the amount of arrays.\n                var collapsedResults =\n                        collapse(\n                            reducedMatch.\n                                map(function(x) {\n                                    return x.requested;\n                                }));\n\n                // For every collapsed result we use the previously match result\n                // and update its requested and virtual path.  Then add that\n                // match to the collapsedMatched set.\n                collapsedResults.forEach(function(path, i) {\n                    var collapsedMatch = reducedMatch[i];\n                    var reducedVirtualPath = collapsedMatch.virtual;\n                    path.forEach(function(atom, index) {\n\n                        // If its not a routed atom then wholesale replace\n                        if (!isRoutedToken(reducedVirtualPath[index])) {\n                            reducedVirtualPath[index] = atom;\n                        }\n                    });\n                    collapsedMatch.requested = path;\n                    collapsedMatched.push(reducedMatch[i]);\n                });\n            });\n        return collapsedMatched;\n    };\n};\n\nfunction match(\n        curr, path, method, matchedFunctions,\n        missingPaths, depth, requested, virtual, precedence) {\n\n    // Nothing left to match\n    if (!curr) {\n        return;\n    }\n\n    /* eslint-disable no-param-reassign */\n    depth = depth || 0;\n    requested = requested || [];\n    virtual = virtual || [];\n    precedence = precedence || [];\n    matchedFunctions = matchedFunctions || [];\n    /* eslint-disable no-param-reassign */\n\n    // At this point in the traversal we have hit a matching function.\n    // Its time to terminate.\n    // Get: simple method matching\n    // Set/Call: The method is unique.  If the path is not complete,\n    // meaning the depth is equivalent to the length,\n    // then we match a 'get' method, else we match a 'set' or 'call' method.\n    var atEndOfPath = path.length === depth;\n    var isSet = method === set;\n    var isCall = method === call;\n    var methodToUse = method;\n    if ((isCall || isSet) && !atEndOfPath) {\n        methodToUse = get;\n    }\n\n    // Stores the matched result if found along or at the end of\n    // the path.  If we are doing a set and there is no set handler\n    // but there is a get handler, then we need to use the get\n    // handler.  This is so that the current value that is in the\n    // clients cache does not get materialized away.\n    var currentMatch = curr[Keys$1.match];\n\n    // From https://github.com/Netflix/falcor-router/issues/76\n    // Set: When there is no set hander then we should default to running\n    // the get handler so that we do not destroy the client local values.\n    if (currentMatch && isSet && !currentMatch[set]) {\n        methodToUse = get;\n    }\n\n    // Check to see if we have\n    if (currentMatch && currentMatch[methodToUse]) {\n        matchedFunctions[matchedFunctions.length] = {\n\n            // Used for collapsing paths that use routes with multiple\n            // string indexers.\n            id: currentMatch[methodToUse + 'Id'],\n            requested: cloneArray(requested),\n            prettyRoute: currentMatch.prettyRoute,\n            action: currentMatch[methodToUse],\n            authorize: currentMatch.authorize,\n            virtual: cloneArray(virtual),\n            precedence: +(precedence.join('')),\n            suffix: path.slice(depth),\n            isSet: atEndOfPath && isSet,\n            isCall: atEndOfPath && isCall\n        };\n    }\n\n    // If the depth has reached the end then we need to stop recursing.  This\n    // can cause odd side effects with matching against {keys} as the last\n    // argument when a path has been exhausted (undefined is still a key value).\n    //\n    // Example:\n    // route1: [{keys}]\n    // route2: [{keys}][{keys}]\n    //\n    // path: ['('].\n    //\n    // This will match route1 and 2 since we do not bail out on length and there\n    // is a {keys} matcher which will match \"undefined\" value.\n    if (depth === path.length) {\n        return;\n    }\n\n    var keySet = path[depth];\n    var i, len, key, next;\n\n    // -------------------------------------------\n    // Specific key matcher.\n    // -------------------------------------------\n    var specificKeys = specificMatcher(keySet, curr);\n    for (i = 0, len = specificKeys.length; i < len; ++i) {\n        key = specificKeys[i];\n        virtual[depth] = key;\n        requested[depth] = key;\n        precedence[depth] = Precedence.specific;\n\n        // Its time to recurse\n        match(\n            curr[specificKeys[i]],\n            path, method, matchedFunctions,\n            missingPaths, depth + 1,\n            requested, virtual, precedence);\n\n        // Removes the virtual, requested, and precedence info\n        virtual.length = depth;\n        requested.length = depth;\n        precedence.length = depth;\n    }\n\n    var ints = pluckIntegers(keySet);\n    var keys = keySet;\n    var intsLength = ints.length;\n\n    // -------------------------------------------\n    // ints, ranges, and keys matcher.\n    // -------------------------------------------\n    allTypes.\n        filter(function(typeAndPrecedence) {\n            var type = typeAndPrecedence.type;\n            // one extra move required for int types\n            if (type === Keys$1.integers || type === Keys$1.ranges) {\n                return curr[type] && intsLength;\n            }\n            return curr[type];\n        }).\n        forEach(function(typeAndPrecedence) {\n            var type = typeAndPrecedence.type;\n            var prec = typeAndPrecedence.precedence;\n            next = curr[type];\n\n            virtual[depth] = {\n                type: type,\n                named: next[Keys$1.named],\n                name: next[Keys$1.name]\n            };\n\n            // The requested set of info needs to be set either\n            // as ints, if int matchers or keys\n            if (type === Keys$1.integers || type === Keys$1.ranges) {\n                requested[depth] = ints;\n            } else {\n                requested[depth] = keys;\n            }\n\n            precedence[depth] = prec;\n\n            // Continue the matching algo.\n            match(\n                next,\n                path, method, matchedFunctions,\n                missingPaths, depth + 1,\n                requested, virtual, precedence);\n\n            // removes the added keys\n            virtual.length = depth;\n            requested.length = depth;\n            precedence.length = depth;\n        });\n}\n\nvar JSONGraphError$2 = {exports: {}};\n\nvar JSONGraphError$1 = JSONGraphError$2.exports = function JSONGraphError(typeValue) {\n    this.typeValue = typeValue;\n};\nJSONGraphError$1.prototype = new Error();\n\nvar JSONGraphErrorExports = JSONGraphError$2.exports;\n\nvar Observable = {};\n\nvar root$1 = {};\n\nvar hasRequiredRoot;\n\nfunction requireRoot () {\n\tif (hasRequiredRoot) return root$1;\n\thasRequiredRoot = 1;\n\t(function (exports) {\n\t\t/**\n\t\t * window: browser in DOM main thread\n\t\t * self: browser in WebWorker\n\t\t * global: Node.js/other\n\t\t */\n\t\texports.root = (typeof window == 'object' && window.window === window && window\n\t\t    || typeof self == 'object' && self.self === self && self\n\t\t    || typeof commonjsGlobal == 'object' && commonjsGlobal.global === commonjsGlobal && commonjsGlobal);\n\t\tif (!exports.root) {\n\t\t    throw new Error('RxJS could not find any global context (window, self, global)');\n\t\t}\n\t\t\n\t} (root$1));\n\treturn root$1;\n}\n\nvar toSubscriber = {};\n\nvar Subscriber = {};\n\nvar isFunction = {};\n\nvar hasRequiredIsFunction;\n\nfunction requireIsFunction () {\n\tif (hasRequiredIsFunction) return isFunction;\n\thasRequiredIsFunction = 1;\n\tfunction isFunction$1(x) {\n\t    return typeof x === 'function';\n\t}\n\tisFunction.isFunction = isFunction$1;\n\t\n\treturn isFunction;\n}\n\nvar Subscription = {};\n\nvar isArray = {};\n\nvar hasRequiredIsArray;\n\nfunction requireIsArray () {\n\tif (hasRequiredIsArray) return isArray;\n\thasRequiredIsArray = 1;\n\tisArray.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n\t\n\treturn isArray;\n}\n\nvar isObject = {};\n\nvar hasRequiredIsObject;\n\nfunction requireIsObject () {\n\tif (hasRequiredIsObject) return isObject;\n\thasRequiredIsObject = 1;\n\tfunction isObject$1(x) {\n\t    return x != null && typeof x === 'object';\n\t}\n\tisObject.isObject = isObject$1;\n\t\n\treturn isObject;\n}\n\nvar tryCatch = {};\n\nvar errorObject = {};\n\nvar hasRequiredErrorObject;\n\nfunction requireErrorObject () {\n\tif (hasRequiredErrorObject) return errorObject;\n\thasRequiredErrorObject = 1;\n\t// typeof any so that it we don't have to cast when comparing a result to the error object\n\terrorObject.errorObject = { e: {} };\n\t\n\treturn errorObject;\n}\n\nvar hasRequiredTryCatch;\n\nfunction requireTryCatch () {\n\tif (hasRequiredTryCatch) return tryCatch;\n\thasRequiredTryCatch = 1;\n\tvar errorObject_1 = requireErrorObject();\n\tvar tryCatchTarget;\n\tfunction tryCatcher() {\n\t    try {\n\t        return tryCatchTarget.apply(this, arguments);\n\t    }\n\t    catch (e) {\n\t        errorObject_1.errorObject.e = e;\n\t        return errorObject_1.errorObject;\n\t    }\n\t}\n\tfunction tryCatch$1(fn) {\n\t    tryCatchTarget = fn;\n\t    return tryCatcher;\n\t}\n\ttryCatch.tryCatch = tryCatch$1;\n\t\n\treturn tryCatch;\n}\n\nvar UnsubscriptionError = {};\n\nvar hasRequiredUnsubscriptionError;\n\nfunction requireUnsubscriptionError () {\n\tif (hasRequiredUnsubscriptionError) return UnsubscriptionError;\n\thasRequiredUnsubscriptionError = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * An error thrown when one or more errors have occurred during the\n\t * `unsubscribe` of a {@link Subscription}.\n\t */\n\tvar UnsubscriptionError$1 = (function (_super) {\n\t    __extends(UnsubscriptionError, _super);\n\t    function UnsubscriptionError(errors) {\n\t        _super.call(this);\n\t        this.errors = errors;\n\t        var err = Error.call(this, errors ?\n\t            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n  ') : '');\n\t        this.name = err.name = 'UnsubscriptionError';\n\t        this.stack = err.stack;\n\t        this.message = err.message;\n\t    }\n\t    return UnsubscriptionError;\n\t}(Error));\n\tUnsubscriptionError.UnsubscriptionError = UnsubscriptionError$1;\n\t\n\treturn UnsubscriptionError;\n}\n\nvar hasRequiredSubscription;\n\nfunction requireSubscription () {\n\tif (hasRequiredSubscription) return Subscription;\n\thasRequiredSubscription = 1;\n\tvar isArray_1 = requireIsArray();\n\tvar isObject_1 = requireIsObject();\n\tvar isFunction_1 = requireIsFunction();\n\tvar tryCatch_1 = requireTryCatch();\n\tvar errorObject_1 = requireErrorObject();\n\tvar UnsubscriptionError_1 = requireUnsubscriptionError();\n\t/**\n\t * Represents a disposable resource, such as the execution of an Observable. A\n\t * Subscription has one important method, `unsubscribe`, that takes no argument\n\t * and just disposes the resource held by the subscription.\n\t *\n\t * Additionally, subscriptions may be grouped together through the `add()`\n\t * method, which will attach a child Subscription to the current Subscription.\n\t * When a Subscription is unsubscribed, all its children (and its grandchildren)\n\t * will be unsubscribed as well.\n\t *\n\t * @class Subscription\n\t */\n\tvar Subscription$1 = (function () {\n\t    /**\n\t     * @param {function(): void} [unsubscribe] A function describing how to\n\t     * perform the disposal of resources when the `unsubscribe` method is called.\n\t     */\n\t    function Subscription(unsubscribe) {\n\t        /**\n\t         * A flag to indicate whether this Subscription has already been unsubscribed.\n\t         * @type {boolean}\n\t         */\n\t        this.closed = false;\n\t        this._parent = null;\n\t        this._parents = null;\n\t        this._subscriptions = null;\n\t        if (unsubscribe) {\n\t            this._unsubscribe = unsubscribe;\n\t        }\n\t    }\n\t    /**\n\t     * Disposes the resources held by the subscription. May, for instance, cancel\n\t     * an ongoing Observable execution or cancel any other type of work that\n\t     * started when the Subscription was created.\n\t     * @return {void}\n\t     */\n\t    Subscription.prototype.unsubscribe = function () {\n\t        var hasErrors = false;\n\t        var errors;\n\t        if (this.closed) {\n\t            return;\n\t        }\n\t        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n\t        this.closed = true;\n\t        this._parent = null;\n\t        this._parents = null;\n\t        // null out _subscriptions first so any child subscriptions that attempt\n\t        // to remove themselves from this subscription will noop\n\t        this._subscriptions = null;\n\t        var index = -1;\n\t        var len = _parents ? _parents.length : 0;\n\t        // if this._parent is null, then so is this._parents, and we\n\t        // don't have to remove ourselves from any parent subscriptions.\n\t        while (_parent) {\n\t            _parent.remove(this);\n\t            // if this._parents is null or index >= len,\n\t            // then _parent is set to null, and the loop exits\n\t            _parent = ++index < len && _parents[index] || null;\n\t        }\n\t        if (isFunction_1.isFunction(_unsubscribe)) {\n\t            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n\t            if (trial === errorObject_1.errorObject) {\n\t                hasErrors = true;\n\t                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?\n\t                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);\n\t            }\n\t        }\n\t        if (isArray_1.isArray(_subscriptions)) {\n\t            index = -1;\n\t            len = _subscriptions.length;\n\t            while (++index < len) {\n\t                var sub = _subscriptions[index];\n\t                if (isObject_1.isObject(sub)) {\n\t                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n\t                    if (trial === errorObject_1.errorObject) {\n\t                        hasErrors = true;\n\t                        errors = errors || [];\n\t                        var err = errorObject_1.errorObject.e;\n\t                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n\t                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n\t                        }\n\t                        else {\n\t                            errors.push(err);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (hasErrors) {\n\t            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n\t        }\n\t    };\n\t    /**\n\t     * Adds a tear down to be called during the unsubscribe() of this\n\t     * Subscription.\n\t     *\n\t     * If the tear down being added is a subscription that is already\n\t     * unsubscribed, is the same reference `add` is being called on, or is\n\t     * `Subscription.EMPTY`, it will not be added.\n\t     *\n\t     * If this subscription is already in an `closed` state, the passed\n\t     * tear down logic will be executed immediately.\n\t     *\n\t     * @param {TeardownLogic} teardown The additional logic to execute on\n\t     * teardown.\n\t     * @return {Subscription} Returns the Subscription used or created to be\n\t     * added to the inner subscriptions list. This Subscription can be used with\n\t     * `remove()` to remove the passed teardown logic from the inner subscriptions\n\t     * list.\n\t     */\n\t    Subscription.prototype.add = function (teardown) {\n\t        if (!teardown || (teardown === Subscription.EMPTY)) {\n\t            return Subscription.EMPTY;\n\t        }\n\t        if (teardown === this) {\n\t            return this;\n\t        }\n\t        var subscription = teardown;\n\t        switch (typeof teardown) {\n\t            case 'function':\n\t                subscription = new Subscription(teardown);\n\t            case 'object':\n\t                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n\t                    return subscription;\n\t                }\n\t                else if (this.closed) {\n\t                    subscription.unsubscribe();\n\t                    return subscription;\n\t                }\n\t                else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n\t                    var tmp = subscription;\n\t                    subscription = new Subscription();\n\t                    subscription._subscriptions = [tmp];\n\t                }\n\t                break;\n\t            default:\n\t                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n\t        }\n\t        var subscriptions = this._subscriptions || (this._subscriptions = []);\n\t        subscriptions.push(subscription);\n\t        subscription._addParent(this);\n\t        return subscription;\n\t    };\n\t    /**\n\t     * Removes a Subscription from the internal list of subscriptions that will\n\t     * unsubscribe during the unsubscribe process of this Subscription.\n\t     * @param {Subscription} subscription The subscription to remove.\n\t     * @return {void}\n\t     */\n\t    Subscription.prototype.remove = function (subscription) {\n\t        var subscriptions = this._subscriptions;\n\t        if (subscriptions) {\n\t            var subscriptionIndex = subscriptions.indexOf(subscription);\n\t            if (subscriptionIndex !== -1) {\n\t                subscriptions.splice(subscriptionIndex, 1);\n\t            }\n\t        }\n\t    };\n\t    Subscription.prototype._addParent = function (parent) {\n\t        var _a = this, _parent = _a._parent, _parents = _a._parents;\n\t        if (!_parent || _parent === parent) {\n\t            // If we don't have a parent, or the new parent is the same as the\n\t            // current parent, then set this._parent to the new parent.\n\t            this._parent = parent;\n\t        }\n\t        else if (!_parents) {\n\t            // If there's already one parent, but not multiple, allocate an Array to\n\t            // store the rest of the parent Subscriptions.\n\t            this._parents = [parent];\n\t        }\n\t        else if (_parents.indexOf(parent) === -1) {\n\t            // Only add the new parent to the _parents list if it's not already there.\n\t            _parents.push(parent);\n\t        }\n\t    };\n\t    Subscription.EMPTY = (function (empty) {\n\t        empty.closed = true;\n\t        return empty;\n\t    }(new Subscription()));\n\t    return Subscription;\n\t}());\n\tSubscription.Subscription = Subscription$1;\n\tfunction flattenUnsubscriptionErrors(errors) {\n\t    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);\n\t}\n\t\n\treturn Subscription;\n}\n\nvar Observer = {};\n\nvar hasRequiredObserver;\n\nfunction requireObserver () {\n\tif (hasRequiredObserver) return Observer;\n\thasRequiredObserver = 1;\n\tObserver.empty = {\n\t    closed: true,\n\t    next: function (value) { },\n\t    error: function (err) { throw err; },\n\t    complete: function () { }\n\t};\n\t\n\treturn Observer;\n}\n\nvar rxSubscriber = {};\n\nvar hasRequiredRxSubscriber;\n\nfunction requireRxSubscriber () {\n\tif (hasRequiredRxSubscriber) return rxSubscriber;\n\thasRequiredRxSubscriber = 1;\n\tvar root_1 = requireRoot();\n\tvar Symbol = root_1.root.Symbol;\n\trxSubscriber.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n\t    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n\t\n\treturn rxSubscriber;\n}\n\nvar hasRequiredSubscriber;\n\nfunction requireSubscriber () {\n\tif (hasRequiredSubscriber) return Subscriber;\n\thasRequiredSubscriber = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar isFunction_1 = requireIsFunction();\n\tvar Subscription_1 = requireSubscription();\n\tvar Observer_1 = requireObserver();\n\tvar rxSubscriber_1 = requireRxSubscriber();\n\t/**\n\t * Implements the {@link Observer} interface and extends the\n\t * {@link Subscription} class. While the {@link Observer} is the public API for\n\t * consuming the values of an {@link Observable}, all Observers get converted to\n\t * a Subscriber, in order to provide Subscription-like capabilities such as\n\t * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n\t * implementing operators, but it is rarely used as a public API.\n\t *\n\t * @class Subscriber<T>\n\t */\n\tvar Subscriber$1 = (function (_super) {\n\t    __extends(Subscriber, _super);\n\t    /**\n\t     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n\t     * defined Observer or a `next` callback function.\n\t     * @param {function(e: ?any): void} [error] The `error` callback of an\n\t     * Observer.\n\t     * @param {function(): void} [complete] The `complete` callback of an\n\t     * Observer.\n\t     */\n\t    function Subscriber(destinationOrNext, error, complete) {\n\t        _super.call(this);\n\t        this.syncErrorValue = null;\n\t        this.syncErrorThrown = false;\n\t        this.syncErrorThrowable = false;\n\t        this.isStopped = false;\n\t        switch (arguments.length) {\n\t            case 0:\n\t                this.destination = Observer_1.empty;\n\t                break;\n\t            case 1:\n\t                if (!destinationOrNext) {\n\t                    this.destination = Observer_1.empty;\n\t                    break;\n\t                }\n\t                if (typeof destinationOrNext === 'object') {\n\t                    if (destinationOrNext instanceof Subscriber) {\n\t                        this.destination = destinationOrNext;\n\t                        this.destination.add(this);\n\t                    }\n\t                    else {\n\t                        this.syncErrorThrowable = true;\n\t                        this.destination = new SafeSubscriber(this, destinationOrNext);\n\t                    }\n\t                    break;\n\t                }\n\t            default:\n\t                this.syncErrorThrowable = true;\n\t                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n\t                break;\n\t        }\n\t    }\n\t    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };\n\t    /**\n\t     * A static factory for a Subscriber, given a (potentially partial) definition\n\t     * of an Observer.\n\t     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n\t     * @param {function(e: ?any): void} [error] The `error` callback of an\n\t     * Observer.\n\t     * @param {function(): void} [complete] The `complete` callback of an\n\t     * Observer.\n\t     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n\t     * Observer represented by the given arguments.\n\t     */\n\t    Subscriber.create = function (next, error, complete) {\n\t        var subscriber = new Subscriber(next, error, complete);\n\t        subscriber.syncErrorThrowable = false;\n\t        return subscriber;\n\t    };\n\t    /**\n\t     * The {@link Observer} callback to receive notifications of type `next` from\n\t     * the Observable, with a value. The Observable may call this method 0 or more\n\t     * times.\n\t     * @param {T} [value] The `next` value.\n\t     * @return {void}\n\t     */\n\t    Subscriber.prototype.next = function (value) {\n\t        if (!this.isStopped) {\n\t            this._next(value);\n\t        }\n\t    };\n\t    /**\n\t     * The {@link Observer} callback to receive notifications of type `error` from\n\t     * the Observable, with an attached {@link Error}. Notifies the Observer that\n\t     * the Observable has experienced an error condition.\n\t     * @param {any} [err] The `error` exception.\n\t     * @return {void}\n\t     */\n\t    Subscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            this.isStopped = true;\n\t            this._error(err);\n\t        }\n\t    };\n\t    /**\n\t     * The {@link Observer} callback to receive a valueless notification of type\n\t     * `complete` from the Observable. Notifies the Observer that the Observable\n\t     * has finished sending push-based notifications.\n\t     * @return {void}\n\t     */\n\t    Subscriber.prototype.complete = function () {\n\t        if (!this.isStopped) {\n\t            this.isStopped = true;\n\t            this._complete();\n\t        }\n\t    };\n\t    Subscriber.prototype.unsubscribe = function () {\n\t        if (this.closed) {\n\t            return;\n\t        }\n\t        this.isStopped = true;\n\t        _super.prototype.unsubscribe.call(this);\n\t    };\n\t    Subscriber.prototype._next = function (value) {\n\t        this.destination.next(value);\n\t    };\n\t    Subscriber.prototype._error = function (err) {\n\t        this.destination.error(err);\n\t        this.unsubscribe();\n\t    };\n\t    Subscriber.prototype._complete = function () {\n\t        this.destination.complete();\n\t        this.unsubscribe();\n\t    };\n\t    Subscriber.prototype._unsubscribeAndRecycle = function () {\n\t        var _a = this, _parent = _a._parent, _parents = _a._parents;\n\t        this._parent = null;\n\t        this._parents = null;\n\t        this.unsubscribe();\n\t        this.closed = false;\n\t        this.isStopped = false;\n\t        this._parent = _parent;\n\t        this._parents = _parents;\n\t        return this;\n\t    };\n\t    return Subscriber;\n\t}(Subscription_1.Subscription));\n\tSubscriber.Subscriber = Subscriber$1;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar SafeSubscriber = (function (_super) {\n\t    __extends(SafeSubscriber, _super);\n\t    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n\t        _super.call(this);\n\t        this._parentSubscriber = _parentSubscriber;\n\t        var next;\n\t        var context = this;\n\t        if (isFunction_1.isFunction(observerOrNext)) {\n\t            next = observerOrNext;\n\t        }\n\t        else if (observerOrNext) {\n\t            context = observerOrNext;\n\t            next = observerOrNext.next;\n\t            error = observerOrNext.error;\n\t            complete = observerOrNext.complete;\n\t            if (isFunction_1.isFunction(context.unsubscribe)) {\n\t                this.add(context.unsubscribe.bind(context));\n\t            }\n\t            context.unsubscribe = this.unsubscribe.bind(this);\n\t        }\n\t        this._context = context;\n\t        this._next = next;\n\t        this._error = error;\n\t        this._complete = complete;\n\t    }\n\t    SafeSubscriber.prototype.next = function (value) {\n\t        if (!this.isStopped && this._next) {\n\t            var _parentSubscriber = this._parentSubscriber;\n\t            if (!_parentSubscriber.syncErrorThrowable) {\n\t                this.__tryOrUnsub(this._next, value);\n\t            }\n\t            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n\t                this.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            var _parentSubscriber = this._parentSubscriber;\n\t            if (this._error) {\n\t                if (!_parentSubscriber.syncErrorThrowable) {\n\t                    this.__tryOrUnsub(this._error, err);\n\t                    this.unsubscribe();\n\t                }\n\t                else {\n\t                    this.__tryOrSetError(_parentSubscriber, this._error, err);\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t            else if (!_parentSubscriber.syncErrorThrowable) {\n\t                this.unsubscribe();\n\t                throw err;\n\t            }\n\t            else {\n\t                _parentSubscriber.syncErrorValue = err;\n\t                _parentSubscriber.syncErrorThrown = true;\n\t                this.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.complete = function () {\n\t        if (!this.isStopped) {\n\t            var _parentSubscriber = this._parentSubscriber;\n\t            if (this._complete) {\n\t                if (!_parentSubscriber.syncErrorThrowable) {\n\t                    this.__tryOrUnsub(this._complete);\n\t                    this.unsubscribe();\n\t                }\n\t                else {\n\t                    this.__tryOrSetError(_parentSubscriber, this._complete);\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t            else {\n\t                this.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n\t        try {\n\t            fn.call(this._context, value);\n\t        }\n\t        catch (err) {\n\t            this.unsubscribe();\n\t            throw err;\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n\t        try {\n\t            fn.call(this._context, value);\n\t        }\n\t        catch (err) {\n\t            parent.syncErrorValue = err;\n\t            parent.syncErrorThrown = true;\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t    SafeSubscriber.prototype._unsubscribe = function () {\n\t        var _parentSubscriber = this._parentSubscriber;\n\t        this._context = null;\n\t        this._parentSubscriber = null;\n\t        _parentSubscriber.unsubscribe();\n\t    };\n\t    return SafeSubscriber;\n\t}(Subscriber$1));\n\t\n\treturn Subscriber;\n}\n\nvar hasRequiredToSubscriber;\n\nfunction requireToSubscriber () {\n\tif (hasRequiredToSubscriber) return toSubscriber;\n\thasRequiredToSubscriber = 1;\n\tvar Subscriber_1 = requireSubscriber();\n\tvar rxSubscriber_1 = requireRxSubscriber();\n\tvar Observer_1 = requireObserver();\n\tfunction toSubscriber$1(nextOrObserver, error, complete) {\n\t    if (nextOrObserver) {\n\t        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n\t            return nextOrObserver;\n\t        }\n\t        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {\n\t            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n\t        }\n\t    }\n\t    if (!nextOrObserver && !error && !complete) {\n\t        return new Subscriber_1.Subscriber(Observer_1.empty);\n\t    }\n\t    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n\t}\n\ttoSubscriber.toSubscriber = toSubscriber$1;\n\t\n\treturn toSubscriber;\n}\n\nvar observable = {};\n\nvar hasRequiredObservable$1;\n\nfunction requireObservable$1 () {\n\tif (hasRequiredObservable$1) return observable;\n\thasRequiredObservable$1 = 1;\n\tvar root_1 = requireRoot();\n\tfunction getSymbolObservable(context) {\n\t    var $$observable;\n\t    var Symbol = context.Symbol;\n\t    if (typeof Symbol === 'function') {\n\t        if (Symbol.observable) {\n\t            $$observable = Symbol.observable;\n\t        }\n\t        else {\n\t            $$observable = Symbol('observable');\n\t            Symbol.observable = $$observable;\n\t        }\n\t    }\n\t    else {\n\t        $$observable = '@@observable';\n\t    }\n\t    return $$observable;\n\t}\n\tobservable.getSymbolObservable = getSymbolObservable;\n\tobservable.$$observable = getSymbolObservable(root_1.root);\n\t\n\treturn observable;\n}\n\nvar hasRequiredObservable;\n\nfunction requireObservable () {\n\tif (hasRequiredObservable) return Observable;\n\thasRequiredObservable = 1;\n\tvar root_1 = requireRoot();\n\tvar toSubscriber_1 = requireToSubscriber();\n\tvar observable_1 = requireObservable$1();\n\t/**\n\t * A representation of any set of values over any amount of time. This the most basic building block\n\t * of RxJS.\n\t *\n\t * @class Observable<T>\n\t */\n\tvar Observable$1 = (function () {\n\t    /**\n\t     * @constructor\n\t     * @param {Function} subscribe the function that is  called when the Observable is\n\t     * initially subscribed to. This function is given a Subscriber, to which new values\n\t     * can be `next`ed, or an `error` method can be called to raise an error, or\n\t     * `complete` can be called to notify of a successful completion.\n\t     */\n\t    function Observable(subscribe) {\n\t        this._isScalar = false;\n\t        if (subscribe) {\n\t            this._subscribe = subscribe;\n\t        }\n\t    }\n\t    /**\n\t     * Creates a new Observable, with this Observable as the source, and the passed\n\t     * operator defined as the new observable's operator.\n\t     * @method lift\n\t     * @param {Operator} operator the operator defining the operation to take on the observable\n\t     * @return {Observable} a new observable with the Operator applied\n\t     */\n\t    Observable.prototype.lift = function (operator) {\n\t        var observable = new Observable();\n\t        observable.source = this;\n\t        observable.operator = operator;\n\t        return observable;\n\t    };\n\t    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n\t        var operator = this.operator;\n\t        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n\t        if (operator) {\n\t            operator.call(sink, this.source);\n\t        }\n\t        else {\n\t            sink.add(this._trySubscribe(sink));\n\t        }\n\t        if (sink.syncErrorThrowable) {\n\t            sink.syncErrorThrowable = false;\n\t            if (sink.syncErrorThrown) {\n\t                throw sink.syncErrorValue;\n\t            }\n\t        }\n\t        return sink;\n\t    };\n\t    Observable.prototype._trySubscribe = function (sink) {\n\t        try {\n\t            return this._subscribe(sink);\n\t        }\n\t        catch (err) {\n\t            sink.syncErrorThrown = true;\n\t            sink.syncErrorValue = err;\n\t            sink.error(err);\n\t        }\n\t    };\n\t    /**\n\t     * @method forEach\n\t     * @param {Function} next a handler for each value emitted by the observable\n\t     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n\t     * @return {Promise} a promise that either resolves on observable completion or\n\t     *  rejects with the handled error\n\t     */\n\t    Observable.prototype.forEach = function (next, PromiseCtor) {\n\t        var _this = this;\n\t        if (!PromiseCtor) {\n\t            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n\t                PromiseCtor = root_1.root.Rx.config.Promise;\n\t            }\n\t            else if (root_1.root.Promise) {\n\t                PromiseCtor = root_1.root.Promise;\n\t            }\n\t        }\n\t        if (!PromiseCtor) {\n\t            throw new Error('no Promise impl found');\n\t        }\n\t        return new PromiseCtor(function (resolve, reject) {\n\t            var subscription = _this.subscribe(function (value) {\n\t                if (subscription) {\n\t                    // if there is a subscription, then we can surmise\n\t                    // the next handling is asynchronous. Any errors thrown\n\t                    // need to be rejected explicitly and unsubscribe must be\n\t                    // called manually\n\t                    try {\n\t                        next(value);\n\t                    }\n\t                    catch (err) {\n\t                        reject(err);\n\t                        subscription.unsubscribe();\n\t                    }\n\t                }\n\t                else {\n\t                    // if there is NO subscription, then we're getting a nexted\n\t                    // value synchronously during subscription. We can just call it.\n\t                    // If it errors, Observable's `subscribe` will ensure the\n\t                    // unsubscription logic is called, then synchronously rethrow the error.\n\t                    // After that, Promise will trap the error and send it\n\t                    // down the rejection path.\n\t                    next(value);\n\t                }\n\t            }, reject, resolve);\n\t        });\n\t    };\n\t    Observable.prototype._subscribe = function (subscriber) {\n\t        return this.source.subscribe(subscriber);\n\t    };\n\t    /**\n\t     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n\t     * @method Symbol.observable\n\t     * @return {Observable} this instance of the observable\n\t     */\n\t    Observable.prototype[observable_1.$$observable] = function () {\n\t        return this;\n\t    };\n\t    // HACK: Since TypeScript inherits static properties too, we have to\n\t    // fight against TypeScript here so Subject can have a different static create signature\n\t    /**\n\t     * Creates a new cold Observable by calling the Observable constructor\n\t     * @static true\n\t     * @owner Observable\n\t     * @method create\n\t     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n\t     * @return {Observable} a new cold observable\n\t     */\n\t    Observable.create = function (subscribe) {\n\t        return new Observable(subscribe);\n\t    };\n\t    return Observable;\n\t}());\n\tObservable.Observable = Observable$1;\n\t\n\treturn Observable;\n}\n\nvar queue = {};\n\nvar QueueAction = {};\n\nvar AsyncAction = {};\n\nvar Action = {};\n\nvar hasRequiredAction;\n\nfunction requireAction () {\n\tif (hasRequiredAction) return Action;\n\thasRequiredAction = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscription_1 = requireSubscription();\n\t/**\n\t * A unit of work to be executed in a {@link Scheduler}. An action is typically\n\t * created from within a Scheduler and an RxJS user does not need to concern\n\t * themselves about creating and manipulating an Action.\n\t *\n\t * ```ts\n\t * class Action<T> extends Subscription {\n\t *   new (scheduler: Scheduler, work: (state?: T) => void);\n\t *   schedule(state?: T, delay: number = 0): Subscription;\n\t * }\n\t * ```\n\t *\n\t * @class Action<T>\n\t */\n\tvar Action$1 = (function (_super) {\n\t    __extends(Action, _super);\n\t    function Action(scheduler, work) {\n\t        _super.call(this);\n\t    }\n\t    /**\n\t     * Schedules this action on its parent Scheduler for execution. May be passed\n\t     * some context object, `state`. May happen at some point in the future,\n\t     * according to the `delay` parameter, if specified.\n\t     * @param {T} [state] Some contextual data that the `work` function uses when\n\t     * called by the Scheduler.\n\t     * @param {number} [delay] Time to wait before executing the work, where the\n\t     * time unit is implicit and defined by the Scheduler.\n\t     * @return {void}\n\t     */\n\t    Action.prototype.schedule = function (state, delay) {\n\t        return this;\n\t    };\n\t    return Action;\n\t}(Subscription_1.Subscription));\n\tAction.Action = Action$1;\n\t\n\treturn Action;\n}\n\nvar hasRequiredAsyncAction;\n\nfunction requireAsyncAction () {\n\tif (hasRequiredAsyncAction) return AsyncAction;\n\thasRequiredAsyncAction = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar root_1 = requireRoot();\n\tvar Action_1 = requireAction();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar AsyncAction$1 = (function (_super) {\n\t    __extends(AsyncAction, _super);\n\t    function AsyncAction(scheduler, work) {\n\t        _super.call(this, scheduler, work);\n\t        this.scheduler = scheduler;\n\t        this.work = work;\n\t        this.pending = false;\n\t    }\n\t    AsyncAction.prototype.schedule = function (state, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        if (this.closed) {\n\t            return this;\n\t        }\n\t        // Always replace the current state with the new state.\n\t        this.state = state;\n\t        // Set the pending flag indicating that this action has been scheduled, or\n\t        // has recursively rescheduled itself.\n\t        this.pending = true;\n\t        var id = this.id;\n\t        var scheduler = this.scheduler;\n\t        //\n\t        // Important implementation note:\n\t        //\n\t        // Actions only execute once by default, unless rescheduled from within the\n\t        // scheduled callback. This allows us to implement single and repeat\n\t        // actions via the same code path, without adding API surface area, as well\n\t        // as mimic traditional recursion but across asynchronous boundaries.\n\t        //\n\t        // However, JS runtimes and timers distinguish between intervals achieved by\n\t        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n\t        // serial `setTimeout` calls can be individually delayed, which delays\n\t        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n\t        // guarantee the interval callback will be invoked more precisely to the\n\t        // interval period, regardless of load.\n\t        //\n\t        // Therefore, we use `setInterval` to schedule single and repeat actions.\n\t        // If the action reschedules itself with the same delay, the interval is not\n\t        // canceled. If the action doesn't reschedule, or reschedules with a\n\t        // different delay, the interval will be canceled after scheduled callback\n\t        // execution.\n\t        //\n\t        if (id != null) {\n\t            this.id = this.recycleAsyncId(scheduler, id, delay);\n\t        }\n\t        this.delay = delay;\n\t        // If this action has already an async Id, don't request a new one.\n\t        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\t        return this;\n\t    };\n\t    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n\t    };\n\t    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        // If this action is rescheduled with the same delay time, don't clear the interval id.\n\t        if (delay !== null && this.delay === delay) {\n\t            return id;\n\t        }\n\t        // Otherwise, if the action's delay time is different from the current delay,\n\t        // clear the interval id\n\t        return root_1.root.clearInterval(id) && undefined || undefined;\n\t    };\n\t    /**\n\t     * Immediately executes this action and the `work` it contains.\n\t     * @return {any}\n\t     */\n\t    AsyncAction.prototype.execute = function (state, delay) {\n\t        if (this.closed) {\n\t            return new Error('executing a cancelled action');\n\t        }\n\t        this.pending = false;\n\t        var error = this._execute(state, delay);\n\t        if (error) {\n\t            return error;\n\t        }\n\t        else if (this.pending === false && this.id != null) {\n\t            // Dequeue if the action didn't reschedule itself. Don't call\n\t            // unsubscribe(), because the action could reschedule later.\n\t            // For example:\n\t            // ```\n\t            // scheduler.schedule(function doWork(counter) {\n\t            //   /* ... I'm a busy worker bee ... */\n\t            //   var originalAction = this;\n\t            //   /* wait 100ms before rescheduling the action */\n\t            //   setTimeout(function () {\n\t            //     originalAction.schedule(counter + 1);\n\t            //   }, 100);\n\t            // }, 1000);\n\t            // ```\n\t            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n\t        }\n\t    };\n\t    AsyncAction.prototype._execute = function (state, delay) {\n\t        var errored = false;\n\t        var errorValue = undefined;\n\t        try {\n\t            this.work(state);\n\t        }\n\t        catch (e) {\n\t            errored = true;\n\t            errorValue = !!e && e || new Error(e);\n\t        }\n\t        if (errored) {\n\t            this.unsubscribe();\n\t            return errorValue;\n\t        }\n\t    };\n\t    AsyncAction.prototype._unsubscribe = function () {\n\t        var id = this.id;\n\t        var scheduler = this.scheduler;\n\t        var actions = scheduler.actions;\n\t        var index = actions.indexOf(this);\n\t        this.work = null;\n\t        this.delay = null;\n\t        this.state = null;\n\t        this.pending = false;\n\t        this.scheduler = null;\n\t        if (index !== -1) {\n\t            actions.splice(index, 1);\n\t        }\n\t        if (id != null) {\n\t            this.id = this.recycleAsyncId(scheduler, id, null);\n\t        }\n\t    };\n\t    return AsyncAction;\n\t}(Action_1.Action));\n\tAsyncAction.AsyncAction = AsyncAction$1;\n\t\n\treturn AsyncAction;\n}\n\nvar hasRequiredQueueAction;\n\nfunction requireQueueAction () {\n\tif (hasRequiredQueueAction) return QueueAction;\n\thasRequiredQueueAction = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar AsyncAction_1 = requireAsyncAction();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar QueueAction$1 = (function (_super) {\n\t    __extends(QueueAction, _super);\n\t    function QueueAction(scheduler, work) {\n\t        _super.call(this, scheduler, work);\n\t        this.scheduler = scheduler;\n\t        this.work = work;\n\t    }\n\t    QueueAction.prototype.schedule = function (state, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        if (delay > 0) {\n\t            return _super.prototype.schedule.call(this, state, delay);\n\t        }\n\t        this.delay = delay;\n\t        this.state = state;\n\t        this.scheduler.flush(this);\n\t        return this;\n\t    };\n\t    QueueAction.prototype.execute = function (state, delay) {\n\t        return (delay > 0 || this.closed) ?\n\t            _super.prototype.execute.call(this, state, delay) :\n\t            this._execute(state, delay);\n\t    };\n\t    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        // If delay exists and is greater than 0, or if the delay is null (the\n\t        // action wasn't rescheduled) but was originally scheduled as an async\n\t        // action, then recycle as an async action.\n\t        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n\t            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n\t        }\n\t        // Otherwise flush the scheduler starting with this action.\n\t        return scheduler.flush(this);\n\t    };\n\t    return QueueAction;\n\t}(AsyncAction_1.AsyncAction));\n\tQueueAction.QueueAction = QueueAction$1;\n\t\n\treturn QueueAction;\n}\n\nvar QueueScheduler = {};\n\nvar AsyncScheduler = {};\n\nvar Scheduler = {};\n\nvar hasRequiredScheduler;\n\nfunction requireScheduler () {\n\tif (hasRequiredScheduler) return Scheduler;\n\thasRequiredScheduler = 1;\n\t/**\n\t * An execution context and a data structure to order tasks and schedule their\n\t * execution. Provides a notion of (potentially virtual) time, through the\n\t * `now()` getter method.\n\t *\n\t * Each unit of work in a Scheduler is called an {@link Action}.\n\t *\n\t * ```ts\n\t * class Scheduler {\n\t *   now(): number;\n\t *   schedule(work, delay?, state?): Subscription;\n\t * }\n\t * ```\n\t *\n\t * @class Scheduler\n\t */\n\tvar Scheduler$1 = (function () {\n\t    function Scheduler(SchedulerAction, now) {\n\t        if (now === void 0) { now = Scheduler.now; }\n\t        this.SchedulerAction = SchedulerAction;\n\t        this.now = now;\n\t    }\n\t    /**\n\t     * Schedules a function, `work`, for execution. May happen at some point in\n\t     * the future, according to the `delay` parameter, if specified. May be passed\n\t     * some context object, `state`, which will be passed to the `work` function.\n\t     *\n\t     * The given arguments will be processed an stored as an Action object in a\n\t     * queue of actions.\n\t     *\n\t     * @param {function(state: ?T): ?Subscription} work A function representing a\n\t     * task, or some unit of work to be executed by the Scheduler.\n\t     * @param {number} [delay] Time to wait before executing the work, where the\n\t     * time unit is implicit and defined by the Scheduler itself.\n\t     * @param {T} [state] Some contextual data that the `work` function uses when\n\t     * called by the Scheduler.\n\t     * @return {Subscription} A subscription in order to be able to unsubscribe\n\t     * the scheduled work.\n\t     */\n\t    Scheduler.prototype.schedule = function (work, delay, state) {\n\t        if (delay === void 0) { delay = 0; }\n\t        return new this.SchedulerAction(this, work).schedule(state, delay);\n\t    };\n\t    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n\t    return Scheduler;\n\t}());\n\tScheduler.Scheduler = Scheduler$1;\n\t\n\treturn Scheduler;\n}\n\nvar hasRequiredAsyncScheduler;\n\nfunction requireAsyncScheduler () {\n\tif (hasRequiredAsyncScheduler) return AsyncScheduler;\n\thasRequiredAsyncScheduler = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Scheduler_1 = requireScheduler();\n\tvar AsyncScheduler$1 = (function (_super) {\n\t    __extends(AsyncScheduler, _super);\n\t    function AsyncScheduler() {\n\t        _super.apply(this, arguments);\n\t        this.actions = [];\n\t        /**\n\t         * A flag to indicate whether the Scheduler is currently executing a batch of\n\t         * queued actions.\n\t         * @type {boolean}\n\t         */\n\t        this.active = false;\n\t        /**\n\t         * An internal ID used to track the latest asynchronous task such as those\n\t         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n\t         * others.\n\t         * @type {any}\n\t         */\n\t        this.scheduled = undefined;\n\t    }\n\t    AsyncScheduler.prototype.flush = function (action) {\n\t        var actions = this.actions;\n\t        if (this.active) {\n\t            actions.push(action);\n\t            return;\n\t        }\n\t        var error;\n\t        this.active = true;\n\t        do {\n\t            if (error = action.execute(action.state, action.delay)) {\n\t                break;\n\t            }\n\t        } while (action = actions.shift()); // exhaust the scheduler queue\n\t        this.active = false;\n\t        if (error) {\n\t            while (action = actions.shift()) {\n\t                action.unsubscribe();\n\t            }\n\t            throw error;\n\t        }\n\t    };\n\t    return AsyncScheduler;\n\t}(Scheduler_1.Scheduler));\n\tAsyncScheduler.AsyncScheduler = AsyncScheduler$1;\n\t\n\treturn AsyncScheduler;\n}\n\nvar hasRequiredQueueScheduler;\n\nfunction requireQueueScheduler () {\n\tif (hasRequiredQueueScheduler) return QueueScheduler;\n\thasRequiredQueueScheduler = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar AsyncScheduler_1 = requireAsyncScheduler();\n\tvar QueueScheduler$1 = (function (_super) {\n\t    __extends(QueueScheduler, _super);\n\t    function QueueScheduler() {\n\t        _super.apply(this, arguments);\n\t    }\n\t    return QueueScheduler;\n\t}(AsyncScheduler_1.AsyncScheduler));\n\tQueueScheduler.QueueScheduler = QueueScheduler$1;\n\t\n\treturn QueueScheduler;\n}\n\nvar hasRequiredQueue;\n\nfunction requireQueue () {\n\tif (hasRequiredQueue) return queue;\n\thasRequiredQueue = 1;\n\tvar QueueAction_1 = requireQueueAction();\n\tvar QueueScheduler_1 = requireQueueScheduler();\n\tqueue.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);\n\t\n\treturn queue;\n}\n\nvar defer$1 = {};\n\nvar defer = {};\n\nvar DeferObservable = {};\n\nvar subscribeToResult = {};\n\nvar isPromise = {};\n\nvar hasRequiredIsPromise;\n\nfunction requireIsPromise () {\n\tif (hasRequiredIsPromise) return isPromise;\n\thasRequiredIsPromise = 1;\n\tfunction isPromise$1(value) {\n\t    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n\t}\n\tisPromise.isPromise = isPromise$1;\n\t\n\treturn isPromise;\n}\n\nvar iterator = {};\n\nvar hasRequiredIterator;\n\nfunction requireIterator () {\n\tif (hasRequiredIterator) return iterator;\n\thasRequiredIterator = 1;\n\tvar root_1 = requireRoot();\n\tfunction symbolIteratorPonyfill(root) {\n\t    var Symbol = root.Symbol;\n\t    if (typeof Symbol === 'function') {\n\t        if (!Symbol.iterator) {\n\t            Symbol.iterator = Symbol('iterator polyfill');\n\t        }\n\t        return Symbol.iterator;\n\t    }\n\t    else {\n\t        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n\t        var Set_1 = root.Set;\n\t        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {\n\t            return '@@iterator';\n\t        }\n\t        var Map_1 = root.Map;\n\t        // required for compatability with es6-shim\n\t        if (Map_1) {\n\t            var keys = Object.getOwnPropertyNames(Map_1.prototype);\n\t            for (var i = 0; i < keys.length; ++i) {\n\t                var key = keys[i];\n\t                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n\t                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {\n\t                    return key;\n\t                }\n\t            }\n\t        }\n\t        return '@@iterator';\n\t    }\n\t}\n\titerator.symbolIteratorPonyfill = symbolIteratorPonyfill;\n\titerator.$$iterator = symbolIteratorPonyfill(root_1.root);\n\t\n\treturn iterator;\n}\n\nvar InnerSubscriber = {};\n\nvar hasRequiredInnerSubscriber;\n\nfunction requireInnerSubscriber () {\n\tif (hasRequiredInnerSubscriber) return InnerSubscriber;\n\thasRequiredInnerSubscriber = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar InnerSubscriber$1 = (function (_super) {\n\t    __extends(InnerSubscriber, _super);\n\t    function InnerSubscriber(parent, outerValue, outerIndex) {\n\t        _super.call(this);\n\t        this.parent = parent;\n\t        this.outerValue = outerValue;\n\t        this.outerIndex = outerIndex;\n\t        this.index = 0;\n\t    }\n\t    InnerSubscriber.prototype._next = function (value) {\n\t        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n\t    };\n\t    InnerSubscriber.prototype._error = function (error) {\n\t        this.parent.notifyError(error, this);\n\t        this.unsubscribe();\n\t    };\n\t    InnerSubscriber.prototype._complete = function () {\n\t        this.parent.notifyComplete(this);\n\t        this.unsubscribe();\n\t    };\n\t    return InnerSubscriber;\n\t}(Subscriber_1.Subscriber));\n\tInnerSubscriber.InnerSubscriber = InnerSubscriber$1;\n\t\n\treturn InnerSubscriber;\n}\n\nvar hasRequiredSubscribeToResult;\n\nfunction requireSubscribeToResult () {\n\tif (hasRequiredSubscribeToResult) return subscribeToResult;\n\thasRequiredSubscribeToResult = 1;\n\tvar root_1 = requireRoot();\n\tvar isArray_1 = requireIsArray();\n\tvar isPromise_1 = requireIsPromise();\n\tvar isObject_1 = requireIsObject();\n\tvar Observable_1 = requireObservable();\n\tvar iterator_1 = requireIterator();\n\tvar InnerSubscriber_1 = requireInnerSubscriber();\n\tvar observable_1 = requireObservable$1();\n\tfunction subscribeToResult$1(outerSubscriber, result, outerValue, outerIndex) {\n\t    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\t    if (destination.closed) {\n\t        return null;\n\t    }\n\t    if (result instanceof Observable_1.Observable) {\n\t        if (result._isScalar) {\n\t            destination.next(result.value);\n\t            destination.complete();\n\t            return null;\n\t        }\n\t        else {\n\t            return result.subscribe(destination);\n\t        }\n\t    }\n\t    else if (isArray_1.isArray(result)) {\n\t        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n\t            destination.next(result[i]);\n\t        }\n\t        if (!destination.closed) {\n\t            destination.complete();\n\t        }\n\t    }\n\t    else if (isPromise_1.isPromise(result)) {\n\t        result.then(function (value) {\n\t            if (!destination.closed) {\n\t                destination.next(value);\n\t                destination.complete();\n\t            }\n\t        }, function (err) { return destination.error(err); })\n\t            .then(null, function (err) {\n\t            // Escaping the Promise trap: globally throw unhandled errors\n\t            root_1.root.setTimeout(function () { throw err; });\n\t        });\n\t        return destination;\n\t    }\n\t    else if (result && typeof result[iterator_1.$$iterator] === 'function') {\n\t        var iterator = result[iterator_1.$$iterator]();\n\t        do {\n\t            var item = iterator.next();\n\t            if (item.done) {\n\t                destination.complete();\n\t                break;\n\t            }\n\t            destination.next(item.value);\n\t            if (destination.closed) {\n\t                break;\n\t            }\n\t        } while (true);\n\t    }\n\t    else if (result && typeof result[observable_1.$$observable] === 'function') {\n\t        var obs = result[observable_1.$$observable]();\n\t        if (typeof obs.subscribe !== 'function') {\n\t            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n\t        }\n\t        else {\n\t            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n\t        }\n\t    }\n\t    else {\n\t        var value = isObject_1.isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n\t        var msg = (\"You provided \" + value + \" where a stream was expected.\")\n\t            + ' You can provide an Observable, Promise, Array, or Iterable.';\n\t        destination.error(new TypeError(msg));\n\t    }\n\t    return null;\n\t}\n\tsubscribeToResult.subscribeToResult = subscribeToResult$1;\n\t\n\treturn subscribeToResult;\n}\n\nvar OuterSubscriber = {};\n\nvar hasRequiredOuterSubscriber;\n\nfunction requireOuterSubscriber () {\n\tif (hasRequiredOuterSubscriber) return OuterSubscriber;\n\thasRequiredOuterSubscriber = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar OuterSubscriber$1 = (function (_super) {\n\t    __extends(OuterSubscriber, _super);\n\t    function OuterSubscriber() {\n\t        _super.apply(this, arguments);\n\t    }\n\t    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n\t        this.destination.next(innerValue);\n\t    };\n\t    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n\t        this.destination.error(error);\n\t    };\n\t    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        this.destination.complete();\n\t    };\n\t    return OuterSubscriber;\n\t}(Subscriber_1.Subscriber));\n\tOuterSubscriber.OuterSubscriber = OuterSubscriber$1;\n\t\n\treturn OuterSubscriber;\n}\n\nvar hasRequiredDeferObservable;\n\nfunction requireDeferObservable () {\n\tif (hasRequiredDeferObservable) return DeferObservable;\n\thasRequiredDeferObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = requireObservable();\n\tvar subscribeToResult_1 = requireSubscribeToResult();\n\tvar OuterSubscriber_1 = requireOuterSubscriber();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar DeferObservable$1 = (function (_super) {\n\t    __extends(DeferObservable, _super);\n\t    function DeferObservable(observableFactory) {\n\t        _super.call(this);\n\t        this.observableFactory = observableFactory;\n\t    }\n\t    /**\n\t     * Creates an Observable that, on subscribe, calls an Observable factory to\n\t     * make an Observable for each new Observer.\n\t     *\n\t     * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n\t     * is subscribed.\n\t     * </span>\n\t     *\n\t     * <img src=\"./img/defer.png\" width=\"100%\">\n\t     *\n\t     * `defer` allows you to create the Observable only when the Observer\n\t     * subscribes, and create a fresh Observable for each Observer. It waits until\n\t     * an Observer subscribes to it, and then it generates an Observable,\n\t     * typically with an Observable factory function. It does this afresh for each\n\t     * subscriber, so although each subscriber may think it is subscribing to the\n\t     * same Observable, in fact each subscriber gets its own individual\n\t     * Observable.\n\t     *\n\t     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>\n\t     * var clicksOrInterval = Rx.Observable.defer(function () {\n\t     *   if (Math.random() > 0.5) {\n\t     *     return Rx.Observable.fromEvent(document, 'click');\n\t     *   } else {\n\t     *     return Rx.Observable.interval(1000);\n\t     *   }\n\t     * });\n\t     * clicksOrInterval.subscribe(x => console.log(x));\n\t     *\n\t     * // Results in the following behavior:\n\t     * // If the result of Math.random() is greater than 0.5 it will listen\n\t     * // for clicks anywhere on the \"document\"; when document is clicked it\n\t     * // will log a MouseEvent object to the console. If the result is less\n\t     * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n\t     *\n\t     * @see {@link create}\n\t     *\n\t     * @param {function(): Observable|Promise} observableFactory The Observable\n\t     * factory function to invoke for each Observer that subscribes to the output\n\t     * Observable. May also return a Promise, which will be converted on the fly\n\t     * to an Observable.\n\t     * @return {Observable} An Observable whose Observers' subscriptions trigger\n\t     * an invocation of the given Observable factory function.\n\t     * @static true\n\t     * @name defer\n\t     * @owner Observable\n\t     */\n\t    DeferObservable.create = function (observableFactory) {\n\t        return new DeferObservable(observableFactory);\n\t    };\n\t    DeferObservable.prototype._subscribe = function (subscriber) {\n\t        return new DeferSubscriber(subscriber, this.observableFactory);\n\t    };\n\t    return DeferObservable;\n\t}(Observable_1.Observable));\n\tDeferObservable.DeferObservable = DeferObservable$1;\n\tvar DeferSubscriber = (function (_super) {\n\t    __extends(DeferSubscriber, _super);\n\t    function DeferSubscriber(destination, factory) {\n\t        _super.call(this, destination);\n\t        this.factory = factory;\n\t        this.tryDefer();\n\t    }\n\t    DeferSubscriber.prototype.tryDefer = function () {\n\t        try {\n\t            this._callFactory();\n\t        }\n\t        catch (err) {\n\t            this._error(err);\n\t        }\n\t    };\n\t    DeferSubscriber.prototype._callFactory = function () {\n\t        var result = this.factory();\n\t        if (result) {\n\t            this.add(subscribeToResult_1.subscribeToResult(this, result));\n\t        }\n\t    };\n\t    return DeferSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\t\n\treturn DeferObservable;\n}\n\nvar hasRequiredDefer$1;\n\nfunction requireDefer$1 () {\n\tif (hasRequiredDefer$1) return defer;\n\thasRequiredDefer$1 = 1;\n\tvar DeferObservable_1 = requireDeferObservable();\n\tdefer.defer = DeferObservable_1.DeferObservable.create;\n\t\n\treturn defer;\n}\n\nvar hasRequiredDefer;\n\nfunction requireDefer () {\n\tif (hasRequiredDefer) return defer$1;\n\thasRequiredDefer = 1;\n\tvar Observable_1 = requireObservable();\n\tvar defer_1 = requireDefer$1();\n\tObservable_1.Observable.defer = defer_1.defer;\n\t\n\treturn defer$1;\n}\n\nvar of$1 = {};\n\nvar of = {};\n\nvar ArrayObservable = {};\n\nvar ScalarObservable = {};\n\nvar hasRequiredScalarObservable;\n\nfunction requireScalarObservable () {\n\tif (hasRequiredScalarObservable) return ScalarObservable;\n\thasRequiredScalarObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = requireObservable();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar ScalarObservable$1 = (function (_super) {\n\t    __extends(ScalarObservable, _super);\n\t    function ScalarObservable(value, scheduler) {\n\t        _super.call(this);\n\t        this.value = value;\n\t        this.scheduler = scheduler;\n\t        this._isScalar = true;\n\t        if (scheduler) {\n\t            this._isScalar = false;\n\t        }\n\t    }\n\t    ScalarObservable.create = function (value, scheduler) {\n\t        return new ScalarObservable(value, scheduler);\n\t    };\n\t    ScalarObservable.dispatch = function (state) {\n\t        var done = state.done, value = state.value, subscriber = state.subscriber;\n\t        if (done) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(value);\n\t        if (subscriber.closed) {\n\t            return;\n\t        }\n\t        state.done = true;\n\t        this.schedule(state);\n\t    };\n\t    ScalarObservable.prototype._subscribe = function (subscriber) {\n\t        var value = this.value;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(ScalarObservable.dispatch, 0, {\n\t                done: false, value: value, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            subscriber.next(value);\n\t            if (!subscriber.closed) {\n\t                subscriber.complete();\n\t            }\n\t        }\n\t    };\n\t    return ScalarObservable;\n\t}(Observable_1.Observable));\n\tScalarObservable.ScalarObservable = ScalarObservable$1;\n\t\n\treturn ScalarObservable;\n}\n\nvar EmptyObservable = {};\n\nvar hasRequiredEmptyObservable;\n\nfunction requireEmptyObservable () {\n\tif (hasRequiredEmptyObservable) return EmptyObservable;\n\thasRequiredEmptyObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = requireObservable();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar EmptyObservable$1 = (function (_super) {\n\t    __extends(EmptyObservable, _super);\n\t    function EmptyObservable(scheduler) {\n\t        _super.call(this);\n\t        this.scheduler = scheduler;\n\t    }\n\t    /**\n\t     * Creates an Observable that emits no items to the Observer and immediately\n\t     * emits a complete notification.\n\t     *\n\t     * <span class=\"informal\">Just emits 'complete', and nothing else.\n\t     * </span>\n\t     *\n\t     * <img src=\"./img/empty.png\" width=\"100%\">\n\t     *\n\t     * This static operator is useful for creating a simple Observable that only\n\t     * emits the complete notification. It can be used for composing with other\n\t     * Observables, such as in a {@link mergeMap}.\n\t     *\n\t     * @example <caption>Emit the number 7, then complete.</caption>\n\t     * var result = Rx.Observable.empty().startWith(7);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n\t     * var interval = Rx.Observable.interval(1000);\n\t     * var result = interval.mergeMap(x =>\n\t     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n\t     * );\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * // Results in the following to the console:\n\t     * // x is equal to the count on the interval eg(0,1,2,3,...)\n\t     * // x will occur every 1000ms\n\t     * // if x % 2 is equal to 1 print abc\n\t     * // if x % 2 is not equal to 1 nothing will be output\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link never}\n\t     * @see {@link of}\n\t     * @see {@link throw}\n\t     *\n\t     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n\t     * the emission of the complete notification.\n\t     * @return {Observable} An \"empty\" Observable: emits only the complete\n\t     * notification.\n\t     * @static true\n\t     * @name empty\n\t     * @owner Observable\n\t     */\n\t    EmptyObservable.create = function (scheduler) {\n\t        return new EmptyObservable(scheduler);\n\t    };\n\t    EmptyObservable.dispatch = function (arg) {\n\t        var subscriber = arg.subscriber;\n\t        subscriber.complete();\n\t    };\n\t    EmptyObservable.prototype._subscribe = function (subscriber) {\n\t        var scheduler = this.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n\t        }\n\t        else {\n\t            subscriber.complete();\n\t        }\n\t    };\n\t    return EmptyObservable;\n\t}(Observable_1.Observable));\n\tEmptyObservable.EmptyObservable = EmptyObservable$1;\n\t\n\treturn EmptyObservable;\n}\n\nvar isScheduler = {};\n\nvar hasRequiredIsScheduler;\n\nfunction requireIsScheduler () {\n\tif (hasRequiredIsScheduler) return isScheduler;\n\thasRequiredIsScheduler = 1;\n\tfunction isScheduler$1(value) {\n\t    return value && typeof value.schedule === 'function';\n\t}\n\tisScheduler.isScheduler = isScheduler$1;\n\t\n\treturn isScheduler;\n}\n\nvar hasRequiredArrayObservable;\n\nfunction requireArrayObservable () {\n\tif (hasRequiredArrayObservable) return ArrayObservable;\n\thasRequiredArrayObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = requireObservable();\n\tvar ScalarObservable_1 = requireScalarObservable();\n\tvar EmptyObservable_1 = requireEmptyObservable();\n\tvar isScheduler_1 = requireIsScheduler();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar ArrayObservable$1 = (function (_super) {\n\t    __extends(ArrayObservable, _super);\n\t    function ArrayObservable(array, scheduler) {\n\t        _super.call(this);\n\t        this.array = array;\n\t        this.scheduler = scheduler;\n\t        if (!scheduler && array.length === 1) {\n\t            this._isScalar = true;\n\t            this.value = array[0];\n\t        }\n\t    }\n\t    ArrayObservable.create = function (array, scheduler) {\n\t        return new ArrayObservable(array, scheduler);\n\t    };\n\t    /**\n\t     * Creates an Observable that emits some values you specify as arguments,\n\t     * immediately one after the other, and then emits a complete notification.\n\t     *\n\t     * <span class=\"informal\">Emits the arguments you provide, then completes.\n\t     * </span>\n\t     *\n\t     * <img src=\"./img/of.png\" width=\"100%\">\n\t     *\n\t     * This static operator is useful for creating a simple Observable that only\n\t     * emits the arguments given, and the complete notification thereafter. It can\n\t     * be used for composing with other Observables, such as with {@link concat}.\n\t     * By default, it uses a `null` IScheduler, which means the `next`\n\t     * notifications are sent synchronously, although with a different IScheduler\n\t     * it is possible to determine when those notifications will be delivered.\n\t     *\n\t     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n\t     * var numbers = Rx.Observable.of(10, 20, 30);\n\t     * var letters = Rx.Observable.of('a', 'b', 'c');\n\t     * var interval = Rx.Observable.interval(1000);\n\t     * var result = numbers.concat(letters).concat(interval);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link empty}\n\t     * @see {@link never}\n\t     * @see {@link throw}\n\t     *\n\t     * @param {...T} values Arguments that represent `next` values to be emitted.\n\t     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n\t     * the emissions of the `next` notifications.\n\t     * @return {Observable<T>} An Observable that emits each given input value.\n\t     * @static true\n\t     * @name of\n\t     * @owner Observable\n\t     */\n\t    ArrayObservable.of = function () {\n\t        var array = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            array[_i - 0] = arguments[_i];\n\t        }\n\t        var scheduler = array[array.length - 1];\n\t        if (isScheduler_1.isScheduler(scheduler)) {\n\t            array.pop();\n\t        }\n\t        else {\n\t            scheduler = null;\n\t        }\n\t        var len = array.length;\n\t        if (len > 1) {\n\t            return new ArrayObservable(array, scheduler);\n\t        }\n\t        else if (len === 1) {\n\t            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n\t        }\n\t        else {\n\t            return new EmptyObservable_1.EmptyObservable(scheduler);\n\t        }\n\t    };\n\t    ArrayObservable.dispatch = function (state) {\n\t        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\n\t        if (index >= count) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(array[index]);\n\t        if (subscriber.closed) {\n\t            return;\n\t        }\n\t        state.index = index + 1;\n\t        this.schedule(state);\n\t    };\n\t    ArrayObservable.prototype._subscribe = function (subscriber) {\n\t        var index = 0;\n\t        var array = this.array;\n\t        var count = array.length;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(ArrayObservable.dispatch, 0, {\n\t                array: array, index: index, count: count, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            for (var i = 0; i < count && !subscriber.closed; i++) {\n\t                subscriber.next(array[i]);\n\t            }\n\t            subscriber.complete();\n\t        }\n\t    };\n\t    return ArrayObservable;\n\t}(Observable_1.Observable));\n\tArrayObservable.ArrayObservable = ArrayObservable$1;\n\t\n\treturn ArrayObservable;\n}\n\nvar hasRequiredOf$1;\n\nfunction requireOf$1 () {\n\tif (hasRequiredOf$1) return of;\n\thasRequiredOf$1 = 1;\n\tvar ArrayObservable_1 = requireArrayObservable();\n\tof.of = ArrayObservable_1.ArrayObservable.of;\n\t\n\treturn of;\n}\n\nvar hasRequiredOf;\n\nfunction requireOf () {\n\tif (hasRequiredOf) return of$1;\n\thasRequiredOf = 1;\n\tvar Observable_1 = requireObservable();\n\tvar of_1 = requireOf$1();\n\tObservable_1.Observable.of = of_1.of;\n\t\n\treturn of$1;\n}\n\nvar from$1 = {};\n\nvar from = {};\n\nvar FromObservable = {};\n\nvar PromiseObservable = {};\n\nvar hasRequiredPromiseObservable;\n\nfunction requirePromiseObservable () {\n\tif (hasRequiredPromiseObservable) return PromiseObservable;\n\thasRequiredPromiseObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar root_1 = requireRoot();\n\tvar Observable_1 = requireObservable();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar PromiseObservable$1 = (function (_super) {\n\t    __extends(PromiseObservable, _super);\n\t    function PromiseObservable(promise, scheduler) {\n\t        _super.call(this);\n\t        this.promise = promise;\n\t        this.scheduler = scheduler;\n\t    }\n\t    /**\n\t     * Converts a Promise to an Observable.\n\t     *\n\t     * <span class=\"informal\">Returns an Observable that just emits the Promise's\n\t     * resolved value, then completes.</span>\n\t     *\n\t     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n\t     * Observable. If the Promise resolves with a value, the output Observable\n\t     * emits that resolved value as a `next`, and then completes. If the Promise\n\t     * is rejected, then the output Observable emits the corresponding Error.\n\t     *\n\t     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n\t     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n\t     * result.subscribe(x => console.log(x), e => console.error(e));\n\t     *\n\t     * @see {@link bindCallback}\n\t     * @see {@link from}\n\t     *\n\t     * @param {Promise<T>} promise The promise to be converted.\n\t     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n\t     * the delivery of the resolved value (or the rejection).\n\t     * @return {Observable<T>} An Observable which wraps the Promise.\n\t     * @static true\n\t     * @name fromPromise\n\t     * @owner Observable\n\t     */\n\t    PromiseObservable.create = function (promise, scheduler) {\n\t        return new PromiseObservable(promise, scheduler);\n\t    };\n\t    PromiseObservable.prototype._subscribe = function (subscriber) {\n\t        var _this = this;\n\t        var promise = this.promise;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler == null) {\n\t            if (this._isScalar) {\n\t                if (!subscriber.closed) {\n\t                    subscriber.next(this.value);\n\t                    subscriber.complete();\n\t                }\n\t            }\n\t            else {\n\t                promise.then(function (value) {\n\t                    _this.value = value;\n\t                    _this._isScalar = true;\n\t                    if (!subscriber.closed) {\n\t                        subscriber.next(value);\n\t                        subscriber.complete();\n\t                    }\n\t                }, function (err) {\n\t                    if (!subscriber.closed) {\n\t                        subscriber.error(err);\n\t                    }\n\t                })\n\t                    .then(null, function (err) {\n\t                    // escape the promise trap, throw unhandled errors\n\t                    root_1.root.setTimeout(function () { throw err; });\n\t                });\n\t            }\n\t        }\n\t        else {\n\t            if (this._isScalar) {\n\t                if (!subscriber.closed) {\n\t                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });\n\t                }\n\t            }\n\t            else {\n\t                promise.then(function (value) {\n\t                    _this.value = value;\n\t                    _this._isScalar = true;\n\t                    if (!subscriber.closed) {\n\t                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));\n\t                    }\n\t                }, function (err) {\n\t                    if (!subscriber.closed) {\n\t                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));\n\t                    }\n\t                })\n\t                    .then(null, function (err) {\n\t                    // escape the promise trap, throw unhandled errors\n\t                    root_1.root.setTimeout(function () { throw err; });\n\t                });\n\t            }\n\t        }\n\t    };\n\t    return PromiseObservable;\n\t}(Observable_1.Observable));\n\tPromiseObservable.PromiseObservable = PromiseObservable$1;\n\tfunction dispatchNext(arg) {\n\t    var value = arg.value, subscriber = arg.subscriber;\n\t    if (!subscriber.closed) {\n\t        subscriber.next(value);\n\t        subscriber.complete();\n\t    }\n\t}\n\tfunction dispatchError(arg) {\n\t    var err = arg.err, subscriber = arg.subscriber;\n\t    if (!subscriber.closed) {\n\t        subscriber.error(err);\n\t    }\n\t}\n\t\n\treturn PromiseObservable;\n}\n\nvar IteratorObservable = {};\n\nvar hasRequiredIteratorObservable;\n\nfunction requireIteratorObservable () {\n\tif (hasRequiredIteratorObservable) return IteratorObservable;\n\thasRequiredIteratorObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar root_1 = requireRoot();\n\tvar Observable_1 = requireObservable();\n\tvar iterator_1 = requireIterator();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar IteratorObservable$1 = (function (_super) {\n\t    __extends(IteratorObservable, _super);\n\t    function IteratorObservable(iterator, scheduler) {\n\t        _super.call(this);\n\t        this.scheduler = scheduler;\n\t        if (iterator == null) {\n\t            throw new Error('iterator cannot be null.');\n\t        }\n\t        this.iterator = getIterator(iterator);\n\t    }\n\t    IteratorObservable.create = function (iterator, scheduler) {\n\t        return new IteratorObservable(iterator, scheduler);\n\t    };\n\t    IteratorObservable.dispatch = function (state) {\n\t        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n\t        if (hasError) {\n\t            subscriber.error(state.error);\n\t            return;\n\t        }\n\t        var result = iterator.next();\n\t        if (result.done) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(result.value);\n\t        state.index = index + 1;\n\t        if (subscriber.closed) {\n\t            if (typeof iterator.return === 'function') {\n\t                iterator.return();\n\t            }\n\t            return;\n\t        }\n\t        this.schedule(state);\n\t    };\n\t    IteratorObservable.prototype._subscribe = function (subscriber) {\n\t        var index = 0;\n\t        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(IteratorObservable.dispatch, 0, {\n\t                index: index, iterator: iterator, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            do {\n\t                var result = iterator.next();\n\t                if (result.done) {\n\t                    subscriber.complete();\n\t                    break;\n\t                }\n\t                else {\n\t                    subscriber.next(result.value);\n\t                }\n\t                if (subscriber.closed) {\n\t                    if (typeof iterator.return === 'function') {\n\t                        iterator.return();\n\t                    }\n\t                    break;\n\t                }\n\t            } while (true);\n\t        }\n\t    };\n\t    return IteratorObservable;\n\t}(Observable_1.Observable));\n\tIteratorObservable.IteratorObservable = IteratorObservable$1;\n\tvar StringIterator = (function () {\n\t    function StringIterator(str, idx, len) {\n\t        if (idx === void 0) { idx = 0; }\n\t        if (len === void 0) { len = str.length; }\n\t        this.str = str;\n\t        this.idx = idx;\n\t        this.len = len;\n\t    }\n\t    StringIterator.prototype[iterator_1.$$iterator] = function () { return (this); };\n\t    StringIterator.prototype.next = function () {\n\t        return this.idx < this.len ? {\n\t            done: false,\n\t            value: this.str.charAt(this.idx++)\n\t        } : {\n\t            done: true,\n\t            value: undefined\n\t        };\n\t    };\n\t    return StringIterator;\n\t}());\n\tvar ArrayIterator = (function () {\n\t    function ArrayIterator(arr, idx, len) {\n\t        if (idx === void 0) { idx = 0; }\n\t        if (len === void 0) { len = toLength(arr); }\n\t        this.arr = arr;\n\t        this.idx = idx;\n\t        this.len = len;\n\t    }\n\t    ArrayIterator.prototype[iterator_1.$$iterator] = function () { return this; };\n\t    ArrayIterator.prototype.next = function () {\n\t        return this.idx < this.len ? {\n\t            done: false,\n\t            value: this.arr[this.idx++]\n\t        } : {\n\t            done: true,\n\t            value: undefined\n\t        };\n\t    };\n\t    return ArrayIterator;\n\t}());\n\tfunction getIterator(obj) {\n\t    var i = obj[iterator_1.$$iterator];\n\t    if (!i && typeof obj === 'string') {\n\t        return new StringIterator(obj);\n\t    }\n\t    if (!i && obj.length !== undefined) {\n\t        return new ArrayIterator(obj);\n\t    }\n\t    if (!i) {\n\t        throw new TypeError('object is not iterable');\n\t    }\n\t    return obj[iterator_1.$$iterator]();\n\t}\n\tvar maxSafeInteger = Math.pow(2, 53) - 1;\n\tfunction toLength(o) {\n\t    var len = +o.length;\n\t    if (isNaN(len)) {\n\t        return 0;\n\t    }\n\t    if (len === 0 || !numberIsFinite(len)) {\n\t        return len;\n\t    }\n\t    len = sign(len) * Math.floor(Math.abs(len));\n\t    if (len <= 0) {\n\t        return 0;\n\t    }\n\t    if (len > maxSafeInteger) {\n\t        return maxSafeInteger;\n\t    }\n\t    return len;\n\t}\n\tfunction numberIsFinite(value) {\n\t    return typeof value === 'number' && root_1.root.isFinite(value);\n\t}\n\tfunction sign(value) {\n\t    var valueAsNumber = +value;\n\t    if (valueAsNumber === 0) {\n\t        return valueAsNumber;\n\t    }\n\t    if (isNaN(valueAsNumber)) {\n\t        return valueAsNumber;\n\t    }\n\t    return valueAsNumber < 0 ? -1 : 1;\n\t}\n\t\n\treturn IteratorObservable;\n}\n\nvar ArrayLikeObservable = {};\n\nvar hasRequiredArrayLikeObservable;\n\nfunction requireArrayLikeObservable () {\n\tif (hasRequiredArrayLikeObservable) return ArrayLikeObservable;\n\thasRequiredArrayLikeObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = requireObservable();\n\tvar ScalarObservable_1 = requireScalarObservable();\n\tvar EmptyObservable_1 = requireEmptyObservable();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar ArrayLikeObservable$1 = (function (_super) {\n\t    __extends(ArrayLikeObservable, _super);\n\t    function ArrayLikeObservable(arrayLike, scheduler) {\n\t        _super.call(this);\n\t        this.arrayLike = arrayLike;\n\t        this.scheduler = scheduler;\n\t        if (!scheduler && arrayLike.length === 1) {\n\t            this._isScalar = true;\n\t            this.value = arrayLike[0];\n\t        }\n\t    }\n\t    ArrayLikeObservable.create = function (arrayLike, scheduler) {\n\t        var length = arrayLike.length;\n\t        if (length === 0) {\n\t            return new EmptyObservable_1.EmptyObservable();\n\t        }\n\t        else if (length === 1) {\n\t            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n\t        }\n\t        else {\n\t            return new ArrayLikeObservable(arrayLike, scheduler);\n\t        }\n\t    };\n\t    ArrayLikeObservable.dispatch = function (state) {\n\t        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n\t        if (subscriber.closed) {\n\t            return;\n\t        }\n\t        if (index >= length) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(arrayLike[index]);\n\t        state.index = index + 1;\n\t        this.schedule(state);\n\t    };\n\t    ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n\t        var index = 0;\n\t        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n\t        var length = arrayLike.length;\n\t        if (scheduler) {\n\t            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n\t                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            for (var i = 0; i < length && !subscriber.closed; i++) {\n\t                subscriber.next(arrayLike[i]);\n\t            }\n\t            subscriber.complete();\n\t        }\n\t    };\n\t    return ArrayLikeObservable;\n\t}(Observable_1.Observable));\n\tArrayLikeObservable.ArrayLikeObservable = ArrayLikeObservable$1;\n\t\n\treturn ArrayLikeObservable;\n}\n\nvar observeOn = {};\n\nvar Notification = {};\n\nvar hasRequiredNotification;\n\nfunction requireNotification () {\n\tif (hasRequiredNotification) return Notification;\n\thasRequiredNotification = 1;\n\tvar Observable_1 = requireObservable();\n\t/**\n\t * Represents a push-based event or value that an {@link Observable} can emit.\n\t * This class is particularly useful for operators that manage notifications,\n\t * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n\t * others. Besides wrapping the actual delivered value, it also annotates it\n\t * with metadata of, for instance, what type of push message it is (`next`,\n\t * `error`, or `complete`).\n\t *\n\t * @see {@link materialize}\n\t * @see {@link dematerialize}\n\t * @see {@link observeOn}\n\t *\n\t * @class Notification<T>\n\t */\n\tvar Notification$1 = (function () {\n\t    function Notification(kind, value, error) {\n\t        this.kind = kind;\n\t        this.value = value;\n\t        this.error = error;\n\t        this.hasValue = kind === 'N';\n\t    }\n\t    /**\n\t     * Delivers to the given `observer` the value wrapped by this Notification.\n\t     * @param {Observer} observer\n\t     * @return\n\t     */\n\t    Notification.prototype.observe = function (observer) {\n\t        switch (this.kind) {\n\t            case 'N':\n\t                return observer.next && observer.next(this.value);\n\t            case 'E':\n\t                return observer.error && observer.error(this.error);\n\t            case 'C':\n\t                return observer.complete && observer.complete();\n\t        }\n\t    };\n\t    /**\n\t     * Given some {@link Observer} callbacks, deliver the value represented by the\n\t     * current Notification to the correctly corresponding callback.\n\t     * @param {function(value: T): void} next An Observer `next` callback.\n\t     * @param {function(err: any): void} [error] An Observer `error` callback.\n\t     * @param {function(): void} [complete] An Observer `complete` callback.\n\t     * @return {any}\n\t     */\n\t    Notification.prototype.do = function (next, error, complete) {\n\t        var kind = this.kind;\n\t        switch (kind) {\n\t            case 'N':\n\t                return next && next(this.value);\n\t            case 'E':\n\t                return error && error(this.error);\n\t            case 'C':\n\t                return complete && complete();\n\t        }\n\t    };\n\t    /**\n\t     * Takes an Observer or its individual callback functions, and calls `observe`\n\t     * or `do` methods accordingly.\n\t     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n\t     * the `next` callback.\n\t     * @param {function(err: any): void} [error] An Observer `error` callback.\n\t     * @param {function(): void} [complete] An Observer `complete` callback.\n\t     * @return {any}\n\t     */\n\t    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n\t        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n\t            return this.observe(nextOrObserver);\n\t        }\n\t        else {\n\t            return this.do(nextOrObserver, error, complete);\n\t        }\n\t    };\n\t    /**\n\t     * Returns a simple Observable that just delivers the notification represented\n\t     * by this Notification instance.\n\t     * @return {any}\n\t     */\n\t    Notification.prototype.toObservable = function () {\n\t        var kind = this.kind;\n\t        switch (kind) {\n\t            case 'N':\n\t                return Observable_1.Observable.of(this.value);\n\t            case 'E':\n\t                return Observable_1.Observable.throw(this.error);\n\t            case 'C':\n\t                return Observable_1.Observable.empty();\n\t        }\n\t        throw new Error('unexpected notification kind value');\n\t    };\n\t    /**\n\t     * A shortcut to create a Notification instance of the type `next` from a\n\t     * given value.\n\t     * @param {T} value The `next` value.\n\t     * @return {Notification<T>} The \"next\" Notification representing the\n\t     * argument.\n\t     */\n\t    Notification.createNext = function (value) {\n\t        if (typeof value !== 'undefined') {\n\t            return new Notification('N', value);\n\t        }\n\t        return this.undefinedValueNotification;\n\t    };\n\t    /**\n\t     * A shortcut to create a Notification instance of the type `error` from a\n\t     * given error.\n\t     * @param {any} [err] The `error` error.\n\t     * @return {Notification<T>} The \"error\" Notification representing the\n\t     * argument.\n\t     */\n\t    Notification.createError = function (err) {\n\t        return new Notification('E', undefined, err);\n\t    };\n\t    /**\n\t     * A shortcut to create a Notification instance of the type `complete`.\n\t     * @return {Notification<any>} The valueless \"complete\" Notification.\n\t     */\n\t    Notification.createComplete = function () {\n\t        return this.completeNotification;\n\t    };\n\t    Notification.completeNotification = new Notification('C');\n\t    Notification.undefinedValueNotification = new Notification('N', undefined);\n\t    return Notification;\n\t}());\n\tNotification.Notification = Notification$1;\n\t\n\treturn Notification;\n}\n\nvar hasRequiredObserveOn;\n\nfunction requireObserveOn () {\n\tif (hasRequiredObserveOn) return observeOn;\n\thasRequiredObserveOn = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\tvar Notification_1 = requireNotification();\n\t/**\n\t * @see {@link Notification}\n\t *\n\t * @param scheduler\n\t * @param delay\n\t * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n\t * @method observeOn\n\t * @owner Observable\n\t */\n\tfunction observeOn$1(scheduler, delay) {\n\t    if (delay === void 0) { delay = 0; }\n\t    return this.lift(new ObserveOnOperator(scheduler, delay));\n\t}\n\tobserveOn.observeOn = observeOn$1;\n\tvar ObserveOnOperator = (function () {\n\t    function ObserveOnOperator(scheduler, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        this.scheduler = scheduler;\n\t        this.delay = delay;\n\t    }\n\t    ObserveOnOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n\t    };\n\t    return ObserveOnOperator;\n\t}());\n\tobserveOn.ObserveOnOperator = ObserveOnOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar ObserveOnSubscriber = (function (_super) {\n\t    __extends(ObserveOnSubscriber, _super);\n\t    function ObserveOnSubscriber(destination, scheduler, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        _super.call(this, destination);\n\t        this.scheduler = scheduler;\n\t        this.delay = delay;\n\t    }\n\t    ObserveOnSubscriber.dispatch = function (arg) {\n\t        var notification = arg.notification, destination = arg.destination;\n\t        notification.observe(destination);\n\t        this.unsubscribe();\n\t    };\n\t    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n\t        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n\t    };\n\t    ObserveOnSubscriber.prototype._next = function (value) {\n\t        this.scheduleMessage(Notification_1.Notification.createNext(value));\n\t    };\n\t    ObserveOnSubscriber.prototype._error = function (err) {\n\t        this.scheduleMessage(Notification_1.Notification.createError(err));\n\t    };\n\t    ObserveOnSubscriber.prototype._complete = function () {\n\t        this.scheduleMessage(Notification_1.Notification.createComplete());\n\t    };\n\t    return ObserveOnSubscriber;\n\t}(Subscriber_1.Subscriber));\n\tobserveOn.ObserveOnSubscriber = ObserveOnSubscriber;\n\tvar ObserveOnMessage = (function () {\n\t    function ObserveOnMessage(notification, destination) {\n\t        this.notification = notification;\n\t        this.destination = destination;\n\t    }\n\t    return ObserveOnMessage;\n\t}());\n\tobserveOn.ObserveOnMessage = ObserveOnMessage;\n\t\n\treturn observeOn;\n}\n\nvar hasRequiredFromObservable;\n\nfunction requireFromObservable () {\n\tif (hasRequiredFromObservable) return FromObservable;\n\thasRequiredFromObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar isArray_1 = requireIsArray();\n\tvar isPromise_1 = requireIsPromise();\n\tvar PromiseObservable_1 = requirePromiseObservable();\n\tvar IteratorObservable_1 = requireIteratorObservable();\n\tvar ArrayObservable_1 = requireArrayObservable();\n\tvar ArrayLikeObservable_1 = requireArrayLikeObservable();\n\tvar iterator_1 = requireIterator();\n\tvar Observable_1 = requireObservable();\n\tvar observeOn_1 = requireObserveOn();\n\tvar observable_1 = requireObservable$1();\n\tvar isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar FromObservable$1 = (function (_super) {\n\t    __extends(FromObservable, _super);\n\t    function FromObservable(ish, scheduler) {\n\t        _super.call(this, null);\n\t        this.ish = ish;\n\t        this.scheduler = scheduler;\n\t    }\n\t    /**\n\t     * Creates an Observable from an Array, an array-like object, a Promise, an\n\t     * iterable object, or an Observable-like object.\n\t     *\n\t     * <span class=\"informal\">Converts almost anything to an Observable.</span>\n\t     *\n\t     * <img src=\"./img/from.png\" width=\"100%\">\n\t     *\n\t     * Convert various other objects and data types into Observables. `from`\n\t     * converts a Promise or an array-like or an\n\t     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n\t     * object into an Observable that emits the items in that promise or array or\n\t     * iterable. A String, in this context, is treated as an array of characters.\n\t     * Observable-like objects (contains a function named with the ES2015 Symbol\n\t     * for Observable) can also be converted through this operator.\n\t     *\n\t     * @example <caption>Converts an array to an Observable</caption>\n\t     * var array = [10, 20, 30];\n\t     * var result = Rx.Observable.from(array);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * // Results in the following:\n\t     * // 10 20 30\n\t     *\n\t     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n\t     * function* generateDoubles(seed) {\n\t     *   var i = seed;\n\t     *   while (true) {\n\t     *     yield i;\n\t     *     i = 2 * i; // double it\n\t     *   }\n\t     * }\n\t     *\n\t     * var iterator = generateDoubles(3);\n\t     * var result = Rx.Observable.from(iterator).take(10);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * // Results in the following:\n\t     * // 3 6 12 24 48 96 192 384 768 1536\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link fromEvent}\n\t     * @see {@link fromEventPattern}\n\t     * @see {@link fromPromise}\n\t     *\n\t     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n\t     * Observable-like, an Array, an iterable or an array-like object to be\n\t     * converted.\n\t     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n\t     * emissions of values.\n\t     * @return {Observable<T>} The Observable whose values are originally from the\n\t     * input object that was converted.\n\t     * @static true\n\t     * @name from\n\t     * @owner Observable\n\t     */\n\t    FromObservable.create = function (ish, scheduler) {\n\t        if (ish != null) {\n\t            if (typeof ish[observable_1.$$observable] === 'function') {\n\t                if (ish instanceof Observable_1.Observable && !scheduler) {\n\t                    return ish;\n\t                }\n\t                return new FromObservable(ish, scheduler);\n\t            }\n\t            else if (isArray_1.isArray(ish)) {\n\t                return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n\t            }\n\t            else if (isPromise_1.isPromise(ish)) {\n\t                return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n\t            }\n\t            else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {\n\t                return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n\t            }\n\t            else if (isArrayLike(ish)) {\n\t                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n\t            }\n\t        }\n\t        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n\t    };\n\t    FromObservable.prototype._subscribe = function (subscriber) {\n\t        var ish = this.ish;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler == null) {\n\t            return ish[observable_1.$$observable]().subscribe(subscriber);\n\t        }\n\t        else {\n\t            return ish[observable_1.$$observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n\t        }\n\t    };\n\t    return FromObservable;\n\t}(Observable_1.Observable));\n\tFromObservable.FromObservable = FromObservable$1;\n\t\n\treturn FromObservable;\n}\n\nvar hasRequiredFrom$1;\n\nfunction requireFrom$1 () {\n\tif (hasRequiredFrom$1) return from;\n\thasRequiredFrom$1 = 1;\n\tvar FromObservable_1 = requireFromObservable();\n\tfrom.from = FromObservable_1.FromObservable.create;\n\t\n\treturn from;\n}\n\nvar hasRequiredFrom;\n\nfunction requireFrom () {\n\tif (hasRequiredFrom) return from$1;\n\thasRequiredFrom = 1;\n\tvar Observable_1 = requireObservable();\n\tvar from_1 = requireFrom$1();\n\tObservable_1.Observable.from = from_1.from;\n\t\n\treturn from$1;\n}\n\nvar _throw$1 = {};\n\nvar _throw = {};\n\nvar ErrorObservable = {};\n\nvar hasRequiredErrorObservable;\n\nfunction requireErrorObservable () {\n\tif (hasRequiredErrorObservable) return ErrorObservable;\n\thasRequiredErrorObservable = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = requireObservable();\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar ErrorObservable$1 = (function (_super) {\n\t    __extends(ErrorObservable, _super);\n\t    function ErrorObservable(error, scheduler) {\n\t        _super.call(this);\n\t        this.error = error;\n\t        this.scheduler = scheduler;\n\t    }\n\t    /**\n\t     * Creates an Observable that emits no items to the Observer and immediately\n\t     * emits an error notification.\n\t     *\n\t     * <span class=\"informal\">Just emits 'error', and nothing else.\n\t     * </span>\n\t     *\n\t     * <img src=\"./img/throw.png\" width=\"100%\">\n\t     *\n\t     * This static operator is useful for creating a simple Observable that only\n\t     * emits the error notification. It can be used for composing with other\n\t     * Observables, such as in a {@link mergeMap}.\n\t     *\n\t     * @example <caption>Emit the number 7, then emit an error.</caption>\n\t     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);\n\t     * result.subscribe(x => console.log(x), e => console.error(e));\n\t     *\n\t     * @example <caption>Map and flattens numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>\n\t     * var interval = Rx.Observable.interval(1000);\n\t     * var result = interval.mergeMap(x =>\n\t     *   x === 13 ?\n\t     *     Rx.Observable.throw('Thirteens are bad') :\n\t     *     Rx.Observable.of('a', 'b', 'c')\n\t     * );\n\t     * result.subscribe(x => console.log(x), e => console.error(e));\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link empty}\n\t     * @see {@link never}\n\t     * @see {@link of}\n\t     *\n\t     * @param {any} error The particular Error to pass to the error notification.\n\t     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n\t     * the emission of the error notification.\n\t     * @return {Observable} An error Observable: emits only the error notification\n\t     * using the given error argument.\n\t     * @static true\n\t     * @name throw\n\t     * @owner Observable\n\t     */\n\t    ErrorObservable.create = function (error, scheduler) {\n\t        return new ErrorObservable(error, scheduler);\n\t    };\n\t    ErrorObservable.dispatch = function (arg) {\n\t        var error = arg.error, subscriber = arg.subscriber;\n\t        subscriber.error(error);\n\t    };\n\t    ErrorObservable.prototype._subscribe = function (subscriber) {\n\t        var error = this.error;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(ErrorObservable.dispatch, 0, {\n\t                error: error, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            subscriber.error(error);\n\t        }\n\t    };\n\t    return ErrorObservable;\n\t}(Observable_1.Observable));\n\tErrorObservable.ErrorObservable = ErrorObservable$1;\n\t\n\treturn ErrorObservable;\n}\n\nvar hasRequired_throw$1;\n\nfunction require_throw$1 () {\n\tif (hasRequired_throw$1) return _throw;\n\thasRequired_throw$1 = 1;\n\tvar ErrorObservable_1 = requireErrorObservable();\n\t_throw._throw = ErrorObservable_1.ErrorObservable.create;\n\t\n\treturn _throw;\n}\n\nvar hasRequired_throw;\n\nfunction require_throw () {\n\tif (hasRequired_throw) return _throw$1;\n\thasRequired_throw = 1;\n\tvar Observable_1 = requireObservable();\n\tvar throw_1 = require_throw$1();\n\tObservable_1.Observable.throw = throw_1._throw;\n\t\n\treturn _throw$1;\n}\n\nvar empty$1 = {};\n\nvar empty = {};\n\nvar hasRequiredEmpty$1;\n\nfunction requireEmpty$1 () {\n\tif (hasRequiredEmpty$1) return empty;\n\thasRequiredEmpty$1 = 1;\n\tvar EmptyObservable_1 = requireEmptyObservable();\n\tempty.empty = EmptyObservable_1.EmptyObservable.create;\n\t\n\treturn empty;\n}\n\nvar hasRequiredEmpty;\n\nfunction requireEmpty () {\n\tif (hasRequiredEmpty) return empty$1;\n\thasRequiredEmpty = 1;\n\tvar Observable_1 = requireObservable();\n\tvar empty_1 = requireEmpty$1();\n\tObservable_1.Observable.empty = empty_1.empty;\n\t\n\treturn empty$1;\n}\n\nvar mergeMap$1 = {};\n\nvar mergeMap = {};\n\nvar hasRequiredMergeMap$1;\n\nfunction requireMergeMap$1 () {\n\tif (hasRequiredMergeMap$1) return mergeMap;\n\thasRequiredMergeMap$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar subscribeToResult_1 = requireSubscribeToResult();\n\tvar OuterSubscriber_1 = requireOuterSubscriber();\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Projects each source value to an Observable which is merged in the output\n\t * Observable.\n\t *\n\t * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n\t * these inner Observables using {@link mergeAll}.</span>\n\t *\n\t * <img src=\"./img/mergeMap.png\" width=\"100%\">\n\t *\n\t * Returns an Observable that emits items based on applying a function that you\n\t * supply to each item emitted by the source Observable, where that function\n\t * returns an Observable, and then merging those resulting Observables and\n\t * emitting the results of this merger.\n\t *\n\t * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n\t * var letters = Rx.Observable.of('a', 'b', 'c');\n\t * var result = letters.mergeMap(x =>\n\t *   Rx.Observable.interval(1000).map(i => x+i)\n\t * );\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // Results in the following:\n\t * // a0\n\t * // b0\n\t * // c0\n\t * // a1\n\t * // b1\n\t * // c1\n\t * // continues to list a,b,c with respective ascending integers\n\t *\n\t * @see {@link concatMap}\n\t * @see {@link exhaustMap}\n\t * @see {@link merge}\n\t * @see {@link mergeAll}\n\t * @see {@link mergeMapTo}\n\t * @see {@link mergeScan}\n\t * @see {@link switchMap}\n\t *\n\t * @param {function(value: T, ?index: number): Observable} project A function\n\t * that, when applied to an item emitted by the source Observable, returns an\n\t * Observable.\n\t * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n\t * A function to produce the value on the output Observable based on the values\n\t * and the indices of the source (outer) emission and the inner Observable\n\t * emission. The arguments passed to this function are:\n\t * - `outerValue`: the value that came from the source\n\t * - `innerValue`: the value that came from the projected Observable\n\t * - `outerIndex`: the \"index\" of the value that came from the source\n\t * - `innerIndex`: the \"index\" of the value from the projected Observable\n\t * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n\t * Observables being subscribed to concurrently.\n\t * @return {Observable} An Observable that emits the result of applying the\n\t * projection function (and the optional `resultSelector`) to each item emitted\n\t * by the source Observable and merging the results of the Observables obtained\n\t * from this transformation.\n\t * @method mergeMap\n\t * @owner Observable\n\t */\n\tfunction mergeMap$1(project, resultSelector, concurrent) {\n\t    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t    if (typeof resultSelector === 'number') {\n\t        concurrent = resultSelector;\n\t        resultSelector = null;\n\t    }\n\t    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));\n\t}\n\tmergeMap.mergeMap = mergeMap$1;\n\tvar MergeMapOperator = (function () {\n\t    function MergeMapOperator(project, resultSelector, concurrent) {\n\t        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t        this.project = project;\n\t        this.resultSelector = resultSelector;\n\t        this.concurrent = concurrent;\n\t    }\n\t    MergeMapOperator.prototype.call = function (observer, source) {\n\t        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n\t    };\n\t    return MergeMapOperator;\n\t}());\n\tmergeMap.MergeMapOperator = MergeMapOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MergeMapSubscriber = (function (_super) {\n\t    __extends(MergeMapSubscriber, _super);\n\t    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n\t        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t        _super.call(this, destination);\n\t        this.project = project;\n\t        this.resultSelector = resultSelector;\n\t        this.concurrent = concurrent;\n\t        this.hasCompleted = false;\n\t        this.buffer = [];\n\t        this.active = 0;\n\t        this.index = 0;\n\t    }\n\t    MergeMapSubscriber.prototype._next = function (value) {\n\t        if (this.active < this.concurrent) {\n\t            this._tryNext(value);\n\t        }\n\t        else {\n\t            this.buffer.push(value);\n\t        }\n\t    };\n\t    MergeMapSubscriber.prototype._tryNext = function (value) {\n\t        var result;\n\t        var index = this.index++;\n\t        try {\n\t            result = this.project(value, index);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.active++;\n\t        this._innerSub(result, value, index);\n\t    };\n\t    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n\t        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n\t    };\n\t    MergeMapSubscriber.prototype._complete = function () {\n\t        this.hasCompleted = true;\n\t        if (this.active === 0 && this.buffer.length === 0) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n\t        if (this.resultSelector) {\n\t            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n\t        }\n\t        else {\n\t            this.destination.next(innerValue);\n\t        }\n\t    };\n\t    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n\t        var result;\n\t        try {\n\t            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.destination.next(result);\n\t    };\n\t    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        var buffer = this.buffer;\n\t        this.remove(innerSub);\n\t        this.active--;\n\t        if (buffer.length > 0) {\n\t            this._next(buffer.shift());\n\t        }\n\t        else if (this.active === 0 && this.hasCompleted) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    return MergeMapSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\tmergeMap.MergeMapSubscriber = MergeMapSubscriber;\n\t\n\treturn mergeMap;\n}\n\nvar hasRequiredMergeMap;\n\nfunction requireMergeMap () {\n\tif (hasRequiredMergeMap) return mergeMap$1;\n\thasRequiredMergeMap = 1;\n\tvar Observable_1 = requireObservable();\n\tvar mergeMap_1 = requireMergeMap$1();\n\tObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\n\tObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n\t\n\treturn mergeMap$1;\n}\n\nvar _do$1 = {};\n\nvar _do = {};\n\nvar hasRequired_do$1;\n\nfunction require_do$1 () {\n\tif (hasRequired_do$1) return _do;\n\thasRequired_do$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Perform a side effect for every emission on the source Observable, but return\n\t * an Observable that is identical to the source.\n\t *\n\t * <span class=\"informal\">Intercepts each emission on the source and runs a\n\t * function, but returns an output which is identical to the source.</span>\n\t *\n\t * <img src=\"./img/do.png\" width=\"100%\">\n\t *\n\t * Returns a mirrored Observable of the source Observable, but modified so that\n\t * the provided Observer is called to perform a side effect for every value,\n\t * error, and completion emitted by the source. Any errors that are thrown in\n\t * the aforementioned Observer or handlers are safely sent down the error path\n\t * of the output Observable.\n\t *\n\t * This operator is useful for debugging your Observables for the correct values\n\t * or performing other side effects.\n\t *\n\t * Note: this is different to a `subscribe` on the Observable. If the Observable\n\t * returned by `do` is not subscribed, the side effects specified by the\n\t * Observer will never happen. `do` therefore simply spies on existing\n\t * execution, it does not trigger an execution to happen like `subscribe` does.\n\t *\n\t * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var positions = clicks\n\t *   .do(ev => console.log(ev))\n\t *   .map(ev => ev.clientX);\n\t * positions.subscribe(x => console.log(x));\n\t *\n\t * @see {@link map}\n\t * @see {@link subscribe}\n\t *\n\t * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n\t * callback for `next`.\n\t * @param {function} [error] Callback for errors in the source.\n\t * @param {function} [complete] Callback for the completion of the source.\n\t * @return {Observable} An Observable identical to the source, but runs the\n\t * specified Observer or callback(s) for each item.\n\t * @method do\n\t * @name do\n\t * @owner Observable\n\t */\n\tfunction _do$1(nextOrObserver, error, complete) {\n\t    return this.lift(new DoOperator(nextOrObserver, error, complete));\n\t}\n\t_do._do = _do$1;\n\tvar DoOperator = (function () {\n\t    function DoOperator(nextOrObserver, error, complete) {\n\t        this.nextOrObserver = nextOrObserver;\n\t        this.error = error;\n\t        this.complete = complete;\n\t    }\n\t    DoOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n\t    };\n\t    return DoOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar DoSubscriber = (function (_super) {\n\t    __extends(DoSubscriber, _super);\n\t    function DoSubscriber(destination, nextOrObserver, error, complete) {\n\t        _super.call(this, destination);\n\t        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n\t        safeSubscriber.syncErrorThrowable = true;\n\t        this.add(safeSubscriber);\n\t        this.safeSubscriber = safeSubscriber;\n\t    }\n\t    DoSubscriber.prototype._next = function (value) {\n\t        var safeSubscriber = this.safeSubscriber;\n\t        safeSubscriber.next(value);\n\t        if (safeSubscriber.syncErrorThrown) {\n\t            this.destination.error(safeSubscriber.syncErrorValue);\n\t        }\n\t        else {\n\t            this.destination.next(value);\n\t        }\n\t    };\n\t    DoSubscriber.prototype._error = function (err) {\n\t        var safeSubscriber = this.safeSubscriber;\n\t        safeSubscriber.error(err);\n\t        if (safeSubscriber.syncErrorThrown) {\n\t            this.destination.error(safeSubscriber.syncErrorValue);\n\t        }\n\t        else {\n\t            this.destination.error(err);\n\t        }\n\t    };\n\t    DoSubscriber.prototype._complete = function () {\n\t        var safeSubscriber = this.safeSubscriber;\n\t        safeSubscriber.complete();\n\t        if (safeSubscriber.syncErrorThrown) {\n\t            this.destination.error(safeSubscriber.syncErrorValue);\n\t        }\n\t        else {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    return DoSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t\n\treturn _do;\n}\n\nvar hasRequired_do;\n\nfunction require_do () {\n\tif (hasRequired_do) return _do$1;\n\thasRequired_do = 1;\n\tvar Observable_1 = requireObservable();\n\tvar do_1 = require_do$1();\n\tObservable_1.Observable.prototype.do = do_1._do;\n\tObservable_1.Observable.prototype._do = do_1._do;\n\t\n\treturn _do$1;\n}\n\nvar defaultIfEmpty$1 = {};\n\nvar defaultIfEmpty = {};\n\nvar hasRequiredDefaultIfEmpty$1;\n\nfunction requireDefaultIfEmpty$1 () {\n\tif (hasRequiredDefaultIfEmpty$1) return defaultIfEmpty;\n\thasRequiredDefaultIfEmpty$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Emits a given value if the source Observable completes without emitting any\n\t * `next` value, otherwise mirrors the source Observable.\n\t *\n\t * <span class=\"informal\">If the source Observable turns out to be empty, then\n\t * this operator will emit a default value.</span>\n\t *\n\t * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n\t *\n\t * `defaultIfEmpty` emits the values emitted by the source Observable or a\n\t * specified default value if the source Observable is empty (completes without\n\t * having emitted any `next` value).\n\t *\n\t * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n\t * var result = clicksBeforeFive.defaultIfEmpty('no clicks');\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * @see {@link empty}\n\t * @see {@link last}\n\t *\n\t * @param {any} [defaultValue=null] The default value used if the source\n\t * Observable is empty.\n\t * @return {Observable} An Observable that emits either the specified\n\t * `defaultValue` if the source Observable emits no items, or the values emitted\n\t * by the source Observable.\n\t * @method defaultIfEmpty\n\t * @owner Observable\n\t */\n\tfunction defaultIfEmpty$1(defaultValue) {\n\t    if (defaultValue === void 0) { defaultValue = null; }\n\t    return this.lift(new DefaultIfEmptyOperator(defaultValue));\n\t}\n\tdefaultIfEmpty.defaultIfEmpty = defaultIfEmpty$1;\n\tvar DefaultIfEmptyOperator = (function () {\n\t    function DefaultIfEmptyOperator(defaultValue) {\n\t        this.defaultValue = defaultValue;\n\t    }\n\t    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));\n\t    };\n\t    return DefaultIfEmptyOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar DefaultIfEmptySubscriber = (function (_super) {\n\t    __extends(DefaultIfEmptySubscriber, _super);\n\t    function DefaultIfEmptySubscriber(destination, defaultValue) {\n\t        _super.call(this, destination);\n\t        this.defaultValue = defaultValue;\n\t        this.isEmpty = true;\n\t    }\n\t    DefaultIfEmptySubscriber.prototype._next = function (value) {\n\t        this.isEmpty = false;\n\t        this.destination.next(value);\n\t    };\n\t    DefaultIfEmptySubscriber.prototype._complete = function () {\n\t        if (this.isEmpty) {\n\t            this.destination.next(this.defaultValue);\n\t        }\n\t        this.destination.complete();\n\t    };\n\t    return DefaultIfEmptySubscriber;\n\t}(Subscriber_1.Subscriber));\n\t\n\treturn defaultIfEmpty;\n}\n\nvar hasRequiredDefaultIfEmpty;\n\nfunction requireDefaultIfEmpty () {\n\tif (hasRequiredDefaultIfEmpty) return defaultIfEmpty$1;\n\thasRequiredDefaultIfEmpty = 1;\n\tvar Observable_1 = requireObservable();\n\tvar defaultIfEmpty_1 = requireDefaultIfEmpty$1();\n\tObservable_1.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;\n\t\n\treturn defaultIfEmpty$1;\n}\n\nvar materialize$2 = {};\n\nvar materialize$1 = {};\n\nvar hasRequiredMaterialize$2;\n\nfunction requireMaterialize$2 () {\n\tif (hasRequiredMaterialize$2) return materialize$1;\n\thasRequiredMaterialize$2 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\tvar Notification_1 = requireNotification();\n\t/**\n\t * Represents all of the notifications from the source Observable as `next`\n\t * emissions marked with their original types within {@link Notification}\n\t * objects.\n\t *\n\t * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n\t * {@link Notification} objects, emitted as `next` on the output Observable.\n\t * </span>\n\t *\n\t * <img src=\"./img/materialize.png\" width=\"100%\">\n\t *\n\t * `materialize` returns an Observable that emits a `next` notification for each\n\t * `next`, `error`, or `complete` emission of the source Observable. When the\n\t * source Observable emits `complete`, the output Observable will emit `next` as\n\t * a Notification of type \"complete\", and then it will emit `complete` as well.\n\t * When the source Observable emits `error`, the output will emit `next` as a\n\t * Notification of type \"error\", and then `complete`.\n\t *\n\t * This operator is useful for producing metadata of the source Observable, to\n\t * be consumed as `next` emissions. Use it in conjunction with\n\t * {@link dematerialize}.\n\t *\n\t * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n\t * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n\t * var upperCase = letters.map(x => x.toUpperCase());\n\t * var materialized = upperCase.materialize();\n\t * materialized.subscribe(x => console.log(x));\n\t *\n\t * // Results in the following:\n\t * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n\t * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n\t * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n\t * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n\t * //   [as project] (http://1\u2026, hasValue: false}\n\t *\n\t * @see {@link Notification}\n\t * @see {@link dematerialize}\n\t *\n\t * @return {Observable<Notification<T>>} An Observable that emits\n\t * {@link Notification} objects that wrap the original emissions from the source\n\t * Observable with metadata.\n\t * @method materialize\n\t * @owner Observable\n\t */\n\tfunction materialize() {\n\t    return this.lift(new MaterializeOperator());\n\t}\n\tmaterialize$1.materialize = materialize;\n\tvar MaterializeOperator = (function () {\n\t    function MaterializeOperator() {\n\t    }\n\t    MaterializeOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new MaterializeSubscriber(subscriber));\n\t    };\n\t    return MaterializeOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MaterializeSubscriber = (function (_super) {\n\t    __extends(MaterializeSubscriber, _super);\n\t    function MaterializeSubscriber(destination) {\n\t        _super.call(this, destination);\n\t    }\n\t    MaterializeSubscriber.prototype._next = function (value) {\n\t        this.destination.next(Notification_1.Notification.createNext(value));\n\t    };\n\t    MaterializeSubscriber.prototype._error = function (err) {\n\t        var destination = this.destination;\n\t        destination.next(Notification_1.Notification.createError(err));\n\t        destination.complete();\n\t    };\n\t    MaterializeSubscriber.prototype._complete = function () {\n\t        var destination = this.destination;\n\t        destination.next(Notification_1.Notification.createComplete());\n\t        destination.complete();\n\t    };\n\t    return MaterializeSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t\n\treturn materialize$1;\n}\n\nvar hasRequiredMaterialize$1;\n\nfunction requireMaterialize$1 () {\n\tif (hasRequiredMaterialize$1) return materialize$2;\n\thasRequiredMaterialize$1 = 1;\n\tvar Observable_1 = requireObservable();\n\tvar materialize_1 = requireMaterialize$2();\n\tObservable_1.Observable.prototype.materialize = materialize_1.materialize;\n\t\n\treturn materialize$2;\n}\n\nvar expand$1 = {};\n\nvar expand = {};\n\nvar hasRequiredExpand$1;\n\nfunction requireExpand$1 () {\n\tif (hasRequiredExpand$1) return expand;\n\thasRequiredExpand$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar tryCatch_1 = requireTryCatch();\n\tvar errorObject_1 = requireErrorObject();\n\tvar OuterSubscriber_1 = requireOuterSubscriber();\n\tvar subscribeToResult_1 = requireSubscribeToResult();\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Recursively projects each source value to an Observable which is merged in\n\t * the output Observable.\n\t *\n\t * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n\t * projection function to every source value as well as every output value.\n\t * It's recursive.</span>\n\t *\n\t * <img src=\"./img/expand.png\" width=\"100%\">\n\t *\n\t * Returns an Observable that emits items based on applying a function that you\n\t * supply to each item emitted by the source Observable, where that function\n\t * returns an Observable, and then merging those resulting Observables and\n\t * emitting the results of this merger. *Expand* will re-emit on the output\n\t * Observable every source value. Then, each output value is given to the\n\t * `project` function which returns an inner Observable to be merged on the\n\t * output Observable. Those output values resulting from the projection are also\n\t * given to the `project` function to produce new output values. This is how\n\t * *expand* behaves recursively.\n\t *\n\t * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var powersOfTwo = clicks\n\t *   .mapTo(1)\n\t *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n\t *   .take(10);\n\t * powersOfTwo.subscribe(x => console.log(x));\n\t *\n\t * @see {@link mergeMap}\n\t * @see {@link mergeScan}\n\t *\n\t * @param {function(value: T, index: number) => Observable} project A function\n\t * that, when applied to an item emitted by the source or the output Observable,\n\t * returns an Observable.\n\t * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n\t * Observables being subscribed to concurrently.\n\t * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n\t * each projected inner Observable.\n\t * @return {Observable} An Observable that emits the source values and also\n\t * result of applying the projection function to each value emitted on the\n\t * output Observable and and merging the results of the Observables obtained\n\t * from this transformation.\n\t * @method expand\n\t * @owner Observable\n\t */\n\tfunction expand$1(project, concurrent, scheduler) {\n\t    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t    if (scheduler === void 0) { scheduler = undefined; }\n\t    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n\t    return this.lift(new ExpandOperator(project, concurrent, scheduler));\n\t}\n\texpand.expand = expand$1;\n\tvar ExpandOperator = (function () {\n\t    function ExpandOperator(project, concurrent, scheduler) {\n\t        this.project = project;\n\t        this.concurrent = concurrent;\n\t        this.scheduler = scheduler;\n\t    }\n\t    ExpandOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n\t    };\n\t    return ExpandOperator;\n\t}());\n\texpand.ExpandOperator = ExpandOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar ExpandSubscriber = (function (_super) {\n\t    __extends(ExpandSubscriber, _super);\n\t    function ExpandSubscriber(destination, project, concurrent, scheduler) {\n\t        _super.call(this, destination);\n\t        this.project = project;\n\t        this.concurrent = concurrent;\n\t        this.scheduler = scheduler;\n\t        this.index = 0;\n\t        this.active = 0;\n\t        this.hasCompleted = false;\n\t        if (concurrent < Number.POSITIVE_INFINITY) {\n\t            this.buffer = [];\n\t        }\n\t    }\n\t    ExpandSubscriber.dispatch = function (arg) {\n\t        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;\n\t        subscriber.subscribeToProjection(result, value, index);\n\t    };\n\t    ExpandSubscriber.prototype._next = function (value) {\n\t        var destination = this.destination;\n\t        if (destination.closed) {\n\t            this._complete();\n\t            return;\n\t        }\n\t        var index = this.index++;\n\t        if (this.active < this.concurrent) {\n\t            destination.next(value);\n\t            var result = tryCatch_1.tryCatch(this.project)(value, index);\n\t            if (result === errorObject_1.errorObject) {\n\t                destination.error(errorObject_1.errorObject.e);\n\t            }\n\t            else if (!this.scheduler) {\n\t                this.subscribeToProjection(result, value, index);\n\t            }\n\t            else {\n\t                var state = { subscriber: this, result: result, value: value, index: index };\n\t                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n\t            }\n\t        }\n\t        else {\n\t            this.buffer.push(value);\n\t        }\n\t    };\n\t    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n\t        this.active++;\n\t        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n\t    };\n\t    ExpandSubscriber.prototype._complete = function () {\n\t        this.hasCompleted = true;\n\t        if (this.hasCompleted && this.active === 0) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n\t        this._next(innerValue);\n\t    };\n\t    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        var buffer = this.buffer;\n\t        this.remove(innerSub);\n\t        this.active--;\n\t        if (buffer && buffer.length > 0) {\n\t            this._next(buffer.shift());\n\t        }\n\t        if (this.hasCompleted && this.active === 0) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    return ExpandSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\texpand.ExpandSubscriber = ExpandSubscriber;\n\t\n\treturn expand;\n}\n\nvar hasRequiredExpand;\n\nfunction requireExpand () {\n\tif (hasRequiredExpand) return expand$1;\n\thasRequiredExpand = 1;\n\tvar Observable_1 = requireObservable();\n\tvar expand_1 = requireExpand$1();\n\tObservable_1.Observable.prototype.expand = expand_1.expand;\n\t\n\treturn expand$1;\n}\n\nvar reduce$1 = {};\n\nvar reduce = {};\n\nvar hasRequiredReduce$1;\n\nfunction requireReduce$1 () {\n\tif (hasRequiredReduce$1) return reduce;\n\thasRequiredReduce$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Applies an accumulator function over the source Observable, and returns the\n\t * accumulated result when the source completes, given an optional seed value.\n\t *\n\t * <span class=\"informal\">Combines together all values emitted on the source,\n\t * using an accumulator function that knows how to join a new source value into\n\t * the accumulation from the past.</span>\n\t *\n\t * <img src=\"./img/reduce.png\" width=\"100%\">\n\t *\n\t * Like\n\t * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n\t * `reduce` applies an `accumulator` function against an accumulation and each\n\t * value of the source Observable (from the past) to reduce it to a single\n\t * value, emitted on the output Observable. Note that `reduce` will only emit\n\t * one value, only when the source Observable completes. It is equivalent to\n\t * applying operator {@link scan} followed by operator {@link last}.\n\t *\n\t * Returns an Observable that applies a specified `accumulator` function to each\n\t * item emitted by the source Observable. If a `seed` value is specified, then\n\t * that value will be used as the initial value for the accumulator. If no seed\n\t * value is specified, the first item of the source is used as the seed.\n\t *\n\t * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n\t * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n\t *   .takeUntil(Rx.Observable.interval(5000));\n\t * var ones = clicksInFiveSeconds.mapTo(1);\n\t * var seed = 0;\n\t * var count = ones.reduce((acc, one) => acc + one, seed);\n\t * count.subscribe(x => console.log(x));\n\t *\n\t * @see {@link count}\n\t * @see {@link expand}\n\t * @see {@link mergeScan}\n\t * @see {@link scan}\n\t *\n\t * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n\t * called on each source value.\n\t * @param {R} [seed] The initial accumulation value.\n\t * @return {Observable<R>} An observable of the accumulated values.\n\t * @return {Observable<R>} An Observable that emits a single value that is the\n\t * result of accumulating the values emitted by the source Observable.\n\t * @method reduce\n\t * @owner Observable\n\t */\n\tfunction reduce$1(accumulator, seed) {\n\t    var hasSeed = false;\n\t    // providing a seed of `undefined` *should* be valid and trigger\n\t    // hasSeed! so don't use `seed !== undefined` checks!\n\t    // For this reason, we have to check it here at the original call site\n\t    // otherwise inside Operator/Subscriber we won't know if `undefined`\n\t    // means they didn't provide anything or if they literally provided `undefined`\n\t    if (arguments.length >= 2) {\n\t        hasSeed = true;\n\t    }\n\t    return this.lift(new ReduceOperator(accumulator, seed, hasSeed));\n\t}\n\treduce.reduce = reduce$1;\n\tvar ReduceOperator = (function () {\n\t    function ReduceOperator(accumulator, seed, hasSeed) {\n\t        if (hasSeed === void 0) { hasSeed = false; }\n\t        this.accumulator = accumulator;\n\t        this.seed = seed;\n\t        this.hasSeed = hasSeed;\n\t    }\n\t    ReduceOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n\t    };\n\t    return ReduceOperator;\n\t}());\n\treduce.ReduceOperator = ReduceOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar ReduceSubscriber = (function (_super) {\n\t    __extends(ReduceSubscriber, _super);\n\t    function ReduceSubscriber(destination, accumulator, seed, hasSeed) {\n\t        _super.call(this, destination);\n\t        this.accumulator = accumulator;\n\t        this.hasSeed = hasSeed;\n\t        this.index = 0;\n\t        this.hasValue = false;\n\t        this.acc = seed;\n\t        if (!this.hasSeed) {\n\t            this.index++;\n\t        }\n\t    }\n\t    ReduceSubscriber.prototype._next = function (value) {\n\t        if (this.hasValue || (this.hasValue = this.hasSeed)) {\n\t            this._tryReduce(value);\n\t        }\n\t        else {\n\t            this.acc = value;\n\t            this.hasValue = true;\n\t        }\n\t    };\n\t    ReduceSubscriber.prototype._tryReduce = function (value) {\n\t        var result;\n\t        try {\n\t            result = this.accumulator(this.acc, value, this.index++);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.acc = result;\n\t    };\n\t    ReduceSubscriber.prototype._complete = function () {\n\t        if (this.hasValue || this.hasSeed) {\n\t            this.destination.next(this.acc);\n\t        }\n\t        this.destination.complete();\n\t    };\n\t    return ReduceSubscriber;\n\t}(Subscriber_1.Subscriber));\n\treduce.ReduceSubscriber = ReduceSubscriber;\n\t\n\treturn reduce;\n}\n\nvar hasRequiredReduce;\n\nfunction requireReduce () {\n\tif (hasRequiredReduce) return reduce$1;\n\thasRequiredReduce = 1;\n\tvar Observable_1 = requireObservable();\n\tvar reduce_1 = requireReduce$1();\n\tObservable_1.Observable.prototype.reduce = reduce_1.reduce;\n\t\n\treturn reduce$1;\n}\n\nvar toArray$1 = {};\n\nvar toArray = {};\n\nvar hasRequiredToArray$1;\n\nfunction requireToArray$1 () {\n\tif (hasRequiredToArray$1) return toArray;\n\thasRequiredToArray$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/**\n\t * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}\n\t * @method toArray\n\t * @owner Observable\n\t */\n\tfunction toArray$1() {\n\t    return this.lift(new ToArrayOperator());\n\t}\n\ttoArray.toArray = toArray$1;\n\tvar ToArrayOperator = (function () {\n\t    function ToArrayOperator() {\n\t    }\n\t    ToArrayOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new ToArraySubscriber(subscriber));\n\t    };\n\t    return ToArrayOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar ToArraySubscriber = (function (_super) {\n\t    __extends(ToArraySubscriber, _super);\n\t    function ToArraySubscriber(destination) {\n\t        _super.call(this, destination);\n\t        this.array = [];\n\t    }\n\t    ToArraySubscriber.prototype._next = function (x) {\n\t        this.array.push(x);\n\t    };\n\t    ToArraySubscriber.prototype._complete = function () {\n\t        this.destination.next(this.array);\n\t        this.destination.complete();\n\t    };\n\t    return ToArraySubscriber;\n\t}(Subscriber_1.Subscriber));\n\t\n\treturn toArray;\n}\n\nvar hasRequiredToArray;\n\nfunction requireToArray () {\n\tif (hasRequiredToArray) return toArray$1;\n\thasRequiredToArray = 1;\n\tvar Observable_1 = requireObservable();\n\tvar toArray_1 = requireToArray$1();\n\tObservable_1.Observable.prototype.toArray = toArray_1.toArray;\n\t\n\treturn toArray$1;\n}\n\nvar map$1 = {};\n\nvar map = {};\n\nvar hasRequiredMap$1;\n\nfunction requireMap$1 () {\n\tif (hasRequiredMap$1) return map;\n\thasRequiredMap$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/**\n\t * Applies a given `project` function to each value emitted by the source\n\t * Observable, and emits the resulting values as an Observable.\n\t *\n\t * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n\t * it passes each source value through a transformation function to get\n\t * corresponding output values.</span>\n\t *\n\t * <img src=\"./img/map.png\" width=\"100%\">\n\t *\n\t * Similar to the well known `Array.prototype.map` function, this operator\n\t * applies a projection to each value and emits that projection in the output\n\t * Observable.\n\t *\n\t * @example <caption>Map every every click to the clientX position of that click</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var positions = clicks.map(ev => ev.clientX);\n\t * positions.subscribe(x => console.log(x));\n\t *\n\t * @see {@link mapTo}\n\t * @see {@link pluck}\n\t *\n\t * @param {function(value: T, index: number): R} project The function to apply\n\t * to each `value` emitted by the source Observable. The `index` parameter is\n\t * the number `i` for the i-th emission that has happened since the\n\t * subscription, starting from the number `0`.\n\t * @param {any} [thisArg] An optional argument to define what `this` is in the\n\t * `project` function.\n\t * @return {Observable<R>} An Observable that emits the values from the source\n\t * Observable transformed by the given `project` function.\n\t * @method map\n\t * @owner Observable\n\t */\n\tfunction map$1(project, thisArg) {\n\t    if (typeof project !== 'function') {\n\t        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n\t    }\n\t    return this.lift(new MapOperator(project, thisArg));\n\t}\n\tmap.map = map$1;\n\tvar MapOperator = (function () {\n\t    function MapOperator(project, thisArg) {\n\t        this.project = project;\n\t        this.thisArg = thisArg;\n\t    }\n\t    MapOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n\t    };\n\t    return MapOperator;\n\t}());\n\tmap.MapOperator = MapOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MapSubscriber = (function (_super) {\n\t    __extends(MapSubscriber, _super);\n\t    function MapSubscriber(destination, project, thisArg) {\n\t        _super.call(this, destination);\n\t        this.project = project;\n\t        this.count = 0;\n\t        this.thisArg = thisArg || this;\n\t    }\n\t    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n\t    // using try/catch optimizations.\n\t    MapSubscriber.prototype._next = function (value) {\n\t        var result;\n\t        try {\n\t            result = this.project.call(this.thisArg, value, this.count++);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.destination.next(result);\n\t    };\n\t    return MapSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t\n\treturn map;\n}\n\nvar hasRequiredMap;\n\nfunction requireMap () {\n\tif (hasRequiredMap) return map$1;\n\thasRequiredMap = 1;\n\tvar Observable_1 = requireObservable();\n\tvar map_1 = requireMap$1();\n\tObservable_1.Observable.prototype.map = map_1.map;\n\t\n\treturn map$1;\n}\n\nvar filter$1 = {};\n\nvar filter = {};\n\nvar hasRequiredFilter$1;\n\nfunction requireFilter$1 () {\n\tif (hasRequiredFilter$1) return filter;\n\thasRequiredFilter$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = requireSubscriber();\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Filter items emitted by the source Observable by only emitting those that\n\t * satisfy a specified predicate.\n\t *\n\t * <span class=\"informal\">Like\n\t * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n\t * it only emits a value from the source if it passes a criterion function.</span>\n\t *\n\t * <img src=\"./img/filter.png\" width=\"100%\">\n\t *\n\t * Similar to the well-known `Array.prototype.filter` method, this operator\n\t * takes values from the source Observable, passes them through a `predicate`\n\t * function and only emits those values that yielded `true`.\n\t *\n\t * @example <caption>Emit only click events whose target was a DIV element</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n\t * clicksOnDivs.subscribe(x => console.log(x));\n\t *\n\t * @see {@link distinct}\n\t * @see {@link distinctUntilChanged}\n\t * @see {@link distinctUntilKeyChanged}\n\t * @see {@link ignoreElements}\n\t * @see {@link partition}\n\t * @see {@link skip}\n\t *\n\t * @param {function(value: T, index: number): boolean} predicate A function that\n\t * evaluates each value emitted by the source Observable. If it returns `true`,\n\t * the value is emitted, if `false` the value is not passed to the output\n\t * Observable. The `index` parameter is the number `i` for the i-th source\n\t * emission that has happened since the subscription, starting from the number\n\t * `0`.\n\t * @param {any} [thisArg] An optional argument to determine the value of `this`\n\t * in the `predicate` function.\n\t * @return {Observable} An Observable of values from the source that were\n\t * allowed by the `predicate` function.\n\t * @method filter\n\t * @owner Observable\n\t */\n\tfunction filter$1(predicate, thisArg) {\n\t    return this.lift(new FilterOperator(predicate, thisArg));\n\t}\n\tfilter.filter = filter$1;\n\tvar FilterOperator = (function () {\n\t    function FilterOperator(predicate, thisArg) {\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t    }\n\t    FilterOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n\t    };\n\t    return FilterOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar FilterSubscriber = (function (_super) {\n\t    __extends(FilterSubscriber, _super);\n\t    function FilterSubscriber(destination, predicate, thisArg) {\n\t        _super.call(this, destination);\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t        this.count = 0;\n\t        this.predicate = predicate;\n\t    }\n\t    // the try catch block below is left specifically for\n\t    // optimization and perf reasons. a tryCatcher is not necessary here.\n\t    FilterSubscriber.prototype._next = function (value) {\n\t        var result;\n\t        try {\n\t            result = this.predicate.call(this.thisArg, value, this.count++);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        if (result) {\n\t            this.destination.next(value);\n\t        }\n\t    };\n\t    return FilterSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t\n\treturn filter;\n}\n\nvar hasRequiredFilter;\n\nfunction requireFilter () {\n\tif (hasRequiredFilter) return filter$1;\n\thasRequiredFilter = 1;\n\tvar Observable_1 = requireObservable();\n\tvar filter_1 = requireFilter$1();\n\tObservable_1.Observable.prototype.filter = filter_1.filter;\n\t\n\treturn filter$1;\n}\n\nvar _catch$1 = {};\n\nvar _catch = {};\n\nvar hasRequired_catch$1;\n\nfunction require_catch$1 () {\n\tif (hasRequired_catch$1) return _catch;\n\thasRequired_catch$1 = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar OuterSubscriber_1 = requireOuterSubscriber();\n\tvar subscribeToResult_1 = requireSubscribeToResult();\n\t/**\n\t * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n\t *\n\t * <img src=\"./img/catch.png\" width=\"100%\">\n\t *\n\t * @example <caption>Continues with a different Observable when there's an error</caption>\n\t *\n\t * Observable.of(1, 2, 3, 4, 5)\n\t *   .map(n => {\n\t * \t   if (n == 4) {\n\t * \t     throw 'four!';\n\t *     }\n\t *\t   return n;\n\t *   })\n\t *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n\t *   .subscribe(x => console.log(x));\n\t *   // 1, 2, 3, I, II, III, IV, V\n\t *\n\t * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n\t *\n\t * Observable.of(1, 2, 3, 4, 5)\n\t *   .map(n => {\n\t * \t   if (n === 4) {\n\t * \t     throw 'four!';\n\t *     }\n\t * \t   return n;\n\t *   })\n\t *   .catch((err, caught) => caught)\n\t *   .take(30)\n\t *   .subscribe(x => console.log(x));\n\t *   // 1, 2, 3, 1, 2, 3, ...\n\t *\n\t * @example <caption>Throws a new error when the source Observable throws an error</caption>\n\t *\n\t * Observable.of(1, 2, 3, 4, 5)\n\t *   .map(n => {\n\t *     if (n == 4) {\n\t *       throw 'four!';\n\t *     }\n\t *     return n;\n\t *   })\n\t *   .catch(err => {\n\t *     throw 'error in source. Details: ' + err;\n\t *   })\n\t *   .subscribe(\n\t *     x => console.log(x),\n\t *     err => console.log(err)\n\t *   );\n\t *   // 1, 2, 3, error in source. Details: four!\n\t *\n\t * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n\t *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n\t *  is returned by the `selector` will be used to continue the observable chain.\n\t * @return {Observable} an observable that originates from either the source or the observable returned by the\n\t *  catch `selector` function.\n\t * @method catch\n\t * @name catch\n\t * @owner Observable\n\t */\n\tfunction _catch$1(selector) {\n\t    var operator = new CatchOperator(selector);\n\t    var caught = this.lift(operator);\n\t    return (operator.caught = caught);\n\t}\n\t_catch._catch = _catch$1;\n\tvar CatchOperator = (function () {\n\t    function CatchOperator(selector) {\n\t        this.selector = selector;\n\t    }\n\t    CatchOperator.prototype.call = function (subscriber, source) {\n\t        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n\t    };\n\t    return CatchOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar CatchSubscriber = (function (_super) {\n\t    __extends(CatchSubscriber, _super);\n\t    function CatchSubscriber(destination, selector, caught) {\n\t        _super.call(this, destination);\n\t        this.selector = selector;\n\t        this.caught = caught;\n\t    }\n\t    // NOTE: overriding `error` instead of `_error` because we don't want\n\t    // to have this flag this subscriber as `isStopped`. We can mimic the\n\t    // behavior of the RetrySubscriber (from the `retry` operator), where\n\t    // we unsubscribe from our source chain, reset our Subscriber flags,\n\t    // then subscribe to the selector result.\n\t    CatchSubscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            var result = void 0;\n\t            try {\n\t                result = this.selector(err, this.caught);\n\t            }\n\t            catch (err2) {\n\t                _super.prototype.error.call(this, err2);\n\t                return;\n\t            }\n\t            this._unsubscribeAndRecycle();\n\t            this.add(subscribeToResult_1.subscribeToResult(this, result));\n\t        }\n\t    };\n\t    return CatchSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\t\n\treturn _catch;\n}\n\nvar hasRequired_catch;\n\nfunction require_catch () {\n\tif (hasRequired_catch) return _catch$1;\n\thasRequired_catch = 1;\n\tvar Observable_1 = requireObservable();\n\tvar catch_1 = require_catch$1();\n\tObservable_1.Observable.prototype.catch = catch_1._catch;\n\tObservable_1.Observable.prototype._catch = catch_1._catch;\n\t\n\treturn _catch$1;\n}\n\nvar concat$1 = {};\n\nvar concat = {};\n\nvar mergeAll = {};\n\nvar hasRequiredMergeAll;\n\nfunction requireMergeAll () {\n\tif (hasRequiredMergeAll) return mergeAll;\n\thasRequiredMergeAll = 1;\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar OuterSubscriber_1 = requireOuterSubscriber();\n\tvar subscribeToResult_1 = requireSubscribeToResult();\n\t/**\n\t * Converts a higher-order Observable into a first-order Observable which\n\t * concurrently delivers all values that are emitted on the inner Observables.\n\t *\n\t * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n\t *\n\t * <img src=\"./img/mergeAll.png\" width=\"100%\">\n\t *\n\t * `mergeAll` subscribes to an Observable that emits Observables, also known as\n\t * a higher-order Observable. Each time it observes one of these emitted inner\n\t * Observables, it subscribes to that and delivers all the values from the\n\t * inner Observable on the output Observable. The output Observable only\n\t * completes once all inner Observables have completed. Any error delivered by\n\t * a inner Observable will be immediately emitted on the output Observable.\n\t *\n\t * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n\t * var firstOrder = higherOrder.mergeAll();\n\t * firstOrder.subscribe(x => console.log(x));\n\t *\n\t * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n\t * var firstOrder = higherOrder.mergeAll(2);\n\t * firstOrder.subscribe(x => console.log(x));\n\t *\n\t * @see {@link combineAll}\n\t * @see {@link concatAll}\n\t * @see {@link exhaust}\n\t * @see {@link merge}\n\t * @see {@link mergeMap}\n\t * @see {@link mergeMapTo}\n\t * @see {@link mergeScan}\n\t * @see {@link switch}\n\t * @see {@link zipAll}\n\t *\n\t * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n\t * Observables being subscribed to concurrently.\n\t * @return {Observable} An Observable that emits values coming from all the\n\t * inner Observables emitted by the source Observable.\n\t * @method mergeAll\n\t * @owner Observable\n\t */\n\tfunction mergeAll$1(concurrent) {\n\t    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t    return this.lift(new MergeAllOperator(concurrent));\n\t}\n\tmergeAll.mergeAll = mergeAll$1;\n\tvar MergeAllOperator = (function () {\n\t    function MergeAllOperator(concurrent) {\n\t        this.concurrent = concurrent;\n\t    }\n\t    MergeAllOperator.prototype.call = function (observer, source) {\n\t        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));\n\t    };\n\t    return MergeAllOperator;\n\t}());\n\tmergeAll.MergeAllOperator = MergeAllOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MergeAllSubscriber = (function (_super) {\n\t    __extends(MergeAllSubscriber, _super);\n\t    function MergeAllSubscriber(destination, concurrent) {\n\t        _super.call(this, destination);\n\t        this.concurrent = concurrent;\n\t        this.hasCompleted = false;\n\t        this.buffer = [];\n\t        this.active = 0;\n\t    }\n\t    MergeAllSubscriber.prototype._next = function (observable) {\n\t        if (this.active < this.concurrent) {\n\t            this.active++;\n\t            this.add(subscribeToResult_1.subscribeToResult(this, observable));\n\t        }\n\t        else {\n\t            this.buffer.push(observable);\n\t        }\n\t    };\n\t    MergeAllSubscriber.prototype._complete = function () {\n\t        this.hasCompleted = true;\n\t        if (this.active === 0 && this.buffer.length === 0) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        var buffer = this.buffer;\n\t        this.remove(innerSub);\n\t        this.active--;\n\t        if (buffer.length > 0) {\n\t            this._next(buffer.shift());\n\t        }\n\t        else if (this.active === 0 && this.hasCompleted) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    return MergeAllSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\tmergeAll.MergeAllSubscriber = MergeAllSubscriber;\n\t\n\treturn mergeAll;\n}\n\nvar hasRequiredConcat$1;\n\nfunction requireConcat$1 () {\n\tif (hasRequiredConcat$1) return concat;\n\thasRequiredConcat$1 = 1;\n\tvar isScheduler_1 = requireIsScheduler();\n\tvar ArrayObservable_1 = requireArrayObservable();\n\tvar mergeAll_1 = requireMergeAll();\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Creates an output Observable which sequentially emits all values from every\n\t * given input Observable after the current Observable.\n\t *\n\t * <span class=\"informal\">Concatenates multiple Observables together by\n\t * sequentially emitting their values, one Observable after the other.</span>\n\t *\n\t * <img src=\"./img/concat.png\" width=\"100%\">\n\t *\n\t * Joins this Observable with multiple other Observables by subscribing to them\n\t * one at a time, starting with the source, and merging their results into the\n\t * output Observable. Will wait for each Observable to complete before moving\n\t * on to the next.\n\t *\n\t * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n\t * var timer = Rx.Observable.interval(1000).take(4);\n\t * var sequence = Rx.Observable.range(1, 10);\n\t * var result = timer.concat(sequence);\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // results in:\n\t * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n\t *\n\t * @example <caption>Concatenate 3 Observables</caption>\n\t * var timer1 = Rx.Observable.interval(1000).take(10);\n\t * var timer2 = Rx.Observable.interval(2000).take(6);\n\t * var timer3 = Rx.Observable.interval(500).take(10);\n\t * var result = timer1.concat(timer2, timer3);\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // results in the following:\n\t * // (Prints to console sequentially)\n\t * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n\t * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n\t * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n\t *\n\t * @see {@link concatAll}\n\t * @see {@link concatMap}\n\t * @see {@link concatMapTo}\n\t *\n\t * @param {Observable} other An input Observable to concatenate after the source\n\t * Observable. More than one input Observables may be given as argument.\n\t * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n\t * Observable subscription on.\n\t * @return {Observable} All values of each passed Observable merged into a\n\t * single Observable, in order, in serial fashion.\n\t * @method concat\n\t * @owner Observable\n\t */\n\tfunction concat$1() {\n\t    var observables = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        observables[_i - 0] = arguments[_i];\n\t    }\n\t    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));\n\t}\n\tconcat.concat = concat$1;\n\t/* tslint:enable:max-line-length */\n\t/**\n\t * Creates an output Observable which sequentially emits all values from every\n\t * given input Observable after the current Observable.\n\t *\n\t * <span class=\"informal\">Concatenates multiple Observables together by\n\t * sequentially emitting their values, one Observable after the other.</span>\n\t *\n\t * <img src=\"./img/concat.png\" width=\"100%\">\n\t *\n\t * Joins multiple Observables together by subscribing to them one at a time and\n\t * merging their results into the output Observable. Will wait for each\n\t * Observable to complete before moving on to the next.\n\t *\n\t * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n\t * var timer = Rx.Observable.interval(1000).take(4);\n\t * var sequence = Rx.Observable.range(1, 10);\n\t * var result = Rx.Observable.concat(timer, sequence);\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // results in:\n\t * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n\t *\n\t * @example <caption>Concatenate 3 Observables</caption>\n\t * var timer1 = Rx.Observable.interval(1000).take(10);\n\t * var timer2 = Rx.Observable.interval(2000).take(6);\n\t * var timer3 = Rx.Observable.interval(500).take(10);\n\t * var result = Rx.Observable.concat(timer1, timer2, timer3);\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * // results in the following:\n\t * // (Prints to console sequentially)\n\t * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n\t * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n\t * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n\t *\n\t * @see {@link concatAll}\n\t * @see {@link concatMap}\n\t * @see {@link concatMapTo}\n\t *\n\t * @param {Observable} input1 An input Observable to concatenate with others.\n\t * @param {Observable} input2 An input Observable to concatenate with others.\n\t * More than one input Observables may be given as argument.\n\t * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n\t * Observable subscription on.\n\t * @return {Observable} All values of each passed Observable merged into a\n\t * single Observable, in order, in serial fashion.\n\t * @static true\n\t * @name concat\n\t * @owner Observable\n\t */\n\tfunction concatStatic() {\n\t    var observables = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        observables[_i - 0] = arguments[_i];\n\t    }\n\t    var scheduler = null;\n\t    var args = observables;\n\t    if (isScheduler_1.isScheduler(args[observables.length - 1])) {\n\t        scheduler = args.pop();\n\t    }\n\t    if (scheduler === null && observables.length === 1) {\n\t        return observables[0];\n\t    }\n\t    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));\n\t}\n\tconcat.concatStatic = concatStatic;\n\t\n\treturn concat;\n}\n\nvar hasRequiredConcat;\n\nfunction requireConcat () {\n\tif (hasRequiredConcat) return concat$1;\n\thasRequiredConcat = 1;\n\tvar Observable_1 = requireObservable();\n\tvar concat_1 = requireConcat$1();\n\tObservable_1.Observable.prototype.concat = concat_1.concat;\n\t\n\treturn concat$1;\n}\n\nvar RouterRx_1;\nvar hasRequiredRouterRx;\n\nfunction requireRouterRx () {\n\tif (hasRequiredRouterRx) return RouterRx_1;\n\thasRequiredRouterRx = 1;\n\tvar RouterRx = {\n\t  Observable: requireObservable().Observable,\n\t  Scheduler: {\n\t    queue: requireQueue().queue\n\t  }\n\t};\n\n\trequireDefer();\n\trequireOf();\n\trequireFrom();\n\trequire_throw();\n\trequireEmpty();\n\n\trequireMergeMap();\n\trequire_do();\n\trequireDefaultIfEmpty();\n\trequireMaterialize$1();\n\trequireExpand();\n\trequireReduce();\n\trequireToArray();\n\trequireMap();\n\trequireFilter();\n\trequire_catch();\n\trequireConcat();\n\n\tRouterRx_1 = RouterRx;\n\treturn RouterRx_1;\n}\n\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n}\n\n/* global window */\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = symbolObservablePonyfill(root);\n\nvar es = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tdefault: result\n});\n\nvar require$$1 = /*@__PURE__*/getAugmentedNamespace(es);\n\nvar outputToObservable;\nvar hasRequiredOutputToObservable;\n\nfunction requireOutputToObservable () {\n\tif (hasRequiredOutputToObservable) return outputToObservable;\n\thasRequiredOutputToObservable = 1;\n\tvar Observable = requireRouterRx().Observable;\n\tvar isArray = Array.isArray;\n\tvar $$observable = require$$1.default;\n\n\t/**\n\t * For the router there are several return types from user\n\t * functions.  The standard set are: synchronous type (boolean or\n\t * json graph) or an async type (observable or a thenable).\n\t */\n\toutputToObservable = function outputToObservable(valueOrObservable) {\n\t    var value = valueOrObservable;\n\n\t    // if it's one of OUR observables, great.\n\t    if (value instanceof Observable) {\n\t        return value;\n\t    }\n\n\t    // falsy value\n\t    if (!value) {\n\t        return Observable.of(value);\n\t    }\n\n\t    // lowercase-o observables, 3rd party observables\n\t    if (value[$$observable]) {\n\t        return Observable.from(value);\n\t    }\n\n\t    // Rx4 and lower observables\n\t    if (value.subscribe) {\n\t        var oldObservable = value;\n\t        return Observable.create(function(observer) {\n\t            var oldObserver = {\n\t              onNext: function (v) {\n\t                  this.observer.next(v);\n\t              },\n\t              onError: function (err) {\n\t                  this.observer.error(err);\n\t              },\n\t              onCompleted: function () {\n\t                  this.observer.complete();\n\t              },\n\t              observer: observer\n\t            };\n\t            var oldSubscription = oldObservable.subscribe(oldObserver);\n\t            return function () {\n\t                oldSubscription.dispose();\n\t            };\n\t        });\n\t    }\n\n\t    // promises\n\t    if (value.then) {\n\t        return Observable.from(value);\n\t    }\n\n\t    // from array of pathValues.\n\t    if (isArray(value)) {\n\t        return Observable.of(value);\n\t    }\n\n\t    // this will be jsong or pathValue at this point.\n\t    // NOTE: For the case of authorize this will be a boolean\n\t    return Observable.of(value);\n\t};\n\treturn outputToObservable;\n}\n\nvar isJSONG;\nvar hasRequiredIsJSONG;\n\nfunction requireIsJSONG () {\n\tif (hasRequiredIsJSONG) return isJSONG;\n\thasRequiredIsJSONG = 1;\n\tisJSONG = function isJSONG(x) {\n\t    return x.jsonGraph;\n\t};\n\treturn isJSONG;\n}\n\nvar errorToPathValue;\nvar hasRequiredErrorToPathValue;\n\nfunction requireErrorToPathValue () {\n\tif (hasRequiredErrorToPathValue) return errorToPathValue;\n\thasRequiredErrorToPathValue = 1;\n\tvar JSONGraphError = JSONGraphErrorExports;\n\terrorToPathValue = function errorToPathValue(error, path) {\n\t    var typeValue = {\n\t        $type: 'error',\n\t        value: {}\n\t    };\n\n\t    if (error.throwToNext) {\n\t        throw error;\n\t    }\n\n\t    // If it is a special JSONGraph error then pull all the data\n\t    if (error instanceof JSONGraphError) {\n\t        typeValue = error.typeValue;\n\t    }\n\n\t    else if (error instanceof Error) {\n\t        typeValue.value.message = error.message;\n\t    }\n\n\t    return {\n\t        path: path,\n\t        value: typeValue\n\t    };\n\t};\n\treturn errorToPathValue;\n}\n\nvar noteToJsongOrPV;\nvar hasRequiredNoteToJsongOrPV;\n\nfunction requireNoteToJsongOrPV () {\n\tif (hasRequiredNoteToJsongOrPV) return noteToJsongOrPV;\n\thasRequiredNoteToJsongOrPV = 1;\n\tvar isJSONG = requireIsJSONG();\n\tvar onNext = 'N';\n\tvar errorToPathValue = requireErrorToPathValue();\n\n\t/**\n\t * Takes a path and for every onNext / onError it will attempt\n\t * to pluck the value or error from the note and process it\n\t * with the path object passed in.\n\t * @param {PathSet|PathSet[]} pathOrPathSet -\n\t * @param {Boolean} isPathSet -\n\t */\n\tnoteToJsongOrPV = function noteToJsongOrPV(pathOrPathSet,\n\t                                          isPathSet,\n\t                                          routerInstance) {\n\t    return function(note) {\n\t        return convertNoteToJsongOrPV(\n\t          pathOrPathSet, note, isPathSet, routerInstance\n\t        );\n\t    };\n\t};\n\n\tfunction convertNoteToJsongOrPV(pathOrPathSet,\n\t                                note,\n\t                                isPathSet,\n\t                                routerInstance) {\n\t    var incomingJSONGOrPathValues;\n\t    var kind = note.kind;\n\n\t    // Take what comes out of the function and assume its either a pathValue or\n\t    // jsonGraph.\n\t    if (kind === onNext) {\n\t        incomingJSONGOrPathValues = note.value;\n\t    }\n\n\t    // Convert the error to a pathValue.\n\t    else {\n\t        incomingJSONGOrPathValues =\n\t            errorToPathValue(note.error, pathOrPathSet);\n\n\t        if (routerInstance._errorHook) {\n\t            routerInstance._errorHook(note.error);\n\t        }\n\t    }\n\n\t    // If its jsong we may need to optionally attach the\n\t    // paths if the paths do not exist\n\t    if (isJSONG(incomingJSONGOrPathValues) &&\n\t        !incomingJSONGOrPathValues.paths) {\n\n\t        incomingJSONGOrPathValues = {\n\t            jsonGraph: incomingJSONGOrPathValues.jsonGraph,\n\t            paths: isPathSet && pathOrPathSet || [pathOrPathSet]\n\t        };\n\t    }\n\n\t    return incomingJSONGOrPathValues;\n\t}\n\treturn noteToJsongOrPV;\n}\n\nvar runGetAction;\nvar hasRequiredRunGetAction;\n\nfunction requireRunGetAction () {\n\tif (hasRequiredRunGetAction) return runGetAction;\n\thasRequiredRunGetAction = 1;\n\tvar outputToObservable = requireOutputToObservable();\n\tvar noteToJsongOrPV = requireNoteToJsongOrPV();\n\tvar Observable = requireRouterRx().Observable;\n\n\trunGetAction = function runGetAction(routerInstance, jsongCache,\n\t    methodSummary) {\n\t    return function innerGetAction(matchAndPath) {\n\t        return getAction(routerInstance, matchAndPath,\n\t            jsongCache, methodSummary);\n\t    };\n\t};\n\n\tfunction getAction(routerInstance, matchAndPath, jsongCache, methodSummary) {\n\t    var match = matchAndPath.match;\n\t    var out;\n\t    try {\n\t        out = match.action.call(routerInstance, matchAndPath.path);\n\t        out = outputToObservable(out);\n\t        if (methodSummary) {\n\t            var _out = out;\n\t            out = Observable.defer(function () {\n\t                var route = {\n\t                    start: routerInstance._now(),\n\t                    route: matchAndPath.match.prettyRoute,\n\t                    pathSet: matchAndPath.path,\n\t                    results: []\n\t                };\n\t                methodSummary.routes.push(route);\n\t                return _out.do(function (response) {\n\t                    route.results.push({\n\t                        time: routerInstance._now(),\n\t                        value: response\n\t                    });\n\t                }, function (err) {\n\t                    route.error = err;\n\t                    route.end = routerInstance._now();\n\t                }, function () {\n\t                    route.end = routerInstance._now();\n\t                });\n\t            });\n\t        }\n\t    } catch (e) {\n\t        out = Observable.throw(e);\n\t    }\n\n\t    return out.\n\t        materialize().\n\t        filter(function(note) {\n\t            return note.kind !== 'C';\n\t        }).\n\t        map(noteToJsongOrPV(matchAndPath.path, false, routerInstance)).\n\t        map(function(jsonGraphOrPV) {\n\t            return [matchAndPath.match, jsonGraphOrPV];\n\t        });\n\t}\n\treturn runGetAction;\n}\n\nvar stripFromRange;\nvar hasRequiredStripFromRange;\n\nfunction requireStripFromRange () {\n\tif (hasRequiredStripFromRange) return stripFromRange;\n\thasRequiredStripFromRange = 1;\n\tvar isArray = Array.isArray;\n\tvar rangeToArray = rangeToArray$2;\n\tvar isNumber = isNumber$2;\n\t/**\n\t *  Takes the first argument, toStrip, and strips it from\n\t * the range.  The output is an array of ranges that represents\n\t * the remaining ranges (relative complement)\n\t *\n\t * One note.  When toStrip is an array, we simply recurse\n\t * over each key.  Else it requires a lot more logic.\n\t *\n\t * Since we recurse array keys we are not guaranteed that each strip\n\t * item coming in is a string integer.  That is why we are doing an isNaN\n\t * check. consider: {from: 0, to: 1} and [0, 'one'] intersect at 0, but will\n\t * get 'one' fed into stripFromRange.\n\t *\n\t * @param {Array|String|Number|Object} argToStrip can be a string, number,\n\t * or a routed token.  Cannot be a range itself.\n\t * @param {Range} range\n\t * @return {Array.<Range>} The relative complement.\n\t */\n\tstripFromRange = function stripFromRange(argToStrip, range) {\n\t    var ranges = [];\n\t    var matches = [];\n\t    var toStrip = argToStrip;\n\t    // TODO: More than likely a bug around numbers and stripping\n\t    var toStripIsNumber = isNumber(toStrip);\n\t    if (toStripIsNumber) {\n\t        toStrip = +toStrip;\n\t    }\n\n\t    // Strip out NaNs\n\t    if (!toStripIsNumber && typeof toStrip === 'string') {\n\t        ranges = [range];\n\t    }\n\n\t    else if (isArray(toStrip)) {\n\t        var currenRanges = [range];\n\t        toStrip.forEach(function(atom) {\n\t            var nextRanges = [];\n\t            currenRanges.forEach(function(currentRename) {\n\t                var matchAndComplement = stripFromRange(atom, currentRename);\n\t                if (matchAndComplement[0] !== undefined) {\n\t                    matches = matches.concat(matchAndComplement[0]);\n\t                }\n\n\t                nextRanges = nextRanges.concat(matchAndComplement[1]);\n\t            });\n\t            currenRanges = nextRanges;\n\t        });\n\n\t        ranges = currenRanges;\n\t    }\n\n\t    // The simple case, its just a number.\n\t    else if (toStripIsNumber) {\n\n\t        if (range.from < toStrip && toStrip < range.to) {\n\t            ranges[0] = {\n\t                from: range.from,\n\t                to: toStrip - 1\n\t            };\n\t            ranges[1] = {\n\t                from: toStrip + 1,\n\t                to: range.to\n\t            };\n\t            matches = [toStrip];\n\t        }\n\n\t        // In case its a 0 length array.\n\t        // Even though this assignment is redundant, its point is\n\t        // to capture the intention.\n\t        else if (range.from === toStrip && range.to === toStrip) {\n\t            ranges = [];\n\t            matches = [toStrip];\n\t        }\n\n\t        else if (range.from === toStrip) {\n\t            ranges[0] = {\n\t                from: toStrip + 1,\n\t                to: range.to\n\t            };\n\t            matches = [toStrip];\n\t        }\n\n\t        else if (range.to === toStrip) {\n\t            ranges[0] = {\n\t                from: range.from,\n\t                to: toStrip - 1\n\t            };\n\t            matches = [toStrip];\n\t        }\n\n\t        // return the range if no intersection.\n\t        else {\n\t            ranges = [range];\n\t        }\n\t    }\n\n\t    // Its a routed token.  Everything is matched.\n\t    else {\n\t        matches = rangeToArray(range);\n\t    }\n\n\t    // If this is a routedToken (Object) then it will match the entire\n\t    // range since its integers, keys, and ranges.\n\t    return [matches, ranges];\n\t};\n\treturn stripFromRange;\n}\n\nvar stripFromArray;\nvar hasRequiredStripFromArray;\n\nfunction requireStripFromArray () {\n\tif (hasRequiredStripFromArray) return stripFromArray;\n\thasRequiredStripFromArray = 1;\n\tvar stripFromRange = requireStripFromRange();\n\tvar Keys = Keys_1;\n\tvar isArray = Array.isArray;\n\n\t/**\n\t * Takes a string, number, or RoutedToken and removes it from\n\t * the array.  The results are the relative complement of what\n\t * remains in the array.\n\t *\n\t * Don't forget: There was an intersection test performed but\n\t * since we recurse over arrays, we will get elements that do\n\t * not intersect.\n\t *\n\t * Another one is if its a routed token and a ranged array then\n\t * no work needs to be done as integers, ranges, and keys match\n\t * that token set.\n\t *\n\t * One more note.  When toStrip is an array, we simply recurse\n\t * over each key.  Else it requires a lot more logic.\n\t *\n\t * @param {Array|String|Number|RoutedToken} toStrip\n\t * @param {Array} array\n\t * @return {Array} the relative complement.\n\t */\n\tstripFromArray = function stripFromArray(toStrip, array) {\n\t    var complement;\n\t    var matches = [];\n\t    var typeToStrip = typeof toStrip;\n\t    var isRangedArray = typeof array[0] === 'object';\n\t    var isNumber = typeToStrip === 'number';\n\t    var isString = typeToStrip === 'string';\n\t    var isRoutedToken = !isNumber && !isString;\n\t    var routeType = isRoutedToken && toStrip.type || false;\n\t    var isKeys = routeType === Keys.keys;\n\t    var toStripIsArray = isArray(toStrip);\n\n\t    // The early break case.  If its a key, then there is never a\n\t    // relative complement.\n\t    if (isKeys) {\n\t        complement = [];\n\t        matches = array;\n\t    }\n\n\t    // Recurse over all the keys of the array.\n\t    else if (toStripIsArray) {\n\t        var currentArray = array;\n\t        toStrip.forEach(function(atom) {\n\t            var results = stripFromArray(atom, currentArray);\n\t            if (results[0] !== undefined) { // eslint-disable-line no-undefined\n\t                matches = matches.concat(results[0]);\n\t            }\n\t            currentArray = results[1];\n\t        });\n\t        complement = currentArray;\n\t    }\n\n\t    // The simple case, remove only the matching element from array.\n\t    else if (!isRangedArray && !isRoutedToken) {\n\t        matches = [toStrip];\n\t        complement = array.filter(function(x) {\n\t            return toStrip !== x;\n\t        });\n\t    }\n\n\t    // 1: from comments above\n\t    else if (isRangedArray && !isRoutedToken) {\n\t        complement = array.reduce(function(comp, range) {\n\t            var results = stripFromRange(toStrip, range);\n\t            if (results[0] !== undefined) { // eslint-disable-line no-undefined\n\t                matches = matches.concat(results[0]);\n\t            }\n\t            return comp.concat(results[1]);\n\t        }, []);\n\t    }\n\n\t    // Strips elements based on routed token type.\n\t    // We already matched keys above, so we only need to strip numbers.\n\t    else if (!isRangedArray && isRoutedToken) {\n\t        complement = array.filter(function(el) {\n\t            var type = typeof el;\n\t            if (type === 'number') {\n\t                matches[matches.length] = el;\n\t                return false;\n\t            }\n\t            return true;\n\t        });\n\t    }\n\n\t    // The final complement is rangedArray with a routedToken,\n\t    // relative complement is always empty.\n\t    else {\n\t        complement = [];\n\t        matches = array;\n\t    }\n\n\t    return [matches, complement];\n\t};\n\treturn stripFromArray;\n}\n\nvar strip;\nvar hasRequiredStrip;\n\nfunction requireStrip () {\n\tif (hasRequiredStrip) return strip;\n\thasRequiredStrip = 1;\n\tvar isArray = Array.isArray;\n\tvar stripFromArray = requireStripFromArray();\n\tvar stripFromRange = requireStripFromRange();\n\n\t/**\n\t *  Takes a virtual atom and the matched atom and returns an\n\t * array of results that is relative complement with matchedAtom\n\t * as the rhs.  I believe the proper set syntax is virutalAtom \\ matchedAtom.\n\t *\n\t * 1) An assumption made is that the matched atom and virtual atom have\n\t * an intersection.  This makes the algorithm easier since if the matched\n\t * atom is a primitive and the virtual atom is an object\n\t * then there is no relative complement to create.  This also means if\n\t * the direct equality test fails and matchedAtom is not an object\n\t * then virtualAtom is an object.  The inverse applies.\n\t *\n\t *\n\t * @param {String|Number|Array|Object} matchedAtom\n\t * @param {String|Number|Array|Object} virtualAtom\n\t * @return {Array} the tuple of what was matched and the relative complenment.\n\t */\n\tstrip = function strip(matchedAtom, virtualAtom) {\n\t    var relativeComplement = [];\n\t    var matchedResults;\n\t    var typeOfMatched = typeof matchedAtom;\n\t    var isArrayMatched = isArray(matchedAtom);\n\t    var isObjectMatched = typeOfMatched === 'object';\n\n\t    // Lets assume they are not objects  This covers the\n\t    // string / number cases.\n\t    if (matchedAtom === virtualAtom ||\n\t       String(matchedAtom) === String(virtualAtom)) {\n\n\t        matchedResults = [matchedAtom];\n\t    }\n\n\t    // See function comment 1)\n\t    else if (!isObjectMatched) {\n\t        matchedResults = [matchedAtom];\n\t    }\n\n\t    // Its a complex object set potentially.  Let the\n\t    // subroutines handle the cases.\n\t    else {\n\t        var results;\n\n\t        // The matchedAtom needs to reduced to everything that is not in\n\t        // the virtualAtom.\n\t        if (isArrayMatched) {\n\t            results = stripFromArray(virtualAtom, matchedAtom);\n\t            matchedResults = results[0];\n\t            relativeComplement = results[1];\n\t        } else {\n\t            results = stripFromRange(virtualAtom, matchedAtom);\n\t            matchedResults = results[0];\n\t            relativeComplement = results[1];\n\t        }\n\t    }\n\n\t    if (matchedResults.length === 1) {\n\t        matchedResults = matchedResults[0];\n\t    }\n\n\t    return [matchedResults, relativeComplement];\n\t};\n\treturn strip;\n}\n\nvar catAndSlice;\nvar hasRequiredCatAndSlice;\n\nfunction requireCatAndSlice () {\n\tif (hasRequiredCatAndSlice) return catAndSlice;\n\thasRequiredCatAndSlice = 1;\n\tcatAndSlice = function catAndSlice(a, b, slice) {\n\t    var next = [], i, j, len;\n\t    for (i = 0, len = a.length; i < len; ++i) {\n\t        next[i] = a[i];\n\t    }\n\n\t    for (j = slice || 0, len = b.length; j < len; ++j, ++i) {\n\t        next[i] = b[j];\n\t    }\n\n\t    return next;\n\t};\n\treturn catAndSlice;\n}\n\nvar stripPath;\nvar hasRequiredStripPath;\n\nfunction requireStripPath () {\n\tif (hasRequiredStripPath) return stripPath;\n\thasRequiredStripPath = 1;\n\tvar strip = requireStrip();\n\tvar catAndSlice = requireCatAndSlice();\n\n\t/**\n\t * Takes in the matched path and virtual path and creates the\n\t * set of paths that represent the virtualPath being stripped\n\t * from the matchedPath.\n\t *\n\t * @example\n\t * Terms:\n\t * * Relative Complement: Of sets A and B the relative complement of A in B is\n\t * the parts of B that A do not contain.  In our example its virtualPath (A) in\n\t * matchedPath (B).\n\t *\n\t * Example:\n\t * matchedInput = [[A, D], [B, E], [C, F]]\n\t * virtualIntput = [A, Keys, C]\n\t *\n\t * This will produce 2 arrays from the matched operation.\n\t * [\n\t *   [D, [B, E], [C, F]],\n\t *   [A, [B, E], [F]]\n\t * ]\n\t *\n\t *\n\t * All the complexity of this function is hidden away in strip and its inner\n\t * stripping functions.\n\t * @param {PathSet} matchedPath\n\t * @param {PathSet} virtualPath\n\t */\n\tstripPath = function stripPath(matchedPath, virtualPath) {\n\t    var relativeComplement = [];\n\t    var exactMatch = [];\n\t    var current = [];\n\n\t    // Always use virtual path because it can be shorter.\n\t    for (var i = 0, len = virtualPath.length; i < len; ++i) {\n\t        var matchedAtom = matchedPath[i];\n\t        var virtualAtom = virtualPath[i];\n\t        var stripResults = strip(matchedAtom, virtualAtom);\n\t        var innerMatch = stripResults[0];\n\t        var innerComplement = stripResults[1];\n\t        var hasComplement = innerComplement.length > 0;\n\n\t        // using the algorithm partially described above we need to split and\n\t        // combine output depending on what comes out of the split function.\n\t        // 1.  If there is no relative complement do no copying / slicing.\n\t        // 2.  If there is both the catAndslice.\n\n\t        if (hasComplement) {\n\t            var flattendIC = innerComplement.length === 1 ?\n\t                innerComplement[0] : innerComplement;\n\t            current[i] = flattendIC;\n\t            relativeComplement[relativeComplement.length] =\n\t                catAndSlice(current, matchedPath, i + 1);\n\t        }\n\n\t        // The exact match needs to be produced for calling function.\n\t        exactMatch[i] = innerMatch;\n\t        current[i] = innerMatch;\n\t    }\n\n\t    return [exactMatch, relativeComplement];\n\t};\n\treturn stripPath;\n}\n\nvar isRange;\nvar hasRequiredIsRange;\n\nfunction requireIsRange () {\n\tif (hasRequiredIsRange) return isRange;\n\thasRequiredIsRange = 1;\n\tisRange = function isRange(range) {\n\t    return range.hasOwnProperty('to') && range.hasOwnProperty('from');\n\t};\n\treturn isRange;\n}\n\nvar hasAtomIntersection;\nvar hasRequiredHasAtomIntersection;\n\nfunction requireHasAtomIntersection () {\n\tif (hasRequiredHasAtomIntersection) return hasAtomIntersection;\n\thasRequiredHasAtomIntersection = 1;\n\tvar Keys = Keys_1;\n\tvar isArray = Array.isArray;\n\tvar isRoutedToken = isRoutedToken$1;\n\tvar isRange = requireIsRange();\n\n\t/**\n\t * Takes a matched and virtual atom and validates that they have an\n\t * intersection.\n\t */\n\thasAtomIntersection = function hasAtomIntersection(matchedAtom, virtualAtom) {\n\t    var virtualIsRoutedToken = isRoutedToken(virtualAtom);\n\t    var isKeys = virtualIsRoutedToken && virtualAtom.type === Keys.keys;\n\t    var matched = false;\n\t    var i, len;\n\n\t    // To simplify the algorithm we do not allow matched atom to be an\n\t    // array.  This makes the intersection test very simple.\n\t    if (isArray(matchedAtom)) {\n\t        for (i = 0, len = matchedAtom.length; i < len && !matched; ++i) {\n\t            matched = hasAtomIntersection(matchedAtom[i], virtualAtom);\n\t        }\n\t    }\n\n\t    // the == is very intentional here with all the use cases review.\n\t    else if (doubleEquals(matchedAtom, virtualAtom)) {\n\t        matched = true;\n\t    }\n\n\t    // Keys match everything.\n\t    else if (isKeys) {\n\t        matched = true;\n\t    }\n\n\t    // The routed token is for integers at this point.\n\t    else if (virtualIsRoutedToken) {\n\t        matched = isNumber(matchedAtom) || isRange(matchedAtom);\n\t    }\n\n\t    // is virtual an array (last option)\n\t    // Go through each of the array elements and compare against matched item.\n\t    else if (isArray(virtualAtom)) {\n\t        for (i = 0, len = virtualAtom.length; i < len && !matched; ++i) {\n\t            matched = hasAtomIntersection(matchedAtom, virtualAtom[i]);\n\t        }\n\t    }\n\n\t    return matched;\n\t};\n\n\t//\n\tfunction isNumber(x) {\n\t    return String(Number(x)) === String(x);\n\t}\n\n\t/**\n\t * This was very intentional ==.  The reason is that '1' must equal 1.\n\t * {} of anysort are always false and array ['one'] == 'one' but that is\n\t * fine because i would have to go through the array anyways at the\n\t * last elseif check.\n\t */\n\tfunction doubleEquals(a, b) {\n\t    return a == b; // eslint-disable-line eqeqeq\n\t}\n\treturn hasAtomIntersection;\n}\n\nvar hasIntersection;\nvar hasRequiredHasIntersection;\n\nfunction requireHasIntersection () {\n\tif (hasRequiredHasIntersection) return hasIntersection;\n\thasRequiredHasIntersection = 1;\n\tvar hasAtomIntersection = requireHasAtomIntersection();\n\n\t/**\n\t * Checks to see if there is an intersection between the matched and\n\t * virtual paths.\n\t */\n\thasIntersection = function hasIntersection(matchedPath, virtualPath) {\n\t    var intersection = true;\n\n\t    // cycles through the atoms and ensure each one has an intersection.\n\t    // only use the virtual path because it can be shorter than the full\n\t    // matched path (since it includes suffix).\n\t    for (var i = 0, len = virtualPath.length; i < len && intersection; ++i) {\n\t        intersection = hasAtomIntersection(matchedPath[i], virtualPath[i]);\n\t    }\n\n\t    return intersection;\n\t};\n\treturn hasIntersection;\n}\n\n/* eslint-disable max-len */\n\nvar getExecutableMatches;\nvar hasRequiredGetExecutableMatches;\n\nfunction requireGetExecutableMatches () {\n\tif (hasRequiredGetExecutableMatches) return getExecutableMatches;\n\thasRequiredGetExecutableMatches = 1;\n\tvar pathUtils = requireLib();\n\tvar collapse = pathUtils.collapse;\n\tvar stripPath = requireStripPath();\n\tvar hasIntersection = requireHasIntersection();\n\t/* eslint-enable max-len */\n\n\t/**\n\t * takes in the set of ordered matches and pathSet that got those matches.\n\t * From there it will give back a list of matches to execute.\n\t */\n\tgetExecutableMatches = function getExecutableMatches(matches, pathSet) {\n\t    var remainingPaths = pathSet;\n\t    var matchAndPaths = [];\n\t    var out = {\n\t        matchAndPaths: matchAndPaths,\n\t        unhandledPaths: false\n\t    };\n\t    for (var i = 0; i < matches.length && remainingPaths.length > 0; ++i) {\n\t        var availablePaths = remainingPaths;\n\t        var match = matches[i];\n\n\t        remainingPaths = [];\n\n\t        if (i > 0) {\n\t            availablePaths = collapse(availablePaths);\n\t        }\n\n\t        // For every available path attempt to intersect.  If there\n\t        // is an intersection then strip and replace.\n\t        // any relative complements, add to remainingPaths\n\t        for (var j = 0; j < availablePaths.length; ++j) {\n\t            var path = availablePaths[j];\n\t            if (hasIntersection(path, match.virtual)) {\n\t                var stripResults = stripPath(path, match.virtual);\n\t                matchAndPaths[matchAndPaths.length] = {\n\t                    path: stripResults[0],\n\t                    match: match\n\t                };\n\t                remainingPaths = remainingPaths.concat(stripResults[1]);\n\t            } else if (i < matches.length - 1) {\n\t                remainingPaths[remainingPaths.length] = path;\n\t            }\n\t        }\n\t    }\n\n\t    // Adds the remaining paths to the unhandled paths section.\n\t    if (remainingPaths && remainingPaths.length) {\n\t        out.unhandledPaths = remainingPaths;\n\t    }\n\n\t    return out;\n\t};\n\treturn getExecutableMatches;\n}\n\nvar runByPrecedence;\nvar hasRequiredRunByPrecedence;\n\nfunction requireRunByPrecedence () {\n\tif (hasRequiredRunByPrecedence) return runByPrecedence;\n\thasRequiredRunByPrecedence = 1;\n\tvar Observable = requireRouterRx().Observable;\n\tvar getExecutableMatches = requireGetExecutableMatches();\n\n\t/**\n\t * Sorts and strips the set of available matches given the pathSet.\n\t */\n\trunByPrecedence = function runByPrecedence(pathSet, matches, actionRunner) {\n\n\t    // Precendence matching\n\t    var sortedMatches = matches.\n\t        sort(function(a, b) {\n\t            if (a.precedence < b.precedence) {\n\t                return 1;\n\t            } else if (a.precedence > b.precedence) {\n\t                return -1;\n\t            }\n\n\t            return 0;\n\t        });\n\n\t    var execs = getExecutableMatches(sortedMatches, [pathSet]);\n\n\t    var setOfMatchedPaths = Observable.\n\t        from(execs.matchAndPaths).\n\t        flatMap(actionRunner).\n\n\t        // Note: We do not wait for each observable to finish,\n\t        // but repeat the cycle per onNext.\n\t        map(function(actionTuple) {\n\n\t            return {\n\t                match: actionTuple[0],\n\t                value: actionTuple[1]\n\t            };\n\t        });\n\n\t    if (execs.unhandledPaths) {\n\t        setOfMatchedPaths = setOfMatchedPaths.\n\t            concat(Observable.of({\n\t                match: {suffix: []},\n\t                value: {\n\t                    isMessage: true,\n\t                    unhandledPaths: execs.unhandledPaths\n\t                }\n\t            }));\n\t    }\n\n\t    return setOfMatchedPaths;\n\t};\n\treturn runByPrecedence;\n}\n\nvar types;\nvar hasRequiredTypes;\n\nfunction requireTypes () {\n\tif (hasRequiredTypes) return types;\n\thasRequiredTypes = 1;\n\ttypes = {\n\t    $ref: 'ref',\n\t    $atom: 'atom',\n\t    $error: 'error'\n\t};\n\treturn types;\n}\n\nvar followReference;\nvar hasRequiredFollowReference;\n\nfunction requireFollowReference () {\n\tif (hasRequiredFollowReference) return followReference;\n\thasRequiredFollowReference = 1;\n\tvar cloneArray = cloneArray_1$1;\n\tvar $ref = requireTypes().$ref;\n\tvar errors = exceptions;\n\n\t/**\n\t * performs the simplified cache reference follow.  This\n\t * differs from get as there is just following and reporting,\n\t * not much else.\n\t *\n\t * @param {Object} cacheRoot\n\t * @param {Array} ref\n\t */\n\tfollowReference = function followReference(cacheRoot, ref, maxRefFollow) {\n\t    var current = cacheRoot;\n\t    var refPath = ref;\n\t    var depth = -1;\n\t    var length = refPath.length;\n\t    var key, next, type;\n\t    var referenceCount = 0;\n\n\t    while (++depth < length) {\n\t        key = refPath[depth];\n\t        next = current[key];\n\t        type = next && next.$type;\n\n\t        if (!next || type && type !== $ref) {\n\t            current = next;\n\t            break;\n\t        }\n\n\t        // Show stopper exception.  This route is malformed.\n\t        if (type && type === $ref && depth + 1 < length) {\n\t            var err = new Error(errors.innerReferences);\n\t            err.throwToNext = true;\n\t            throw err;\n\t        }\n\n\t        // potentially follow reference\n\t        if (depth + 1 === length) {\n\t            if (type === $ref) {\n\t                depth = -1;\n\t                refPath = next.value;\n\t                length = refPath.length;\n\t                next = cacheRoot;\n\t                referenceCount++;\n\t            }\n\n\t            if (referenceCount > maxRefFollow) {\n\t                throw new Error(errors.circularReference);\n\t            }\n\t        }\n\t        current = next;\n\t    }\n\n\t    return [current, cloneArray(refPath)];\n\t};\n\treturn followReference;\n}\n\nvar optimizePathSets;\nvar hasRequiredOptimizePathSets;\n\nfunction requireOptimizePathSets () {\n\tif (hasRequiredOptimizePathSets) return optimizePathSets;\n\thasRequiredOptimizePathSets = 1;\n\tvar iterateKeySet = requireLib().iterateKeySet;\n\tvar cloneArray = cloneArray_1$1;\n\tvar catAndSlice = requireCatAndSlice();\n\tvar $types = requireTypes();\n\tvar $ref = $types.$ref;\n\tvar followReference = requireFollowReference();\n\n\t/**\n\t * The fastest possible optimize of paths.\n\t *\n\t * What it does:\n\t * - Any atom short-circuit / found value will be removed from the path.\n\t * - All paths will be exploded which means that collapse will need to be\n\t *   ran afterwords.\n\t * - Any missing path will be optimized as much as possible.\n\t */\n\toptimizePathSets = function optimizePathSets(cache, paths, maxRefFollow) {\n\t    var optimized = [];\n\t    paths.forEach(function(p) {\n\t        optimizePathSet(cache, cache, p, 0, optimized, [], maxRefFollow);\n\t    });\n\n\t    return optimized;\n\t};\n\n\n\t/**\n\t * optimizes one pathSet at a time.\n\t */\n\tfunction optimizePathSet(cache, cacheRoot, pathSet,\n\t                         depth, out, optimizedPath, maxRefFollow) {\n\n\t    // at missing, report optimized path.\n\t    if (cache === undefined) {\n\t        out[out.length] = catAndSlice(optimizedPath, pathSet, depth);\n\t        return;\n\t    }\n\n\t    // all other sentinels are short circuited.\n\t    // Or we found a primitive (which includes null)\n\t    if (cache === null || (cache.$type && cache.$type !== $ref) ||\n\t            (typeof cache !== 'object')) {\n\t        return;\n\t    }\n\n\t    // If the reference is the last item in the path then do not\n\t    // continue to search it.\n\t    if (cache.$type === $ref && depth === pathSet.length) {\n\t        return;\n\t    }\n\n\t    var keySet = pathSet[depth];\n\t    var nextDepth = depth + 1;\n\t    var iteratorNote = {};\n\t    var key, next, nextOptimized;\n\n\t    key = iterateKeySet(keySet, iteratorNote);\n\t    do {\n\t        next = cache[key];\n\t        var optimizedPathLength = optimizedPath.length;\n\t        if (key !== null) {\n\t            optimizedPath[optimizedPathLength] = key;\n\t        }\n\n\t        if (next && next.$type === $ref && nextDepth < pathSet.length) {\n\t            var refResults =\n\t                followReference(cacheRoot, next.value, maxRefFollow);\n\t            next = refResults[0];\n\n\t            // must clone to avoid the mutation from above destroying the cache.\n\t            nextOptimized = cloneArray(refResults[1]);\n\t        } else {\n\t            nextOptimized = optimizedPath;\n\t        }\n\n\t        optimizePathSet(next, cacheRoot, pathSet, nextDepth,\n\t                        out, nextOptimized, maxRefFollow);\n\t        optimizedPath.length = optimizedPathLength;\n\n\t        if (!iteratorNote.done) {\n\t            key = iterateKeySet(keySet, iteratorNote);\n\t        }\n\t    } while (!iteratorNote.done);\n\t}\n\treturn optimizePathSets;\n}\n\nvar clone;\nvar hasRequiredClone;\n\nfunction requireClone () {\n\tif (hasRequiredClone) return clone;\n\thasRequiredClone = 1;\n\tclone = function copy(valueType) {\n\t    if ((typeof valueType !== 'object') || (valueType === null)) {\n\t        return valueType;\n\t    }\n\n\t    return Object.\n\t        keys(valueType).\n\t        reduce(function(acc, k) {\n\t            acc[k] = valueType[k];\n\t            return acc;\n\t        }, {});\n\t};\n\treturn clone;\n}\n\nvar jsongMerge;\nvar hasRequiredJsongMerge;\n\nfunction requireJsongMerge () {\n\tif (hasRequiredJsongMerge) return jsongMerge;\n\thasRequiredJsongMerge = 1;\n\tvar iterateKeySet = requireLib().iterateKeySet;\n\tvar types = requireTypes();\n\tvar $ref = types.$ref;\n\tvar $error = types.$error;\n\tvar clone = requireClone();\n\tvar cloneArray = cloneArray_1$1;\n\tvar catAndSlice = requireCatAndSlice();\n\n\t/**\n\t * merges jsong into a seed\n\t */\n\tjsongMerge = function jsongMerge(cache, jsongEnv, routerInstance) {\n\t    var paths = jsongEnv.paths;\n\t    var j = jsongEnv.jsonGraph;\n\t    var references = [];\n\t    var values = [];\n\n\t    paths.forEach(function(p) {\n\t        merge({\n\t            router: routerInstance,\n\t            cacheRoot: cache,\n\t            messageRoot: j,\n\t            references: references,\n\t            values: values,\n\t            requestedPath: [],\n\t            requestIdx: -1,\n\t            ignoreCount: 0\n\t        },  cache, j, 0, p);\n\t    });\n\n\t    return {\n\t        references: references,\n\t        values: values\n\t    };\n\t};\n\n\tfunction merge(config, cache, message, depth, path, fromParent, fromKey) {\n\t    var cacheRoot = config.cacheRoot;\n\t    var messageRoot = config.messageRoot;\n\t    var requestedPath = config.requestedPath;\n\t    var ignoreCount = config.ignoreCount;\n\t    var typeOfMessage = typeof message;\n\t    var requestIdx = config.requestIdx;\n\t    var updateRequestedPath = ignoreCount <= depth;\n\t    if (updateRequestedPath) {\n\t        requestIdx = ++config.requestIdx;\n\t    }\n\n\t    // The message at this point should always be defined.\n\t    // Reached the end of the JSONG message path\n\t    if (message === null || typeOfMessage !== 'object' || message.$type) {\n\t        fromParent[fromKey] = clone(message);\n\n\t        // If we notice an error while merging, we'll fire the error hook\n\t        // for logging purposes.\n\t        if (message && message.$type === $error) {\n\t            config.router._pathErrorHook({ path: path, value: message });\n\t        }\n\n\t        // NOTE: If we have found a reference at our cloning position\n\t        // and we have resolved our path then add the reference to\n\t        // the unfulfilledRefernces.\n\t        if (message && message.$type === $ref) {\n\t            var references = config.references;\n\t            references.push({\n\t                path: cloneArray(requestedPath),\n\t                value: message.value\n\t            });\n\t        }\n\n\t        // We are dealing with a value.  We need this for call\n\t        // Call needs to report all of its values into the jsongCache\n\t        // and paths.\n\t        else {\n\t            var values = config.values;\n\t            values.push({\n\t                path: cloneArray(requestedPath),\n\t                value: (message && message.type) ? message.value : message\n\t            });\n\t        }\n\n\t        return;\n\t    }\n\n\t    var outerKey = path[depth];\n\t    var iteratorNote = {};\n\t    var key;\n\t    key = iterateKeySet(outerKey, iteratorNote);\n\n\t    // We always attempt this as a loop.  If the memo exists then\n\t    // we assume that the permutation is needed.\n\t    do {\n\n\t        // If the cache exists and we are not at our height, then\n\t        // just follow cache, else attempt to follow message.\n\t        var cacheRes = cache[key];\n\t        var messageRes = message[key];\n\n\t        // We no longer materialize inside of jsonGraph merge.  Either the\n\t        // client should specify all of the paths\n\t        if (messageRes !== undefined) {\n\n\t            var nextPath = path;\n\t            var nextDepth = depth + 1;\n\t            if (updateRequestedPath) {\n\t                requestedPath[requestIdx] = key;\n\t            }\n\n\t            // We do not continue with this branch since the cache\n\t            if (cacheRes === undefined) {\n\t                cacheRes = cache[key] = {};\n\t            }\n\n\t            var nextIgnoreCount = ignoreCount;\n\n\t            // TODO: Potential performance gain since we know that\n\t            // references are always pathSets of 1, they can be evaluated\n\t            // iteratively.\n\n\t            // There is only a need to consider message references since the\n\t            // merge is only for the path that is provided.\n\t            if (messageRes && messageRes.$type === $ref &&\n\t                depth < path.length - 1) {\n\n\t                nextDepth = 0;\n\t                nextPath = catAndSlice(messageRes.value, path, depth + 1);\n\t                cache[key] = clone(messageRes);\n\n\t                // Reset position in message and cache.\n\t                nextIgnoreCount = messageRes.value.length;\n\t                messageRes = messageRoot;\n\t                cacheRes = cacheRoot;\n\t            }\n\n\t            // move forward down the path progression.\n\t            config.ignoreCount = nextIgnoreCount;\n\t            merge(config, cacheRes, messageRes,\n\t                  nextDepth, nextPath, cache, key);\n\t            config.ignoreCount = ignoreCount;\n\t        }\n\n\t        if (updateRequestedPath) {\n\t            requestedPath.length = requestIdx;\n\t        }\n\n\t        // Are we done with the loop?\n\t        key = iterateKeySet(outerKey, iteratorNote);\n\t    } while (!iteratorNote.done);\n\t}\n\treturn jsongMerge;\n}\n\nvar pathValueMerge;\nvar hasRequiredPathValueMerge;\n\nfunction requirePathValueMerge () {\n\tif (hasRequiredPathValueMerge) return pathValueMerge;\n\thasRequiredPathValueMerge = 1;\n\tvar clone = requireClone();\n\tvar types = requireTypes();\n\tvar $ref = types.$ref;\n\tvar iterateKeySet = requireLib().iterateKeySet;\n\n\t/**\n\t * merges pathValue into a cache\n\t */\n\tpathValueMerge = function pathValueMerge(cache, pathValue) {\n\t    var refs = [];\n\t    var values = [];\n\t    var invalidations = [];\n\t    var valueType = true;\n\n\t    // The pathValue invalidation shape.\n\t    if (pathValue.invalidated === true) {\n\t        invalidations.push({path: pathValue.path});\n\t        valueType = false;\n\t    }\n\n\t    // References.  Needed for evaluationg suffixes in all three types, get,\n\t    // call and set.\n\t    else if ((pathValue.value !== null) && (pathValue.value.$type === $ref)) {\n\t        refs.push({\n\t            path: pathValue.path,\n\t            value: pathValue.value.value\n\t        });\n\t    }\n\n\t    // Values.  Needed for reporting for call.\n\t    else {\n\t        values.push(pathValue);\n\t    }\n\n\t    // If the type of pathValue is a valueType (reference or value) then merge\n\t    // it into the jsonGraph cache.\n\t    if (valueType) {\n\t        innerPathValueMerge(cache, pathValue);\n\t    }\n\n\t    return {\n\t        references: refs,\n\t        values: values,\n\t        invalidations: invalidations\n\t    };\n\t};\n\n\tfunction innerPathValueMerge(cache, pathValue) {\n\t    var path = pathValue.path;\n\t    var curr = cache;\n\t    var next, key, cloned, outerKey, iteratorNote;\n\t    var i, len;\n\n\t    for (i = 0, len = path.length - 1; i < len; ++i) {\n\t        outerKey = path[i];\n\n\t        // Setup the memo and the key.\n\t        if (outerKey && typeof outerKey === 'object') {\n\t            iteratorNote = {};\n\t            key = iterateKeySet(outerKey, iteratorNote);\n\t        } else {\n\t            key = outerKey;\n\t            iteratorNote = false;\n\t        }\n\n\t        do {\n\t            next = curr[key];\n\n\t            if (!next) {\n\t                next = curr[key] = {};\n\t            }\n\n\t            if (iteratorNote) {\n\t                innerPathValueMerge(\n\t                    next, {\n\t                        path: path.slice(i + 1),\n\t                        value: pathValue.value\n\t                    });\n\n\t                if (!iteratorNote.done) {\n\t                    key = iterateKeySet(outerKey, iteratorNote);\n\t                }\n\t            }\n\n\t            else {\n\t                curr = next;\n\t            }\n\t        } while (iteratorNote && !iteratorNote.done);\n\n\t        // All memoized paths need to be stopped to avoid\n\t        // extra key insertions.\n\t        if (iteratorNote) {\n\t            return;\n\t        }\n\t    }\n\n\n\t    // TODO: This clearly needs a re-write.  I am just unsure of how i want\n\t    // this to look.  Plus i want to measure performance.\n\t    outerKey = path[i];\n\n\t    iteratorNote = {};\n\t    key = iterateKeySet(outerKey, iteratorNote);\n\n\t    do {\n\n\t        cloned = clone(pathValue.value);\n\t        curr[key] = cloned;\n\n\t        if (!iteratorNote.done) {\n\t            key = iterateKeySet(outerKey, iteratorNote);\n\t        }\n\t    } while (!iteratorNote.done);\n\t}\n\treturn pathValueMerge;\n}\n\nvar isMessage;\nvar hasRequiredIsMessage;\n\nfunction requireIsMessage () {\n\tif (hasRequiredIsMessage) return isMessage;\n\thasRequiredIsMessage = 1;\n\tisMessage = function isMessage(output) {\n\t    return output.hasOwnProperty('isMessage');\n\t};\n\treturn isMessage;\n}\n\nvar mergeCacheAndGatherRefsAndInvalidations_1;\nvar hasRequiredMergeCacheAndGatherRefsAndInvalidations;\n\nfunction requireMergeCacheAndGatherRefsAndInvalidations () {\n\tif (hasRequiredMergeCacheAndGatherRefsAndInvalidations) return mergeCacheAndGatherRefsAndInvalidations_1;\n\thasRequiredMergeCacheAndGatherRefsAndInvalidations = 1;\n\tvar jsongMerge = requireJsongMerge();\n\tvar pathValueMerge = requirePathValueMerge();\n\tvar isJSONG = requireIsJSONG();\n\tvar isMessage = requireIsMessage();\n\tmergeCacheAndGatherRefsAndInvalidations_1 = mergeCacheAndGatherRefsAndInvalidations;\n\n\t/**\n\t * takes the response from an action and merges it into the\n\t * cache.  Anything that is an invalidation will be added to\n\t * the first index of the return value, and the inserted refs\n\t * are the second index of the return value.  The third index\n\t * of the return value is messages from the action handlers\n\t *\n\t * @param {Object} cache\n\t * @param {Array} jsongOrPVs\n\t */\n\tfunction mergeCacheAndGatherRefsAndInvalidations(\n\t    cache, jsongOrPVs, routerInstance\n\t) {\n\t    var references = [];\n\t    var len = -1;\n\t    var invalidations = [];\n\t    var unhandledPaths = [];\n\t    var messages = [];\n\t    var values = [];\n\n\t    // Go through each of the outputs from the route end point and separate out\n\t    // each type of potential output.\n\t    //\n\t    // * There are values that need to be merged into the JSONGraphCache\n\t    // * There are references that need to be merged and potentially followed\n\t    // * There are messages that can alter the behavior of the\n\t    //   recurseMatchAndExecute cycle.\n\t    // * unhandledPaths happens when a path matches a route but the route does\n\t    //   not match the entire path, therefore there is unmatched paths.\n\t    jsongOrPVs.forEach(function(jsongOrPV) {\n\t        var refsAndValues = [];\n\n\t        if (isMessage(jsongOrPV)) {\n\t            messages[messages.length] = jsongOrPV;\n\t        }\n\n\t        else if (isJSONG(jsongOrPV)) {\n\t            refsAndValues = jsongMerge(cache, jsongOrPV, routerInstance);\n\t        }\n\n\t        // Last option are path values.\n\t        else {\n\t            refsAndValues = pathValueMerge(cache, jsongOrPV);\n\t        }\n\n\t        var refs = refsAndValues.references;\n\t        var vals = refsAndValues.values;\n\t        var invs = refsAndValues.invalidations;\n\t        var unhandled = refsAndValues.unhandledPaths;\n\n\t        if (vals && vals.length) {\n\t            values = values.concat(vals);\n\t        }\n\n\t        if (invs && invs.length) {\n\t            invalidations = invalidations.concat(invs);\n\t        }\n\n\t        if (unhandled && unhandled.length) {\n\t            unhandledPaths = unhandledPaths.concat(unhandled);\n\t        }\n\n\t        if (refs && refs.length) {\n\t            refs.forEach(function(ref) {\n\t                references[++len] = ref;\n\t            });\n\t        }\n\t    });\n\n\t    return {\n\t        invalidations: invalidations,\n\t        references: references,\n\t        messages: messages,\n\t        values: values,\n\t        unhandledPaths: unhandledPaths\n\t    };\n\t}\n\treturn mergeCacheAndGatherRefsAndInvalidations_1;\n}\n\nvar recurseMatchAndExecute;\nvar hasRequiredRecurseMatchAndExecute;\n\nfunction requireRecurseMatchAndExecute () {\n\tif (hasRequiredRecurseMatchAndExecute) return recurseMatchAndExecute;\n\thasRequiredRecurseMatchAndExecute = 1;\n\tvar Rx = requireRouterRx();\n\tvar Observable = Rx.Observable;\n\tvar runByPrecedence = requireRunByPrecedence();\n\tvar pathUtils = requireLib();\n\tvar collapse = pathUtils.collapse;\n\tvar optimizePathSets = requireOptimizePathSets();\n\tvar mCGRI = requireMergeCacheAndGatherRefsAndInvalidations();\n\tvar isArray = Array.isArray;\n\n\t/**\n\t * The recurse and match function will async recurse as long as\n\t * there are still more paths to be executed.  The match function\n\t * will return a set of objects that have how much of the path that\n\t * is matched.  If there still is more, denoted by suffixes,\n\t * paths to be matched then the recurser will keep running.\n\t */\n\trecurseMatchAndExecute = function recurseMatchAndExecute(\n\t        match, actionRunner, paths,\n\t        method, routerInstance, jsongCache) {\n\n\t    return _recurseMatchAndExecute(\n\t        match, actionRunner, paths,\n\t        method, routerInstance, jsongCache);\n\t};\n\n\t/**\n\t * performs the actual recursing\n\t */\n\tfunction _recurseMatchAndExecute(\n\t        match, actionRunner, paths,\n\t        method, routerInstance, jsongCache) {\n\t    var unhandledPaths = [];\n\t    var invalidated = [];\n\t    var reportedPaths = [];\n\t    var currentMethod = method;\n\t    return Observable.\n\n\t        // Each pathSet (some form of collapsed path) need to be sent\n\t        // independently.  for each collapsed pathSet will, if producing\n\t        // refs, be the highest likelihood of collapsibility.\n\t        from(paths).\n\t        expand(function(nextPaths) {\n\t            if (!nextPaths.length) {\n\t                return Observable.empty();\n\t            }\n\n\t            // We have to return an Observable of error instead of just\n\t            // throwing.\n\t            var matchedResults;\n\t            try {\n\t                matchedResults = match(currentMethod, nextPaths);\n\t            } catch (e) {\n\t                return Observable.throw(e);\n\t            }\n\n\t            // When there is explicitly not a match then we need to handle\n\t            // the unhandled paths.\n\t            if (!matchedResults.length) {\n\t                unhandledPaths.push(nextPaths);\n\t                return Observable.empty();\n\t            }\n\t            return runByPrecedence(nextPaths, matchedResults, actionRunner).\n\t                // Generate from the combined results the next requestable paths\n\t                // and insert errors / values into the cache.\n\t                flatMap(function(results) {\n\t                    var value = results.value;\n\t                    var suffix = results.match.suffix;\n\n\t                    // TODO: MaterializedPaths, use result.path to build up a\n\t                    // \"foundPaths\" array.  This could be used to materialize\n\t                    // if that is the case.  I don't think this is a\n\t                    // requirement, but it could be.\n\t                    if (!isArray(value)) {\n\t                        value = [value];\n\t                    }\n\n\t                    var invsRefsAndValues =\n\t                        mCGRI(jsongCache, value, routerInstance);\n\t                    var invalidations = invsRefsAndValues.invalidations;\n\t                    var unhandled = invsRefsAndValues.unhandledPaths;\n\t                    var messages = invsRefsAndValues.messages;\n\t                    var pathsToExpand = [];\n\n\t                    if (suffix.length > 0) {\n\t                        pathsToExpand = invsRefsAndValues.references;\n\t                    }\n\n\t                    // Merge the invalidations and unhandledPaths.\n\t                    invalidations.forEach(function(invalidation) {\n\t                        invalidated[invalidated.length] = invalidation.path;\n\t                    });\n\n\t                    unhandled.forEach(function(unhandledPath) {\n\t                        unhandledPaths[unhandledPaths.length] = unhandledPath;\n\t                    });\n\n\t                    // Merges the remaining suffix with remaining nextPaths\n\t                    pathsToExpand = pathsToExpand.map(function(next) {\n\t                        return next.value.concat(suffix);\n\t                    });\n\n\t                    // Alters the behavior of the expand\n\t                    messages.forEach(function(message) {\n\t                        // mutates the method type for the matcher\n\t                        if (message.method) {\n\t                            currentMethod = message.method;\n\t                        }\n\n\t                        // Mutates the nextPaths and adds any additionalPaths\n\t                        else if (message.additionalPath) {\n\t                            var path = message.additionalPath;\n\t                            pathsToExpand[pathsToExpand.length] = path;\n\t                            reportedPaths[reportedPaths.length] = path;\n\t                        }\n\n\t                        // Any invalidations that come down from a call\n\t                        else if (message.invalidations) {\n\t                            message.\n\t                                invalidations.\n\t                                forEach(function(invalidation) {\n\t                                    invalidated.push(invalidation);\n\t                                });\n\t                        }\n\n\t                        // We need to add the unhandledPaths to the jsonGraph\n\t                        // response.\n\t                        else if (message.unhandledPaths) {\n\t                            unhandledPaths = unhandledPaths.\n\t                                concat(message.unhandledPaths);\n\t                        }\n\t                    });\n\n\t                    // Explodes and collapse the tree to remove\n\t                    // redundants and get optimized next set of\n\t                    // paths to evaluate.\n\t                    pathsToExpand = optimizePathSets(\n\t                        jsongCache, pathsToExpand, routerInstance.maxRefFollow);\n\n\t                    if (pathsToExpand.length) {\n\t                        pathsToExpand = collapse(pathsToExpand);\n\t                    }\n\n\t                    return Observable.\n\t                        from(pathsToExpand);\n\t                }).\n\t                defaultIfEmpty([]);\n\n\t        }, Number.POSITIVE_INFINITY, Rx.Scheduler.queue).\n\t        reduce(function(acc, x) {\n\t            return acc;\n\t        }, null).\n\t        map(function() {\n\t            return {\n\t                unhandledPaths: unhandledPaths,\n\t                invalidated: invalidated,\n\t                jsonGraph: jsongCache,\n\t                reportedPaths: reportedPaths\n\t            };\n\t        });\n\t}\n\treturn recurseMatchAndExecute;\n}\n\n/**\n * takes in a range and normalizes it to have a to / from\n */\n\nvar normalize;\nvar hasRequiredNormalize;\n\nfunction requireNormalize () {\n\tif (hasRequiredNormalize) return normalize;\n\thasRequiredNormalize = 1;\n\tnormalize = function normalize(range) {\n\t    var from = range.from || 0;\n\t    var to;\n\t    if (typeof range.to === 'number') {\n\t        to = range.to;\n\t    } else {\n\t        to = from + range.length - 1;\n\t    }\n\n\t    return {to: to, from: from};\n\t};\n\treturn normalize;\n}\n\nvar normalizePathSets;\nvar hasRequiredNormalizePathSets;\n\nfunction requireNormalizePathSets () {\n\tif (hasRequiredNormalizePathSets) return normalizePathSets;\n\thasRequiredNormalizePathSets = 1;\n\tvar normalize = requireNormalize();\n\n\t/**\n\t * warning:  This mutates the array of arrays.\n\t * It only converts the ranges to properly normalized ranges\n\t * so the rest of the algos do not have to consider it.\n\t */\n\tnormalizePathSets = function normalizePathSets(path) {\n\t    path.forEach(function(key, i) {\n\t        // the algo becomes very simple if done recursively.  If\n\t        // speed is needed, this is an easy optimization to make.\n\t        if (Array.isArray(key)) {\n\t            normalizePathSets(key);\n\t        }\n\n\t        else if (typeof key === 'object') {\n\t            path[i] = normalize(path[i]);\n\t        }\n\t    });\n\t    return path;\n\t};\n\treturn normalizePathSets;\n}\n\nvar materialize;\nvar hasRequiredMaterialize;\n\nfunction requireMaterialize () {\n\tif (hasRequiredMaterialize) return materialize;\n\thasRequiredMaterialize = 1;\n\tvar pathValueMerge = requirePathValueMerge();\n\tvar optimizePathSets = requireOptimizePathSets();\n\tvar $atom = requireTypes().$atom;\n\n\t/**\n\t * given a set of paths and a jsonGraph envelope, materialize missing will\n\t * crawl all the paths to ensure that they have been fully filled in.  The\n\t * paths that are missing will be filled with materialized atoms.\n\t */\n\tmaterialize = function materializeMissing(router, paths, jsongEnv) {\n\t    var jsonGraph = jsongEnv.jsonGraph;\n\t    var materializedAtom = {$type: $atom};\n\n\t    // Optimizes the pathSets from the jsong then\n\t    // inserts atoms of undefined.\n\t    optimizePathSets(jsonGraph, paths, router.maxRefFollow).\n\t        forEach(function(optMissingPath) {\n\t            pathValueMerge(jsonGraph, {\n\t                path: optMissingPath,\n\t                value: materializedAtom\n\t            });\n\t        });\n\n\t    return {jsonGraph: jsonGraph};\n\t};\n\treturn materialize;\n}\n\nvar MaxPathsExceededError_1;\nvar hasRequiredMaxPathsExceededError;\n\nfunction requireMaxPathsExceededError () {\n\tif (hasRequiredMaxPathsExceededError) return MaxPathsExceededError_1;\n\thasRequiredMaxPathsExceededError = 1;\n\tvar MESSAGE = \"Maximum number of paths exceeded.\";\n\n\tvar MaxPathsExceededError = function MaxPathsExceededError(message) {\n\t    this.message = message === undefined ? MESSAGE : message;\n\t    this.stack = (new Error()).stack;\n\t};\n\n\tMaxPathsExceededError.prototype = new Error();\n\tMaxPathsExceededError.prototype.throwToNext = true;\n\n\tMaxPathsExceededError_1 = MaxPathsExceededError;\n\treturn MaxPathsExceededError_1;\n}\n\nvar getPathsCount_1;\nvar hasRequiredGetPathsCount;\n\nfunction requireGetPathsCount () {\n\tif (hasRequiredGetPathsCount) return getPathsCount_1;\n\thasRequiredGetPathsCount = 1;\n\tvar falcorPathUtils = requireLib();\n\n\tfunction getPathsCount(pathSets) {\n\t    return pathSets.reduce(function(numPaths, pathSet) {\n\t        return numPaths + falcorPathUtils.pathCount(pathSet);\n\t    }, 0);\n\t}\n\n\tgetPathsCount_1 = getPathsCount;\n\treturn getPathsCount_1;\n}\n\nvar rxNewToRxNewAndOld;\nvar hasRequiredRxNewToRxNewAndOld;\n\nfunction requireRxNewToRxNewAndOld () {\n\tif (hasRequiredRxNewToRxNewAndOld) return rxNewToRxNewAndOld;\n\thasRequiredRxNewToRxNewAndOld = 1;\n\tfunction noop() {}\n\n\tfunction toRxNewObserver(observer) {\n\t    var onNext = observer.onNext;\n\t    var onError = observer.onError;\n\t    var onCompleted = observer.onCompleted;\n\t    if (\n\t        typeof onNext !== \"function\" &&\n\t        typeof onError !== \"function\" &&\n\t        typeof onCompleted !== \"function\"\n\t    ) {\n\t        return observer;\n\t    }\n\t    // old observer!\n\t    return {\n\t        next: typeof onNext === \"function\"\n\t            ? function(x) {\n\t                  this.destination.onNext(x);\n\t              }\n\t            : noop,\n\t        error: typeof onError === \"function\"\n\t            ? function(err) {\n\t                  this.destination.onError(err);\n\t              }\n\t            : noop,\n\t        complete: typeof onCompleted === \"function\"\n\t            ? function() {\n\t                  this.destination.onCompleted();\n\t              }\n\t            : noop,\n\t        destination: observer\n\t    };\n\t}\n\n\t// WHY NOT BOTH?\n\trxNewToRxNewAndOld = function rxNewToRxNewAndOld(rxNewObservable) {\n\t    var _subscribe = rxNewObservable.subscribe;\n\n\t    rxNewObservable.subscribe = function(observerOrNextFn, errFn, compFn) {\n\t        var subscription;\n\t        if (typeof observerOrNextFn !== \"object\" || observerOrNextFn === null) {\n\t            subscription = _subscribe.call(\n\t                this,\n\t                observerOrNextFn,\n\t                errFn,\n\t                compFn\n\t            );\n\t        } else {\n\t            var observer = toRxNewObserver(observerOrNextFn);\n\t            subscription = _subscribe.call(this, observer);\n\t        }\n\n\t        var _unsubscribe = subscription.unsubscribe;\n\n\t        subscription.unsubscribe = subscription.dispose = function() {\n\t            this.isDisposed = true;\n\t            _unsubscribe.call(this);\n\t        };\n\n\t        return subscription;\n\t    };\n\n\t    return rxNewObservable;\n\t};\n\treturn rxNewToRxNewAndOld;\n}\n\nvar get_1;\nvar hasRequiredGet;\n\nfunction requireGet () {\n\tif (hasRequiredGet) return get_1;\n\thasRequiredGet = 1;\n\tvar runGetAction = requireRunGetAction();\n\tvar get = 'get';\n\tvar recurseMatchAndExecute = requireRecurseMatchAndExecute();\n\tvar normalizePathSets = requireNormalizePathSets();\n\tvar materialize = requireMaterialize();\n\tvar Observable = requireRouterRx().Observable;\n\tvar mCGRI = requireMergeCacheAndGatherRefsAndInvalidations();\n\tvar MaxPathsExceededError = requireMaxPathsExceededError();\n\tvar getPathsCount = requireGetPathsCount();\n\tvar outputToObservable = requireOutputToObservable();\n\tvar rxNewToRxNewAndOld = requireRxNewToRxNewAndOld();\n\n\t/**\n\t * The router get function\n\t */\n\tget_1 = function routerGet(paths) {\n\n\t    var router = this;\n\n\t    return rxNewToRxNewAndOld(Observable.defer(function() {\n\t        var methodSummary;\n\t        if (router._methodSummaryHook) {\n\t            methodSummary = {\n\t                method: 'get',\n\t                pathSets: paths,\n\t                start: router._now(),\n\t                results: [],\n\t                routes: []\n\t            };\n\t        }\n\n\t        var result = Observable.defer(function () {\n\t            var jsongCache = {};\n\t            var action = runGetAction(router, jsongCache, methodSummary);\n\t            var normPS = normalizePathSets(paths);\n\n\t            if (getPathsCount(normPS) > router.maxPaths) {\n\t                throw new MaxPathsExceededError();\n\t            }\n\n\t            return recurseMatchAndExecute(router._matcher, action, normPS,\n\t                                        get, router, jsongCache).\n\n\t                // Turn it(jsongGraph, invalidations, missing, etc.) into a\n\t                // jsonGraph envelope\n\t                flatMap(function flatMapAfterRouterGet(details) {\n\t                    var out = {\n\t                        jsonGraph: details.jsonGraph\n\t                    };\n\n\n\t                    // If the unhandledPaths are present then we need to\n\t                    // call the backup method for generating materialized.\n\t                    if (details.unhandledPaths.length && router._unhandled) {\n\t                        var unhandledPaths = details.unhandledPaths;\n\n\t                        // The 3rd argument is the beginning of the actions\n\t                        // arguments, which for get is the same as the\n\t                        // unhandledPaths.\n\t                        return outputToObservable(\n\t                            router._unhandled.get(unhandledPaths)).\n\n\t                            // Merge the solution back into the overall message.\n\t                            map(function(jsonGraphFragment) {\n\t                                mCGRI(out.jsonGraph, [{\n\t                                    jsonGraph: jsonGraphFragment.jsonGraph,\n\t                                    paths: unhandledPaths\n\t                                }], router);\n\t                                return out;\n\t                            }).\n\t                            defaultIfEmpty(out);\n\t                    }\n\n\t                    return Observable.of(out);\n\t                }).\n\n\t            // We will continue to materialize over the whole jsonGraph message.\n\t            // This makes sense if you think about pathValues and an API that if\n\t            // ask for a range of 10 and only 8 were returned, it would not\n\t            // materialize for you, instead, allow the router to do that.\n\t                map(function(jsonGraphEnvelope) {\n\t                    return materialize(router, normPS, jsonGraphEnvelope);\n\t                });\n\t        });\n\n\t        if (router._methodSummaryHook || router._errorHook) {\n\t            result = result.\n\t                do(function (response) {\n\t                    if (router._methodSummaryHook) {\n\t                        methodSummary.results.push({\n\t                            time: router._now(),\n\t                            value: response\n\t                        });\n\t                    }\n\t                }, function (err) {\n\t                    if (router._methodSummaryHook) {\n\t                        methodSummary.end = router._now();\n\t                        methodSummary.error = err;\n\t                        router._methodSummaryHook(methodSummary);\n\t                    }\n\t                    if (router._errorHook) {\n\t                        router._errorHook(err);\n\t                    }\n\t                }, function () {\n\t                    if (router._methodSummaryHook) {\n\t                        methodSummary.end = router._now();\n\t                        router._methodSummaryHook(methodSummary);\n\t                    }\n\t                });\n\t        }\n\n\t        return result;\n\t    }));\n\t};\n\treturn get_1;\n}\n\nvar spreadPaths;\nvar hasRequiredSpreadPaths;\n\nfunction requireSpreadPaths () {\n\tif (hasRequiredSpreadPaths) return spreadPaths;\n\thasRequiredSpreadPaths = 1;\n\tvar iterateKeySet = requireLib().iterateKeySet;\n\tvar cloneArray = cloneArray_1$1;\n\n\t/**\n\t * Takes in a ptahSet and will create a set of simple paths.\n\t * @param {Array} paths\n\t */\n\tspreadPaths = function spreadPaths(paths) {\n\t    var allPaths = [];\n\t    paths.forEach(function(x) {\n\t        _spread(x, 0, allPaths);\n\t    });\n\n\t    return allPaths;\n\t};\n\n\tfunction _spread(pathSet, depth, out, currentPath) {\n\n\t    /* eslint-disable no-param-reassign */\n\t    currentPath = currentPath || [];\n\t    /* eslint-enable no-param-reassign */\n\n\t    if (depth === pathSet.length) {\n\t        out[out.length] = cloneArray(currentPath);\n\t        return;\n\t    }\n\n\t    // Simple case\n\t    var key = pathSet[depth];\n\t    if (typeof key !== 'object') {\n\t        currentPath[depth] = key;\n\t        _spread(pathSet, depth + 1, out, currentPath);\n\t        return;\n\t    }\n\n\t    // complex key.\n\t    var iteratorNote = {};\n\t    var innerKey = iterateKeySet(key, iteratorNote);\n\t    do {\n\t        // spreads the paths\n\t        currentPath[depth] = innerKey;\n\t        _spread(pathSet, depth + 1, out, currentPath);\n\t        currentPath.length = depth;\n\n\t        innerKey = iterateKeySet(key, iteratorNote);\n\t    } while (!iteratorNote.done);\n\t}\n\treturn spreadPaths;\n}\n\n/**\n * To simplify this algorithm, the path must be a simple\n * path with no complex keys.\n *\n * Note: The path coming in must contain no references, as\n * all set data caches have no references.\n * @param {Object} cache\n * @param {PathSet} path\n */\n\nvar getValue;\nvar hasRequiredGetValue;\n\nfunction requireGetValue () {\n\tif (hasRequiredGetValue) return getValue;\n\thasRequiredGetValue = 1;\n\tgetValue = function getValue(cache, path) {\n\t    return path.reduce(function(acc, key) {\n\t        return acc[key];\n\t    }, cache);\n\t};\n\treturn getValue;\n}\n\n/* eslint-disable max-len */\n\nvar runSetAction_1;\nvar hasRequiredRunSetAction;\n\nfunction requireRunSetAction () {\n\tif (hasRequiredRunSetAction) return runSetAction_1;\n\thasRequiredRunSetAction = 1;\n\tvar outputToObservable = requireOutputToObservable();\n\tvar noteToJsongOrPV = requireNoteToJsongOrPV();\n\tvar spreadPaths = requireSpreadPaths();\n\tvar getValue = requireGetValue();\n\tvar jsongMerge = requireJsongMerge();\n\tvar optimizePathSets = requireOptimizePathSets();\n\tvar hasIntersection = requireHasIntersection();\n\tvar pathValueMerge = requirePathValueMerge();\n\tvar Observable = requireRouterRx().Observable;\n\t/* eslint-enable max-len */\n\n\trunSetAction_1 = function outerRunSetAction(routerInstance, modelContext,\n\t                                            jsongCache, methodSummary) {\n\t    return function innerRunSetAction(matchAndPath) {\n\t        return runSetAction(routerInstance, modelContext,\n\t                            matchAndPath, jsongCache, methodSummary);\n\t    };\n\t};\n\n\tfunction runSetAction(routerInstance, jsongMessage, matchAndPath,\n\t    jsongCache, methodSummary) {\n\t    var match = matchAndPath.match;\n\t    var out;\n\t    var arg = matchAndPath.path;\n\n\t    // We are at out destination.  Its time to get out\n\t    // the pathValues from the\n\t    if (match.isSet) {\n\t        var paths = spreadPaths(jsongMessage.paths);\n\n\t        // We have to ensure that the paths maps in order\n\t        // to the optimized paths array.\n\t        var optimizedPathsAndPaths =\n\t            paths.\n\t                // Optimizes each path.\n\t                map(function(path) {\n\t                    return [optimizePathSets(\n\t                        jsongCache, [path], routerInstance.maxRefFollow)[0],\n\t                        path];\n\t                }).\n\t                // only includes the paths from the set that intersect\n\t                // the virtual path\n\t                filter(function(optimizedAndPath) {\n\t                    return optimizedAndPath[0] &&\n\t                        hasIntersection(optimizedAndPath[0], match.virtual);\n\t                });\n\t        var optimizedPaths = optimizedPathsAndPaths.map(function(opp) {\n\t            return opp[0];\n\t        });\n\t        var subSetPaths = optimizedPathsAndPaths.map(function(opp) {\n\t            return opp[1];\n\t        });\n\t        var tmpJsonGraph = subSetPaths.\n\t            reduce(function(json, path, i) {\n\t                pathValueMerge(json, {\n\t                    path: optimizedPaths[i],\n\t                    value: getValue(jsongMessage.jsonGraph, path)\n\t                });\n\t                return json;\n\t            }, {});\n\n\t        // Takes the temporary JSONGraph, attaches only the matched paths\n\t        // then creates the subset json and assigns it to the argument to\n\t        // the set function.\n\t        var subJsonGraphEnv = {\n\t            jsonGraph: tmpJsonGraph,\n\t            paths: [match.requested]\n\t        };\n\t        arg = {};\n\t        jsongMerge(arg, subJsonGraphEnv, routerInstance);\n\t    }\n\t    try {\n\t        out = match.action.call(routerInstance, arg);\n\t        out = outputToObservable(out);\n\n\t        if (methodSummary) {\n\t            var _out = out;\n\t            out = Observable.defer(function () {\n\t                var route = {\n\t                    route: matchAndPath.match.prettyRoute,\n\t                    pathSet: matchAndPath.path,\n\t                    start: routerInstance._now()\n\t                };\n\t                methodSummary.routes.push(route);\n\n\t                return _out.do(\n\t                    function (result) {\n\t                        route.results = route.results || [];\n\t                        route.results.push({\n\t                            time: routerInstance._now(),\n\t                            value: result\n\t                        });\n\t                    },\n\t                    function (err) {\n\t                        route.error = err;\n\t                        route.end = routerInstance._now();\n\t                    },\n\t                    function () {\n\t                        route.end = routerInstance._now();\n\t                    }\n\t                )\n\t            });\n\t        }\n\t    } catch (e) {\n\t        out = Observable.throw(e);\n\t    }\n\n\t    return out.\n\t        materialize().\n\t        filter(function(note) {\n\t            return note.kind !== 'C';\n\t        }).\n\t        map(noteToJsongOrPV(matchAndPath.path, false, routerInstance)).\n\t        map(function(jsonGraphOrPV) {\n\t            return [matchAndPath.match, jsonGraphOrPV];\n\t        });\n\t}\n\treturn runSetAction_1;\n}\n\n/**\n * @param {PathSet} path - A simple path\n * @param {Object} tree - The tree should have `null` leaves to denote a\n * leaf node.\n */\n\nvar hasIntersectionWithTree;\nvar hasRequiredHasIntersectionWithTree;\n\nfunction requireHasIntersectionWithTree () {\n\tif (hasRequiredHasIntersectionWithTree) return hasIntersectionWithTree;\n\thasRequiredHasIntersectionWithTree = 1;\n\thasIntersectionWithTree = function hasIntersectionWithTree(path, tree) {\n\t    return _hasIntersection(path, tree, 0);\n\t};\n\n\tfunction _hasIntersection(path, node, depth) {\n\n\t    // Exit / base condition.  We have reached the\n\t    // length of our path and we are at a node of null.\n\t    if (depth === path.length && node === null) {\n\t        return true;\n\t    }\n\n\t    var key = path[depth];\n\t    var next = node[key];\n\n\t    // If its not undefined, then its a branch.\n\t    if (node !== undefined) {\n\t        return _hasIntersection(path, next, depth + 1);\n\t    }\n\n\t    return false;\n\t}\n\treturn hasIntersectionWithTree;\n}\n\nvar set_1;\nvar hasRequiredSet;\n\nfunction requireSet () {\n\tif (hasRequiredSet) return set_1;\n\thasRequiredSet = 1;\n\tvar set = 'set';\n\tvar recurseMatchAndExecute = requireRecurseMatchAndExecute();\n\tvar runSetAction = requireRunSetAction();\n\tvar materialize = requireMaterialize();\n\tvar Observable = requireRouterRx().Observable;\n\tvar spreadPaths = requireSpreadPaths();\n\tvar pathValueMerge = requirePathValueMerge();\n\tvar optimizePathSets = requireOptimizePathSets();\n\tvar hasIntersectionWithTree =\n\t    requireHasIntersectionWithTree();\n\tvar getValue = requireGetValue();\n\tvar normalizePathSets = requireNormalizePathSets();\n\tvar pathUtils = requireLib();\n\tvar collapse = pathUtils.collapse;\n\tvar mCGRI = requireMergeCacheAndGatherRefsAndInvalidations();\n\tvar MaxPathsExceededError = requireMaxPathsExceededError();\n\tvar getPathsCount = requireGetPathsCount();\n\tvar outputToObservable = requireOutputToObservable();\n\tvar rxNewToRxNewAndOld = requireRxNewToRxNewAndOld();\n\n\t/**\n\t * @returns {Observable.<JSONGraph>}\n\t * @private\n\t */\n\tset_1 = function routerSet(jsonGraph) {\n\n\t    var router = this;\n\n\t    var source = Observable.defer(function() {\n\t        var jsongCache = {};\n\n\t        var methodSummary;\n\t        if (router._methodSummaryHook) {\n\t            methodSummary = {\n\t                method: 'set',\n\t                jsonGraphEnvelope: jsonGraph,\n\t                start: router._now(),\n\t                results: [],\n\t                routes: []\n\t            };\n\t        }\n\n\t        var action = runSetAction(router, jsonGraph, jsongCache, methodSummary);\n\t        jsonGraph.paths = normalizePathSets(jsonGraph.paths);\n\n\t        if (getPathsCount(jsonGraph.paths) > router.maxPaths) {\n\t            throw new MaxPathsExceededError();\n\t        }\n\n\t        var innerSource = recurseMatchAndExecute(router._matcher, action,\n\t            jsonGraph.paths, set, router, jsongCache).\n\n\t            // Takes the jsonGraphEnvelope and extra details that comes out\n\t            // of the recursive matching algorithm and either attempts the\n\t            // fallback options or returns the built jsonGraph.\n\t            flatMap(function(details) {\n\t                var out = {\n\t                    jsonGraph: details.jsonGraph\n\t                };\n\n\t                // If there is an unhandler then we should call that method and\n\t                // provide the subset of jsonGraph that represents the missing\n\t                // routes.\n\t                if (details.unhandledPaths.length && router._unhandled) {\n\t                    var unhandledPaths = details.unhandledPaths;\n\t                    var jsonGraphFragment = {};\n\n\t                    // PERFORMANCE:\n\t                    //   We know this is a potential performance downfall\n\t                    //   but we want to see if its even a corner case.\n\t                    //   Most likely this will not be hit, but if it does\n\t                    //   then we can take care of it\n\t                    // Set is interesting.  This is what has to happen.\n\t                    // 1. incoming paths are spread so that each one is simple.\n\t                    // 2. incoming path, one at a time, are optimized by the\n\t                    //    incoming jsonGraph.\n\t                    // 3. test intersection against incoming optimized path and\n\t                    //    unhandledPathSet\n\t                    // 4. If 3 is true, build the jsonGraphFragment by using a\n\t                    //    pathValue of optimizedPath and vale from un-optimized\n\t                    //    path and original jsonGraphEnvelope.\n\t                    var jsonGraphEnvelope = {jsonGraph: jsonGraphFragment};\n\t                    var unhandledPathsTree = unhandledPaths.\n\t                        reduce(function(acc, path) {\n\t                            pathValueMerge(acc, {path: path, value: null});\n\t                            return acc;\n\t                        }, {});\n\n\t                    // 1. Spread\n\t                    var pathIntersection = spreadPaths(jsonGraph.paths).\n\n\t                        // 2.1 Optimize.  We know its one at a time therefore we\n\t                        // just pluck [0] out.\n\t                        map(function(path) {\n\t                            return [\n\t                                // full path\n\t                                path,\n\n\t                                // optimized path\n\t                                optimizePathSets(details.jsonGraph, [path],\n\t                                                    router.maxRefFollow)[0]]\n\t                        }).\n\n\t                        // 2.2 Remove all the optimized paths that were found in\n\t                        // the cache.\n\t                        filter(function(x) { return x[1]; }).\n\n\t                        // 3.1 test intersection.\n\t                        map(function(pathAndOPath) {\n\t                            var oPath = pathAndOPath[1];\n\t                            var hasIntersection = hasIntersectionWithTree(\n\t                                oPath, unhandledPathsTree);\n\n\t                            // Creates the pathValue if there are a path\n\t                            // intersection\n\t                            if (hasIntersection) {\n\t                                var value =\n\t                                    getValue(jsonGraph.jsonGraph,\n\t                                        pathAndOPath[0]);\n\n\t                                return {\n\t                                    path: oPath,\n\t                                    value: value\n\t                                };\n\t                            }\n\n\t                            return null;\n\t                        }).\n\n\t                        // 3.2 strip out nulls (the non-intersection paths).\n\t                        filter(function(x) { return x !== null; });\n\n\t                        // 4. build the optimized JSONGraph envelope.\n\t                        pathIntersection.\n\t                            reduce(function(acc, pathValue) {\n\t                                pathValueMerge(acc, pathValue);\n\t                                return acc;\n\t                            }, jsonGraphFragment);\n\n\t                    jsonGraphEnvelope.paths = collapse(\n\t                        pathIntersection.map(function(pV) {\n\t                            return pV.path;\n\t                        }));\n\n\t                    return outputToObservable(\n\t                        router._unhandled.set(jsonGraphEnvelope)).\n\n\t                        // Merge the solution back into the overall message.\n\t                        map(function(unhandledJsonGraphEnv) {\n\t                            mCGRI(out.jsonGraph, [{\n\t                                jsonGraph: unhandledJsonGraphEnv.jsonGraph,\n\t                                paths: unhandledPaths\n\t                            }], router);\n\t                            return out;\n\t                        }).\n\t                        defaultIfEmpty(out);\n\t                }\n\n\t                return Observable.of(out);\n\t            }).\n\n\t            // We will continue to materialize over the whole jsonGraph message.\n\t            // This makes sense if you think about pathValues and an API that\n\t            // if ask for a range of 10 and only 8 were returned, it would not\n\t            // materialize for you, instead, allow the router to do that.\n\t            map(function(jsonGraphEnvelope) {\n\t                return materialize(router, jsonGraph.paths, jsonGraphEnvelope);\n\t            });\n\n\t            if (router._errorHook || router._methodSummaryHook) {\n\t                innerSource = innerSource.\n\t                    do(\n\t                        function (response) {\n\t                            if (router._methodSummaryHook) {\n\t                                methodSummary.results.push({\n\t                                    time: router._now(),\n\t                                    value: response\n\t                                });\n\t                            }\n\t                        }, function (err) {\n\t                            if (router._methodSummaryHook) {\n\t                                methodSummary.end = router._now();\n\t                                methodSummary.error = err;\n\t                                router._methodSummaryHook(methodSummary);\n\t                            }\n\t                            if (router._errorHook) {\n\t                                router._errorHook(err);\n\t                            }\n\t                        }, function () {\n\t                            if (router._methodSummaryHook) {\n\t                                methodSummary.end = router._now();\n\t                                router._methodSummaryHook(methodSummary);\n\t                            }\n\t                        }\n\t                    );\n\t            }\n\t            return innerSource;\n\t    });\n\n\t    if (router._errorHook) {\n\t        source = source.\n\t            do(null, function summaryHookErrorHandler(err) {\n\t                router._errorHook(err);\n\t            });\n\t    }\n\n\t    return rxNewToRxNewAndOld(source);\n\t};\n\treturn set_1;\n}\n\nvar CallRequiresPathsError_1;\nvar hasRequiredCallRequiresPathsError;\n\nfunction requireCallRequiresPathsError () {\n\tif (hasRequiredCallRequiresPathsError) return CallRequiresPathsError_1;\n\thasRequiredCallRequiresPathsError = 1;\n\tvar MESSAGE = 'Any JSONG-Graph returned from call must have paths.';\n\tvar CallRequiresPathsError = function CallRequiresPathsError() {\n\t    this.message = MESSAGE;\n\t    this.stack = (new Error()).stack;\n\t};\n\n\tCallRequiresPathsError.prototype = new Error();\n\n\tCallRequiresPathsError_1 = CallRequiresPathsError;\n\treturn CallRequiresPathsError_1;\n}\n\nvar runCallAction_1;\nvar hasRequiredRunCallAction;\n\nfunction requireRunCallAction () {\n\tif (hasRequiredRunCallAction) return runCallAction_1;\n\thasRequiredRunCallAction = 1;\n\tvar isJSONG = requireIsJSONG();\n\tvar outputToObservable = requireOutputToObservable();\n\tvar noteToJsongOrPV = requireNoteToJsongOrPV();\n\tvar CallRequiresPathsError = requireCallRequiresPathsError();\n\tvar mCGRI = requireMergeCacheAndGatherRefsAndInvalidations();\n\tvar Observable = requireRouterRx().Observable;\n\n\trunCallAction_1 =  outerRunCallAction;\n\n\tfunction outerRunCallAction(routerInstance, callPath, args,\n\t                            suffixes, paths, jsongCache, methodSummary) {\n\t    return function innerRunCallAction(matchAndPath) {\n\t        return runCallAction(matchAndPath, routerInstance, callPath,\n\t                             args, suffixes, paths, jsongCache, methodSummary);\n\t    };\n\t}\n\n\tfunction runCallAction(matchAndPath, routerInstance, callPath, args,\n\t                       suffixes, paths, jsongCache, methodSummary) {\n\n\t    var match = matchAndPath.match;\n\t    var matchedPath = matchAndPath.path;\n\t    var out;\n\n\t    // We are at out destination.  Its time to get out\n\t    // the pathValues from the\n\t    if (match.isCall) {\n\n\t        // This is where things get interesting\n\t        out = Observable.\n\t            defer(function() {\n\t                var next;\n\t                try {\n\t                    next = match.\n\t                        action.call(\n\t                            routerInstance, matchedPath, args, suffixes, paths);\n\t                } catch (e) {\n\t                    e.throwToNext = true;\n\t                    throw e;\n\t                }\n\t                var output = outputToObservable(next);\n\n\t                if (methodSummary) {\n\t                    var route = {\n\t                        start: routerInstance._now(),\n\t                        route: matchAndPath.match.prettyRoute,\n\t                        pathSet: matchAndPath.path,\n\t                        results: []\n\t                    };\n\t                    methodSummary.routes.push(route);\n\n\t                    output = output.do(\n\t                        function (response) {\n\t                            route.results.push({\n\t                                time: routerInstance._now(),\n\t                                value: response\n\t                            });\n\t                        },\n\t                        function (err) {\n\t                            route.error = err;\n\t                            route.end = routerInstance._now();\n\t                        },\n\t                        function () {\n\t                            route.end = routerInstance._now();\n\t                        }\n\t                    );\n\t                }\n\t                return output.toArray();\n\t            }).\n\n\t            // Required to get the references from the outputting jsong\n\t            // and pathValues.\n\t            map(function(res) {\n\n\t                // checks call for isJSONG and if there is jsong without paths\n\t                // throw errors.\n\t                var refs = [];\n\t                var values = [];\n\n\t                // Will flatten any arrays of jsong/pathValues.\n\t                var callOutput = res.\n\n\t                    // Filters out any falsy values\n\t                    filter(function(x) {\n\t                        return x;\n\t                    }).\n\t                    reduce(function(flattenedRes, next) {\n\t                        return flattenedRes.concat(next);\n\t                    }, []);\n\n\t                // An empty output from call\n\t                if (callOutput.length === 0) {\n\t                    return [];\n\t                }\n\n\t                var refLen = -1;\n\t                callOutput.forEach(function(r) {\n\n\t                    // its json graph.\n\t                    if (isJSONG(r)) {\n\n\t                        // This is a hard error and must fully stop the server\n\t                        if (!r.paths) {\n\t                            var err =\n\t                                new CallRequiresPathsError();\n\t                            err.throwToNext = true;\n\t                            throw err;\n\t                        }\n\t                    }\n\n\t                });\n\n\t                var invsRefsAndValues =\n\t                    mCGRI(jsongCache, callOutput, routerInstance);\n\t                invsRefsAndValues.references.forEach(function(ref) {\n\t                    refs[++refLen] = ref;\n\t                });\n\n\t                values = invsRefsAndValues.values.map(function(pv) {\n\t                    return pv.path;\n\t                });\n\n\t                var callLength = callOutput.length;\n\t                var callPathSave1 = callPath.slice(0, callPath.length - 1);\n\t                var hasSuffixes = suffixes && suffixes.length;\n\t                var hasPaths = paths && paths.length;\n\n\t                // We are going to use recurseMatchAndExecute to run\n\t                // the paths and suffixes for call.  For that to happen\n\t                // we must send a message to the outside to switch from\n\t                // call to get.\n\t                callOutput[++callLength] = {isMessage: true, method: 'get'};\n\n\t                // If there are paths to add then push them into the next\n\t                // paths through 'additionalPaths' message.\n\t                if (hasPaths && (callLength + 1)) {\n\t                    paths.forEach(function(path) {\n\t                        callOutput[++callLength] = {\n\t                            isMessage: true,\n\t                            additionalPath: callPathSave1.concat(path)\n\t                        };\n\t                    });\n\t                }\n\n\t                // Suffix is the same as paths except for how to calculate\n\t                // a path per reference found from the callPath.\n\t                if (hasSuffixes) {\n\n\t                    // matchedPath is the optimized path to call.\n\t                    // e.g:\n\t                    // callPath: [genreLists, 0, add] ->\n\t                    // matchedPath: [lists, 'abc', add]\n\t                    var optimizedPathLength = matchedPath.length - 1;\n\n\t                    // For every reference build the complete path\n\t                    // from the callPath - 1 and concat remaining\n\t                    // path from the PathReference (path is where the\n\t                    // reference was found, not the value of the reference).\n\t                    // e.g: from the above example the output is:\n\t                    // output = {path: [lists, abc, 0], value: [titles, 123]}\n\t                    //\n\t                    // This means the refs object = [output];\n\t                    // callPathSave1: [genreLists, 0],\n\t                    // optimizedPathLength: 3 - 1 = 2\n\t                    // ref.path.slice(2): [lists, abc, 0].slice(2) = [0]\n\t                    // deoptimizedPath: [genreLists, 0, 0]\n\t                    //\n\t                    // Add the deoptimizedPath to the callOutput messages.\n\t                    // This will make the outer expand run those as a 'get'\n\t                    refs.forEach(function(ref) {\n\t                        var deoptimizedPath = callPathSave1.concat(\n\t                                ref.path.slice(optimizedPathLength));\n\t                        suffixes.forEach(function(suffix) {\n\t                            var additionalPath =\n\t                                deoptimizedPath.concat(suffix);\n\t                            callOutput[++callLength] = {\n\t                                isMessage: true,\n\t                                additionalPath: additionalPath\n\t                            };\n\t                        });\n\t                    });\n\t                }\n\n\t                // If there are no suffixes but there are references, report\n\t                // the paths to the references.  There may be values as well,\n\t                // add those to the output.\n\t                if (refs.length && !hasSuffixes || values.length) {\n\t                    var additionalPaths = [];\n\t                    if (refs.length && !hasSuffixes) {\n\t                        additionalPaths = refs.\n\t                            map(function(x) { return x.path; });\n\t                    }\n\t                    additionalPaths.\n\t                        concat(values).\n\t                        forEach(function(path) {\n\t                            callOutput[++callLength] = {\n\t                                isMessage: true,\n\t                                additionalPath: path\n\t                            };\n\t                        });\n\t                }\n\n\t                return callOutput;\n\t            }).\n\n\t            // When call has an error it needs to be propagated to the next\n\t            // level instead of onCompleted'ing\n\t            do(null, function(e) {\n\t                e.throwToNext = true;\n\t                throw e;\n\t            });\n\t    } else {\n\t        out = Observable.defer(function () {\n\t            return outputToObservable(\n\t                match.action.call(routerInstance, matchAndPath.path)\n\t            );\n\t        });\n\n\t        if (methodSummary) {\n\t            var route = {\n\t                start: routerInstance._now(),\n\t                route: matchAndPath.match.prettyRoute,\n\t                pathSet: matchAndPath.path,\n\t                results: []\n\t            };\n\t            methodSummary.routes.push(route);\n\n\t            out = out.do(\n\t                function (response) {\n\t                    route.results.push({\n\t                        time: routerInstance._now(),\n\t                        value: response\n\t                    });\n\t                },\n\t                function (err) {\n\t                    route.error = err;\n\t                    route.end = routerInstance._now();\n\t                },\n\t                function () {\n\t                    route.end = routerInstance._now();\n\t                }\n\t            );\n\t        }\n\t    }\n\n\t    return out.\n\t        materialize().\n\t        filter(function(note) {\n\t            return note.kind !== 'C';\n\t        }).\n\t        map(noteToJsongOrPV(matchAndPath.path, false, routerInstance)).\n\t        map(function(jsonGraphOrPV) {\n\t            return [matchAndPath.match, jsonGraphOrPV];\n\t        });\n\t}\n\treturn runCallAction_1;\n}\n\nvar call_1;\nvar hasRequiredCall;\n\nfunction requireCall () {\n\tif (hasRequiredCall) return call_1;\n\thasRequiredCall = 1;\n\tvar call = 'call';\n\tvar runCallAction = requireRunCallAction();\n\tvar recurseMatchAndExecute = requireRecurseMatchAndExecute();\n\tvar normalizePathSets = requireNormalizePathSets();\n\tvar CallNotFoundError = requireCallNotFoundError();\n\tvar materialize = requireMaterialize();\n\tvar pathUtils = requireLib();\n\tvar collapse = pathUtils.collapse;\n\tvar Observable = requireRouterRx().Observable;\n\tvar MaxPathsExceededError = requireMaxPathsExceededError();\n\tvar getPathsCount = requireGetPathsCount();\n\tvar outputToObservable = requireOutputToObservable();\n\tvar rxNewToRxNewAndOld = requireRxNewToRxNewAndOld();\n\n\t/**\n\t * Performs the call mutation.  If a call is unhandled, IE throws error, then\n\t * we will chain to the next dataSource in the line.\n\t */\n\tcall_1 = function routerCall(callPath, args,\n\t                                     refPathsArg, thisPathsArg) {\n\t    var router = this;\n\n\t    var source = Observable.defer(function () {\n\t        var methodSummary;\n\t        if (router._methodSummaryHook) {\n\t            methodSummary = {\n\t                method: 'call',\n\t                start: router._now(),\n\t                callPath: callPath,\n\t                args: args,\n\t                refPaths: refPathsArg,\n\t                thisPaths: thisPathsArg,\n\t                results: [],\n\t                routes: []\n\t            };\n\t        }\n\n\t        var innerSource = Observable.defer(function() {\n\n\t            var refPaths = normalizePathSets(refPathsArg || []);\n\t            var thisPaths = normalizePathSets(thisPathsArg || []);\n\t            var jsongCache = {};\n\t            var action = runCallAction(router, callPath, args,\n\t                refPaths, thisPaths, jsongCache, methodSummary);\n\t            var callPaths = [callPath];\n\n\t            if (getPathsCount(refPaths) +\n\t                getPathsCount(thisPaths) +\n\t                getPathsCount(callPaths) >\n\t                router.maxPaths) {\n\t                throw new MaxPathsExceededError();\n\t            }\n\n\t            return recurseMatchAndExecute(router._matcher, action,\n\t                callPaths, call,\n\t                router, jsongCache).\n\n\t                // Take that\n\t                map(function(jsongResult) {\n\t                    var reportedPaths = jsongResult.reportedPaths;\n\t                    var jsongEnv = {\n\t                        jsonGraph: jsongResult.jsonGraph\n\t                    };\n\n\t                    // Call must report the paths that have been produced.\n\t                    if (reportedPaths.length) {\n\t                    // Collapse the reported paths as they may be inefficient\n\t                    // to send across the wire.\n\t                        jsongEnv.paths = collapse(reportedPaths);\n\t                    }\n\t                    else {\n\t                        jsongEnv.paths = [];\n\t                        jsongEnv.jsonGraph = {};\n\t                    }\n\n\t                    // add the invalidated paths to the jsonGraph Envelope\n\t                    var invalidated = jsongResult.invalidated;\n\t                    if (invalidated && invalidated.length) {\n\t                        jsongEnv.invalidated = invalidated;\n\t                    }\n\n\t                    // Calls are currently materialized.\n\t                    materialize(router, reportedPaths, jsongEnv);\n\t                    return jsongEnv;\n\t                }).\n\n\t            // For us to be able to chain call requests then the error that is\n\t            // caught has to be a 'function does not exist.' error.  From that\n\t            // we will try the next dataSource in the line.\n\t                catch(function catchException(e) {\n\t                    if (e instanceof CallNotFoundError && router._unhandled) {\n\t                        return outputToObservable(\n\t                            router._unhandled.\n\t                            call(callPath, args, refPaths, thisPaths));\n\t                    }\n\t                    throw e;\n\t                });\n\t        });\n\n\t        if (router._methodSummaryHook || router._errorHook) {\n\t            innerSource = innerSource.\n\t                do(function (response) {\n\t                    if (router._methodSummaryHook) {\n\t                        methodSummary.results.push({\n\t                            time: router._now(),\n\t                            value: response\n\t                        });\n\t                    }\n\t                }, function (err) {\n\t                    if (router._methodSummaryHook) {\n\t                        methodSummary.error = err;\n\t                        methodSummary.end = router._now();\n\t                        router._methodSummaryHook(methodSummary);\n\t                    }\n\t                    if (router._errorHook) {\n\t                        router._errorHook(err);\n\t                    }\n\t                }, function () {\n\t                    if (router._methodSummaryHook) {\n\t                        methodSummary.end = router._now();\n\t                        router._methodSummaryHook(methodSummary);\n\t                    }\n\t                });\n\t        }\n\n\t        return innerSource\n\t    });\n\n\n\n\n\n\n\n\t        return rxNewToRxNewAndOld(source);\n\t};\n\treturn call_1;\n}\n\nvar Keys = Keys_1;\nvar parseTree = parseTree$1;\nvar matcher = matcher$1;\nvar JSONGraphError = JSONGraphErrorExports;\nvar MAX_REF_FOLLOW = 50;\nvar MAX_PATHS = 9000;\n\nvar noOp = function noOp() {};\nvar defaultNow = function defaultNow() {\n    return Date.now();\n};\n\nvar Router = function(routes, options) {\n    this._routes = routes;\n    this._rst = parseTree(routes);\n    this._matcher = matcher(this._rst);\n    this._setOptions(options);\n};\n\nRouter.createClass = function(routes) {\n    function C(options) {\n        this._setOptions(options);\n    }\n\n    C.prototype = new Router(routes);\n    C.prototype.constructor = C;\n\n    return C;\n};\n\nRouter.prototype = {\n    /**\n     * Performs the get algorithm on the router.\n     * @param {PathSet[]} paths -\n     * @returns {Observable.<JSONGraphEnvelope>}\n     */\n    get: requireGet(),\n\n    /**\n     * Takes in a jsonGraph and outputs a Observable.<jsonGraph>.  The set\n     * method will use get until it evaluates the last key of the path inside\n     * of paths.  At that point it will produce an intermediate structure that\n     * matches the path and has the value that is found in the jsonGraph env.\n     *\n     * One of the requirements for interaction with a dataSource is that the\n     * set message must be optimized to the best of the incoming sources\n     * knowledge.\n     *\n     * @param {JSONGraphEnvelope} jsonGraph -\n     * @returns {Observable.<JSONGraphEnvelope>}\n     */\n    set: requireSet(),\n\n    /**\n     * Invokes a function in the DataSource's JSONGraph object at the path\n     * provided in the callPath argument.  If there are references that are\n     * followed, a get will be performed to get to the call function.\n     *\n     * @param {Path} callPath -\n     * @param {Array.<*>} args -\n     * @param {Array.<PathSet>} refPaths -\n     * @param {Array.<PathSet>} thisPaths -\n     */\n    call: requireCall(),\n\n    /**\n     * When a route misses on a call, get, or set the unhandledDataSource will\n     * have a chance to fulfill that request.\n     * @param {DataSource} dataSource -\n     */\n    routeUnhandledPathsTo: function routeUnhandledPathsTo(dataSource) {\n        this._unhandled = dataSource;\n    },\n\n    _setOptions: function _setOptions(options) {\n        var opts = options || {};\n        this._debug = opts.debug;\n        this._pathErrorHook = (opts.hooks && opts.hooks.pathError) || noOp;\n        this._errorHook = opts.hooks && opts.hooks.error;\n        this._methodSummaryHook = opts.hooks && opts.hooks.methodSummary;\n        this._now = (opts.hooks && opts.hooks.now) || opts.now || defaultNow;\n        this.maxRefFollow = opts.maxRefFollow || MAX_REF_FOLLOW;\n        this.maxPaths = opts.maxPaths || MAX_PATHS;\n    }\n};\n\nRouter.ranges = Keys.ranges;\nRouter.integers = Keys.integers;\nRouter.keys = Keys.keys;\nRouter.JSONGraphError = JSONGraphError;\nvar Router_1 = Router;\n\nvar Router$1 = /*@__PURE__*/getDefaultExportFromCjs(Router_1);\n\nexport { Router$1 as Router };\n", "export function urlLogger ({ missing, continued, scope, method, url, origUrl, cached, corsConf, body, duration, res, richConsole = true, verbose }) {\n  let badgeColor = ''\n\n  // console.log(url, origUrl, scope)\n  if (!verbose) {\n    if (cached && !missing && method === 'GET' && scope === 'ipfs') {\n      return\n    }\n\n    if (continued) {\n      return\n    }\n  }\n\n  if (richConsole) {\n    badgeColor = 'grey'\n\n    if (cached) {\n      badgeColor = '#099009'\n    } else if (cached === false) {\n      badgeColor = 'orange'\n    }\n\n    if (method === 'POST' || method === 'SET' ) {\n      badgeColor = 'rgb(170, 90, 217)'\n    } else if (method === 'PUT') {\n      badgeColor = 'rgb(174, 12, 226)'\n    } else if (method === 'CALL') {\n      badgeColor = 'rgb(236 124 248)'\n    } else if (method === 'PRELOAD') {\n      badgeColor = '#6ad4f6'\n    }\n  }\n\n  // TODO: move format url her : if (location) {\n  //   url = url.replace(location.origin, '')\n  //   // url = url.split('/').join('/ ')\n  // }\n\n  let displayUrl = ''\n  try {\n    if (typeof location !== 'undefined' && location.origin) { // TODO: deno --location <href> or Deno check\n      displayUrl = url.replace(location.origin, '')\n    } else {\n      displayUrl = url\n    }\n  } catch (_e) {\n    displayUrl = url\n  }\n\n  const edgeWorker = scope?.endsWith('edge-worker')\n\n  /* eslint-disable no-console */\n  if (richConsole) {\n    console.groupCollapsed(\n      `${(scope && edgeWorker) ? scope + ': ' : ''}%c${missing ? 'route error' : ''}%c${missing ? ' ' : ''}%c${method}%c %c ${displayUrl}`,\n      richConsole && missing ? `background-color:red;border-radius:3px;color:black;font-weight:bold;padding-left:2px;padding-right:2px` : '',\n      richConsole ? 'color:grey' : '',\n      richConsole ? `background-color:${badgeColor};border-radius:3px;color:black;font-weight:bold;padding-left:2px;padding-right:2px` : '',\n      richConsole ? 'color:grey' : '',\n      richConsole ? 'color:grey' : ''\n    )\n  } else {\n    console.log(`${(scope && edgeWorker) ? scope + ': ' : ''} ${missing ? 'route error' : ''} ${missing ? ' ' : ''} ${method}    ${displayUrl}`)\n  }\n\n  if (!edgeWorker && scope) {\n    console.info(scope)\n  }\n\n  if (cached === true) {\n    console.info('cache-status: hit')\n  } else if (cached === false) {\n    console.info('cache-status: miss')\n  }\n\n  if (origUrl && (url !== origUrl)) {\n    console.info('rewritten from: ', origUrl)\n  }\n\n  if (corsConf && corsConf.mode === 'proxy') {\n    console.info('proxied through: ' + corsConf.server)\n  }\n\n  if (typeof duration !== 'undefined') {\n    console.log(`duration: ${duration}ms`)\n  }\n\n  if (continued) {\n    console.info('continued processing of previous request')\n  }\n\n  if (body) {\n    console.info(body)\n  }\n\n  if (richConsole) {\n    console.groupEnd()\n  }\n  /* eslint-enable no-console */\n}\n", "// TODO: warn Observable handlers cannot be async functions themselves\n// TODO: filter out changes of own set/ call operations\n\nlet changes\nfunction doSync (dbs, since, Observable, _model) {\n  let id\n  let i = 0\n  function schedule (action) {\n    if (i < 5) {\n      i++\n      if (id) {\n        clearTimeout(id)\n        id = null\n      }\n      id = setTimeout(action, 5)\n    }\n  }\n\n  return Observable.create(subscriber => {\n    //   const changes = db.changes({\n    //     since: since,\n    //     include_docs: true\n    //   })\n    //   const { results, last_seq } = await changes\n    //   not necesarry for single shot: changes.cancel()\n    //   if (results.length) {\n    //     subscriber.onNext([\n    //       { path: ['_seq'], value: { $type: 'atom', value: last_seq } },\n    //       ...results.map(change => ({ path: ['_docs', change.id], value: { $type: 'atom', value: change.doc } }))\n    //     ])\n    //     return () => {}\n    //   }\n\n    let catchupFeed = false\n    let usedFeed\n    if (!changes) {\n      // console.log('creating pouch _sync changes feed', since)\n      changes = dbs.pouch.changes({\n        since: since || 'now',\n        live: true,\n        timeout: false,\n        include_docs: true\n      })\n\n      dbs.pouch.info().then(info => {\n        changes.lastSeq = info.update_seq\n      })\n      usedFeed = changes\n    } else {\n      if (since !== undefined && changes.lastSeq > since) {\n        // TODO: catchup feed should be oneshot ?\n        catchupFeed = true\n        console.log('creating pouch _sync catchup feed', since, changes.lastSeq)\n        usedFeed = dbs.pouch.changes({\n          since: since,\n          live: true,\n          timeout: false,\n          include_docs: true\n        })\n      } else {\n        usedFeed = changes\n      }\n    }\n\n    const complListener = _info => {\n      subscriber.onCompleted()\n    }\n\n    const errListener = err => {\n      subscriber.onError({ path: ['_seq'], value: { $type: 'error', value: err }})\n    }\n\n    const changeListener = change => {\n      // FIXME: value: invalidated: true not working, and also jsong invalidations:\n      // [ ['todos'] ], invalidate: [ ['todos'] ], invalidated: [ ['todos'] ]\n\n      usedFeed.lastSeq = change.seq\n\n      const jsonGE = {\n        jsonGraph: {},\n        paths: []\n      }\n\n      if (change.doc.type === 'system:counter' && change.doc.path) {\n        const changePath = change.doc.path.split('.')\n        jsonGE.paths.push(changePath)\n\n        let target = jsonGE.jsonGraph\n        let i = 0\n        for (const key of changePath) {\n          i ++\n          if (!target[key]) {\n            target[key] = {}\n          }\n          if (i === changePath.length) {\n            target[key] = { value: change.doc.value, $type: 'atom' }\n          } else {\n            target = target[key]\n          }\n        }\n      } else {\n        jsonGE.paths.push(['_docs', change.id])\n        jsonGE.jsonGraph._docs = {\n          [change.id]: { $type: 'atom', value: change.doc, $expires: 1 }\n        }\n      }\n\n      jsonGE.paths.push(['_seq'])\n      jsonGE.jsonGraph._seq = { $type: 'atom', value: change.seq }\n\n      // TODO: fix router to forward before complete for long running observable!\n      subscriber.onNext(jsonGE)\n\n      schedule(() => {\n        if (!subscriber.isStopped) {\n          subscriber.onCompleted()\n        }\n      })\n    }\n\n    // console.log('attaching change listeners')\n    usedFeed.on('change', changeListener)\n    usedFeed.on('error', errListener)\n    usedFeed.on('complete', complListener)\n\n    return () => {\n      // console.log('cleaning change listeners')\n      if (catchupFeed) {\n        // TODO: cancel changes when no active requests for a while,\n        usedFeed.cancel()\n      }\n\n      usedFeed.removeListener('change', changeListener)\n      usedFeed.removeListener('error', errListener)\n      usedFeed.removeListener('complete', complListener)\n    }\n  })\n}\n\nexport const _sync = ({ dbs, Observable, model }, [ since ]) => {\n  return dbs && doSync(dbs, since, Observable, model)\n}\n\nexport async function getDocs ({ ids, dbs }) {\n  const docs = await dbs.sync.pullDocs(ids.filter(id => id), {includeDocs: true})\n\n  const _docs = {}\n\n  docs.forEach(doc => {\n    const envelope = { $type: 'atom', value: doc, $expires: 1 }\n\n    if (doc.type) {\n      envelope.$schema = { $ref: doc.type }\n    } else if (doc.types?.length === 1) {\n      envelope.$schema = { $ref: doc.types[0].profile }\n    } else if (doc.types?.length > 1) {\n      envelope.$schema = { anyOf: doc.types.map(type => ({ '$ref': type.profile })) }\n    }\n\n    _docs[doc._id] = envelope\n  })\n\n  return {\n    jsonGraph: {\n      _docs\n    }\n  }\n}\n\n// TODO: chan support\n// doc.chans?.forEach(chan => {\n//   paths.push(['contactsByChan', btoa(chan.href)])\n//   contactsByChan[btoa(chan.href)] = { $type: 'ref', value: ['byId', row.id] }\n// })\n", "// https://moment.github.io/luxon/es6/luxon.min.js\nclass t extends Error{}class z extends t{constructor(t){super(\"Invalid DateTime: \"+t.toMessage())}}class q extends t{constructor(t){super(\"Invalid Interval: \"+t.toMessage())}}class A extends t{constructor(t){super(\"Invalid Duration: \"+t.toMessage())}}class j extends t{}class _ extends t{constructor(t){super(\"Invalid unit \"+t)}}class o extends t{}class r extends t{constructor(){super(\"Zone is an abstract class\")}}var e=\"numeric\",n=\"short\",s=\"long\";const U={year:e,month:e,day:e},$={year:e,month:n,day:e},H={year:e,month:n,day:e,weekday:n},W={year:e,month:s,day:e},R={year:e,month:s,day:e,weekday:s},J={hour:e,minute:e},Y={hour:e,minute:e,second:e},P={hour:e,minute:e,second:e,timeZoneName:n},G={hour:e,minute:e,second:e,timeZoneName:s},B={hour:e,minute:e,hourCycle:\"h23\"},Q={hour:e,minute:e,second:e,hourCycle:\"h23\"},K={hour:e,minute:e,second:e,hourCycle:\"h23\",timeZoneName:n},X={hour:e,minute:e,second:e,hourCycle:\"h23\",timeZoneName:s},tt={year:e,month:e,day:e,hour:e,minute:e},et={year:e,month:e,day:e,hour:e,minute:e,second:e},rt={year:e,month:n,day:e,hour:e,minute:e},nt={year:e,month:n,day:e,hour:e,minute:e,second:e},st={year:e,month:n,day:e,weekday:n,hour:e,minute:e},it={year:e,month:s,day:e,hour:e,minute:e,timeZoneName:n},at={year:e,month:s,day:e,hour:e,minute:e,second:e,timeZoneName:n},ot={year:e,month:s,day:e,weekday:s,hour:e,minute:e,timeZoneName:s},ut={year:e,month:s,day:e,weekday:s,hour:e,minute:e,second:e,timeZoneName:s};function O(t){return void 0===t}function c(t){return\"number\"==typeof t}function lt(t){return\"number\"==typeof t&&t%1==0}function ct(t){return\"[object Date]\"===Object.prototype.toString.call(t)}function ht(){try{return\"undefined\"!=typeof Intl&&!!Intl.RelativeTimeFormat}catch(t){return!1}}function dt(t){return Array.isArray(t)?t:[t]}function mt(t,r,n){if(0!==t.length)return t.reduce((t,e)=>{e=[r(e),e];return t&&n(t[0],e[0])===t[0]?t:e},null)[1]}function h(t,e){return Object.prototype.hasOwnProperty.call(t,e)}function u(t,e,r){return lt(t)&&e<=t&&t<=r}function l(t,e=2){let r;return r=t<0?\"-\"+(\"\"+-t).padStart(e,\"0\"):(\"\"+t).padStart(e,\"0\")}function d(t){if(!O(t)&&null!==t&&\"\"!==t)return parseInt(t,10)}function m(t){if(!O(t)&&null!==t&&\"\"!==t)return parseFloat(t)}function ft(t){if(!O(t)&&null!==t&&\"\"!==t)return t=1e3*parseFloat(\"0.\"+t),Math.floor(t)}function yt(t,e,r=!1){const n=10**e,s=r?Math.trunc:Math.round;return s(t*n)/n}function gt(t){return t%4==0&&(t%100!=0||t%400==0)}function wt(t){return gt(t)?366:365}function vt(t,e){var r,n=(n=e-1)-(r=12)*Math.floor(n/r)+1;return 2==n?gt(t+(e-n)/12)?29:28:[31,null,31,30,31,30,31,31,30,31,30,31][n-1]}function pt(t){let e=Date.UTC(t.year,t.month-1,t.day,t.hour,t.minute,t.second,t.millisecond);return t.year<100&&0<=t.year&&(e=new Date(e)).setUTCFullYear(e.getUTCFullYear()-1900),+e}function Tt(t){var e=(t+Math.floor(t/4)-Math.floor(t/100)+Math.floor(t/400))%7,t=t-1,t=(t+Math.floor(t/4)-Math.floor(t/100)+Math.floor(t/400))%7;return 4==e||3==t?53:52}function St(t){return 99<t?t:60<t?1900+t:2e3+t}function Ot(t,e,r,n=null){const s=new Date(t),i={hourCycle:\"h23\",year:\"numeric\",month:\"2-digit\",day:\"2-digit\",hour:\"2-digit\",minute:\"2-digit\"};n&&(i.timeZone=n);t={timeZoneName:e,...i},n=new Intl.DateTimeFormat(r,t).formatToParts(s).find(t=>\"timezonename\"===t.type.toLowerCase());return n?n.value:null}function bt(t,e){let r=parseInt(t,10);Number.isNaN(r)&&(r=0);t=parseInt(e,10)||0,e=r<0||Object.is(r,-0)?-t:t;return 60*r+e}function kt(t){var e=Number(t);if(\"boolean\"==typeof t||\"\"===t||Number.isNaN(e))throw new o(\"Invalid unit value \"+t);return e}function Mt(t,e){const r={};for(const s in t){var n;!h(t,s)||null!=(n=t[s])&&(r[e(s)]=kt(n))}return r}function Nt(t,e){var r=Math.trunc(Math.abs(t/60)),n=Math.trunc(Math.abs(t%60)),s=0<=t?\"+\":\"-\";switch(e){case\"short\":return s+l(r,2)+\":\"+l(n,2);case\"narrow\":return s+r+(0<n?\":\"+n:\"\");case\"techie\":return s+l(r,2)+l(n,2);default:throw new RangeError(`Value format ${e} is out of range for property format`)}}function Dt(t){return r=t,[\"hour\",\"minute\",\"second\",\"millisecond\"].reduce((t,e)=>(t[e]=r[e],t),{});var r}n=/[A-Za-z_+-]{1,256}(?::?\\/[A-Za-z0-9_+-]{1,256}(?:\\/[A-Za-z0-9_+-]{1,256})?)?/;const Et=[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],Vt=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],xt=[\"J\",\"F\",\"M\",\"A\",\"M\",\"J\",\"J\",\"A\",\"S\",\"O\",\"N\",\"D\"];function It(t){switch(t){case\"narrow\":return[...xt];case\"short\":return[...Vt];case\"long\":return[...Et];case\"numeric\":return[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"];case\"2-digit\":return[\"01\",\"02\",\"03\",\"04\",\"05\",\"06\",\"07\",\"08\",\"09\",\"10\",\"11\",\"12\"];default:return null}}const Ct=[\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"],Ft=[\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\"],Zt=[\"M\",\"T\",\"W\",\"T\",\"F\",\"S\",\"S\"];function Lt(t){switch(t){case\"narrow\":return[...Zt];case\"short\":return[...Ft];case\"long\":return[...Ct];case\"numeric\":return[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\"];default:return null}}const zt=[\"AM\",\"PM\"],qt=[\"Before Christ\",\"Anno Domini\"],At=[\"BC\",\"AD\"],jt=[\"B\",\"A\"];function _t(t){switch(t){case\"narrow\":return[...jt];case\"short\":return[...At];case\"long\":return[...qt];default:return null}}function Ut(t){return zt[t.hour<12?0:1]}function $t(t,e){return Lt(e)[t.weekday-1]}function Ht(t,e){return It(e)[t.month-1]}function Wt(t,e){return _t(e)[t.year<0?0:1]}function Rt(t,e,r=\"always\",n=!1){var s={years:[\"year\",\"yr.\"],quarters:[\"quarter\",\"qtr.\"],months:[\"month\",\"mo.\"],weeks:[\"week\",\"wk.\"],days:[\"day\",\"day\",\"days\"],hours:[\"hour\",\"hr.\"],minutes:[\"minute\",\"min.\"],seconds:[\"second\",\"sec.\"]},i=-1===[\"hours\",\"minutes\",\"seconds\"].indexOf(t);if(\"auto\"===r&&i){var a=\"days\"===t;switch(e){case 1:return a?\"tomorrow\":\"next \"+s[t][0];case-1:return a?\"yesterday\":\"last \"+s[t][0];case 0:return a?\"today\":\"this \"+s[t][0]}}var r=Object.is(e,-0)||e<0,i=Math.abs(e),e=1===i,o=s[t],n=n?!e&&o[2]||o[1]:e?s[t][0]:t;return r?i+` ${n} ago`:`in ${i} `+n}function Jt(t,e){let r=\"\";for(const n of t)n.literal?r+=n.val:r+=e(n.val);return r}const Yt={D:U,DD:$,DDD:W,DDDD:R,t:J,tt:Y,ttt:P,tttt:G,T:B,TT:Q,TTT:K,TTTT:X,f:tt,ff:rt,fff:it,ffff:ot,F:et,FF:nt,FFF:at,FFFF:ut};class f{static create(t,e={}){return new f(t,e)}static parseFormat(e){let r=null,n=\"\",s=!1;const i=[];for(let t=0;t<e.length;t++){var a=e.charAt(t);\"'\"===a?(0<n.length&&i.push({literal:s,val:n}),r=null,n=\"\",s=!s):s||a===r?n+=a:(0<n.length&&i.push({literal:!1,val:n}),n=a,r=a)}return 0<n.length&&i.push({literal:s,val:n}),i}static macroTokenToFormatOpts(t){return Yt[t]}constructor(t,e){this.opts=e,this.loc=t,this.systemLoc=null}formatWithSystemDefault(t,e){null===this.systemLoc&&(this.systemLoc=this.loc.redefaultToSystem());const r=this.systemLoc.dtFormatter(t,{...this.opts,...e});return r.format()}formatDateTime(t,e={}){const r=this.loc.dtFormatter(t,{...this.opts,...e});return r.format()}formatDateTimeParts(t,e={}){const r=this.loc.dtFormatter(t,{...this.opts,...e});return r.formatToParts()}resolvedOptions(t,e={}){const r=this.loc.dtFormatter(t,{...this.opts,...e});return r.resolvedOptions()}num(t,e=0){if(this.opts.forceSimple)return l(t,e);const r={...this.opts};return 0<e&&(r.padTo=e),this.loc.numberFormatter(r).format(t)}formatDateTimeFromString(r,t){const n=\"en\"===this.loc.listingMode(),e=this.loc.outputCalendar&&\"gregory\"!==this.loc.outputCalendar,s=(t,e)=>this.loc.extract(r,t,e),i=t=>r.isOffsetFixed&&0===r.offset&&t.allowZ?\"Z\":r.isValid?r.zone.formatOffset(r.ts,t.format):\"\",a=()=>n?Ut(r):s({hour:\"numeric\",hourCycle:\"h12\"},\"dayperiod\"),o=(t,e)=>n?Ht(r,t):s(e?{month:t}:{month:t,day:\"numeric\"},\"month\"),u=(t,e)=>n?$t(r,t):s(e?{weekday:t}:{weekday:t,month:\"long\",day:\"numeric\"},\"weekday\"),l=t=>{var e=f.macroTokenToFormatOpts(t);return e?this.formatWithSystemDefault(r,e):t},c=t=>n?Wt(r,t):s({era:t},\"era\");return Jt(f.parseFormat(t),t=>{switch(t){case\"S\":return this.num(r.millisecond);case\"u\":case\"SSS\":return this.num(r.millisecond,3);case\"s\":return this.num(r.second);case\"ss\":return this.num(r.second,2);case\"uu\":return this.num(Math.floor(r.millisecond/10),2);case\"uuu\":return this.num(Math.floor(r.millisecond/100));case\"m\":return this.num(r.minute);case\"mm\":return this.num(r.minute,2);case\"h\":return this.num(r.hour%12==0?12:r.hour%12);case\"hh\":return this.num(r.hour%12==0?12:r.hour%12,2);case\"H\":return this.num(r.hour);case\"HH\":return this.num(r.hour,2);case\"Z\":return i({format:\"narrow\",allowZ:this.opts.allowZ});case\"ZZ\":return i({format:\"short\",allowZ:this.opts.allowZ});case\"ZZZ\":return i({format:\"techie\",allowZ:this.opts.allowZ});case\"ZZZZ\":return r.zone.offsetName(r.ts,{format:\"short\",locale:this.loc.locale});case\"ZZZZZ\":return r.zone.offsetName(r.ts,{format:\"long\",locale:this.loc.locale});case\"z\":return r.zoneName;case\"a\":return a();case\"d\":return e?s({day:\"numeric\"},\"day\"):this.num(r.day);case\"dd\":return e?s({day:\"2-digit\"},\"day\"):this.num(r.day,2);case\"c\":return this.num(r.weekday);case\"ccc\":return u(\"short\",!0);case\"cccc\":return u(\"long\",!0);case\"ccccc\":return u(\"narrow\",!0);case\"E\":return this.num(r.weekday);case\"EEE\":return u(\"short\",!1);case\"EEEE\":return u(\"long\",!1);case\"EEEEE\":return u(\"narrow\",!1);case\"L\":return e?s({month:\"numeric\",day:\"numeric\"},\"month\"):this.num(r.month);case\"LL\":return e?s({month:\"2-digit\",day:\"numeric\"},\"month\"):this.num(r.month,2);case\"LLL\":return o(\"short\",!0);case\"LLLL\":return o(\"long\",!0);case\"LLLLL\":return o(\"narrow\",!0);case\"M\":return e?s({month:\"numeric\"},\"month\"):this.num(r.month);case\"MM\":return e?s({month:\"2-digit\"},\"month\"):this.num(r.month,2);case\"MMM\":return o(\"short\",!1);case\"MMMM\":return o(\"long\",!1);case\"MMMMM\":return o(\"narrow\",!1);case\"y\":return e?s({year:\"numeric\"},\"year\"):this.num(r.year);case\"yy\":return e?s({year:\"2-digit\"},\"year\"):this.num(r.year.toString().slice(-2),2);case\"yyyy\":return e?s({year:\"numeric\"},\"year\"):this.num(r.year,4);case\"yyyyyy\":return e?s({year:\"numeric\"},\"year\"):this.num(r.year,6);case\"G\":return c(\"short\");case\"GG\":return c(\"long\");case\"GGGGG\":return c(\"narrow\");case\"kk\":return this.num(r.weekYear.toString().slice(-2),2);case\"kkkk\":return this.num(r.weekYear,4);case\"W\":return this.num(r.weekNumber);case\"WW\":return this.num(r.weekNumber,2);case\"o\":return this.num(r.ordinal);case\"ooo\":return this.num(r.ordinal,3);case\"q\":return this.num(r.quarter);case\"qq\":return this.num(r.quarter,2);case\"X\":return this.num(Math.floor(r.ts/1e3));case\"x\":return this.num(r.ts);default:return l(t)}})}formatDurationFromString(t,e){const r=t=>{switch(t[0]){case\"S\":return\"millisecond\";case\"s\":return\"second\";case\"m\":return\"minute\";case\"h\":return\"hour\";case\"d\":return\"day\";case\"w\":return\"week\";case\"M\":return\"month\";case\"y\":return\"year\";default:return null}},n=f.parseFormat(e),s=n.reduce((t,{literal:e,val:r})=>e?t:t.concat(r),[]),i=t.shiftTo(...s.map(r).filter(t=>t));return Jt(n,(a=i,t=>{var e=r(t);return e?this.num(a.get(e),t.length):t}));var a}}class y{constructor(t,e){this.reason=t,this.explanation=e}toMessage(){return this.explanation?this.reason+\": \"+this.explanation:this.reason}}class i{get type(){throw new r}get name(){throw new r}get ianaName(){return this.name}get isUniversal(){throw new r}offsetName(t,e){throw new r}formatOffset(t,e){throw new r}offset(t){throw new r}equals(t){throw new r}get isValid(){throw new r}}let Pt=null;class Gt extends i{static get instance(){return Pt=null===Pt?new Gt:Pt}get type(){return\"system\"}get name(){return(new Intl.DateTimeFormat).resolvedOptions().timeZone}get isUniversal(){return!1}offsetName(t,{format:e,locale:r}){return Ot(t,e,r)}formatOffset(t,e){return Nt(this.offset(t),e)}offset(t){return-new Date(t).getTimezoneOffset()}equals(t){return\"system\"===t.type}get isValid(){return!0}}let Bt={};function Qt(t){return Bt[t]||(Bt[t]=new Intl.DateTimeFormat(\"en-US\",{hour12:!1,timeZone:t,year:\"numeric\",month:\"2-digit\",day:\"2-digit\",hour:\"2-digit\",minute:\"2-digit\",second:\"2-digit\",era:\"short\"})),Bt[t]}const Kt={year:0,month:1,day:2,era:3,hour:4,minute:5,second:6};function Xt(t,e){var t=t.format(e).replace(/\\u200E/g,\"\"),[,e,t,r,n,s,i,a]=/(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(t);return[r,e,t,n,s,i,a]}function te(t,e){var r=t.formatToParts(e);const n=[];for(let t=0;t<r.length;t++){var{type:s,value:i}=r[t],a=Kt[s];\"era\"===s?n[a]=i:O(a)||(n[a]=parseInt(i,10))}return n}let ee={};class w extends i{static create(t){return ee[t]||(ee[t]=new w(t)),ee[t]}static resetCache(){ee={},Bt={}}static isValidSpecifier(t){return this.isValidZone(t)}static isValidZone(t){if(!t)return!1;try{return new Intl.DateTimeFormat(\"en-US\",{timeZone:t}).format(),!0}catch(t){return!1}}constructor(t){super(),this.zoneName=t,this.valid=w.isValidZone(t)}get type(){return\"iana\"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(t,{format:e,locale:r}){return Ot(t,e,r,this.name)}formatOffset(t,e){return Nt(this.offset(t),e)}offset(t){t=new Date(t);if(isNaN(t))return NaN;var e=Qt(this.name);let[r,n,s,i,a,o,u]=(e.formatToParts?te:Xt)(e,t);e=+t,t=e%1e3;return(pt({year:r=\"BC\"===i?1-Math.abs(r):r,month:n,day:s,hour:24===a?0:a,minute:o,second:u,millisecond:0})-(e-=0<=t?t:1e3+t))/6e4}equals(t){return\"iana\"===t.type&&t.name===this.name}get isValid(){return this.valid}}let re=null;class v extends i{static get utcInstance(){return re=null===re?new v(0):re}static instance(t){return 0===t?v.utcInstance:new v(t)}static parseSpecifier(t){if(t){t=t.match(/^utc(?:([+-]\\d{1,2})(?::(\\d{2}))?)?$/i);if(t)return new v(bt(t[1],t[2]))}return null}constructor(t){super(),this.fixed=t}get type(){return\"fixed\"}get name(){return 0===this.fixed?\"UTC\":\"UTC\"+Nt(this.fixed,\"narrow\")}get ianaName(){return 0===this.fixed?\"Etc/UTC\":\"Etc/GMT\"+Nt(-this.fixed,\"narrow\")}offsetName(){return this.name}formatOffset(t,e){return Nt(this.fixed,e)}get isUniversal(){return!0}offset(){return this.fixed}equals(t){return\"fixed\"===t.type&&t.fixed===this.fixed}get isValid(){return!0}}class ne extends i{constructor(t){super(),this.zoneName=t}get type(){return\"invalid\"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(){return null}formatOffset(){return\"\"}offset(){return NaN}equals(){return!1}get isValid(){return!1}}function b(t,e){var r;return O(t)||null===t?e:t instanceof i?t:\"string\"==typeof t?\"default\"===(r=t.toLowerCase())?e:\"local\"===r||\"system\"===r?Gt.instance:\"utc\"===r||\"gmt\"===r?v.utcInstance:v.parseSpecifier(r)||w.create(t):c(t)?v.instance(t):\"object\"==typeof t&&t.offset&&\"number\"==typeof t.offset?t:new ne(t)}let se=()=>Date.now(),ie=\"system\",ae=null,oe=null,ue=null,le;class k{static get now(){return se}static set now(t){se=t}static set defaultZone(t){ie=t}static get defaultZone(){return b(ie,Gt.instance)}static get defaultLocale(){return ae}static set defaultLocale(t){ae=t}static get defaultNumberingSystem(){return oe}static set defaultNumberingSystem(t){oe=t}static get defaultOutputCalendar(){return ue}static set defaultOutputCalendar(t){ue=t}static get throwOnInvalid(){return le}static set throwOnInvalid(t){le=t}static resetCaches(){M.resetCache(),w.resetCache()}}let ce={};function he(t,e={}){var r=JSON.stringify([t,e]);let n=ce[r];return n||(n=new Intl.ListFormat(t,e),ce[r]=n),n}let de={};function me(t,e={}){var r=JSON.stringify([t,e]);let n=de[r];return n||(n=new Intl.DateTimeFormat(t,e),de[r]=n),n}let fe={};function ye(t,e={}){var r=JSON.stringify([t,e]);let n=fe[r];return n||(n=new Intl.NumberFormat(t,e),fe[r]=n),n}let ge={};function we(t,e={}){const{base:r,...n}=e;var s=JSON.stringify([t,n]);let i=ge[s];return i||(i=new Intl.RelativeTimeFormat(t,e),ge[s]=i),i}let ve=null;function pe(){return ve=ve||(new Intl.DateTimeFormat).resolvedOptions().locale}function Te(t){var r=t.indexOf(\"-u-\");if(-1===r)return[t];{let e;r=t.substring(0,r);try{e=me(t).resolvedOptions()}catch(t){e=me(r).resolvedOptions()}var{numberingSystem:t,calendar:n}=e;return[r,t,n]}}function Se(t,e,r){return(r||e)&&(t+=\"-u\",r&&(t+=\"-ca-\"+r),e&&(t+=\"-nu-\"+e)),t}function Oe(e){const r=[];for(let t=1;t<=12;t++){var n=L.utc(2016,t,1);r.push(e(n))}return r}function be(e){const r=[];for(let t=1;t<=7;t++){var n=L.utc(2016,11,13+t);r.push(e(n))}return r}function ke(t,e,r,n,s){t=t.listingMode(r);return\"error\"===t?null:(\"en\"===t?n:s)(e)}function Me(t){return(!t.numberingSystem||\"latn\"===t.numberingSystem)&&(\"latn\"===t.numberingSystem||!t.locale||t.locale.startsWith(\"en\")||\"latn\"===new Intl.DateTimeFormat(t.intl).resolvedOptions().numberingSystem)}class Ne{constructor(t,e,r){this.padTo=r.padTo||0,this.floor=r.floor||!1;const{padTo:n,floor:s,...i}=r;if(!e||0<Object.keys(i).length){const a={useGrouping:!1,...r};0<r.padTo&&(a.minimumIntegerDigits=r.padTo),this.inf=ye(t,a)}}format(t){var e;return this.inf?(e=this.floor?Math.floor(t):t,this.inf.format(e)):l(this.floor?Math.floor(t):yt(t,3),this.padTo)}}class De{constructor(t,e,r){this.opts=r;let n;var s;t.zone.isUniversal?(s=0<=(s=t.offset/60*-1)?\"Etc/GMT+\"+s:\"Etc/GMT\"+s,0!==t.offset&&w.create(s).valid?(n=s,this.dt=t):(n=\"UTC\",r.timeZoneName?this.dt=t:this.dt=0===t.offset?t:L.fromMillis(t.ts+60*t.offset*1e3))):\"system\"===t.zone.type?this.dt=t:(this.dt=t,n=t.zone.name);const i={...this.opts};n&&(i.timeZone=n),this.dtf=me(e,i)}format(){return this.dtf.format(this.dt.toJSDate())}formatToParts(){return this.dtf.formatToParts(this.dt.toJSDate())}resolvedOptions(){return this.dtf.resolvedOptions()}}class Ee{constructor(t,e,r){this.opts={style:\"long\",...r},!e&&ht()&&(this.rtf=we(t,r))}format(t,e){return this.rtf?this.rtf.format(t,e):Rt(e,t,this.opts.numeric,\"long\"!==this.opts.style)}formatToParts(t,e){return this.rtf?this.rtf.formatToParts(t,e):[]}}class M{static fromOpts(t){return M.create(t.locale,t.numberingSystem,t.outputCalendar,t.defaultToEN)}static create(t,e,r,n=!1){t=t||k.defaultLocale,n=t||(n?\"en-US\":pe()),e=e||k.defaultNumberingSystem,r=r||k.defaultOutputCalendar;return new M(n,e,r,t)}static resetCache(){ve=null,de={},fe={},ge={}}static fromObject({locale:t,numberingSystem:e,outputCalendar:r}={}){return M.create(t,e,r)}constructor(t,e,r,n){var[t,s,i]=Te(t);this.locale=t,this.numberingSystem=e||s||null,this.outputCalendar=r||i||null,this.intl=Se(this.locale,this.numberingSystem,this.outputCalendar),this.weekdaysCache={format:{},standalone:{}},this.monthsCache={format:{},standalone:{}},this.meridiemCache=null,this.eraCache={},this.specifiedLocale=n,this.fastNumbersCached=null}get fastNumbers(){return null==this.fastNumbersCached&&(this.fastNumbersCached=Me(this)),this.fastNumbersCached}listingMode(){var t=this.isEnglish(),e=!(null!==this.numberingSystem&&\"latn\"!==this.numberingSystem||null!==this.outputCalendar&&\"gregory\"!==this.outputCalendar);return t&&e?\"en\":\"intl\"}clone(t){return t&&0!==Object.getOwnPropertyNames(t).length?M.create(t.locale||this.specifiedLocale,t.numberingSystem||this.numberingSystem,t.outputCalendar||this.outputCalendar,t.defaultToEN||!1):this}redefaultToEN(t={}){return this.clone({...t,defaultToEN:!0})}redefaultToSystem(t={}){return this.clone({...t,defaultToEN:!1})}months(r,n=!1,t=!0){return ke(this,r,t,It,()=>{const e=n?{month:r,day:\"numeric\"}:{month:r},t=n?\"format\":\"standalone\";return this.monthsCache[t][r]||(this.monthsCache[t][r]=Oe(t=>this.extract(t,e,\"month\"))),this.monthsCache[t][r]})}weekdays(r,n=!1,t=!0){return ke(this,r,t,Lt,()=>{const e=n?{weekday:r,year:\"numeric\",month:\"long\",day:\"numeric\"}:{weekday:r},t=n?\"format\":\"standalone\";return this.weekdaysCache[t][r]||(this.weekdaysCache[t][r]=be(t=>this.extract(t,e,\"weekday\"))),this.weekdaysCache[t][r]})}meridiems(t=!0){return ke(this,void 0,t,()=>zt,()=>{if(!this.meridiemCache){const e={hour:\"numeric\",hourCycle:\"h12\"};this.meridiemCache=[L.utc(2016,11,13,9),L.utc(2016,11,13,19)].map(t=>this.extract(t,e,\"dayperiod\"))}return this.meridiemCache})}eras(t,e=!0){return ke(this,t,e,_t,()=>{const e={era:t};return this.eraCache[t]||(this.eraCache[t]=[L.utc(-40,1,1),L.utc(2017,1,1)].map(t=>this.extract(t,e,\"era\"))),this.eraCache[t]})}extract(t,e,r){const n=this.dtFormatter(t,e),s=n.formatToParts(),i=s.find(t=>t.type.toLowerCase()===r);return i?i.value:null}numberFormatter(t={}){return new Ne(this.intl,t.forceSimple||this.fastNumbers,t)}dtFormatter(t,e={}){return new De(t,this.intl,e)}relFormatter(t={}){return new Ee(this.intl,this.isEnglish(),t)}listFormatter(t={}){return he(this.intl,t)}isEnglish(){return\"en\"===this.locale||\"en-us\"===this.locale.toLowerCase()||new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith(\"en-us\")}equals(t){return this.locale===t.locale&&this.numberingSystem===t.numberingSystem&&this.outputCalendar===t.outputCalendar}}function a(...t){t=t.reduce((t,e)=>t+e.source,\"\");return RegExp(`^${t}$`)}function g(...t){return i=>t.reduce(([t,e,r],n)=>{var[n,r,s]=n(i,r);return[{...t,...n},r||e,s]},[{},null,1]).slice(0,2)}function p(t,...e){if(null!=t)for(var[r,n]of e){r=r.exec(t);if(r)return n(r)}return[null,null]}function Ve(...s){return(t,e)=>{const r={};let n;for(n=0;n<s.length;n++)r[s[n]]=d(t[e+n]);return[r,null,e+n]}}var e=/(?:(Z)|([+-]\\d\\d)(?::?(\\d\\d))?)/,s=/(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:[.,](\\d{1,30}))?)?)?/,xe=RegExp(s.source+`(?:${e.source}?(?:\\\\[(${n.source})\\\\])?)?`),Ie=RegExp(`(?:T${xe.source})?`),Ce=Ve(\"weekYear\",\"weekNumber\",\"weekDay\"),Fe=Ve(\"year\",\"ordinal\"),e=RegExp(s.source+` ?(?:${e.source}|(${n.source}))?`),n=RegExp(`(?: ${e.source})?`);function T(t,e,r){t=t[e];return O(t)?r:d(t)}function S(t,e){return[{hours:T(t,e,0),minutes:T(t,e+1,0),seconds:T(t,e+2,0),milliseconds:ft(t[e+3])},null,e+4]}function Ze(t,e){var r=!t[e]&&!t[e+1],t=bt(t[e+1],t[e+2]);return[{},r?null:v.instance(t),e+3]}function Le(t,e){return[{},t[e]?w.create(t[e]):null,e+1]}const ze=RegExp(`^T?${s.source}$`),qe=/^-?P(?:(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)Y)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)W)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)D)?(?:T(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)H)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20})(?:[.,](-?\\d{1,20}))?S)?)?)$/;function Ae(t){var[t,e,r,n,s,i,a,o,u]=t;const l=\"-\"===t[0];var t=o&&\"-\"===o[0],c=(t,e=!1)=>void 0!==t&&(e||t&&l)?-t:t;return[{years:c(m(e)),months:c(m(r)),weeks:c(m(n)),days:c(m(s)),hours:c(m(i)),minutes:c(m(a)),seconds:c(m(o),\"-0\"===o),milliseconds:c(ft(u),t)}]}const je={GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function _e(t,e,r,n,s,i,a){const o={year:2===e.length?St(d(e)):d(e),month:Vt.indexOf(r)+1,day:d(n),hour:d(s),minute:d(i)};return a&&(o.second=d(a)),t&&(o.weekday=3<t.length?Ct.indexOf(t)+1:Ft.indexOf(t)+1),o}const Ue=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\\d\\d)(\\d\\d)))$/;function $e(t){var[,t,e,r,n,s,i,a,o,u,l,c]=t,t=_e(t,n,r,e,s,i,a);let h;return h=o?je[o]:u?0:bt(l,c),[t,new v(h)]}const He=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d\\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,We=/^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\\d\\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,Re=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \\d|\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) (\\d{4})$/;function Je(t){var[,t,e,r,n,s,i,a]=t;return[_e(t,n,r,e,s,i,a),v.utcInstance]}function Ye(t){var[,t,e,r,n,s,i,a]=t;return[_e(t,a,e,r,n,s,i),v.utcInstance]}const Pe=a(/([+-]\\d{6}|\\d{4})(?:-?(\\d\\d)(?:-?(\\d\\d))?)?/,Ie),Ge=a(/(\\d{4})-?W(\\d\\d)(?:-?(\\d))?/,Ie),Be=a(/(\\d{4})-?(\\d{3})/,Ie),Qe=a(xe),Ke=g(function(t,e){return[{year:T(t,e),month:T(t,e+1,1),day:T(t,e+2,1)},null,e+3]},S,Ze,Le),Xe=g(Ce,S,Ze,Le),tr=g(Fe,S,Ze,Le),er=g(S,Ze,Le);function rr(t){return p(t,[Pe,Ke],[Ge,Xe],[Be,tr],[Qe,er])}function nr(t){return p(t.replace(/\\([^)]*\\)|[\\n\\t]/g,\" \").replace(/(\\s\\s+)/g,\" \").trim(),[Ue,$e])}function sr(t){return p(t,[He,Je],[We,Je],[Re,Ye])}function ir(t){return p(t,[qe,Ae])}const ar=g(S);function or(t){return p(t,[ze,ar])}const ur=a(/(\\d{4})-(\\d\\d)-(\\d\\d)/,n),lr=a(e),cr=g(S,Ze,Le);function hr(t){return p(t,[ur,Ke],[lr,cr])}const dr={weeks:{days:7,hours:168,minutes:10080,seconds:604800,milliseconds:6048e5},days:{hours:24,minutes:1440,seconds:86400,milliseconds:864e5},hours:{minutes:60,seconds:3600,milliseconds:36e5},minutes:{seconds:60,milliseconds:6e4},seconds:{milliseconds:1e3}},mr={years:{quarters:4,months:12,weeks:52,days:365,hours:8760,minutes:525600,seconds:31536e3,milliseconds:31536e6},quarters:{months:3,weeks:13,days:91,hours:2184,minutes:131040,seconds:7862400,milliseconds:78624e5},months:{weeks:4,days:30,hours:720,minutes:43200,seconds:2592e3,milliseconds:2592e6},...dr},N=365.2425,fr=30.436875,yr={years:{quarters:4,months:12,weeks:N/7,days:N,hours:24*N,minutes:525949.2,seconds:525949.2*60,milliseconds:525949.2*60*1e3},quarters:{months:3,weeks:N/28,days:N/4,hours:24*N/4,minutes:131487.3,seconds:525949.2*60/4,milliseconds:7889237999.999999},months:{weeks:fr/7,days:fr,hours:24*fr,minutes:43829.1,seconds:2629746,milliseconds:2629746e3},...dr},D=[\"years\",\"quarters\",\"months\",\"weeks\",\"days\",\"hours\",\"minutes\",\"seconds\",\"milliseconds\"],gr=D.slice(0).reverse();function E(t,e,r=!1){r={values:r?e.values:{...t.values,...e.values||{}},loc:t.loc.clone(e.loc),conversionAccuracy:e.conversionAccuracy||t.conversionAccuracy,matrix:e.matrix||t.matrix};return new V(r)}function wr(t,e,r,n,s){var t=t[s][r],i=e[r]/t,a=!(Math.sign(i)===Math.sign(n[s]))&&0!==n[s]&&Math.abs(i)<=1?(a=i)<0?Math.floor(a):Math.ceil(a):Math.trunc(i);n[s]+=a,e[r]-=a*t}function vr(r,n){gr.reduce((t,e)=>O(n[e])?t:(t&&wr(r,n,t,n,e),e),null)}class V{constructor(t){var e=\"longterm\"===t.conversionAccuracy||!1;let r=e?yr:mr;t.matrix&&(r=t.matrix),this.values=t.values,this.loc=t.loc||M.create(),this.conversionAccuracy=e?\"longterm\":\"casual\",this.invalid=t.invalid||null,this.matrix=r,this.isLuxonDuration=!0}static fromMillis(t,e){return V.fromObject({milliseconds:t},e)}static fromObject(t,e={}){if(null==t||\"object\"!=typeof t)throw new o(\"Duration.fromObject: argument expected to be an object, got \"+(null===t?\"null\":typeof t));return new V({values:Mt(t,V.normalizeUnit),loc:M.fromObject(e),conversionAccuracy:e.conversionAccuracy,matrix:e.matrix})}static fromDurationLike(t){if(c(t))return V.fromMillis(t);if(V.isDuration(t))return t;if(\"object\"==typeof t)return V.fromObject(t);throw new o(`Unknown duration argument ${t} of type `+typeof t)}static fromISO(t,e){var[r]=ir(t);return r?V.fromObject(r,e):V.invalid(\"unparsable\",`the input \"${t}\" can't be parsed as ISO 8601`)}static fromISOTime(t,e){var[r]=or(t);return r?V.fromObject(r,e):V.invalid(\"unparsable\",`the input \"${t}\" can't be parsed as ISO 8601`)}static invalid(t,e=null){if(!t)throw new o(\"need to specify a reason the Duration is invalid\");t=t instanceof y?t:new y(t,e);if(k.throwOnInvalid)throw new A(t);return new V({invalid:t})}static normalizeUnit(t){var e={year:\"years\",years:\"years\",quarter:\"quarters\",quarters:\"quarters\",month:\"months\",months:\"months\",week:\"weeks\",weeks:\"weeks\",day:\"days\",days:\"days\",hour:\"hours\",hours:\"hours\",minute:\"minutes\",minutes:\"minutes\",second:\"seconds\",seconds:\"seconds\",millisecond:\"milliseconds\",milliseconds:\"milliseconds\"}[t&&t.toLowerCase()];if(e)return e;throw new _(t)}static isDuration(t){return t&&t.isLuxonDuration||!1}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}toFormat(t,e={}){e={...e,floor:!1!==e.round&&!1!==e.floor};return this.isValid?f.create(this.loc,e).formatDurationFromString(this,t):\"Invalid Duration\"}toHuman(r={}){var t=D.map(t=>{var e=this.values[t];return O(e)?null:this.loc.numberFormatter({style:\"unit\",unitDisplay:\"long\",...r,unit:t.slice(0,-1)}).format(e)}).filter(t=>t);return this.loc.listFormatter({type:\"conjunction\",style:r.listStyle||\"narrow\",...r}).format(t)}toObject(){return this.isValid?{...this.values}:{}}toISO(){if(!this.isValid)return null;let t=\"P\";return 0!==this.years&&(t+=this.years+\"Y\"),0===this.months&&0===this.quarters||(t+=this.months+3*this.quarters+\"M\"),0!==this.weeks&&(t+=this.weeks+\"W\"),0!==this.days&&(t+=this.days+\"D\"),0===this.hours&&0===this.minutes&&0===this.seconds&&0===this.milliseconds||(t+=\"T\"),0!==this.hours&&(t+=this.hours+\"H\"),0!==this.minutes&&(t+=this.minutes+\"M\"),0===this.seconds&&0===this.milliseconds||(t+=yt(this.seconds+this.milliseconds/1e3,3)+\"S\"),\"P\"===t&&(t+=\"T0S\"),t}toISOTime(t={}){if(!this.isValid)return null;var e=this.toMillis();if(e<0||864e5<=e)return null;t={suppressMilliseconds:!1,suppressSeconds:!1,includePrefix:!1,format:\"extended\",...t};const r=this.shiftTo(\"hours\",\"minutes\",\"seconds\",\"milliseconds\");let n=\"basic\"===t.format?\"hhmm\":\"hh:mm\",s=(t.suppressSeconds&&0===r.seconds&&0===r.milliseconds||(n+=\"basic\"===t.format?\"ss\":\":ss\",t.suppressMilliseconds&&0===r.milliseconds||(n+=\".SSS\")),r.toFormat(n));return s=t.includePrefix?\"T\"+s:s}toJSON(){return this.toISO()}toString(){return this.toISO()}toMillis(){return this.as(\"milliseconds\")}valueOf(){return this.toMillis()}plus(t){if(!this.isValid)return this;const e=V.fromDurationLike(t),r={};for(const n of D)(h(e.values,n)||h(this.values,n))&&(r[n]=e.get(n)+this.get(n));return E(this,{values:r},!0)}minus(t){if(!this.isValid)return this;const e=V.fromDurationLike(t);return this.plus(e.negate())}mapUnits(t){if(!this.isValid)return this;const e={};for(const r of Object.keys(this.values))e[r]=kt(t(this.values[r],r));return E(this,{values:e},!0)}get(t){return this[V.normalizeUnit(t)]}set(t){return this.isValid?E(this,{values:{...this.values,...Mt(t,V.normalizeUnit)}}):this}reconfigure({locale:t,numberingSystem:e,conversionAccuracy:r,matrix:n}={}){t=this.loc.clone({locale:t,numberingSystem:e});return E(this,{loc:t,matrix:n,conversionAccuracy:r})}as(t){return this.isValid?this.shiftTo(t).get(t):NaN}normalize(){if(!this.isValid)return this;var t=this.toObject();return vr(this.matrix,t),E(this,{values:t},!0)}shiftTo(...t){if(!this.isValid)return this;if(0===t.length)return this;t=t.map(t=>V.normalizeUnit(t));const e={},r={},n=this.toObject();let s;for(const a of D)if(0<=t.indexOf(a)){s=a;let t=0;for(const o in r)t+=this.matrix[o][a]*r[o],r[o]=0;c(n[a])&&(t+=n[a]);var i=Math.trunc(t);e[a]=i,r[a]=(1e3*t-1e3*i)/1e3;for(const u in n)D.indexOf(u)>D.indexOf(a)&&wr(this.matrix,n,u,e,a)}else c(n[a])&&(r[a]=n[a]);for(const l in r)0!==r[l]&&(e[s]+=l===s?r[l]:r[l]/this.matrix[s][l]);return E(this,{values:e},!0).normalize()}negate(){if(!this.isValid)return this;const t={};for(const e of Object.keys(this.values))t[e]=0===this.values[e]?0:-this.values[e];return E(this,{values:t},!0)}get years(){return this.isValid?this.values.years||0:NaN}get quarters(){return this.isValid?this.values.quarters||0:NaN}get months(){return this.isValid?this.values.months||0:NaN}get weeks(){return this.isValid?this.values.weeks||0:NaN}get days(){return this.isValid?this.values.days||0:NaN}get hours(){return this.isValid?this.values.hours||0:NaN}get minutes(){return this.isValid?this.values.minutes||0:NaN}get seconds(){return this.isValid?this.values.seconds||0:NaN}get milliseconds(){return this.isValid?this.values.milliseconds||0:NaN}get isValid(){return null===this.invalid}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}equals(t){if(!this.isValid||!t.isValid)return!1;if(!this.loc.equals(t.loc))return!1;for(const n of D)if(e=this.values[n],r=t.values[n],!(void 0===e||0===e?void 0===r||0===r:e===r))return!1;var e,r;return!0}}const pr=\"Invalid Interval\";function Tr(t,e){return t&&t.isValid?e&&e.isValid?e<t?x.invalid(\"end before start\",`The end of an interval must be after its start, but you had start=${t.toISO()} and end=`+e.toISO()):null:x.invalid(\"missing or invalid end\"):x.invalid(\"missing or invalid start\")}class x{constructor(t){this.s=t.start,this.e=t.end,this.invalid=t.invalid||null,this.isLuxonInterval=!0}static invalid(t,e=null){if(!t)throw new o(\"need to specify a reason the Interval is invalid\");t=t instanceof y?t:new y(t,e);if(k.throwOnInvalid)throw new q(t);return new x({invalid:t})}static fromDateTimes(t,e){var t=On(t),e=On(e),r=Tr(t,e);return null==r?new x({start:t,end:e}):r}static after(t,e){const r=V.fromDurationLike(e),n=On(t);return x.fromDateTimes(n,n.plus(r))}static before(t,e){const r=V.fromDurationLike(e),n=On(t);return x.fromDateTimes(n.minus(r),n)}static fromISO(t,s){var[i,a]=(t||\"\").split(\"/\",2);if(i&&a){let t,e;try{t=L.fromISO(i,s),e=t.isValid}catch(a){e=!1}let r,n;try{r=L.fromISO(a,s),n=r.isValid}catch(a){n=!1}if(e&&n)return x.fromDateTimes(t,r);if(e){var o=V.fromISO(a,s);if(o.isValid)return x.after(t,o)}else if(n){o=V.fromISO(i,s);if(o.isValid)return x.before(r,o)}}return x.invalid(\"unparsable\",`the input \"${t}\" can't be parsed as ISO 8601`)}static isInterval(t){return t&&t.isLuxonInterval||!1}get start(){return this.isValid?this.s:null}get end(){return this.isValid?this.e:null}get isValid(){return null===this.invalidReason}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}length(t=\"milliseconds\"){return this.isValid?this.toDuration(t).get(t):NaN}count(t=\"milliseconds\"){if(!this.isValid)return NaN;const e=this.start.startOf(t),r=this.end.startOf(t);return Math.floor(r.diff(e,t).get(t))+1}hasSame(t){return!!this.isValid&&(this.isEmpty()||this.e.minus(1).hasSame(this.s,t))}isEmpty(){return this.s.valueOf()===this.e.valueOf()}isAfter(t){return!!this.isValid&&this.s>t}isBefore(t){return!!this.isValid&&this.e<=t}contains(t){return!!this.isValid&&(this.s<=t&&this.e>t)}set({start:t,end:e}={}){return this.isValid?x.fromDateTimes(t||this.s,e||this.e):this}splitAt(...t){if(!this.isValid)return[];const e=t.map(On).filter(t=>this.contains(t)).sort(),r=[];let n=this[\"s\"],s=0;for(;n<this.e;){var i=e[s]||this.e,i=+i>+this.e?this.e:i;r.push(x.fromDateTimes(n,i)),n=i,s+=1}return r}splitBy(t){const e=V.fromDurationLike(t);if(!this.isValid||!e.isValid||0===e.as(\"milliseconds\"))return[];let r=this[\"s\"],n=1,s;const i=[];for(;r<this.e;){var a=this.start.plus(e.mapUnits(t=>t*n));s=+a>+this.e?this.e:a,i.push(x.fromDateTimes(r,s)),r=s,n+=1}return i}divideEqually(t){return this.isValid?this.splitBy(this.length()/t).slice(0,t):[]}overlaps(t){return this.e>t.s&&this.s<t.e}abutsStart(t){return!!this.isValid&&+this.e==+t.s}abutsEnd(t){return!!this.isValid&&+t.e==+this.s}engulfs(t){return!!this.isValid&&(this.s<=t.s&&this.e>=t.e)}equals(t){return!(!this.isValid||!t.isValid)&&(this.s.equals(t.s)&&this.e.equals(t.e))}intersection(t){if(!this.isValid)return this;var e=(this.s>t.s?this:t).s,t=(this.e<t.e?this:t).e;return t<=e?null:x.fromDateTimes(e,t)}union(t){if(!this.isValid)return this;var e=(this.s<t.s?this:t).s,t=(this.e>t.e?this:t).e;return x.fromDateTimes(e,t)}static merge(t){const[e,r]=t.sort((t,e)=>t.s-e.s).reduce(([t,e],r)=>e?e.overlaps(r)||e.abutsStart(r)?[t,e.union(r)]:[t.concat([e]),r]:[t,r],[[],null]);return r&&e.push(r),e}static xor(t){let e=null,r=0;const n=[],s=t.map(t=>[{time:t.s,type:\"s\"},{time:t.e,type:\"e\"}]),i=Array.prototype.concat(...s),a=i.sort((t,e)=>t.time-e.time);for(const o of a)r+=\"s\"===o.type?1:-1,e=1===r?o.time:(e&&+e!=+o.time&&n.push(x.fromDateTimes(e,o.time)),null);return x.merge(n)}difference(...t){return x.xor([this].concat(t)).map(t=>this.intersection(t)).filter(t=>t&&!t.isEmpty())}toString(){return this.isValid?`[${this.s.toISO()} \u2013 ${this.e.toISO()})`:pr}toISO(t){return this.isValid?this.s.toISO(t)+\"/\"+this.e.toISO(t):pr}toISODate(){return this.isValid?this.s.toISODate()+\"/\"+this.e.toISODate():pr}toISOTime(t){return this.isValid?this.s.toISOTime(t)+\"/\"+this.e.toISOTime(t):pr}toFormat(t,{separator:e=\" \u2013 \"}={}){return this.isValid?\"\"+this.s.toFormat(t)+e+this.e.toFormat(t):pr}toDuration(t,e){return this.isValid?this.e.diff(this.s,t,e):V.invalid(this.invalidReason)}mapEndpoints(t){return x.fromDateTimes(t(this.s),t(this.e))}}class Sr{static hasDST(t=k.defaultZone){const e=L.now().setZone(t).set({month:12});return!t.isUniversal&&e.offset!==e.set({month:6}).offset}static isValidIANAZone(t){return w.isValidZone(t)}static normalizeZone(t){return b(t,k.defaultZone)}static months(t=\"long\",{locale:e=null,numberingSystem:r=null,locObj:n=null,outputCalendar:s=\"gregory\"}={}){return(n||M.create(e,r,s)).months(t)}static monthsFormat(t=\"long\",{locale:e=null,numberingSystem:r=null,locObj:n=null,outputCalendar:s=\"gregory\"}={}){return(n||M.create(e,r,s)).months(t,!0)}static weekdays(t=\"long\",{locale:e=null,numberingSystem:r=null,locObj:n=null}={}){return(n||M.create(e,r,null)).weekdays(t)}static weekdaysFormat(t=\"long\",{locale:e=null,numberingSystem:r=null,locObj:n=null}={}){return(n||M.create(e,r,null)).weekdays(t,!0)}static meridiems({locale:t=null}={}){return M.create(t).meridiems()}static eras(t=\"short\",{locale:e=null}={}){return M.create(e,null,\"gregory\").eras(t)}static features(){return{relative:ht()}}}function Or(t,e){var r=t=>t.toUTC(0,{keepLocalTime:!0}).startOf(\"day\").valueOf(),e=r(e)-r(t);return Math.floor(V.fromMillis(e).as(\"days\"))}function br(t,e,r,n){let[s,i,a,o]=function(e,r,t){var n,s;const i={};let a,o;for([n,s]of[[\"years\",(t,e)=>e.year-t.year],[\"quarters\",(t,e)=>e.quarter-t.quarter],[\"months\",(t,e)=>e.month-t.month+12*(e.year-t.year)],[\"weeks\",(t,e)=>{t=Or(t,e);return(t-t%7)/7}],[\"days\",Or]])if(0<=t.indexOf(n)){a=n;let t=s(e,r);(o=e.plus({[n]:t}))>r?(e=e.plus({[n]:t-1}),--t):e=o,i[n]=t}return[e,i,o,a]}(t,e,r);t=e-s,r=r.filter(t=>0<=[\"hours\",\"minutes\",\"seconds\",\"milliseconds\"].indexOf(t)),0===r.length&&(a=a<e?s.plus({[o]:1}):a)!==s&&(i[o]=(i[o]||0)+t/(a-s)),e=V.fromObject(i,n);return 0<r.length?V.fromMillis(t,n).shiftTo(...r).plus(e):e}const kr={arab:\"[\u0660-\u0669]\",arabext:\"[\u06F0-\u06F9]\",bali:\"[\u1B50-\u1B59]\",beng:\"[\u09E6-\u09EF]\",deva:\"[\u0966-\u096F]\",fullwide:\"[\uFF10-\uFF19]\",gujr:\"[\u0AE6-\u0AEF]\",hanidec:\"[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]\",khmr:\"[\u17E0-\u17E9]\",knda:\"[\u0CE6-\u0CEF]\",laoo:\"[\u0ED0-\u0ED9]\",limb:\"[\u1946-\u194F]\",mlym:\"[\u0D66-\u0D6F]\",mong:\"[\u1810-\u1819]\",mymr:\"[\u1040-\u1049]\",orya:\"[\u0B66-\u0B6F]\",tamldec:\"[\u0BE6-\u0BEF]\",telu:\"[\u0C66-\u0C6F]\",thai:\"[\u0E50-\u0E59]\",tibt:\"[\u0F20-\u0F29]\",latn:\"\\\\d\"},Mr={arab:[1632,1641],arabext:[1776,1785],bali:[6992,7001],beng:[2534,2543],deva:[2406,2415],fullwide:[65296,65303],gujr:[2790,2799],khmr:[6112,6121],knda:[3302,3311],laoo:[3792,3801],limb:[6470,6479],mlym:[3430,3439],mong:[6160,6169],mymr:[4160,4169],orya:[2918,2927],tamldec:[3046,3055],telu:[3174,3183],thai:[3664,3673],tibt:[3872,3881]},Nr=kr.hanidec.replace(/[\\[|\\]]/g,\"\").split(\"\");function I({numberingSystem:t},e=\"\"){return new RegExp(\"\"+kr[t||\"latn\"]+e)}const Dr=\"missing Intl.DateTimeFormat.formatToParts support\";function C(t,e=t=>t){return{regex:t,deser:([t])=>e(function(e){let r=parseInt(e,10);if(isNaN(r)){r=\"\";for(let t=0;t<e.length;t++){var n=e.charCodeAt(t);if(-1!==e[t].search(kr.hanidec))r+=Nr.indexOf(e[t]);else for(const a in Mr){var[s,i]=Mr[a];s<=n&&n<=i&&(r+=n-s)}}return parseInt(r,10)}return r}(t))}}const Er=`[ ${String.fromCharCode(160)}]`,Vr=new RegExp(Er,\"g\");function xr(t){return t.replace(/\\./g,\"\\\\.?\").replace(Vr,Er)}function Ir(t){return t.replace(/\\./g,\"\").replace(Vr,\" \").toLowerCase()}function F(t,r){return null===t?null:{regex:RegExp(t.map(xr).join(\"|\")),deser:([e])=>t.findIndex(t=>Ir(e)===Ir(t))+r}}function Cr(t,e){return{regex:t,deser:([,t,e])=>bt(t,e),groups:e}}function Fr(t){return{regex:t,deser:([t])=>t}}const Zr={year:{\"2-digit\":\"yy\",numeric:\"yyyyy\"},month:{numeric:\"M\",\"2-digit\":\"MM\",short:\"MMM\",long:\"MMMM\"},day:{numeric:\"d\",\"2-digit\":\"dd\"},weekday:{short:\"EEE\",long:\"EEEE\"},dayperiod:\"a\",dayPeriod:\"a\",hour:{numeric:\"h\",\"2-digit\":\"hh\"},minute:{numeric:\"m\",\"2-digit\":\"mm\"},second:{numeric:\"s\",\"2-digit\":\"ss\"},timeZoneName:{long:\"ZZZZZ\",short:\"ZZZ\"}};let Lr=null;function zr(t,n){return Array.prototype.concat(...t.map(t=>{{var e=n;if(t.literal)return t;const r=jr(f.macroTokenToFormatOpts(t.val),e);return null==r||r.includes(void 0)?t:r}}))}function qr(g,t,e){const r=zr(f.parseFormat(e),g),n=r.map(t=>{{var e=t,r=g;const n=I(r),s=I(r,\"{2}\"),i=I(r,\"{3}\"),a=I(r,\"{4}\"),o=I(r,\"{6}\"),u=I(r,\"{1,2}\"),l=I(r,\"{1,3}\"),c=I(r,\"{1,6}\"),h=I(r,\"{1,9}\"),d=I(r,\"{2,4}\"),m=I(r,\"{4,6}\"),f=t=>({regex:RegExp(t.val.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g,\"\\\\$&\")),deser:([t])=>t,literal:!0}),y=(t=>{if(e.literal)return f(t);switch(t.val){case\"G\":return F(r.eras(\"short\",!1),0);case\"GG\":return F(r.eras(\"long\",!1),0);case\"y\":return C(c);case\"yy\":return C(d,St);case\"yyyy\":return C(a);case\"yyyyy\":return C(m);case\"yyyyyy\":return C(o);case\"M\":return C(u);case\"MM\":return C(s);case\"MMM\":return F(r.months(\"short\",!0,!1),1);case\"MMMM\":return F(r.months(\"long\",!0,!1),1);case\"L\":return C(u);case\"LL\":return C(s);case\"LLL\":return F(r.months(\"short\",!1,!1),1);case\"LLLL\":return F(r.months(\"long\",!1,!1),1);case\"d\":return C(u);case\"dd\":return C(s);case\"o\":return C(l);case\"ooo\":return C(i);case\"HH\":return C(s);case\"H\":return C(u);case\"hh\":return C(s);case\"h\":return C(u);case\"mm\":return C(s);case\"m\":case\"q\":return C(u);case\"qq\":return C(s);case\"s\":return C(u);case\"ss\":return C(s);case\"S\":return C(l);case\"SSS\":return C(i);case\"u\":return Fr(h);case\"uu\":return Fr(u);case\"uuu\":return C(n);case\"a\":return F(r.meridiems(),0);case\"kkkk\":return C(a);case\"kk\":return C(d,St);case\"W\":return C(u);case\"WW\":return C(s);case\"E\":case\"c\":return C(n);case\"EEE\":return F(r.weekdays(\"short\",!1,!1),1);case\"EEEE\":return F(r.weekdays(\"long\",!1,!1),1);case\"ccc\":return F(r.weekdays(\"short\",!0,!1),1);case\"cccc\":return F(r.weekdays(\"long\",!0,!1),1);case\"Z\":case\"ZZ\":return Cr(new RegExp(`([+-]${u.source})(?::(${s.source}))?`),2);case\"ZZZ\":return Cr(new RegExp(`([+-]${u.source})(${s.source})?`),2);case\"z\":return Fr(/[a-z_+-/]{1,256}?/i);default:return f(t)}})(e)||{invalidReason:Dr};return y.token=e,y}}),s=n.find(t=>t.invalidReason);if(s)return{input:t,tokens:r,invalidReason:s.invalidReason};var[e,i]=[`^${(e=n).map(t=>t.regex).reduce((t,e)=>`${t}(${e.source})`,\"\")}$`,e],e=RegExp(e,\"i\"),[i,a]=function(t,e,r){const n=t.match(e);if(n){const s={};let t=1;for(const i in r)if(h(r,i)){const a=r[i],o=a.groups?a.groups+1:1;!a.literal&&a.token&&(s[a.token.val[0]]=a.deser(n.slice(t,t+o))),t+=o}return[n,s]}return[n,{}]}(t,e,i),[o,u,l]=a?function(n){let t=null,e;return O(n.z)||(t=w.create(n.z)),O(n.Z)||(t=t||new v(n.Z),e=n.Z),O(n.q)||(n.M=3*(n.q-1)+1),O(n.h)||(n.h<12&&1===n.a?n.h+=12:12===n.h&&0===n.a&&(n.h=0)),0===n.G&&n.y&&(n.y=-n.y),O(n.u)||(n.S=ft(n.u)),[Object.keys(n).reduce((t,e)=>{var r=(t=>{switch(t){case\"S\":return\"millisecond\";case\"s\":return\"second\";case\"m\":return\"minute\";case\"h\":case\"H\":return\"hour\";case\"d\":return\"day\";case\"o\":return\"ordinal\";case\"L\":case\"M\":return\"month\";case\"y\":return\"year\";case\"E\":case\"c\":return\"weekday\";case\"W\":return\"weekNumber\";case\"k\":return\"weekYear\";case\"q\":return\"quarter\";default:return null}})(e);return r&&(t[r]=n[e]),t},{}),t,e]}(a):[null,null,void 0];if(h(a,\"a\")&&h(a,\"H\"))throw new j(\"Can't include meridiem when specifying 24-hour format\");return{input:t,tokens:r,regex:e,rawMatches:i,matches:a,result:o,zone:u,specificOffset:l}}function Ar(t,e,r){var{result:t,zone:e,specificOffset:r,invalidReason:n}=qr(t,e,r);return[t,e,r,n]}function jr(s,t){if(!s)return null;const e=f.create(t,s),r=e.formatDateTimeParts(Lr=Lr||L.fromMillis(1555555555555));return r.map(e=>{{var r=s,{type:e,value:n}=e;if(\"literal\"===e)return{literal:!0,val:n};n=r[e];let t=Zr[e];return(t=\"object\"==typeof t?t[n]:t)?{literal:!1,val:t}:void 0}})}const _r=[0,31,59,90,120,151,181,212,243,273,304,334],Ur=[0,31,60,91,121,152,182,213,244,274,305,335];function Z(t,e){return new y(\"unit out of range\",`you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`)}function $r(t,e,r){const n=new Date(Date.UTC(t,e-1,r));t<100&&0<=t&&n.setUTCFullYear(n.getUTCFullYear()-1900);e=n.getUTCDay();return 0===e?7:e}function Hr(t,e,r){return r+(gt(t)?Ur:_r)[e-1]}function Wr(t,e){const r=gt(t)?Ur:_r,n=r.findIndex(t=>t<e),s=e-r[n];return{month:n+1,day:s}}function Rr(t){var{year:e,month:r,day:n}=t,s=Hr(e,r,n),r=$r(e,r,n);let i=Math.floor((s-r+10)/7),a;return i<1?(a=e-1,i=Tt(a)):i>Tt(e)?(a=e+1,i=1):a=e,{weekYear:a,weekNumber:i,weekday:r,...Dt(t)}}function Jr(t){var{weekYear:e,weekNumber:r,weekday:n}=t,s=$r(e,1,4),i=wt(e);let a=7*r+n-s-3,o;a<1?(o=e-1,a+=wt(o)):a>i?(o=e+1,a-=wt(e)):o=e;var{month:r,day:n}=Wr(o,a);return{year:o,month:r,day:n,...Dt(t)}}function Yr(t){var{year:e,month:r,day:n}=t;return{year:e,ordinal:Hr(e,r,n),...Dt(t)}}function Pr(t){var{year:e,ordinal:r}=t,{month:r,day:n}=Wr(e,r);return{year:e,month:r,day:n,...Dt(t)}}function Gr(t){var e=lt(t.weekYear),r=u(t.weekNumber,1,Tt(t.weekYear)),n=u(t.weekday,1,7);return e?r?!n&&Z(\"weekday\",t.weekday):Z(\"week\",t.week):Z(\"weekYear\",t.weekYear)}function Br(t){var e=lt(t.year),r=u(t.ordinal,1,wt(t.year));return e?!r&&Z(\"ordinal\",t.ordinal):Z(\"year\",t.year)}function Qr(t){var e=lt(t.year),r=u(t.month,1,12),n=u(t.day,1,vt(t.year,t.month));return e?r?!n&&Z(\"day\",t.day):Z(\"month\",t.month):Z(\"year\",t.year)}function Kr(t){var{hour:t,minute:e,second:r,millisecond:n}=t,s=u(t,0,23)||24===t&&0===e&&0===r&&0===n,i=u(e,0,59),a=u(r,0,59),o=u(n,0,999);return s?i?a?!o&&Z(\"millisecond\",n):Z(\"second\",r):Z(\"minute\",e):Z(\"hour\",t)}const Xr=\"Invalid DateTime\";function tn(t){return new y(\"unsupported zone\",`the zone \"${t.name}\" is not supported`)}function en(t){return null===t.weekData&&(t.weekData=Rr(t.c)),t.weekData}function rn(t,e){t={ts:t.ts,zone:t.zone,c:t.c,o:t.o,loc:t.loc,invalid:t.invalid};return new L({...t,...e,old:t})}function nn(t,e,r){let n=t-60*e*1e3;var s=r.offset(n);if(e===s)return[n,e];n-=60*(s-e)*1e3;e=r.offset(n);return s===e?[n,s]:[t-60*Math.min(s,e)*1e3,Math.max(s,e)]}function sn(t,e){t+=60*e*1e3;const r=new Date(t);return{year:r.getUTCFullYear(),month:r.getUTCMonth()+1,day:r.getUTCDate(),hour:r.getUTCHours(),minute:r.getUTCMinutes(),second:r.getUTCSeconds(),millisecond:r.getUTCMilliseconds()}}function an(t,e,r){return nn(pt(t),e,r)}function on(t,e){var r=t.o,n=t.c.year+Math.trunc(e.years),s=t.c.month+Math.trunc(e.months)+3*Math.trunc(e.quarters),n={...t.c,year:n,month:s,day:Math.min(t.c.day,vt(n,s))+Math.trunc(e.days)+7*Math.trunc(e.weeks)},s=V.fromObject({years:e.years-Math.trunc(e.years),quarters:e.quarters-Math.trunc(e.quarters),months:e.months-Math.trunc(e.months),weeks:e.weeks-Math.trunc(e.weeks),days:e.days-Math.trunc(e.days),hours:e.hours,minutes:e.minutes,seconds:e.seconds,milliseconds:e.milliseconds}).as(\"milliseconds\");let[i,a]=nn(pt(n),r,t.zone);return 0!==s&&(i+=s,a=t.zone.offset(i)),{ts:i,o:a}}function un(t,e,r,n,s,i){var{setZone:a,zone:o}=r;if(t&&0!==Object.keys(t).length){const u=e||o,l=L.fromObject(t,{...r,zone:u,specificOffset:i});return a?l:l.setZone(o)}return L.invalid(new y(\"unparsable\",`the input \"${s}\" can't be parsed as `+n))}function ln(t,e,r=!0){return t.isValid?f.create(M.create(\"en-US\"),{allowZ:r,forceSimple:!0}).formatDateTimeFromString(t,e):null}function cn(t,e){var r=9999<t.c.year||t.c.year<0;let n=\"\";return r&&0<=t.c.year&&(n+=\"+\"),n+=l(t.c.year,r?6:4),n=e?(n=(n+=\"-\")+l(t.c.month)+\"-\")+l(t.c.day):(n+=l(t.c.month))+l(t.c.day)}function hn(t,e,r,n,s,i){let a=l(t.c.hour);return e?(a=(a+=\":\")+l(t.c.minute),0===t.c.second&&r||(a+=\":\")):a+=l(t.c.minute),0===t.c.second&&r||(a+=l(t.c.second),0===t.c.millisecond&&n||(a=(a+=\".\")+l(t.c.millisecond,3))),s&&(t.isOffsetFixed&&0===t.offset&&!i?a+=\"Z\":a=t.o<0?(a=(a+=\"-\")+l(Math.trunc(-t.o/60))+\":\")+l(Math.trunc(-t.o%60)):(a=(a+=\"+\")+l(Math.trunc(t.o/60))+\":\")+l(Math.trunc(t.o%60))),i&&(a+=\"[\"+t.zone.ianaName+\"]\"),a}const dn={month:1,day:1,hour:0,minute:0,second:0,millisecond:0},mn={weekNumber:1,weekday:1,hour:0,minute:0,second:0,millisecond:0},fn={ordinal:1,hour:0,minute:0,second:0,millisecond:0},yn=[\"year\",\"month\",\"day\",\"hour\",\"minute\",\"second\",\"millisecond\"],gn=[\"weekYear\",\"weekNumber\",\"weekday\",\"hour\",\"minute\",\"second\",\"millisecond\"],wn=[\"year\",\"ordinal\",\"hour\",\"minute\",\"second\",\"millisecond\"];function vn(t){var e={year:\"year\",years:\"year\",month:\"month\",months:\"month\",day:\"day\",days:\"day\",hour:\"hour\",hours:\"hour\",minute:\"minute\",minutes:\"minute\",quarter:\"quarter\",quarters:\"quarter\",second:\"second\",seconds:\"second\",millisecond:\"millisecond\",milliseconds:\"millisecond\",weekday:\"weekday\",weekdays:\"weekday\",weeknumber:\"weekNumber\",weeksnumber:\"weekNumber\",weeknumbers:\"weekNumber\",weekyear:\"weekYear\",weekyears:\"weekYear\",ordinal:\"ordinal\"}[t.toLowerCase()];if(e)return e;throw new _(t)}function pn(t,e){const r=b(e.zone,k.defaultZone),n=M.fromObject(e),s=k.now();let i,a;if(O(t.year))i=s;else{for(const o of yn)O(t[o])&&(t[o]=dn[o]);e=Qr(t)||Kr(t);if(e)return L.invalid(e);e=r.offset(s);[i,a]=an(t,e,r)}return new L({ts:i,zone:r,loc:n,o:a})}function Tn(e,n,s){const i=!!O(s.round)||s.round,t=(t,e)=>{t=yt(t,i||s.calendary?0:2,!0);const r=n.loc.clone(s).relFormatter(s);return r.format(t,e)},r=t=>s.calendary?n.hasSame(e,t)?0:n.startOf(t).diff(e.startOf(t),t).get(t):n.diff(e,t).get(t);if(s.unit)return t(r(s.unit),s.unit);for(const o of s.units){var a=r(o);if(1<=Math.abs(a))return t(a,o)}return t(n<e?-0:0,s.units[s.units.length-1])}function Sn(t){let e={},r;return r=0<t.length&&\"object\"==typeof t[t.length-1]?(e=t[t.length-1],Array.from(t).slice(0,t.length-1)):Array.from(t),[e,r]}class L{constructor(t){const e=t.zone||k.defaultZone;let r=t.invalid||(Number.isNaN(t.ts)?new y(\"invalid input\"):null)||(e.isValid?null:tn(e)),n=(this.ts=O(t.ts)?k.now():t.ts,null),s=null;var i;r||(t.old&&t.old.ts===this.ts&&t.old.zone.equals(e)?[n,s]=[t.old.c,t.old.o]:(i=e.offset(this.ts),n=sn(this.ts,i),r=Number.isNaN(n.year)?new y(\"invalid input\"):null,n=r?null:n,s=r?null:i)),this._zone=e,this.loc=t.loc||M.create(),this.invalid=r,this.weekData=null,this.c=n,this.o=s,this.isLuxonDateTime=!0}static now(){return new L({})}static local(){var[t,e]=Sn(arguments),[e,r,n,s,i,a,o]=e;return pn({year:e,month:r,day:n,hour:s,minute:i,second:a,millisecond:o},t)}static utc(){const[t,e]=Sn(arguments),[r,n,s,i,a,o,u]=e;return t.zone=v.utcInstance,pn({year:r,month:n,day:s,hour:i,minute:a,second:o,millisecond:u},t)}static fromJSDate(t,e={}){t=ct(t)?t.valueOf():NaN;if(Number.isNaN(t))return L.invalid(\"invalid input\");var r=b(e.zone,k.defaultZone);return r.isValid?new L({ts:t,zone:r,loc:M.fromObject(e)}):L.invalid(tn(r))}static fromMillis(t,e={}){if(c(t))return t<-864e13||864e13<t?L.invalid(\"Timestamp out of range\"):new L({ts:t,zone:b(e.zone,k.defaultZone),loc:M.fromObject(e)});throw new o(`fromMillis requires a numerical input, but received a ${typeof t} with value `+t)}static fromSeconds(t,e={}){if(c(t))return new L({ts:1e3*t,zone:b(e.zone,k.defaultZone),loc:M.fromObject(e)});throw new o(\"fromSeconds requires a numerical input\")}static fromObject(t,e={}){t=t||{};const r=b(e.zone,k.defaultZone);if(!r.isValid)return L.invalid(tn(r));const n=k.now(),s=O(e.specificOffset)?r.offset(n):e.specificOffset,i=Mt(t,vn),a=!O(i.ordinal),o=!O(i.year),u=!O(i.month)||!O(i.day),l=o||u,c=i.weekYear||i.weekNumber,h=M.fromObject(e);if((l||a)&&c)throw new j(\"Can't mix weekYear/weekNumber units with year/month/day or ordinals\");if(u&&a)throw new j(\"Can't mix ordinal dates with month/day\");e=c||i.weekday&&!l;let d,m,f=sn(n,s),y=(e?(d=gn,m=mn,f=Rr(f)):a?(d=wn,m=fn,f=Yr(f)):(d=yn,m=dn),!1);for(const S of d)O(i[S])?y?i[S]=m[S]:i[S]=f[S]:y=!0;var g=(e?Gr:a?Br:Qr)(i)||Kr(i);if(g)return L.invalid(g);const w=e?Jr(i):a?Pr(i):i,[v,p]=an(w,s,r),T=new L({ts:v,zone:r,o:p,loc:h});return i.weekday&&l&&t.weekday!==T.weekday?L.invalid(\"mismatched weekday\",`you can't specify both a weekday of ${i.weekday} and a date of `+T.toISO()):T}static fromISO(t,e={}){var[r,n]=rr(t);return un(r,n,e,\"ISO 8601\",t)}static fromRFC2822(t,e={}){var[r,n]=nr(t);return un(r,n,e,\"RFC 2822\",t)}static fromHTTP(t,e={}){var[t,r]=sr(t);return un(t,r,e,\"HTTP\",e)}static fromFormat(t,e,r={}){if(O(t)||O(e))throw new o(\"fromFormat requires an input string and a format\");var{locale:n=null,numberingSystem:s=null}=r,[n,s,i,a]=Ar(M.fromOpts({locale:n,numberingSystem:s,defaultToEN:!0}),t,e);return a?L.invalid(a):un(n,s,r,\"format \"+e,t,i)}static fromString(t,e,r={}){return L.fromFormat(t,e,r)}static fromSQL(t,e={}){var[r,n]=hr(t);return un(r,n,e,\"SQL\",t)}static invalid(t,e=null){if(!t)throw new o(\"need to specify a reason the DateTime is invalid\");t=t instanceof y?t:new y(t,e);if(k.throwOnInvalid)throw new z(t);return new L({invalid:t})}static isDateTime(t){return t&&t.isLuxonDateTime||!1}static parseFormatForOpts(t,e={}){const r=jr(t,M.fromObject(e));return r?r.map(t=>t?t.val:null).join(\"\"):null}static expandFormat(t,e={}){const r=zr(f.parseFormat(t),M.fromObject(e));return r.map(t=>t.val).join(\"\")}get(t){return this[t]}get isValid(){return null===this.invalid}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}get outputCalendar(){return this.isValid?this.loc.outputCalendar:null}get zone(){return this._zone}get zoneName(){return this.isValid?this.zone.name:null}get year(){return this.isValid?this.c.year:NaN}get quarter(){return this.isValid?Math.ceil(this.c.month/3):NaN}get month(){return this.isValid?this.c.month:NaN}get day(){return this.isValid?this.c.day:NaN}get hour(){return this.isValid?this.c.hour:NaN}get minute(){return this.isValid?this.c.minute:NaN}get second(){return this.isValid?this.c.second:NaN}get millisecond(){return this.isValid?this.c.millisecond:NaN}get weekYear(){return this.isValid?en(this).weekYear:NaN}get weekNumber(){return this.isValid?en(this).weekNumber:NaN}get weekday(){return this.isValid?en(this).weekday:NaN}get ordinal(){return this.isValid?Yr(this.c).ordinal:NaN}get monthShort(){return this.isValid?Sr.months(\"short\",{locObj:this.loc})[this.month-1]:null}get monthLong(){return this.isValid?Sr.months(\"long\",{locObj:this.loc})[this.month-1]:null}get weekdayShort(){return this.isValid?Sr.weekdays(\"short\",{locObj:this.loc})[this.weekday-1]:null}get weekdayLong(){return this.isValid?Sr.weekdays(\"long\",{locObj:this.loc})[this.weekday-1]:null}get offset(){return this.isValid?+this.o:NaN}get offsetNameShort(){return this.isValid?this.zone.offsetName(this.ts,{format:\"short\",locale:this.locale}):null}get offsetNameLong(){return this.isValid?this.zone.offsetName(this.ts,{format:\"long\",locale:this.locale}):null}get isOffsetFixed(){return this.isValid?this.zone.isUniversal:null}get isInDST(){return!this.isOffsetFixed&&(this.offset>this.set({month:1,day:1}).offset||this.offset>this.set({month:5}).offset)}get isInLeapYear(){return gt(this.year)}get daysInMonth(){return vt(this.year,this.month)}get daysInYear(){return this.isValid?wt(this.year):NaN}get weeksInWeekYear(){return this.isValid?Tt(this.weekYear):NaN}resolvedLocaleOptions(t={}){var{locale:t,numberingSystem:e,calendar:r}=f.create(this.loc.clone(t),t).resolvedOptions(this);return{locale:t,numberingSystem:e,outputCalendar:r}}toUTC(t=0,e={}){return this.setZone(v.instance(t),e)}toLocal(){return this.setZone(k.defaultZone)}setZone(e,{keepLocalTime:r=!1,keepCalendarTime:n=!1}={}){if((e=b(e,k.defaultZone)).equals(this.zone))return this;if(e.isValid){let t=this.ts;return(r||n)&&(r=e.offset(this.ts),n=this.toObject(),[t]=an(n,r,e)),rn(this,{ts:t,zone:e})}return L.invalid(tn(e))}reconfigure({locale:t,numberingSystem:e,outputCalendar:r}={}){t=this.loc.clone({locale:t,numberingSystem:e,outputCalendar:r});return rn(this,{loc:t})}setLocale(t){return this.reconfigure({locale:t})}set(t){if(!this.isValid)return this;var t=Mt(t,vn),e=!O(t.weekYear)||!O(t.weekNumber)||!O(t.weekday),r=!O(t.ordinal),n=!O(t.year),s=!O(t.month)||!O(t.day),i=t.weekYear||t.weekNumber;if((n||s||r)&&i)throw new j(\"Can't mix weekYear/weekNumber units with year/month/day or ordinals\");if(s&&r)throw new j(\"Can't mix ordinal dates with month/day\");let a;e?a=Jr({...Rr(this.c),...t}):O(t.ordinal)?(a={...this.toObject(),...t},O(t.day)&&(a.day=Math.min(vt(a.year,a.month),a.day))):a=Pr({...Yr(this.c),...t});var[n,i]=an(a,this.o,this.zone);return rn(this,{ts:n,o:i})}plus(t){return this.isValid?rn(this,on(this,V.fromDurationLike(t))):this}minus(t){return this.isValid?rn(this,on(this,V.fromDurationLike(t).negate())):this}startOf(t){if(!this.isValid)return this;const e={},r=V.normalizeUnit(t);switch(r){case\"years\":e.month=1;case\"quarters\":case\"months\":e.day=1;case\"weeks\":case\"days\":e.hour=0;case\"hours\":e.minute=0;case\"minutes\":e.second=0;case\"seconds\":e.millisecond=0}return\"weeks\"===r&&(e.weekday=1),\"quarters\"===r&&(t=Math.ceil(this.month/3),e.month=3*(t-1)+1),this.set(e)}endOf(t){return this.isValid?this.plus({[t]:1}).startOf(t).minus(1):this}toFormat(t,e={}){return this.isValid?f.create(this.loc.redefaultToEN(e)).formatDateTimeFromString(this,t):Xr}toLocaleString(t=U,e={}){return this.isValid?f.create(this.loc.clone(e),t).formatDateTime(this):Xr}toLocaleParts(t={}){return this.isValid?f.create(this.loc.clone(t),t).formatDateTimeParts(this):[]}toISO({format:t=\"extended\",suppressSeconds:e=!1,suppressMilliseconds:r=!1,includeOffset:n=!0,extendedZone:s=!1}={}){if(!this.isValid)return null;var t=\"extended\"===t,i=cn(this,t);return(i+=\"T\")+hn(this,t,e,r,n,s)}toISODate({format:t=\"extended\"}={}){return this.isValid?cn(this,\"extended\"===t):null}toISOWeekDate(){return ln(this,\"kkkk-'W'WW-c\")}toISOTime({suppressMilliseconds:t=!1,suppressSeconds:e=!1,includeOffset:r=!0,includePrefix:n=!1,extendedZone:s=!1,format:i=\"extended\"}={}){return this.isValid?(n?\"T\":\"\")+hn(this,\"extended\"===i,e,t,r,s):null}toRFC2822(){return ln(this,\"EEE, dd LLL yyyy HH:mm:ss ZZZ\",!1)}toHTTP(){return ln(this.toUTC(),\"EEE, dd LLL yyyy HH:mm:ss 'GMT'\")}toSQLDate(){return this.isValid?cn(this,!0):null}toSQLTime({includeOffset:t=!0,includeZone:e=!1,includeOffsetSpace:r=!0}={}){let n=\"HH:mm:ss.SSS\";return(e||t)&&(r&&(n+=\" \"),e?n+=\"z\":t&&(n+=\"ZZ\")),ln(this,n,!0)}toSQL(t={}){return this.isValid?this.toSQLDate()+\" \"+this.toSQLTime(t):null}toString(){return this.isValid?this.toISO():Xr}valueOf(){return this.toMillis()}toMillis(){return this.isValid?this.ts:NaN}toSeconds(){return this.isValid?this.ts/1e3:NaN}toUnixInteger(){return this.isValid?Math.floor(this.ts/1e3):NaN}toJSON(){return this.toISO()}toBSON(){return this.toJSDate()}toObject(t={}){if(!this.isValid)return{};const e={...this.c};return t.includeConfig&&(e.outputCalendar=this.outputCalendar,e.numberingSystem=this.loc.numberingSystem,e.locale=this.loc.locale),e}toJSDate(){return new Date(this.isValid?this.ts:NaN)}diff(t,e=\"milliseconds\",r={}){if(!this.isValid||!t.isValid)return V.invalid(\"created by diffing an invalid DateTime\");r={locale:this.locale,numberingSystem:this.numberingSystem,...r};const n=dt(e).map(V.normalizeUnit),s=t.valueOf()>this.valueOf(),i=s?this:t,a=s?t:this,o=br(i,a,n,r);return s?o.negate():o}diffNow(t=\"milliseconds\",e={}){return this.diff(L.now(),t,e)}until(t){return this.isValid?x.fromDateTimes(this,t):this}hasSame(t,e){if(!this.isValid)return!1;var r=t.valueOf();const n=this.setZone(t.zone,{keepLocalTime:!0});return n.startOf(e)<=r&&r<=n.endOf(e)}equals(t){return this.isValid&&t.isValid&&this.valueOf()===t.valueOf()&&this.zone.equals(t.zone)&&this.loc.equals(t.loc)}toRelative(t={}){if(!this.isValid)return null;var e=t.base||L.fromObject({},{zone:this.zone}),r=t.padding?this<e?-t.padding:t.padding:0;let n=[\"years\",\"months\",\"days\",\"hours\",\"minutes\",\"seconds\"],s=t.unit;return Array.isArray(t.unit)&&(n=t.unit,s=void 0),Tn(e,this.plus(r),{...t,numeric:\"always\",units:n,unit:s})}toRelativeCalendar(t={}){return this.isValid?Tn(t.base||L.fromObject({},{zone:this.zone}),this,{...t,numeric:\"auto\",units:[\"years\",\"months\",\"days\"],calendary:!0}):null}static min(...t){if(t.every(L.isDateTime))return mt(t,t=>t.valueOf(),Math.min);throw new o(\"min requires all arguments be DateTimes\")}static max(...t){if(t.every(L.isDateTime))return mt(t,t=>t.valueOf(),Math.max);throw new o(\"max requires all arguments be DateTimes\")}static fromFormatExplain(t,e,r={}){var{locale:r=null,numberingSystem:n=null}=r;return qr(M.fromOpts({locale:r,numberingSystem:n,defaultToEN:!0}),t,e)}static fromStringExplain(t,e,r={}){return L.fromFormatExplain(t,e,r)}static get DATE_SHORT(){return U}static get DATE_MED(){return $}static get DATE_MED_WITH_WEEKDAY(){return H}static get DATE_FULL(){return W}static get DATE_HUGE(){return R}static get TIME_SIMPLE(){return J}static get TIME_WITH_SECONDS(){return Y}static get TIME_WITH_SHORT_OFFSET(){return P}static get TIME_WITH_LONG_OFFSET(){return G}static get TIME_24_SIMPLE(){return B}static get TIME_24_WITH_SECONDS(){return Q}static get TIME_24_WITH_SHORT_OFFSET(){return K}static get TIME_24_WITH_LONG_OFFSET(){return X}static get DATETIME_SHORT(){return tt}static get DATETIME_SHORT_WITH_SECONDS(){return et}static get DATETIME_MED(){return rt}static get DATETIME_MED_WITH_SECONDS(){return nt}static get DATETIME_MED_WITH_WEEKDAY(){return st}static get DATETIME_FULL(){return it}static get DATETIME_FULL_WITH_SECONDS(){return at}static get DATETIME_HUGE(){return ot}static get DATETIME_HUGE_WITH_SECONDS(){return ut}}function On(t){if(L.isDateTime(t))return t;if(t&&t.valueOf&&c(t.valueOf()))return L.fromJSDate(t);if(t&&\"object\"==typeof t)return L.fromObject(t);throw new o(`Unknown datetime argument: ${t}, of type `+typeof t)}s=\"3.0.3\";export{L as DateTime,V as Duration,v as FixedOffsetZone,w as IANAZone,Sr as Info,x as Interval,ne as InvalidZone,k as Settings,Gt as SystemZone,s as VERSION,i as Zone};", "// eslint-disable-next-line no-restricted-imports\nimport { DateTime } from '../deps/luxon.js'\n\nexport const sleep = ms => new Promise(resolve => setTimeout(resolve, ms))\n// min, max are inclusive\nexport const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1) + min)\nexport const sleepRandom = () => {\n  const ms = randomInt(500, 1500)\n  return sleep(ms)\n}\n\nexport function escapeId (baseString, doc) {\n  let result = ''\n  let char = ''\n  let validTest\n  if (doc) {\n    validTest = RegExp(/[a-zA-Z0-9_$<>=\\-.!']/)\n  } else {\n    validTest = RegExp(/[a-z0-9_$+-]/)\n  }\n  for (let i = 0; i < baseString.length; i++) {\n    char = baseString.charAt(i)\n    if (!validTest.test(char)) {\n      result += '(' + char.codePointAt() + ')'\n    } else {\n      result += char\n    }\n  }\n  return result\n}\n\nexport function formatBytes (bytes, pad) {\n  if (!bytes && bytes !== 0) {\n    return ''\n  }\n  const units = [ 'B', 'KB', 'MB', 'GB', 'TB', 'PT' ]\n  let dim = 0\n  let n = parseInt(bytes, 10) || 0\n\n  while (n >= 1024 && ++dim) {\n    n = n / 1024\n  }\n  const number = n.toFixed(n < 10 && dim > 0 ? 1 : 0)\n  return (pad ? number.padEnd(pad, ' ') : (number + ' ')) + units[dim]\n}\n\nexport function fromNow (timestamp) {\n  return DateTime.fromMillis(timestamp).toRelative()\n}\n\nexport function formatTime (timestamp) {\n  return DateTime.fromMillis(timestamp).toFormat('HH:mm, dd.MM.y')\n}\n\nexport function getFlagEmoji (countryCode) {\n  const codePoints = countryCode\n    .toUpperCase()\n    .split('')\n    .map(char => 127397 + char.charCodeAt())\n  return String.fromCodePoint(...codePoints)\n}\n", "// import { getKvStore } from '/_kvs.js'\n// import { getWait } from './wait.js'\n// import log from './log.js'\nimport { sleepRandom } from './helpers.js'\n\n// TODO: handle logout detection and service worker integration!!!\n// TODO: integrate base features with edge/lib/req.js\nexport default async function req (url, { method, body, headers: headersArg = {}, raw: rawArg, retry = false, redirect = 'manual' } = {}) {\n  // TODO: ttl, cacheKey, cacheNs,\n  // const { waitUntil, event } = getWait()\n  if (!method) {\n    method = body ? 'POST' : 'GET'\n  }\n\n  const headers = new Headers(headersArg)\n\n  if (body && !headers.get('content-type')) {\n    headers.set('content-type', 'application/json')\n  }\n\n  headers.set('X-Requested-With', 'XMLHttpRequest')\n\n  if (body && headers.get('content-type') === 'application/json') {\n    body = JSON.stringify(body)\n  }\n\n  let res\n  let kvs\n  // if (cacheNs) {\n  //   if (!cacheKey) {\n  //     cacheKey = url\n  //   }\n\n  //   kvs = getKvStore(cacheNs)\n\n  //   // TODO: streams are faster for non binaries\n  //   const kvRes = await kvs.getWithMetadata(cacheKey, { type: 'arrayBuffer', cacheTtl: 604800 }) //  1 week, TODO ttl for other?\n\n  //   if (kvRes?.value) {\n  //     kvRes.metadata.headers['cache-status'] = `edge-kv; hit${kvRes.metadata.expiration ? '; ttl=' + (kvRes.metadata.expiration - Math.floor(Date.now() / 1000)) : ''}`\n  //     kvRes.metadata.ok = true\n  //     kvRes.metadata.statusText = 'OK'\n  //     kvRes.metadata.status = 200\n  //     kvRes.metadata.redirected = false\n  //     res = new Response(kvRes.value, kvRes.metadata)\n  //   }\n  // }\n\n  let retried\n  const reqStart = Date.now()\n  const wasCached = !!res\n  if (!wasCached) {\n    res = await fetch(url, { method, body, headers, redirect }).catch(fetchError => ({ ok: false, error: fetchError }))\n\n    // FIXME: do not retry redirects etc that are also not ok\n    if (!res.ok && retry) {\n      retried = {\n        status: res.status,\n        statusText: res.statusText,\n        text: res.text ? await res.text() : undefined,\n        error: res.error,\n        redirect: res.redirected || res.type === 'opaqueredirect'\n      }\n      if (retried.redirect || res.status === 401) {\n        self.session?.refresh()\n        // FIXME: abort here\n      }\n      await sleepRandom()\n      res = await fetch(url, { method, body, headers, redirect }).catch(fetchError => ({ ok: false, error: fetchError }))\n    }\n\n    // if (res.ok && cacheNs) {\n    //   waitUntil((async () => {\n    //     await kvs.put(cacheKey, await res.clone().arrayBuffer(), {\n    //       expirationTtl: ttl, // s\n    //       metadata: {\n    //         expiration: ttl ? (Math.floor(Date.now() / 1000) + ttl) : undefined,\n    //         headers:  {\n    //           'content-type': res.headers.get('content-type'),\n    //           'content-length': res.headers.get('content-length'),\n    //           'last-modified': res.headers.get('last-modified')\n    //         }\n    //       }\n    //     })\n    //   })())\n    // }\n  }\n  const duration = (Date.now() - reqStart)\n\n  let resHeaders\n  let json\n  let text\n  if (!rawArg && res.headers) {\n    resHeaders = Object.fromEntries(res.headers.entries())\n    if (!wasCached) {\n      let oldCacheStatus = res.headers.get('cache-status') || ''\n      if (oldCacheStatus) {\n        oldCacheStatus += ', '\n      }\n      resHeaders['cache-status'] = oldCacheStatus + 'edge-kv; miss' + (kvs ? '; stored' : '')\n    }\n\n    text = await res.text()\n    if (res.headers.get('content-type') === 'application/json') {\n      json = JSON.parse(text)\n    }\n  }\n\n  const baseResponse = {\n    headers: resHeaders,\n\n    duration,\n    ok: res.ok,\n    redirect: res.redirected || res.type === 'opaqueredirect',\n    status: res.status,\n    statusText: res.statusText,\n    retried,\n    error: res.error\n  }\n\n  if (baseResponse.redirect || res.status === 401) {\n    self.session?.refresh()\n  }\n\n  // headers['referer'] = 'todo'\n  // headers['traceId'] = 'todo'\n  // headers['host'] = 'todo'\n  // if (!wasCached) {\n  //   waitUntil(log({\n  //     stats: event?.stats,\n  //     req: {\n  //       method,\n  //       url: new URL(url),\n  //       headers: Object.fromEntries(headers.entries())\n  //     },\n  //     res: { body: text, ...baseResponse},\n  //     body,\n  //     duration\n  //   }))\n  // }\n\n  return {\n    raw: res,\n    json,\n    text,\n    ...baseResponse\n  }\n}\n", "// eslint-disable-next-line no-restricted-imports\nimport { Observable } from '../../build/deps/falcor-observable.js' // @graphistry ?\n// eslint-disable-next-line no-restricted-imports\nimport { Router } from '../../build/deps/falcor-router.js' // @graphistry ?\n\nimport { urlLogger } from '../lib/url-logger.js'\nimport * as systemHandlers from '../schema/falcor-handlers/index.js'\nimport req from '../lib/req.js'\n\nexport function falcorTags (routes) {\n  Object.keys(routes).forEach(key => {\n    Object.keys(routes[key]).forEach(method => {\n      const tags = routes[key][method].tags\n      routes[key][method].tags = tags ? tags.push('falcor') : ['falcor']\n    })\n  })\n\n  return routes\n}\n\nfunction maxRange (ranges) {\n  let from\n  let to\n  ranges.forEach(range => {\n    if (to === undefined) {\n      to = range.to\n    } else {\n      to = Math.max(to, range.to)\n    }\n\n    if (from === undefined) {\n      from = range.from\n    } else {\n      from = Math.min(from, range.from)\n    }\n  })\n\n  return { from, to }\n}\n\nexport function toFalcorRoutes (schema) {\n  // The first case in 13 years that the semicolon was actually necessary!! (but only due to the bundler) :D\n  const routes = [];\n\n  [...Object.entries(schema.paths)].forEach(([path, handlerArgs]) => {\n    const handlers = {}\n\n    Object.entries(handlerArgs).forEach(([handlerType, handlerConf]) => {\n      if (handlerConf.tags?.includes('falcor')) {\n        if (!['get', 'set', 'call'].includes(handlerType)) {\n          console.error('unsupported falcor handler type ' + handlerType)\n        }\n\n        const handler = handlerConf.handler || (handlerConf.operationId && systemHandlers[handlerConf.operationId])\n\n        handlers[handlerType] = function () {\n          /* eslint-disable functional/no-this-expression */\n          arguments[0].dbs = this.dbs\n          arguments[0].session = this.session\n          arguments[0].Observable = this.Observable\n          arguments[0].req = this.req\n          arguments[0].model = this.model\n          /* eslint-enable functional/no-this-expression */\n\n          arguments[0].maxRange = maxRange\n\n          let getRes = handler(...arguments)\n\n          if (handlerType === 'get') {\n            const pathArg = arguments[0]\n\n            const auoWrap = (paAr, res) => {\n              if ((!res.value && !res.path) || ['boolean', 'undefined', 'number', 'string'].includes(typeof res)) {\n                res = { value: { $type: 'atom', value: res } }\n              }\n              if (res.value !== undefined && !res.path) {\n                res.path = paAr.length ? [ ...paAr ] : [ paAr ]\n              }\n              return res\n            }\n\n            if (typeof getRes.then === 'function') {\n              getRes = getRes.then(res => {\n                return auoWrap(pathArg, res)\n              })\n            } else {\n              getRes = auoWrap(pathArg, getRes)\n            }\n          }\n\n          return getRes\n        }\n      }\n    })\n\n    if (Object.keys(handlers).length > 0) {\n      routes.push({\n        route: path,\n        ...handlers\n      })\n    }\n  })\n\n  return routes\n}\n\nexport function makeRouter (dataRoutes) {\n  class AtreyuRouter extends Router.createClass(dataRoutes) { // eslint-disable-line functional/no-class\n    constructor ({ session, dbs }) {\n      super({\n        // FIXME: check why debug flag and path errors dont work!\n        debug: false,\n        hooks: {\n          pathError: err => {\n            console.error(err)\n          },\n          error: err => {\n            console.error(err)\n          },\n          methodSummary: e => {\n            const totalDuration = e.end - e.start\n\n            e.routes?.forEach((route, i) => {\n              let batchMarker = ''\n              if (e.routes.length > 1) {\n                if (i === 0) {\n                  batchMarker = ' (batched >'\n                } else if (i === e.routes.length - 1) {\n                  batchMarker = ' < batched)'\n                } else {\n                  batchMarker = ' ...'\n                }\n\n                const body = route.results?.map(res => res.value.jsonGraph || res.value)\n                const duration = route.end && route.start ? route.end - route.start : 0\n\n                urlLogger({\n                  method: e.method.toUpperCase() + batchMarker,\n                  url: `falcor://${JSON.stringify(route.pathSet)}`,\n                  duration,\n                  error: route.error,\n                  body\n                })\n              } else {\n                urlLogger({\n                  method: e.method.toUpperCase(),\n                  url: `falcor://${JSON.stringify(route.pathSet)}`,\n                  error: route.error,\n                  duration: totalDuration,\n                  body: e.results[i]?.value.jsonGraph || e.results[i]?.value.value\n                })\n              }\n            })\n\n            const reqPaths = [...(e.pathSets || []), ...(e.callPath ? [e.callPath] : []) , ...(e.jsonGraphEnvelope?.paths || [])]\n            if (reqPaths.length > (e.routes?.length || 0)) {\n              // console.log(e, reqPaths)\n\n              reqPaths.slice(e.routes.length).forEach(pathSet => {\n                urlLogger({\n                  missing: true,\n                  error: e.error,\n                  method: e.method.toUpperCase(),\n                  url: `falcor://${JSON.stringify(pathSet)}`,\n                  duration: totalDuration,\n                  args: e.args\n                })\n              })\n            }\n          }\n        }\n      })\n\n      /* eslint-disable functional/no-this-expression */\n      this.session = session\n      this.dbs = dbs\n      this.req = req\n      this.Observable = Observable\n      /* eslint-enable functional/no-this-expression */\n    }\n  }\n\n  return AtreyuRouter\n}\n", "function getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction getAugmentedNamespace(n) {\n  if (n.__esModule) return n;\n  var f = n.default;\n\tif (typeof f == \"function\") {\n\t\tvar a = function a () {\n\t\t\tif (this instanceof a) {\n        return Reflect.construct(f, arguments, this.constructor);\n\t\t\t}\n\t\t\treturn f.apply(this, arguments);\n\t\t};\n\t\ta.prototype = f.prototype;\n  } else a = {};\n  Object.defineProperty(a, '__esModule', {value: true});\n\tObject.keys(n).forEach(function (k) {\n\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn n[k];\n\t\t\t}\n\t\t});\n\t});\n\treturn a;\n}\n\nvar functionTypeof = \"function\";\n\nvar isFunction$5 = function isFunction(func) {\n    return Boolean(func) && typeof func === functionTypeof;\n};\n\nvar objTypeof$1 = \"object\";\nvar isObject$f = function isObject(value) {\n    return value !== null && typeof value === objTypeof$1;\n};\n\nvar isObject$e = isObject$f;\nvar hasOwn$3 = Object.prototype.hasOwnProperty;\n\nvar hasOwn_1 = function(obj, prop) {\n  return isObject$e(obj) && hasOwn$3.call(obj, prop);\n};\n\nvar isFunction$4 = isFunction$5;\nvar hasOwn$2 = hasOwn_1;\n\nfunction ModelRoot$1(o) {\n\n    var options = o || {};\n\n    this.syncRefCount = 0;\n    this.expired = options.expired || [];\n    this.unsafeMode = options.unsafeMode || false;\n    this.cache = {};\n\n    if (isFunction$4(options.comparator)) {\n        this.comparator = options.comparator;\n    }\n\n    if (isFunction$4(options.errorSelector)) {\n        this.errorSelector = options.errorSelector;\n    }\n\n    if (isFunction$4(options.onChange)) {\n        this.onChange = options.onChange;\n    }\n}\n\nModelRoot$1.prototype.errorSelector = function errorSelector(x, y) {\n    return y;\n};\nModelRoot$1.prototype.comparator = function comparator(cacheNode, messageNode) {\n    if (hasOwn$2(cacheNode, \"value\") && hasOwn$2(messageNode, \"value\")) {\n        // They are the same only if the following fields are the same.\n        return cacheNode.value === messageNode.value &&\n            cacheNode.$type === messageNode.$type &&\n            cacheNode.$expires === messageNode.$expires;\n    }\n    return cacheNode === messageNode;\n};\n\nvar ModelRoot_1 = ModelRoot$1;\n\nfunction ModelDataSourceAdapter$1(model) {\n    this._model = model._materialize().treatErrorsAsValues();\n}\n\nModelDataSourceAdapter$1.prototype.get = function get(pathSets) {\n    return this._model.get.apply(this._model, pathSets)._toJSONG();\n};\n\nModelDataSourceAdapter$1.prototype.set = function set(jsongResponse) {\n    return this._model.set(jsongResponse)._toJSONG();\n};\n\nModelDataSourceAdapter$1.prototype.call = function call(path, args, suffixes, paths) {\n    var params = [path, args, suffixes];\n    Array.prototype.push.apply(params, paths);\n    return this._model.call.apply(this._model, params)._toJSONG();\n};\n\nvar ModelDataSourceAdapter_1 = ModelDataSourceAdapter$1;\n\nvar RequestTypes$1 = {\n    GetRequest: \"GET\"\n};\n\nvar reservedPrefix$1 = \"$\";\n\nvar reservedPrefix = reservedPrefix$1;\n\nvar privatePrefix$2 = reservedPrefix + \"_\";\n\nvar ref$1;\nvar hasRequiredRef;\n\nfunction requireRef () {\n\tif (hasRequiredRef) return ref$1;\n\thasRequiredRef = 1;\n\tref$1 = privatePrefix$2 + \"ref\";\n\treturn ref$1;\n}\n\nvar __ref$4 = requireRef();\n\nvar createHardlink$2 = function createHardlink(from, to) {\n\n    // create a back reference\n    // eslint-disable-next-line camelcase\n    var backRefs = to.$_refsLength || 0;\n    to[__ref$4 + backRefs] = from;\n    // eslint-disable-next-line camelcase\n    to.$_refsLength = backRefs + 1;\n\n    // create a hard reference\n    // eslint-disable-next-line camelcase\n    from.$_refIndex = backRefs;\n    // eslint-disable-next-line camelcase\n    from.$_context = to;\n};\n\nvar ref = \"ref\";\n\nvar now$3 = Date.now;\n\nvar expiresNow$1 = 0;\n\nvar expiresNever = 1;\n\nvar now$2 = now$3;\nvar $now$1 = expiresNow$1;\nvar $never$1 = expiresNever;\n\nvar isAlreadyExpired = function isAlreadyExpired(node) {\n    var exp = node.$expires;\n    return (exp != null) && (\n        exp !== $never$1) && (\n        exp !== $now$1) && (\n        exp < now$2());\n};\n\nvar objTypeof = \"object\";\nvar isPrimitive$4 = function isPrimitive(value) {\n    return value == null || typeof value !== objTypeof;\n};\n\nvar splice$2 = function lruSplice(root, object) {\n\n    // Its in the cache.  Splice out.\n    // eslint-disable-next-line camelcase\n    var prev = object.$_prev;\n    // eslint-disable-next-line camelcase\n    var next = object.$_next;\n    if (next) {\n        // eslint-disable-next-line camelcase\n        next.$_prev = prev;\n    }\n    if (prev) {\n        // eslint-disable-next-line camelcase\n        prev.$_next = next;\n    }\n    // eslint-disable-next-line camelcase\n    object.$_prev = object.$_next = undefined;\n\n    // eslint-disable-next-line camelcase\n    if (object === root.$_head) {\n        // eslint-disable-next-line camelcase\n        root.$_head = next;\n    }\n    // eslint-disable-next-line camelcase\n    if (object === root.$_tail) {\n        // eslint-disable-next-line camelcase\n        root.$_tail = prev;\n    }\n};\n\nvar splice$1 = splice$2;\n\nvar expireNode$5 = function expireNode(node, expired, lru) {\n    // eslint-disable-next-line camelcase\n    if (!node.$_invalidated) {\n        // eslint-disable-next-line camelcase\n        node.$_invalidated = true;\n        expired.push(node);\n        splice$1(lru, node);\n    }\n    return node;\n};\n\nvar isArray$9 = Array.isArray;\n\n/**\n * Takes in a keySet and a note attempts to iterate over it.\n * If the value is a primitive, the key will be returned and the note will\n * be marked done\n * If the value is an object, then each value of the range will be returned\n * and when finished the note will be marked done.\n * If the value is an array, each value will be iterated over, if any of the\n * inner values are ranges, those will be iterated over.  When fully done,\n * the note will be marked done.\n *\n * @param {Object|Array|String|Number} keySet -\n * @param {Object} note - The non filled note\n * @returns {String|Number|undefined} - The current iteration value.\n * If undefined, then the keySet is empty\n * @public\n */\nvar iterateKeySet$7 = function iterateKeySet(keySet, note) {\n    if (note.isArray === undefined) {\n        /*#__NOINLINE__*/ initializeNote(keySet, note);\n    }\n\n    // Array iteration\n    if (note.isArray) {\n        var nextValue;\n\n        // Cycle through the array and pluck out the next value.\n        do {\n            if (note.loaded && note.rangeOffset > note.to) {\n                ++note.arrayOffset;\n                note.loaded = false;\n            }\n\n            var idx = note.arrayOffset, length = keySet.length;\n            if (idx >= length) {\n                note.done = true;\n                break;\n            }\n\n            var el = keySet[note.arrayOffset];\n\n            // Inner range iteration.\n            if (el !== null && typeof el === 'object') {\n                if (!note.loaded) {\n                    initializeRange(el, note);\n                }\n\n                // Empty to/from\n                if (note.empty) {\n                    continue;\n                }\n\n                nextValue = note.rangeOffset++;\n            }\n\n            // Primitive iteration in array.\n            else {\n                ++note.arrayOffset;\n                nextValue = el;\n            }\n        } while (nextValue === undefined);\n\n        return nextValue;\n    }\n\n    // Range iteration\n    else if (note.isObject) {\n        if (!note.loaded) {\n            initializeRange(keySet, note);\n        }\n        if (note.rangeOffset > note.to) {\n            note.done = true;\n            return undefined;\n        }\n\n        return note.rangeOffset++;\n    }\n\n    // Primitive value\n    else {\n        if (!note.loaded) {\n            note.loaded = true;\n            return keySet;\n        }\n        note.done = true;\n        return undefined;\n    }\n};\n\nfunction initializeRange(key, memo) {\n    var from = memo.from = key.from || 0;\n    var to = memo.to = key.to ||\n        (typeof key.length === 'number' &&\n        memo.from + key.length - 1 || 0);\n    memo.rangeOffset = memo.from;\n    memo.loaded = true;\n    if (from > to) {\n        memo.empty = true;\n    }\n}\n\nfunction initializeNote(key, note) {\n    note.done = false;\n    var isObject = note.isObject = !!(key && typeof key === 'object');\n    note.isArray = isObject && isArray$9(key);\n    note.arrayOffset = 0;\n}\n\nvar iterateKeySet$6 = iterateKeySet$7;\n\n/**\n * @param {Array} paths -\n * @returns {Object} -\n */\nvar toTree$2 = function toTree(paths) {\n    return paths.reduce(__reducer, {});\n};\n\nfunction __reducer(acc, path) {\n    /*#__NOINLINE__*/ innerToTree(acc, path, 0);\n    return acc;\n}\n\nfunction innerToTree(seed, path, depth) {\n    var keySet = path[depth];\n    var iteratorNote = {};\n    var key;\n    var nextDepth = depth + 1;\n\n    key = iterateKeySet$6(keySet, iteratorNote);\n\n    while (!iteratorNote.done) {\n        var next = Object.prototype.hasOwnProperty.call(seed, key) && seed[key];\n        if (!next) {\n            if (nextDepth === path.length) {\n                seed[key] = null;\n            } else if (key !== undefined) {\n                next = seed[key] = {};\n            }\n        }\n\n        if (nextDepth < path.length) {\n            innerToTree(next, path, nextDepth);\n        }\n\n        key = iterateKeySet$6(keySet, iteratorNote);\n    }\n}\n\nvar iterateKeySet$5 = iterateKeySet$7;\n\n/**\n * Tests to see if the intersection should be stripped from the\n * total paths.  The only way this happens currently is if the entirety\n * of the path is contained in the tree.\n * @private\n */\nvar hasIntersection$2 = function hasIntersection(tree, path, depth) {\n    var current = tree;\n    var intersects = true;\n\n    // Continue iteratively going down a path until a complex key is\n    // encountered, then recurse.\n    for (;intersects && depth < path.length; ++depth) {\n        var key = path[depth];\n        var keyType = typeof key;\n\n        // We have to iterate key set\n        if (key && keyType === 'object') {\n            var note = {};\n            var innerKey = iterateKeySet$5(key, note);\n            var nextDepth = depth + 1;\n\n            // Loop through the innerKeys setting the intersects flag\n            // to each result.  Break out on false.\n            do {\n                var next = current[innerKey];\n                intersects = next !== undefined;\n\n                if (intersects) {\n                    intersects = hasIntersection(next, path, nextDepth);\n                }\n                innerKey = iterateKeySet$5(key, note);\n            } while (intersects && !note.done);\n\n            // Since we recursed, we shall not pass any further!\n            break;\n        }\n\n        // Its a simple key, just move forward with the testing.\n        current = current[key];\n        intersects = current !== undefined;\n    }\n\n    return intersects;\n};\n\nvar hasIntersection$1 = hasIntersection$2;\n\n/**\n * Compares the paths passed in with the tree.  Any of the paths that are in\n * the tree will be stripped from the paths.\n *\n * **Does not mutate** the incoming paths object.\n * **Proper subset** only matching.\n *\n * @param {Array} paths - A list of paths (complex or simple) to strip the\n * intersection\n * @param {Object} tree -\n * @public\n */\nvar pathsComplementFromTree = function pathsComplementFromTree(paths, tree) {\n    var out = [];\n    var outLength = -1;\n\n    for (var i = 0, len = paths.length; i < len; ++i) {\n        // If this does not intersect then add it to the output.\n        if (!hasIntersection$1(tree, paths[i], 0)) {\n            out[++outLength] = paths[i];\n        }\n    }\n    return out;\n};\n\nvar hasIntersection = hasIntersection$2;\n\n/**\n * Compares the paths passed in with the tree.  Any of the paths that are in\n * the tree will be stripped from the paths.\n *\n * **Does not mutate** the incoming paths object.\n * **Proper subset** only matching.\n *\n * @param {Array} paths - A list of paths (complex or simple) to strip the\n * intersection\n * @param {Object} tree -\n * @public\n */\nvar pathsComplementFromLengthTree = function pathsComplementFromLengthTree(paths, tree) {\n    var out = [];\n    var outLength = -1;\n\n    for (var i = 0, len = paths.length; i < len; ++i) {\n        // If this does not intersect then add it to the output.\n        var path = paths[i];\n        if (!hasIntersection(tree[path.length], path, 0)) {\n            out[++outLength] = path;\n        }\n    }\n    return out;\n};\n\nvar jsonKey = {};\n\n/**\n * Helper for getting a reproducible, key-sorted string representation of object.\n * Used to interpret an object as a falcor key.\n * @function\n * @param {Object} obj\n * @return stringified object with sorted keys.\n */\nfunction toJsonKey(obj) {\n    if (Object.prototype.toString.call(obj) === \"[object Object]\") {\n        var key = JSON.stringify(obj, replacer);\n        if (key[0] === \"{\") {\n            return key;\n        }\n    }\n    throw new TypeError(\"Only plain objects can be converted to JSON keys\")\n}\n\nfunction replacer(key, value) {\n    if (typeof value !== \"object\" || value === null || Array.isArray(value)) {\n        return value;\n    }\n    return Object.keys(value)\n        .sort()\n        .reduce(function (acc, k) {\n            acc[k] = value[k];\n            return acc;\n        }, {});\n}\n\nfunction maybeJsonKey(key) {\n    if (typeof key !== 'string' || key[0] !== '{') {\n        return;\n    }\n    var parsed;\n    try {\n        parsed = JSON.parse(key);\n    } catch (e) {\n        return;\n    }\n    if (JSON.stringify(parsed, replacer) !== key) {\n        return;\n    }\n    return parsed;\n}\n\nfunction isJsonKey(key) {\n    return typeof maybeJsonKey(key) !== \"undefined\";\n}\n\njsonKey.toJsonKey = toJsonKey;\njsonKey.isJsonKey = isJsonKey;\njsonKey.maybeJsonKey = maybeJsonKey;\n\nvar toPaths$2 = {exports: {}};\n\nvar integerKey = {};\n\nvar MAX_SAFE_INTEGER = 9007199254740991; // Number.MAX_SAFE_INTEGER in es6\nvar abs = Math.abs;\nvar isSafeInteger = Number.isSafeInteger || function isSafeInteger(num) {\n    return typeof num === \"number\" && num % 1 === 0 && abs(num) <= MAX_SAFE_INTEGER;\n};\n\n/**\n * Return number if argument is a number or can be cast to a number which\n * roundtrips to the same string, otherwise return undefined.\n */\nfunction maybeIntegerKey$1(val) {\n    if (typeof val === \"string\") {\n        var num = Number(val);\n        if(isSafeInteger(num) && String(num) === val) {\n            return num;\n        }\n    } else if (isSafeInteger(val)) {\n        return val;\n    }\n}\n\n/**\n * Return true if argument is a number or can be cast to a number which\n * roundtrips to the same string.\n */\nfunction isIntegerKey$1(val) {\n    if (typeof val === \"string\") {\n        var num = Number(val);\n        return isSafeInteger(num) && String(num) === val;\n    }\n    return isSafeInteger(val);\n}\n\nintegerKey.isIntegerKey = isIntegerKey$1;\nintegerKey.maybeIntegerKey = maybeIntegerKey$1;\n\nvar maybeIntegerKey = integerKey.maybeIntegerKey;\nvar isIntegerKey = integerKey.isIntegerKey;\nvar isArray$8 = Array.isArray;\nvar typeOfObject = \"object\";\nvar typeOfNumber = \"number\";\n\n/* jshint forin: false */\ntoPaths$2.exports = function toPaths(lengths) {\n    var pathmap;\n    var allPaths = [];\n    for (var length in lengths) {\n        var num = maybeIntegerKey(length);\n        if (typeof num === typeOfNumber && isObject$d(pathmap = lengths[length])) {\n            var paths = collapsePathMap(pathmap, 0, num).sets;\n            var pathsIndex = -1;\n            var pathsCount = paths.length;\n            while (++pathsIndex < pathsCount) {\n                allPaths.push(collapsePathSetIndexes(paths[pathsIndex]));\n            }\n        }\n    }\n    return allPaths;\n};\n\nfunction isObject$d(value) {\n    return value !== null && typeof value === typeOfObject;\n}\n\nfunction collapsePathMap(pathmap, depth, length) {\n\n    var key;\n    var code = getHashCode(String(depth));\n    var subs = Object.create(null);\n\n    var codes = [];\n    var codesIndex = -1;\n    var codesCount = 0;\n\n    var pathsets = [];\n    var pathsetsCount = 0;\n\n    var subPath, subCode,\n        subKeys, subKeysIndex, subKeysCount,\n        subSets, subSetsIndex, subSetsCount,\n        pathset, pathsetIndex, pathsetCount,\n        firstSubKey, pathsetClone;\n\n    subKeys = [];\n    subKeysIndex = -1;\n\n    if (depth < length - 1) {\n\n        subKeysCount = getKeys$1(pathmap, subKeys);\n\n        while (++subKeysIndex < subKeysCount) {\n            key = subKeys[subKeysIndex];\n            subPath = collapsePathMap(pathmap[key], depth + 1, length);\n            subCode = subPath.code;\n            if(subs[subCode]) {\n                subPath = subs[subCode];\n            } else {\n                codes[codesCount++] = subCode;\n                subPath = subs[subCode] = {\n                    keys: [],\n                    sets: subPath.sets\n                };\n            }\n            code = getHashCode(code + key + subCode);\n            var num = maybeIntegerKey(key);\n            subPath.keys.push(typeof num === typeOfNumber ? num : key);\n        }\n\n        while(++codesIndex < codesCount) {\n\n            key = codes[codesIndex];\n            subPath = subs[key];\n            subKeys = subPath.keys;\n            subKeysCount = subKeys.length;\n\n            if (subKeysCount > 0) {\n\n                subSets = subPath.sets;\n                subSetsIndex = -1;\n                subSetsCount = subSets.length;\n                firstSubKey = subKeys[0];\n\n                while (++subSetsIndex < subSetsCount) {\n\n                    pathset = subSets[subSetsIndex];\n                    pathsetIndex = -1;\n                    pathsetCount = pathset.length;\n                    pathsetClone = new Array(pathsetCount + 1);\n                    pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;\n\n                    while (++pathsetIndex < pathsetCount) {\n                        pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];\n                    }\n\n                    pathsets[pathsetsCount++] = pathsetClone;\n                }\n            }\n        }\n    } else {\n        subKeysCount = getKeys$1(pathmap, subKeys);\n        if (subKeysCount > 1) {\n            pathsets[pathsetsCount++] = [subKeys];\n        } else {\n            pathsets[pathsetsCount++] = subKeys;\n        }\n        while (++subKeysIndex < subKeysCount) {\n            code = getHashCode(code + subKeys[subKeysIndex]);\n        }\n    }\n\n    return {\n        code: code,\n        sets: pathsets\n    };\n}\n\nfunction collapsePathSetIndexes(pathset) {\n\n    var keysetIndex = -1;\n    var keysetCount = pathset.length;\n\n    while (++keysetIndex < keysetCount) {\n        var keyset = pathset[keysetIndex];\n        if (isArray$8(keyset)) {\n            pathset[keysetIndex] = collapseIndex(keyset);\n        }\n    }\n\n    return pathset;\n}\n\n/**\n * Collapse range indexers, e.g. when there is a continuous\n * range in an array, turn it into an object instead:\n *\n * [1,2,3,4,5,6] => {\"from\":1, \"to\":6}\n *\n * @private\n */\nfunction collapseIndex(keyset) {\n\n    // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?\n    // var hash = {};\n    var keyIndex = -1;\n    var keyCount = keyset.length - 1;\n    var isSparseRange = keyCount > 0;\n\n    while (++keyIndex <= keyCount) {\n\n        var key = keyset[keyIndex];\n\n        if (!isIntegerKey(key) /* || hash[key] === true*/ ) {\n            isSparseRange = false;\n            break;\n        }\n        // hash[key] = true;\n        // Cast number indexes to integers.\n        keyset[keyIndex] = parseInt(key, 10);\n    }\n\n    if (isSparseRange === true) {\n\n        keyset.sort(sortListAscending);\n\n        var from = keyset[0];\n        var to = keyset[keyCount];\n\n        // If we re-introduce deduped integer indexers, change this comparson to \"===\".\n        if (to - from <= keyCount) {\n            return {\n                from: from,\n                to: to\n            };\n        }\n    }\n\n    return keyset;\n}\n\nfunction sortListAscending(a, b) {\n    return a - b;\n}\n\n/* jshint forin: false */\nfunction getKeys$1(map, keys, sort) {\n    var len = 0;\n\n    for (var key in map) {\n        keys[len++] = key;\n    }\n    return len;\n}\n\nfunction getHashCode(key) {\n    var code = 5381;\n    var index = -1;\n    var count = key.length;\n    while (++index < count) {\n        code = (code << 5) + code + key.charCodeAt(index);\n    }\n    return String(code);\n}\n\n// backwards-compatibility (temporary)\ntoPaths$2.exports._isSafeNumber = isIntegerKey;\n\nvar toPathsExports = toPaths$2.exports;\n\nvar toPaths$1 = toPathsExports;\nvar toTree$1 = toTree$2;\n\nvar collapse = function collapse(paths) {\n    var collapseMap = paths.\n        reduce(function(acc, path) {\n            var len = path.length;\n            if (!acc[len]) {\n                acc[len] = [];\n            }\n            acc[len].push(path);\n            return acc;\n        }, {});\n\n    Object.\n        keys(collapseMap).\n        forEach(function(collapseKey) {\n            collapseMap[collapseKey] = toTree$1(collapseMap[collapseKey]);\n        });\n\n    return toPaths$1(collapseMap);\n};\n\n/*eslint-disable*/\n\nvar errors$1 = {\n    innerReferences: 'References with inner references are not allowed.',\n    circularReference: 'There appears to be a circular reference, maximum reference following exceeded.'\n};\n\nvar errors = errors$1;\n\n/**\n * performs the simplified cache reference follow.  This\n * differs from get as there is just following and reporting,\n * not much else.\n *\n * @param {Object} cacheRoot\n * @param {Array} ref\n */\nfunction followReference$2(cacheRoot, ref, maxRefFollow) {\n    if (typeof maxRefFollow === \"undefined\") {\n        maxRefFollow = 5;\n    }\n    var branch = cacheRoot;\n    var node = branch;\n    var refPath = ref;\n    var depth = -1;\n    var referenceCount = 0;\n\n    while (++depth < refPath.length) {\n        var key = refPath[depth];\n        node = branch[key];\n\n        if (\n            node === null ||\n            typeof node !== \"object\" ||\n            (node.$type && node.$type !== \"ref\")\n        ) {\n            break;\n        }\n\n        if (node.$type === \"ref\") {\n            // Show stopper exception.  This route is malformed.\n            if (depth + 1 < refPath.length) {\n                return { error: new Error(errors.innerReferences) };\n            }\n            if (referenceCount >= maxRefFollow) {\n                return { error: new Error(errors.circularReference) };\n            }\n\n            refPath = node.value;\n            depth = -1;\n            branch = cacheRoot;\n            referenceCount++;\n        } else {\n            branch = node;\n        }\n    }\n    return { node: node, refPath: refPath };\n}\n\nvar followReference_1$1 = followReference$2;\n\nfunction cloneArray$1(arr, index) {\n    var a = [];\n    var len = arr.length;\n    for (var i = index || 0; i < len; i++) {\n        a[i] = arr[i];\n    }\n    return a;\n}\n\nvar cloneArray_1 = cloneArray$1;\n\nvar catAndSlice$1 = function catAndSlice(a, b, slice) {\n    var next = [], i, j, len;\n    for (i = 0, len = a.length; i < len; ++i) {\n        next[i] = a[i];\n    }\n\n    for (j = slice || 0, len = b.length; j < len; ++j, ++i) {\n        next[i] = b[j];\n    }\n\n    return next;\n};\n\nvar iterateKeySet$4 = iterateKeySet$7;\nvar cloneArray = cloneArray_1;\nvar catAndSlice = catAndSlice$1;\nvar followReference$1 = followReference_1$1;\n\n/**\n * The fastest possible optimize of paths.\n *\n * What it does:\n * - Any atom short-circuit / found value will be removed from the path.\n * - All paths will be exploded which means that collapse will need to be\n *   ran afterwords.\n * - Any missing path will be optimized as much as possible.\n */\nvar optimizePathSets = function optimizePathSets(cache, paths, maxRefFollow) {\n    if (typeof maxRefFollow === \"undefined\") {\n        maxRefFollow = 5;\n    }\n    var optimized = [];\n    for (var i = 0, len = paths.length; i < len; ++i) {\n        var error = optimizePathSet(cache, cache, paths[i], 0, optimized, [], maxRefFollow);\n        if (error) {\n            return { error: error };\n        }\n    }\n    return { paths: optimized };\n};\n\n\n/**\n * optimizes one pathSet at a time.\n */\nfunction optimizePathSet(cache, cacheRoot, pathSet,\n                         depth, out, optimizedPath, maxRefFollow) {\n\n    // at missing, report optimized path.\n    if (cache === undefined) {\n        out[out.length] = catAndSlice(optimizedPath, pathSet, depth);\n        return;\n    }\n\n    // all other sentinels are short circuited.\n    // Or we found a primitive (which includes null)\n    if (cache === null || (cache.$type && cache.$type !== \"ref\") ||\n            (typeof cache !== 'object')) {\n        return;\n    }\n\n    // If the reference is the last item in the path then do not\n    // continue to search it.\n    if (cache.$type === \"ref\" && depth === pathSet.length) {\n        return;\n    }\n\n    var keySet = pathSet[depth];\n    var isKeySet = typeof keySet === 'object' && keySet !== null;\n    var nextDepth = depth + 1;\n    var iteratorNote = false;\n    var key = keySet;\n    if (isKeySet) {\n        iteratorNote = {};\n        key = iterateKeySet$4(keySet, iteratorNote);\n    }\n    var next, nextOptimized;\n    do {\n        next = cache[key];\n        var optimizedPathLength = optimizedPath.length;\n        optimizedPath[optimizedPathLength] = key;\n\n        if (next && next.$type === \"ref\" && nextDepth < pathSet.length) {\n            var refResults =\n                followReference$1(cacheRoot, next.value, maxRefFollow);\n            if (refResults.error) {\n                return refResults.error;\n            }\n            next = refResults.node;\n            // must clone to avoid the mutation from above destroying the cache.\n            nextOptimized = cloneArray(refResults.refPath);\n        } else {\n            nextOptimized = optimizedPath;\n        }\n\n        var error = optimizePathSet(next, cacheRoot, pathSet, nextDepth,\n                        out, nextOptimized, maxRefFollow);\n        if (error) {\n            return error;\n        }\n        optimizedPath.length = optimizedPathLength;\n\n        if (iteratorNote && !iteratorNote.done) {\n            key = iterateKeySet$4(keySet, iteratorNote);\n        }\n    } while (iteratorNote && !iteratorNote.done);\n}\n\n/**\n * Helper for getPathCount. Used to determine the size of a key or range.\n * @function\n * @param {Object} rangeOrKey\n * @return The size of the key or range passed in.\n */\nfunction getRangeOrKeySize(rangeOrKey) {\n    if (rangeOrKey == null) {\n        return 1;\n    } else if (Array.isArray(rangeOrKey)) {\n        throw new Error(\"Unexpected Array found in keySet: \" + JSON.stringify(rangeOrKey));\n    } else if (typeof rangeOrKey === \"object\") {\n        return getRangeSize(rangeOrKey);\n    } else {\n        return 1;\n    }\n}\n\n/**\n * Returns the size (number of items) in a Range,\n * @function\n * @param {Object} range The Range with both \"from\" and \"to\", or just \"to\"\n * @return The number of items in the range.\n */\nfunction getRangeSize(range) {\n\n    var to = range.to;\n    var length = range.length;\n\n    if (to != null) {\n        if (isNaN(to) || parseInt(to, 10) !== to) {\n            throw new Error(\"Invalid range, 'to' is not an integer: \" + JSON.stringify(range));\n        }\n        var from = range.from || 0;\n        if (isNaN(from) || parseInt(from, 10) !== from) {\n            throw new Error(\"Invalid range, 'from' is not an integer: \" + JSON.stringify(range));\n        }\n        if (from <= to) {\n            return (to - from) + 1;\n        } else {\n            return 0;\n        }\n    } else if (length != null) {\n        if (isNaN(length) || parseInt(length, 10) !== length) {\n            throw new Error(\"Invalid range, 'length' is not an integer: \" + JSON.stringify(range));\n        } else {\n            return length;\n        }\n    } else {\n        throw new Error(\"Invalid range, expected 'to' or 'length': \" + JSON.stringify(range));\n    }\n}\n\n/**\n * Returns a count of the number of paths this pathset\n * represents.\n *\n * For example, [\"foo\", {\"from\":0, \"to\":10}, \"bar\"],\n * would represent 11 paths (0 to 10, inclusive), and\n * [\"foo, [\"baz\", \"boo\"], \"bar\"] would represent 2 paths.\n *\n * @function\n * @param {Object[]} pathSet the path set.\n *\n * @return The number of paths this represents\n */\nfunction getPathCount(pathSet) {\n    if (pathSet.length === 0) {\n        throw new Error(\"All paths must have length larger than zero.\");\n    }\n\n    var numPaths = 1;\n\n    for (var i = 0; i < pathSet.length; i++) {\n        var segment = pathSet[i];\n\n        if (Array.isArray(segment)) {\n\n            var numKeys = 0;\n\n            for (var j = 0; j < segment.length; j++) {\n                var keySet = segment[j];\n\n                numKeys += getRangeOrKeySize(keySet);\n            }\n\n            numPaths *= numKeys;\n\n        } else {\n            numPaths *= getRangeOrKeySize(segment);\n        }\n    }\n\n    return numPaths;\n}\n\n\nvar pathCount = getPathCount;\n\n/**\n * Escapes a string by prefixing it with \"_\". This function should be used on\n * untrusted input before it is embedded into paths. The goal is to ensure that\n * no reserved words (ex. \"$type\") make their way into paths and consequently\n * JSON Graph objects.\n */\n\nvar _escape = function escape(str) {\n    return \"_\" + str;\n};\n\n/**\n * Unescapes a string by removing the leading \"_\". This function is the inverse\n * of escape, which is used to encode untrusted input to ensure it\n * does not contain reserved JSON Graph keywords (ex. \"$type\").\n */\n\nvar _unescape = function unescape(str) {\n    if (str.slice(0, 1) === \"_\") {\n        return str.slice(1);\n    } else {\n        throw SyntaxError(\"Expected \\\"_\\\".\");\n    }\n};\n\nvar iterateKeySet$3 = iterateKeySet$7;\n\n/**\n * Construct a jsonGraph from a pathSet and a value.\n *\n * @param {PathSet} pathSet - pathSet of paths at which to materialize value.\n * @param {JsonGraphNode} value - value to materialize at pathSet paths.\n * @returns {JsonGraphNode} - JsonGraph of value at pathSet paths.\n * @public\n */\n\nvar materialize = function materialize(pathSet, value) {\n  return pathSet.reduceRight(function materializeInner(acc, keySet) {\n    var branch = {};\n    if (typeof keySet !== 'object' || keySet === null) {\n      branch[keySet] = acc;\n      return branch;\n    }\n    var iteratorNote = {};\n    var key = iterateKeySet$3(keySet, iteratorNote);\n    while (!iteratorNote.done) {\n      branch[key] = acc;\n      key = iterateKeySet$3(keySet, iteratorNote);\n    }\n    return branch;\n  }, value);\n};\n\n// @flow\n/*::\nimport type { Key, KeySet, PathSet, Path, JsonGraph, JsonGraphNode, JsonMap } from \"falcor-json-graph\";\nexport type PathTree = { [key: string]: PathTree | null | void };\nexport type LengthTree = { [key: number]: PathTree | void };\nexport type IteratorNote = { done?: boolean };\ntype FalcorPathUtils = {\n    iterateKeySet(keySet: KeySet, note: IteratorNote): Key;\n    toTree(paths: PathSet[]): PathTree;\n    pathsComplementFromTree(paths: PathSet[], tree: PathTree): PathSet[];\n    pathsComplementFromLengthTree(paths: PathSet[], tree: LengthTree): PathSet[];\n    toJsonKey(obj: JsonMap): string;\n    isJsonKey(key: Key): boolean;\n    maybeJsonKey(key: Key): JsonMap | void;\n    hasIntersection(tree: PathTree, path: PathSet, depth: number): boolean;\n    toPaths(lengths: LengthTree): PathSet[];\n    isIntegerKey(key: Key): boolean;\n    maybeIntegerKey(key: Key): number | void;\n    collapse(paths: PathSet[]): PathSet[];\n    followReference(\n        cacheRoot: JsonGraph,\n        ref: Path,\n        maxRefFollow?: number\n    ): { error: Error } | { error?: empty, node: ?JsonGraphNode, refPath: Path };\n    optimizePathSets(\n        cache: JsonGraph,\n        paths: PathSet[],\n        maxRefFollow?: number\n    ): { error: Error } | { error?: empty, paths: PathSet[] };\n    pathCount(path: PathSet): number;\n    escape(key: string): string;\n    unescape(key: string): string;\n    materialize(pathSet: PathSet, value: JsonGraphNode): JsonGraphNode;\n};\n*/\nvar lib$1 = ({\n    iterateKeySet: iterateKeySet$7,\n    toTree: toTree$2,\n    pathsComplementFromTree: pathsComplementFromTree,\n    pathsComplementFromLengthTree: pathsComplementFromLengthTree,\n    toJsonKey: jsonKey.toJsonKey,\n    isJsonKey: jsonKey.isJsonKey,\n    maybeJsonKey: jsonKey.maybeJsonKey,\n    hasIntersection: hasIntersection$2,\n    toPaths: toPathsExports,\n    isIntegerKey: integerKey.isIntegerKey,\n    maybeIntegerKey: integerKey.maybeIntegerKey,\n    collapse: collapse,\n    followReference: followReference_1$1,\n    optimizePathSets: optimizePathSets,\n    pathCount: pathCount,\n    escape: _escape,\n    unescape: _unescape,\n    materialize: materialize\n}/*: FalcorPathUtils*/);\n\nvar incrementVersion$3 = {exports: {}};\n\nvar version$1 = 1;\nincrementVersion$3.exports = function incrementVersion() {\n    return version$1++;\n};\nincrementVersion$3.exports.getCurrentVersion = function getCurrentVersion() {\n    return version$1;\n};\n\nvar incrementVersionExports = incrementVersion$3.exports;\n\nvar error = \"error\";\n\nvar isObject$c = isObject$f;\nvar getSize$6 = function getSize(node) {\n    return isObject$c(node) && node.$size || 0;\n};\n\nvar isObject$b = isObject$f;\nvar getTimestamp$2 = function getTimestamp(node) {\n    return isObject$b(node) && node.$timestamp || undefined;\n};\n\nvar now$1 = now$3;\nvar $now = expiresNow$1;\nvar $never = expiresNever;\n\nvar isExpired$7 = function isExpired(node) {\n    var exp = node.$expires;\n    return (exp != null) && (\n        exp !== $never ) && (\n        exp === $now || exp < now$1());\n};\n\nvar privatePrefix$1 = privatePrefix$2;\nvar hasOwn$1 = hasOwn_1;\nvar isArray$7 = Array.isArray;\nvar isObject$a = isObject$f;\n\nvar clone$4 = function clone(value) {\n    var dest = value;\n    if (isObject$a(dest)) {\n        dest = isArray$7(value) ? [] : {};\n        var src = value;\n        for (var key in src) {\n            if (key.lastIndexOf(privatePrefix$1, 0) === 0 || !hasOwn$1(src, key)) {\n                continue;\n            }\n            dest[key] = src[key];\n        }\n    }\n    return dest;\n};\n\nvar isObject$9 = isObject$f;\nvar getExpires$1 = function getSize(node) {\n    return isObject$9(node) && node.$expires || undefined;\n};\n\nvar atom;\nvar hasRequiredAtom;\n\nfunction requireAtom () {\n\tif (hasRequiredAtom) return atom;\n\thasRequiredAtom = 1;\n\tatom = \"atom\";\n\treturn atom;\n}\n\nvar now = now$3;\nvar expiresNow = expiresNow$1;\n\nvar atomSize = 50;\n\nvar clone$3 = clone$4;\nvar isArray$6 = Array.isArray;\nvar getSize$5 = getSize$6;\nvar getExpires = getExpires$1;\nvar atomType = requireAtom();\n\nvar wrapNode$2 = function wrapNode(nodeArg, typeArg, value) {\n\n    var size = 0;\n    var node = nodeArg;\n    var type = typeArg;\n\n    if (type) {\n        var modelCreated = node.$_modelCreated;\n        node = clone$3(node);\n        size = getSize$5(node);\n        node.$type = type;\n        // eslint-disable-next-line camelcase\n        node.$_prev = undefined;\n        // eslint-disable-next-line camelcase\n        node.$_next = undefined;\n        // eslint-disable-next-line camelcase\n        node.$_modelCreated = modelCreated || false;\n    } else {\n        node = {\n            $type: atomType,\n            value: value,\n            // eslint-disable-next-line camelcase\n            $_prev: undefined,\n            // eslint-disable-next-line camelcase\n            $_next: undefined,\n            // eslint-disable-next-line camelcase\n            $_modelCreated: true\n        };\n    }\n\n    if (value == null) {\n        size = atomSize + 1;\n    } else if (size == null || size <= 0) {\n        switch (typeof value) {\n            case \"object\":\n                if (isArray$6(value)) {\n                    size = atomSize + value.length;\n                } else {\n                    size = atomSize + 1;\n                }\n                break;\n            case \"string\":\n                size = atomSize + value.length;\n                break;\n            default:\n                size = atomSize + 1;\n                break;\n        }\n    }\n\n    var expires = getExpires(node);\n\n    if (typeof expires === \"number\" && expires < expiresNow) {\n        node.$expires = now() + (expires * -1);\n    }\n\n    node.$size = size;\n\n    return node;\n};\n\n/* eslint-disable camelcase */\n\nvar insertNode$2 = function insertNode(node, parent, key, version, optimizedPath) {\n    node.$_key = key;\n    node.$_parent = parent;\n\n    if (version !== undefined) {\n        node.$_version = version;\n    }\n    if (!node.$_absolutePath) {\n        if (Array.isArray(key)) {\n            node.$_absolutePath = optimizedPath.slice(0, optimizedPath.index);\n            Array.prototype.push.apply(node.$_absolutePath, key);\n        } else {\n            node.$_absolutePath = optimizedPath.slice(0, optimizedPath.index);\n            node.$_absolutePath.push(key);\n        }\n    }\n\n    parent[key] = node;\n\n    return node;\n};\n\nvar __ref$3 = requireRef();\n\nvar transferBackReferences$1 = function transferBackReferences(fromNode, destNode) {\n    // eslint-disable-next-line camelcase\n    var fromNodeRefsLength = fromNode.$_refsLength || 0,\n        // eslint-disable-next-line camelcase\n        destNodeRefsLength = destNode.$_refsLength || 0,\n        i = -1;\n    while (++i < fromNodeRefsLength) {\n        var ref = fromNode[__ref$3 + i];\n        if (ref !== void 0) {\n            // eslint-disable-next-line camelcase\n            ref.$_context = destNode;\n            destNode[__ref$3 + (destNodeRefsLength + i)] = ref;\n            fromNode[__ref$3 + i] = void 0;\n        }\n    }\n    // eslint-disable-next-line camelcase\n    destNode.$_refsLength = fromNodeRefsLength + destNodeRefsLength;\n    // eslint-disable-next-line camelcase\n    fromNode.$_refsLength = void 0;\n    return destNode;\n};\n\nvar __ref$2 = requireRef();\n\nvar unlinkBackReferences$1 = function unlinkBackReferences(node) {\n    // eslint-disable-next-line camelcase\n    var i = -1, n = node.$_refsLength || 0;\n    while (++i < n) {\n        var ref = node[__ref$2 + i];\n        if (ref != null) {\n            // eslint-disable-next-line camelcase\n            ref.$_context = ref.$_refIndex = node[__ref$2 + i] = void 0;\n        }\n    }\n    // eslint-disable-next-line camelcase\n    node.$_refsLength = void 0;\n    return node;\n};\n\nvar __ref$1 = requireRef();\n\nvar unlinkForwardReference$1 = function unlinkForwardReference(reference) {\n    // eslint-disable-next-line camelcase\n    var destination = reference.$_context;\n    if (destination) {\n        // eslint-disable-next-line camelcase\n        var i = (reference.$_refIndex || 0) - 1,\n            // eslint-disable-next-line camelcase\n            n = (destination.$_refsLength || 0) - 1;\n        while (++i <= n) {\n            destination[__ref$1 + i] = destination[__ref$1 + (i + 1)];\n        }\n        // eslint-disable-next-line camelcase\n        destination.$_refsLength = n;\n        // eslint-disable-next-line camelcase\n        reference.$_refIndex = reference.$_context = destination = void 0;\n    }\n    return reference;\n};\n\nvar $ref$6 = ref;\nvar splice = splice$2;\nvar isObject$8 = isObject$f;\nvar unlinkBackReferences = unlinkBackReferences$1;\nvar unlinkForwardReference = unlinkForwardReference$1;\n\nvar removeNode$2 = function removeNode(node, parent, key, lru) {\n    if (isObject$8(node)) {\n        var type = node.$type;\n        if (type) {\n            if (type === $ref$6) {\n                unlinkForwardReference(node);\n            }\n            splice(lru, node);\n        }\n        unlinkBackReferences(node);\n        // eslint-disable-next-line camelcase\n        parent[key] = node.$_parent = void 0;\n        return true;\n    }\n    return false;\n};\n\nvar removeNodeAndDescendants$1;\nvar hasRequiredRemoveNodeAndDescendants;\n\nfunction requireRemoveNodeAndDescendants () {\n\tif (hasRequiredRemoveNodeAndDescendants) return removeNodeAndDescendants$1;\n\thasRequiredRemoveNodeAndDescendants = 1;\n\tvar hasOwn = hasOwn_1;\n\tvar prefix = reservedPrefix$1;\n\tvar removeNode = removeNode$2;\n\n\tremoveNodeAndDescendants$1 = function removeNodeAndDescendants(node, parent, key, lru, mergeContext) {\n\t    if (removeNode(node, parent, key, lru)) {\n\t        if (node.$type !== undefined && mergeContext && node.$_absolutePath) {\n\t            mergeContext.hasInvalidatedResult = true;\n\t        }\n\n\t        if (node.$type == null) {\n\t            for (var key2 in node) {\n\t                if (key2[0] !== prefix && hasOwn(node, key2)) {\n\t                    removeNodeAndDescendants(node[key2], node, key2, lru, mergeContext);\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\treturn removeNodeAndDescendants$1;\n}\n\nvar isObject$7 = isObject$f;\nvar transferBackReferences = transferBackReferences$1;\nvar removeNodeAndDescendants = requireRemoveNodeAndDescendants();\n\nvar replaceNode$2 = function replaceNode(node, replacement, parent, key, lru, mergeContext) {\n    if (node === replacement) {\n        return node;\n    } else if (isObject$7(node)) {\n        transferBackReferences(node, replacement);\n        removeNodeAndDescendants(node, parent, key, lru, mergeContext);\n    }\n\n    parent[key] = replacement;\n    return replacement;\n};\n\nvar __ref = requireRef();\n\nvar updateBackReferenceVersions$2 = function updateBackReferenceVersions(nodeArg, version) {\n    var stack = [nodeArg];\n    var count = 0;\n    do {\n        var node = stack[count];\n        // eslint-disable-next-line camelcase\n        if (node && node.$_version !== version) {\n            // eslint-disable-next-line camelcase\n            node.$_version = version;\n            // eslint-disable-next-line camelcase\n            stack[count++] = node.$_parent;\n            var i = -1;\n            // eslint-disable-next-line camelcase\n            var n = node.$_refsLength || 0;\n            while (++i < n) {\n                stack[count++] = node[__ref + i];\n            }\n        }\n    } while (--count > -1);\n    return nodeArg;\n};\n\nvar removeNode$1 = removeNode$2;\nvar updateBackReferenceVersions$1 = updateBackReferenceVersions$2;\n\nvar updateNodeAncestors$3 = function updateNodeAncestors(nodeArg, offset, lru, version) {\n    var child = nodeArg;\n    do {\n        var node = child.$_parent;\n        var size = child.$size = (child.$size || 0) - offset;\n        if (size <= 0 && node != null) {\n            removeNode$1(child, node, child.$_key, lru);\n        } else if (child.$_version !== version) {\n            updateBackReferenceVersions$1(child, version);\n        }\n        child = node;\n    } while (child);\n    return nodeArg;\n};\n\n/**\n * Reconstructs the path for the current key, from currentPath (requestedPath)\n * state maintained during set/merge walk operations.\n *\n * During the walk, since the requestedPath array is updated after we attempt to\n * merge/insert nodes during a walk (it reflects the inserted node's parent branch)\n * we need to reconstitute a path from it.\n *\n * @param  {Array} currentPath The current requestedPath state, during the walk\n * @param  {String} key        The current key value, during the walk\n * @return {Array} A new array, with the path which represents the node we're about\n * to insert\n */\n\nvar reconstructPath$2 = function reconstructPath(currentPath, key) {\n\n    var path = currentPath.slice(0, currentPath.depth);\n    path[path.length] = key;\n\n    return path;\n};\n\nvar $ref$5 = ref;\nvar $error$4 = error;\nvar getSize$4 = getSize$6;\nvar getTimestamp$1 = getTimestamp$2;\nvar isObject$6 = isObject$f;\nvar isExpired$6 = isExpired$7;\nvar isFunction$3 = isFunction$5;\n\nvar wrapNode$1 = wrapNode$2;\nvar insertNode$1 = insertNode$2;\nvar expireNode$4 = expireNode$5;\nvar replaceNode$1 = replaceNode$2;\nvar updateNodeAncestors$2 = updateNodeAncestors$3;\nvar reconstructPath$1 = reconstructPath$2;\n\nvar mergeJSONGraphNode$1 = function mergeJSONGraphNode(\n    parent, node, message, key, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n    var sizeOffset;\n\n    var cType, mType,\n        cIsObject, mIsObject,\n        cTimestamp, mTimestamp;\n\n    var nodeValue = node && node.value !== undefined ? node.value : node;\n\n    // If the cache and message are the same, we can probably return early:\n    // - If they're both nullsy,\n    //   - If null then the node needs to be wrapped in an atom and inserted.\n    //     This happens from whole branch merging when a leaf is just a null value\n    //     instead of being wrapped in an atom.\n    //   - If undefined then return null (previous behavior).\n    // - If they're both branches, return the branch.\n    // - If they're both edges, continue below.\n    if (nodeValue === message) {\n        // There should not be undefined values.  Those should always be\n        // wrapped in an $atom\n        if (message === null) {\n            node = wrapNode$1(message, undefined, message);\n            parent = updateNodeAncestors$2(parent, -node.$size, lru, version);\n            node = insertNode$1(node, parent, key, undefined, optimizedPath);\n            return node;\n        }\n\n        // The messange and cache are both undefined, therefore return null.\n        else if (message === undefined) {\n            return message;\n        }\n\n        else {\n            cIsObject = isObject$6(node);\n            if (cIsObject) {\n                // Is the cache node a branch? If so, return the cache branch.\n                cType = node.$type;\n                if (cType == null) {\n                    // Has the branch been introduced to the cache yet? If not,\n                    // give it a parent, key, and absolute path.\n                    if (node.$_parent == null) {\n                        insertNode$1(node, parent, key, version, optimizedPath);\n                    }\n                    return node;\n                }\n            }\n        }\n    } else {\n        cIsObject = isObject$6(node);\n        if (cIsObject) {\n            cType = node.$type;\n        }\n    }\n\n    // If the cache isn't a reference, we might be able to return early.\n    if (cType !== $ref$5) {\n        mIsObject = isObject$6(message);\n        if (mIsObject) {\n            mType = message.$type;\n        }\n        if (cIsObject && !cType) {\n            // If the cache is a branch and the message is empty or\n            // also a branch, continue with the cache branch.\n            if (message == null || (mIsObject && !mType)) {\n                return node;\n            }\n        }\n    }\n    // If the cache is a reference, we might not need to replace it.\n    else {\n        // If the cache is a reference, but the message is empty, leave the cache alone...\n        if (message == null) {\n            // ...unless the cache is an expired reference. In that case, expire\n            // the cache node and return undefined.\n            if (isExpired$6(node)) {\n                expireNode$4(node, expired, lru);\n                return void 0;\n            }\n            return node;\n        }\n        mIsObject = isObject$6(message);\n        if (mIsObject) {\n            mType = message.$type;\n            // If the cache and the message are both references,\n            // check if we need to replace the cache reference.\n            if (mType === $ref$5) {\n                if (node === message) {\n                    // If the cache and message are the same reference,\n                    // we performed a whole-branch merge of one of the\n                    // grandparents. If we've previously graphed this\n                    // reference, break early. Otherwise, continue to\n                    // leaf insertion below.\n                    if (node.$_parent != null) {\n                        return node;\n                    }\n                } else {\n\n                    cTimestamp = node.$timestamp;\n                    mTimestamp = message.$timestamp;\n\n                    // - If either the cache or message reference is expired,\n                    //   replace the cache reference with the message.\n                    // - If neither of the references are expired, compare their\n                    //   timestamps. If either of them don't have a timestamp,\n                    //   or the message's timestamp is newer, replace the cache\n                    //   reference with the message reference.\n                    // - If the message reference is older than the cache\n                    //   reference, short-circuit.\n                    if (!isExpired$6(node) && !isExpired$6(message) && mTimestamp < cTimestamp) {\n                        return void 0;\n                    }\n                }\n            }\n        }\n    }\n\n    // If the cache is a leaf but the message is a branch, merge the branch over the leaf.\n    if (cType && mIsObject && !mType) {\n        return insertNode$1(replaceNode$1(node, message, parent, key, lru, replacedPaths), parent, key, undefined, optimizedPath);\n    }\n    // If the message is a sentinel or primitive, insert it into the cache.\n    else if (mType || !mIsObject) {\n        // If the cache and the message are the same value, we branch-merged one\n        // of the message's ancestors. If this is the first time we've seen this\n        // leaf, give the message a $size and $type, attach its graph pointers,\n        // and update the cache sizes and versions.\n\n        if (mType === $error$4 && isFunction$3(errorSelector)) {\n            message = errorSelector(reconstructPath$1(requestedPath, key), message);\n            mType = message.$type || mType;\n        }\n\n        if (mType && node === message) {\n            if (node.$_parent == null) {\n                node = wrapNode$1(node, mType, node.value);\n                parent = updateNodeAncestors$2(parent, -node.$size, lru, version);\n                node = insertNode$1(node, parent, key, version, optimizedPath);\n            }\n        }\n        // If the cache and message are different, the cache value is expired,\n        // or the message is a primitive, replace the cache with the message value.\n        // If the message is a sentinel, clone and maintain its type.\n        // If the message is a primitive value, wrap it in an atom.\n        else {\n            var isDistinct = true;\n            // If the cache is a branch, but the message is a leaf, replace the\n            // cache branch with the message leaf.\n            if ((cType && !isExpired$6(node)) || !cIsObject) {\n                // Compare the current cache value with the new value. If either of\n                // them don't have a timestamp, or the message's timestamp is newer,\n                // replace the cache value with the message value. If a comparator\n                // is specified, the comparator takes precedence over timestamps.\n                //\n                // Comparing either Number or undefined to undefined always results in false.\n                isDistinct = (getTimestamp$1(message) < getTimestamp$1(node)) === false;\n\n                // If at least one of the cache/message are sentinels, compare them.\n                if (isDistinct && (cType || mType) && isFunction$3(comparator)) {\n                    isDistinct = !comparator(nodeValue, message, optimizedPath.slice(0, optimizedPath.index));\n                }\n            }\n            if (isDistinct) {\n                message = wrapNode$1(message, mType, mType ? message.value : message);\n                sizeOffset = getSize$4(node) - getSize$4(message);\n                node = replaceNode$1(node, message, parent, key, lru, replacedPaths);\n                parent = updateNodeAncestors$2(parent, sizeOffset, lru, version);\n                node = insertNode$1(node, parent, key, version, optimizedPath);\n            }\n        }\n\n        // Promote the message edge in the LRU.\n        if (isExpired$6(node)) {\n            expireNode$4(node, expired, lru);\n        }\n    }\n    else if (node == null) {\n        node = insertNode$1({}, parent, key, undefined, optimizedPath);\n    }\n\n    return node;\n};\n\nfunction applyErrorPrototype$4(errorType) {\n    errorType.prototype = Object.create(Error.prototype, {\n        constructor: {\n        value: Error,\n        enumerable: false,\n        writable: true,\n        configurable: true\n        }\n    });\n\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(errorType, Error);\n    } else {\n        // eslint-disable-next-line\n        errorType.__proto__ = Error;\n    }\n}\n\nvar applyErrorPrototype_1 = applyErrorPrototype$4;\n\nvar applyErrorPrototype$3 = applyErrorPrototype_1;\n\n/**\n * Does not allow null in path\n *\n * @private\n */\nfunction NullInPathError$2() {\n    var instance = new Error(\"`null` and `undefined` are not allowed in branch key positions\");\n\n    instance.name = \"NullInPathError\";\n\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    }\n\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(instance, NullInPathError$2);\n    }\n\n    return instance;\n}\n\napplyErrorPrototype$3(NullInPathError$2);\n\nvar NullInPathError_1 = NullInPathError$2;\n\nvar createHardlink$1 = createHardlink$2;\nvar $ref$4 = ref;\n\nvar isExpired$5 = isAlreadyExpired;\nvar isFunction$2 = isFunction$5;\nvar isPrimitive$3 = isPrimitive$4;\nvar expireNode$3 = expireNode$5;\nvar iterateKeySet$2 = lib$1.iterateKeySet;\nvar incrementVersion$2 = incrementVersionExports;\nvar mergeJSONGraphNode = mergeJSONGraphNode$1;\nvar NullInPathError$1 = NullInPathError_1;\n\n/**\n * Merges a list of {@link JSONGraphEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to merge the {@link JSONGraphEnvelope}s.\n * @param {Array.<PathValue>} jsonGraphEnvelopes - the {@link JSONGraphEnvelope}s to merge.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nvar setJSONGraphs$3 = function setJSONGraphs(model, jsonGraphEnvelopes, x, errorSelector, comparator, replacedPaths) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = incrementVersion$2();\n    var cache = modelRoot.cache;\n    var initialVersion = cache.$_version;\n\n    var requestedPath = [];\n    var optimizedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var jsonGraphEnvelopeIndex = -1;\n    var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;\n\n    while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {\n\n        var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];\n        var paths = jsonGraphEnvelope.paths;\n        var jsonGraph = jsonGraphEnvelope.jsonGraph;\n\n        var pathIndex = -1;\n        var pathCount = paths.length;\n\n        while (++pathIndex < pathCount) {\n\n            var path = paths[pathIndex];\n            optimizedPath.index = 0;\n\n            setJSONGraphPathSet(\n                path, 0,\n                cache, cache, cache,\n                jsonGraph, jsonGraph, jsonGraph,\n                requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector, replacedPaths\n            );\n        }\n    }\n\n    var newVersion = cache.$_version;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction$2(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setJSONGraphPathSet(\n    path, depth, root, parent, node,\n    messageRoot, messageParent, message,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet$2(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n\n        var results = setNode$1(\n            root, parent, node, messageRoot, messageParent, message,\n            key, branch, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, replacedPaths\n        );\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n        optimizedPath[optimizedPath.index++] = key;\n        var nextNode = results[0];\n        var nextParent = results[1];\n        if (nextNode) {\n            if (branch) {\n                setJSONGraphPathSet(\n                    path, depth + 1, root, nextParent, nextNode,\n                    messageRoot, results[3], results[2],\n                    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                    version, expired, lru, comparator, errorSelector, replacedPaths\n                );\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(optimizedPath.slice(0, optimizedPath.index));\n            }\n        }\n        key = iterateKeySet$2(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nvar _result = new Array(4);\nfunction setReference$1(\n    root, node, messageRoot, message, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n    var reference = node.value;\n    optimizedPath.length = 0;\n    optimizedPath.push.apply(optimizedPath, reference);\n\n    if (isExpired$5(node)) {\n        optimizedPath.index = reference.length;\n        expireNode$3(node, expired, lru);\n        _result[0] = undefined;\n        _result[1] = root;\n        _result[2] = message;\n        _result[3] = messageRoot;\n        return _result;\n    }\n\n    var index = 0;\n    var container = node;\n    var count = reference.length - 1;\n    var parent = node = root;\n    var messageParent = message = messageRoot;\n\n    do {\n        var key = reference[index];\n        var branch = index < count;\n        optimizedPath.index = index;\n\n        var results = setNode$1(\n            root, parent, node, messageRoot, messageParent, message,\n            key, branch, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, replacedPaths\n        );\n        node = results[0];\n        if (isPrimitive$3(node)) {\n            optimizedPath.index = index;\n            return results;\n        }\n        parent = results[1];\n        message = results[2];\n        messageParent = results[3];\n    } while (index++ < count);\n\n    optimizedPath.index = index;\n\n    if (container.$_context !== node) {\n        createHardlink$1(container, node);\n    }\n\n    _result[0] = node;\n    _result[1] = parent;\n    _result[2] = message;\n    _result[3] = messageParent;\n    return _result;\n}\n\nfunction setNode$1(\n    root, parent, node, messageRoot, messageParent, message,\n    key, branch, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n    var type = node.$type;\n\n    while (type === $ref$4) {\n\n        var results = setReference$1(\n            root, node, messageRoot, message, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, replacedPaths\n        );\n\n        node = results[0];\n\n        if (isPrimitive$3(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        message = results[2];\n        messageParent = results[3];\n        type = node.$type;\n    }\n\n    if (type !== void 0) {\n        _result[0] = node;\n        _result[1] = parent;\n        _result[2] = message;\n        _result[3] = messageParent;\n        return _result;\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new NullInPathError$1();\n        } else if (node) {\n            key = node.$_key;\n        }\n    } else {\n        parent = node;\n        messageParent = message;\n        node = parent[key];\n        message = messageParent && messageParent[key];\n    }\n\n    node = mergeJSONGraphNode(\n        parent, node, message, key, requestedPath, optimizedPath,\n        version, expired, lru, comparator, errorSelector, replacedPaths\n    );\n\n    _result[0] = node;\n    _result[1] = parent;\n    _result[2] = message;\n    _result[3] = messageParent;\n    return _result;\n}\n\nvar promote$3;\nvar hasRequiredPromote;\n\nfunction requirePromote () {\n\tif (hasRequiredPromote) return promote$3;\n\thasRequiredPromote = 1;\n\tvar EXPIRES_NEVER = expiresNever;\n\n\t// [H] -> Next -> ... -> [T]\n\t// [T] -> Prev -> ... -> [H]\n\tpromote$3 = function lruPromote(root, object) {\n\t    // Never promote node.$expires === 1.  They cannot expire.\n\t    if (object.$expires === EXPIRES_NEVER) {\n\t        return;\n\t    }\n\n\t    // eslint-disable-next-line camelcase\n\t    var head = root.$_head;\n\n\t    // Nothing is in the cache.\n\t    if (!head) {\n\t        // eslint-disable-next-line camelcase\n\t        root.$_head = root.$_tail = object;\n\t        return;\n\t    }\n\n\t    if (head === object) {\n\t        return;\n\t    }\n\n\t    // The item always exist in the cache since to get anything in the\n\t    // cache it first must go through set.\n\t    // eslint-disable-next-line camelcase\n\t    var prev = object.$_prev;\n\t    // eslint-disable-next-line camelcase\n\t    var next = object.$_next;\n\t    if (next) {\n\t        // eslint-disable-next-line camelcase\n\t        next.$_prev = prev;\n\t    }\n\t    if (prev) {\n\t        // eslint-disable-next-line camelcase\n\t        prev.$_next = next;\n\t    }\n\t    // eslint-disable-next-line camelcase\n\t    object.$_prev = undefined;\n\n\t    // Insert into head position\n\t    // eslint-disable-next-line camelcase\n\t    root.$_head = object;\n\t    // eslint-disable-next-line camelcase\n\t    object.$_next = head;\n\t    // eslint-disable-next-line camelcase\n\t    head.$_prev = object;\n\n\t    // If the item we promoted was the tail, then set prev to tail.\n\t    // eslint-disable-next-line camelcase\n\t    if (object === root.$_tail) {\n\t        // eslint-disable-next-line camelcase\n\t        root.$_tail = prev;\n\t    }\n\t};\n\treturn promote$3;\n}\n\nvar clone$2;\nvar hasRequiredClone;\n\nfunction requireClone () {\n\tif (hasRequiredClone) return clone$2;\n\thasRequiredClone = 1;\n\t// Copies the node\n\tvar privatePrefix = privatePrefix$2;\n\n\tclone$2 = function clone(node) {\n\t    if (node === undefined) {\n\t        return node;\n\t    }\n\n\t    var outValue = {};\n\t    for (var k in node) {\n\t        if (k.lastIndexOf(privatePrefix, 0) === 0) {\n\t            continue;\n\t        }\n\t        outValue[k] = node[k];\n\t    }\n\t    return outValue;\n\t};\n\treturn clone$2;\n}\n\nvar promote$2 = requirePromote();\nvar clone$1 = requireClone();\nvar $ref$3 = ref;\nvar $atom = requireAtom();\nvar $error$3 = error;\n\nvar onValue$2 = function onValue(model, node, seed, depth, outerResults,\n                                  branchInfo, requestedPath, optimizedPath,\n                                  optimizedLength, isJSONG) {\n    // Promote first.  Even if no output is produced we should still promote.\n    if (node) {\n        promote$2(model._root, node);\n    }\n\n    // Preload\n    if (!seed) {\n        return;\n    }\n\n    var i, len, k, key, curr, prev = null, prevK;\n    var materialized = false, valueNode, nodeType = node && node.$type, nodeValue = node && node.value;\n\n    if (nodeValue === undefined) {\n        materialized = model._materialized;\n    }\n\n    // materialized\n    if (materialized) {\n        valueNode = {$type: $atom};\n    }\n\n    // Boxed Mode will clone the node.\n    else if (model._boxed) {\n        valueNode = clone$1(node);\n    }\n\n    // We don't want to emit references in json output\n    else if (!isJSONG && nodeType === $ref$3) {\n        valueNode = undefined;\n    }\n\n    // JSONG always clones the node.\n    else if (nodeType === $ref$3 || nodeType === $error$3) {\n        if (isJSONG) {\n            valueNode = clone$1(node);\n        } else {\n            valueNode = nodeValue;\n        }\n    }\n\n    else if (isJSONG) {\n        var isObject = nodeValue && typeof nodeValue === \"object\";\n        var isUserCreatedNode = !node || !node.$_modelCreated;\n        if (isObject || isUserCreatedNode) {\n            valueNode = clone$1(node);\n        } else {\n            valueNode = nodeValue;\n        }\n    }\n\n    else if (node && nodeType === undefined && nodeValue === undefined) {\n        // Include an empty value for branch nodes\n        valueNode = {};\n    } else {\n        valueNode = nodeValue;\n    }\n\n    var hasValues = false;\n\n    if (isJSONG) {\n        curr = seed.jsonGraph;\n        if (!curr) {\n            hasValues = true;\n            curr = seed.jsonGraph = {};\n            seed.paths = [];\n        }\n        for (i = 0, len = optimizedLength - 1; i < len; i++) {\n            key = optimizedPath[i];\n\n            if (!curr[key]) {\n                hasValues = true;\n                curr[key] = {};\n            }\n            curr = curr[key];\n        }\n\n        // assign the last\n        key = optimizedPath[i];\n\n        // TODO: Special case? do string comparisons make big difference?\n        curr[key] = materialized ? {$type: $atom} : valueNode;\n        if (requestedPath) {\n            seed.paths.push(requestedPath.slice(0, depth));\n        }\n    }\n\n    // The output is pathMap and the depth is 0.  It is just a\n    // value report it as the found JSON\n    else if (depth === 0) {\n        hasValues = true;\n        seed.json = valueNode;\n    }\n\n    // The output is pathMap but we need to build the pathMap before\n    // reporting the value.\n    else {\n        curr = seed.json;\n        if (!curr) {\n            hasValues = true;\n            curr = seed.json = {};\n        }\n        for (i = 0; i < depth - 1; i++) {\n            k = requestedPath[i];\n\n            // The branch info is already generated output from the walk algo\n            // with the required __path information on it.\n            if (!curr[k]) {\n                hasValues = true;\n                curr[k] = branchInfo[i];\n            }\n\n            prev = curr;\n            prevK = k;\n            curr = curr[k];\n        }\n        k = requestedPath[i];\n        if (valueNode !== undefined) {\n          if (k != null) {\n              hasValues = true;\n              if (!curr[k]) {\n                curr[k] = valueNode;\n              }\n          } else {\n              // We are protected from reaching here when depth is 1 and prev is\n              // undefined by the InvalidModelError and NullInPathError checks.\n              prev[prevK] = valueNode;\n          }\n        }\n    }\n    if (outerResults) {\n        outerResults.hasValues = hasValues;\n    }\n};\n\nvar isExpired$4;\nvar hasRequiredIsExpired;\n\nfunction requireIsExpired () {\n\tif (hasRequiredIsExpired) return isExpired$4;\n\thasRequiredIsExpired = 1;\n\tisExpired$4 = isExpired$7;\n\treturn isExpired$4;\n}\n\nvar followReference_1;\nvar hasRequiredFollowReference;\n\nfunction requireFollowReference () {\n\tif (hasRequiredFollowReference) return followReference_1;\n\thasRequiredFollowReference = 1;\n\tvar createHardlink = createHardlink$2;\n\tvar onValue = onValue$2;\n\tvar isExpired = requireIsExpired();\n\tvar $ref = ref;\n\tvar promote = requirePromote();\n\n\t/* eslint-disable no-constant-condition */\n\tfunction followReference(model, root, nodeArg, referenceContainerArg,\n\t                         referenceArg, seed, isJSONG) {\n\n\t    var node = nodeArg;\n\t    var reference = referenceArg;\n\t    var referenceContainer = referenceContainerArg;\n\t    var depth = 0;\n\t    var k, next;\n\n\t    while (true) {\n\t        if (depth === 0 && referenceContainer.$_context) {\n\t            depth = reference.length;\n\t            next = referenceContainer.$_context;\n\t        } else {\n\t            k = reference[depth++];\n\t            next = node[k];\n\t        }\n\t        if (next) {\n\t            var type = next.$type;\n\t            var value = type && next.value || next;\n\n\t            if (depth < reference.length) {\n\t                if (type) {\n\t                    node = next;\n\t                    break;\n\t                }\n\n\t                node = next;\n\t                continue;\n\t            }\n\n\t            // We need to report a value or follow another reference.\n\t            else {\n\n\t                node = next;\n\n\t                if (type && isExpired(next)) {\n\t                    break;\n\t                }\n\n\t                if (!referenceContainer.$_context) {\n\t                    createHardlink(referenceContainer, next);\n\t                }\n\n\t                // Restart the reference follower.\n\t                if (type === $ref) {\n\n\t                    // Nulls out the depth, outerResults,\n\t                    if (isJSONG) {\n\t                        onValue(model, next, seed, null, null, null, null,\n\t                                reference, reference.length, isJSONG);\n\t                    } else {\n\t                        promote(model._root, next);\n\t                    }\n\n\t                    depth = 0;\n\t                    reference = value;\n\t                    referenceContainer = next;\n\t                    node = root;\n\t                    continue;\n\t                }\n\n\t                break;\n\t            }\n\t        } else {\n\t            node = void 0;\n\t        }\n\t        break;\n\t    }\n\n\n\t    if (depth < reference.length && node !== void 0) {\n\t        var ref = [];\n\t        for (var i = 0; i < depth; i++) {\n\t            ref[i] = reference[i];\n\t        }\n\t        reference = ref;\n\t    }\n\n\t    return [node, reference, referenceContainer];\n\t}\n\t/* eslint-enable */\n\n\tfollowReference_1 = followReference;\n\treturn followReference_1;\n}\n\nvar getValueSync;\nvar hasRequiredGetValueSync;\n\nfunction requireGetValueSync () {\n\tif (hasRequiredGetValueSync) return getValueSync;\n\thasRequiredGetValueSync = 1;\n\tvar followReference = requireFollowReference();\n\tvar clone = requireClone();\n\tvar isExpired = requireIsExpired();\n\tvar promote = requirePromote();\n\tvar $ref = ref;\n\tvar $atom = requireAtom();\n\tvar $error = error;\n\n\tgetValueSync = function getValueSync(model, simplePath, noClone) {\n\t    var root = model._root.cache;\n\t    var len = simplePath.length;\n\t    var optimizedPath = [];\n\t    var shorted = false, shouldShort = false;\n\t    var depth = 0;\n\t    var key, i, next = root, curr = root, out = root, type, ref, refNode;\n\t    var found = true;\n\t    var expired = false;\n\n\t    while (next && depth < len) {\n\t        key = simplePath[depth++];\n\t        if (key !== null) {\n\t            next = curr[key];\n\t            optimizedPath[optimizedPath.length] = key;\n\t        }\n\n\t        if (!next) {\n\t            out = undefined;\n\t            shorted = true;\n\t            found = false;\n\t            break;\n\t        }\n\n\t        type = next.$type;\n\n\t        // A materialized item.  There is nothing to deref to.\n\t        if (type === $atom && next.value === undefined) {\n\t            out = undefined;\n\t            found = false;\n\t            shorted = depth < len;\n\t            break;\n\t        }\n\n\t        // Up to the last key we follow references, ensure that they are not\n\t        // expired either.\n\t        if (depth < len) {\n\t            if (type === $ref) {\n\n\t                // If the reference is expired then we need to set expired to\n\t                // true.\n\t                if (isExpired(next)) {\n\t                    expired = true;\n\t                    out = undefined;\n\t                    break;\n\t                }\n\n\t                ref = followReference(model, root, root, next, next.value);\n\t                refNode = ref[0];\n\n\t                // The next node is also set to undefined because nothing\n\t                // could be found, this reference points to nothing, so\n\t                // nothing must be returned.\n\t                if (!refNode) {\n\t                    out = void 0;\n\t                    next = void 0;\n\t                    found = false;\n\t                    break;\n\t                }\n\t                type = refNode.$type;\n\t                next = refNode;\n\t                optimizedPath = ref[1].slice(0);\n\t            }\n\n\t            if (type) {\n\t                break;\n\t            }\n\t        }\n\t        // If there is a value, then we have great success, else, report an undefined.\n\t        else {\n\t            out = next;\n\t        }\n\t        curr = next;\n\t    }\n\n\t    if (depth < len && !expired) {\n\t        // Unfortunately, if all that follows are nulls, then we have not shorted.\n\t        for (i = depth; i < len; ++i) {\n\t            if (simplePath[depth] !== null) {\n\t                shouldShort = true;\n\t                break;\n\t            }\n\t        }\n\t        // if we should short or report value.  Values are reported on nulls.\n\t        if (shouldShort) {\n\t            shorted = true;\n\t            out = void 0;\n\t        } else {\n\t            out = next;\n\t        }\n\n\t        for (i = depth; i < len; ++i) {\n\t            if (simplePath[i] !== null) {\n\t                optimizedPath[optimizedPath.length] = simplePath[i];\n\t            }\n\t        }\n\t    }\n\n\t    // promotes if not expired\n\t    if (out && type) {\n\t        if (isExpired(out)) {\n\t            out = void 0;\n\t        } else {\n\t            promote(model._root, out);\n\t        }\n\t    }\n\n\t    // if (out && out.$type === $error && !model._treatErrorsAsValues) {\n\t    if (out && type === $error && !model._treatErrorsAsValues) {\n\t        /* eslint-disable no-throw-literal */\n\t        throw {\n\t            path: depth === len ? simplePath : simplePath.slice(0, depth),\n\t            value: out.value\n\t        };\n\t        /* eslint-enable no-throw-literal */\n\t    } else if (out && model._boxed) {\n\t        out = Boolean(type) && !noClone ? clone(out) : out;\n\t    } else if (!out && model._materialized) {\n\t        out = {$type: $atom};\n\t    } else if (out) {\n\t        out = out.value;\n\t    }\n\n\t    return {\n\t        value: out,\n\t        shorted: shorted,\n\t        optimizedPath: optimizedPath,\n\t        found: found\n\t    };\n\t};\n\treturn getValueSync;\n}\n\nvar InvalidModelError_1;\nvar hasRequiredInvalidModelError;\n\nfunction requireInvalidModelError () {\n\tif (hasRequiredInvalidModelError) return InvalidModelError_1;\n\thasRequiredInvalidModelError = 1;\n\tvar applyErrorPrototype = applyErrorPrototype_1;\n\n\t/**\n\t * An InvalidModelError can only happen when a user binds, whether sync\n\t * or async to shorted value.  See the unit tests for examples.\n\t *\n\t * @param {*} boundPath\n\t * @param {*} shortedPath\n\t *\n\t * @private\n\t */\n\tfunction InvalidModelError(boundPath, shortedPath) {\n\t    var instance = new Error(\"The boundPath of the model is not valid since a value or error was found before the path end.\");\n\n\t    instance.name = \"InvalidModelError\";\n\t    instance.boundPath = boundPath;\n\t    instance.shortedPath = shortedPath;\n\n\t    if (Object.setPrototypeOf) {\n\t        Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n\t    }\n\n\t    if (Error.captureStackTrace) {\n\t        Error.captureStackTrace(instance, InvalidModelError);\n\t    }\n\n\t    return instance;\n\t}\n\n\tapplyErrorPrototype(InvalidModelError);\n\n\tInvalidModelError_1 = InvalidModelError;\n\treturn InvalidModelError_1;\n}\n\nvar getBoundValue$1;\nvar hasRequiredGetBoundValue;\n\nfunction requireGetBoundValue () {\n\tif (hasRequiredGetBoundValue) return getBoundValue$1;\n\thasRequiredGetBoundValue = 1;\n\tvar getValueSync = requireGetValueSync();\n\tvar InvalidModelError = requireInvalidModelError();\n\n\tgetBoundValue$1 = function getBoundValue(model, pathArg, materialized) {\n\n\t    var path = pathArg;\n\t    var boundPath = pathArg;\n\t    var boxed, treatErrorsAsValues,\n\t        value, shorted, found;\n\n\t    boxed = model._boxed;\n\t    materialized = model._materialized;\n\t    treatErrorsAsValues = model._treatErrorsAsValues;\n\n\t    model._boxed = true;\n\t    model._materialized = materialized === undefined || materialized;\n\t    model._treatErrorsAsValues = true;\n\n\t    value = getValueSync(model, path.concat(null), true);\n\n\t    model._boxed = boxed;\n\t    model._materialized = materialized;\n\t    model._treatErrorsAsValues = treatErrorsAsValues;\n\n\t    path = value.optimizedPath;\n\t    shorted = value.shorted;\n\t    found = value.found;\n\t    value = value.value;\n\n\t    while (path.length && path[path.length - 1] === null) {\n\t        path.pop();\n\t    }\n\n\t    if (found && shorted) {\n\t        throw new InvalidModelError(boundPath, path);\n\t    }\n\n\t    return {\n\t        path: path,\n\t        value: value,\n\t        shorted: shorted,\n\t        found: found\n\t    };\n\t};\n\treturn getBoundValue$1;\n}\n\nvar isObject$5 = isObject$f;\n\nvar getType$1 = function getType(node, anyType) {\n    var type = isObject$5(node) && node.$type || void 0;\n    if (anyType && type) {\n        return \"branch\";\n    }\n    return type;\n};\n\nvar $ref$2 = ref;\nvar $error$2 = error;\nvar getType = getType$1;\nvar getSize$3 = getSize$6;\nvar getTimestamp = getTimestamp$2;\n\nvar isExpired$3 = isExpired$7;\nvar isPrimitive$2 = isPrimitive$4;\nvar isFunction$1 = isFunction$5;\n\nvar wrapNode = wrapNode$2;\nvar expireNode$2 = expireNode$5;\nvar insertNode = insertNode$2;\nvar replaceNode = replaceNode$2;\nvar updateNodeAncestors$1 = updateNodeAncestors$3;\nvar updateBackReferenceVersions = updateBackReferenceVersions$2;\nvar reconstructPath = reconstructPath$2;\n\nvar mergeValueOrInsertBranch$1 = function mergeValueOrInsertBranch(\n    parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n    var type = getType(node, reference);\n\n    if (branch || reference) {\n        if (type && isExpired$3(node)) {\n            type = \"expired\";\n            expireNode$2(node, expired, lru);\n        }\n        if ((type && type !== $ref$2) || isPrimitive$2(node)) {\n            node = replaceNode(node, {}, parent, key, lru, replacedPaths);\n            node = insertNode(node, parent, key, version, optimizedPath);\n            node = updateBackReferenceVersions(node, version);\n        }\n    } else {\n        var message = value;\n        var mType = getType(message);\n        // Compare the current cache value with the new value. If either of\n        // them don't have a timestamp, or the message's timestamp is newer,\n        // replace the cache value with the message value. If a comparator\n        // is specified, the comparator takes precedence over timestamps.\n        //\n        // Comparing either Number or undefined to undefined always results in false.\n        var isDistinct = (getTimestamp(message) < getTimestamp(node)) === false;\n        // If at least one of the cache/message are sentinels, compare them.\n        if ((type || mType) && isFunction$1(comparator)) {\n            isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));\n        }\n        if (isDistinct) {\n\n            if (mType === $error$2 && isFunction$1(errorSelector)) {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n                mType = message.$type || mType;\n            }\n\n            message = wrapNode(message, mType, mType ? message.value : message);\n\n            var sizeOffset = getSize$3(node) - getSize$3(message);\n\n            node = replaceNode(node, message, parent, key, lru, replacedPaths);\n            parent = updateNodeAncestors$1(parent, sizeOffset, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    }\n\n    return node;\n};\n\nvar setPathValues$2;\nvar hasRequiredSetPathValues;\n\nfunction requireSetPathValues () {\n\tif (hasRequiredSetPathValues) return setPathValues$2;\n\thasRequiredSetPathValues = 1;\n\tvar createHardlink = createHardlink$2;\n\tvar $ref = ref;\n\n\tvar getBoundValue = requireGetBoundValue();\n\n\tvar isExpired = isExpired$7;\n\tvar isFunction = isFunction$5;\n\tvar isPrimitive = isPrimitive$4;\n\tvar expireNode = expireNode$5;\n\tvar iterateKeySet = lib$1.iterateKeySet;\n\tvar incrementVersion = incrementVersionExports;\n\tvar mergeValueOrInsertBranch = mergeValueOrInsertBranch$1;\n\tvar NullInPathError = NullInPathError_1;\n\n\t/**\n\t * Sets a list of {@link PathValue}s into a {@link JSONGraph}.\n\t * @function\n\t * @param {Object} model - the Model for which to insert the {@link PathValue}s.\n\t * @param {Array.<PathValue>} pathValues - the list of {@link PathValue}s to set.\n\t * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n\t */\n\n\tsetPathValues$2 = function setPathValues(model, pathValues, x, errorSelector, comparator) {\n\n\t    var modelRoot = model._root;\n\t    var lru = modelRoot;\n\t    var expired = modelRoot.expired;\n\t    var version = incrementVersion();\n\t    var bound = model._path;\n\t    var cache = modelRoot.cache;\n\t    var node = bound.length ? getBoundValue(model, bound).value : cache;\n\t    var parent = node.$_parent || cache;\n\t    var initialVersion = cache.$_version;\n\n\t    var requestedPath = [];\n\t    var requestedPaths = [];\n\t    var optimizedPaths = [];\n\t    var optimizedIndex = bound.length;\n\t    var pathValueIndex = -1;\n\t    var pathValueCount = pathValues.length;\n\n\t    while (++pathValueIndex < pathValueCount) {\n\n\t        var pathValue = pathValues[pathValueIndex];\n\t        var path = pathValue.path;\n\t        var value = pathValue.value;\n\t        var optimizedPath = bound.slice(0);\n\t        optimizedPath.index = optimizedIndex;\n\n\t        setPathSet(\n\t            value, path, 0, cache, parent, node,\n\t            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n\t            version, expired, lru, comparator, errorSelector\n\t        );\n\t    }\n\n\t    var newVersion = cache.$_version;\n\t    var rootChangeHandler = modelRoot.onChange;\n\n\t    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n\t        rootChangeHandler();\n\t    }\n\n\t    return [requestedPaths, optimizedPaths];\n\t};\n\n\t/* eslint-disable no-constant-condition */\n\tfunction setPathSet(\n\t    value, path, depth, root, parent, node,\n\t    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n\t    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n\t    var note = {};\n\t    var branch = depth < path.length - 1;\n\t    var keySet = path[depth];\n\t    var key = iterateKeySet(keySet, note);\n\t    var optimizedIndex = optimizedPath.index;\n\n\t    do {\n\n\t        requestedPath.depth = depth;\n\n\t        var results = setNode(\n\t            root, parent, node, key, value,\n\t            branch, false, requestedPath, optimizedPath,\n\t            version, expired, lru, comparator, errorSelector, replacedPaths\n\t        );\n\t        requestedPath[depth] = key;\n\t        requestedPath.index = depth;\n\t        optimizedPath[optimizedPath.index++] = key;\n\t        var nextNode = results[0];\n\t        var nextParent = results[1];\n\t        if (nextNode) {\n\t            if (branch) {\n\t                setPathSet(\n\t                    value, path, depth + 1,\n\t                    root, nextParent, nextNode,\n\t                    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n\t                    version, expired, lru, comparator, errorSelector\n\t                );\n\t            } else {\n\t                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n\t                optimizedPaths.push(optimizedPath.slice(0, optimizedPath.index));\n\t            }\n\t        }\n\t        key = iterateKeySet(keySet, note);\n\t        if (note.done) {\n\t            break;\n\t        }\n\t        optimizedPath.index = optimizedIndex;\n\t    } while (true);\n\t}\n\t/* eslint-enable */\n\n\tfunction setReference(\n\t    value, root, node, requestedPath, optimizedPath,\n\t    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n\t    var reference = node.value;\n\t    optimizedPath.length = 0;\n\t    optimizedPath.push.apply(optimizedPath, reference);\n\n\t    if (isExpired(node)) {\n\t        optimizedPath.index = reference.length;\n\t        expireNode(node, expired, lru);\n\t        return [undefined, root];\n\t    }\n\n\t    var container = node;\n\t    var parent = root;\n\n\t    node = node.$_context;\n\n\t    if (node != null) {\n\t        parent = node.$_parent || root;\n\t        optimizedPath.index = reference.length;\n\t    } else {\n\n\t        var index = 0;\n\t        var count = reference.length - 1;\n\n\t        parent = node = root;\n\n\t        do {\n\t            var key = reference[index];\n\t            var branch = index < count;\n\t            optimizedPath.index = index;\n\n\t            var results = setNode(\n\t                root, parent, node, key, value,\n\t                branch, true, requestedPath, optimizedPath,\n\t                version, expired, lru, comparator, errorSelector, replacedPaths\n\t            );\n\t            node = results[0];\n\t            if (isPrimitive(node)) {\n\t                optimizedPath.index = index;\n\t                return results;\n\t            }\n\t            parent = results[1];\n\t        } while (index++ < count);\n\n\t        optimizedPath.index = index;\n\n\t        if (container.$_context !== node) {\n\t            createHardlink(container, node);\n\t        }\n\t    }\n\n\t    return [node, parent];\n\t}\n\n\tfunction setNode(\n\t    root, parent, node, key, value,\n\t    branch, reference, requestedPath, optimizedPath,\n\t    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n\t    var type = node.$type;\n\n\t    while (type === $ref) {\n\n\t        var results = setReference(\n\t            value, root, node, requestedPath, optimizedPath,\n\t            version, expired, lru, comparator, errorSelector, replacedPaths\n\t        );\n\n\t        node = results[0];\n\n\t        if (isPrimitive(node)) {\n\t            return results;\n\t        }\n\n\t        parent = results[1];\n\t        type = node.$type;\n\t    }\n\n\t    if (branch && type !== void 0) {\n\t        return [node, parent];\n\t    }\n\n\t    if (key == null) {\n\t        if (branch) {\n\t            throw new NullInPathError();\n\t        } else if (node) {\n\t            key = node.$_key;\n\t        }\n\t    } else {\n\t        parent = node;\n\t        node = parent[key];\n\t    }\n\n\t    node = mergeValueOrInsertBranch(\n\t        parent, node, key, value,\n\t        branch, reference, requestedPath, optimizedPath,\n\t        version, expired, lru, comparator, errorSelector, replacedPaths\n\t    );\n\n\t    return [node, parent];\n\t}\n\treturn setPathValues$2;\n}\n\nvar applyErrorPrototype$2 = applyErrorPrototype_1;\n\n/**\n * InvalidSourceError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n *\n * @private\n */\nfunction InvalidSourceError$6(error) {\n    var instance = new Error(\"An exception was thrown when making a request.\");\n\n    instance.name = \"InvalidSourceError\";\n    instance.innerError = error;\n\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    }\n\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(instance, InvalidSourceError$6);\n    }\n\n    return instance;\n}\n\napplyErrorPrototype$2(InvalidSourceError$6);\n\nvar InvalidSourceError_1 = InvalidSourceError$6;\n\nvar setJSONGraphs$2 = setJSONGraphs$3;\nvar setPathValues$1 = requireSetPathValues();\nvar InvalidSourceError$5 = InvalidSourceError_1;\n\nvar emptyArray$2 = [];\nvar emptyDisposable = {dispose: function() {}};\n\n/**\n * A set request is not an object like GetRequest.  It simply only needs to\n * close over a couple values and its never batched together (at least not now).\n *\n * @private\n * @param {JSONGraphEnvelope} jsonGraph -\n * @param {Model} model -\n * @param {number} attemptCount\n * @param {Function} callback -\n */\nvar sendSetRequest$1 = function(originalJsonGraph, model, attemptCount, callback) {\n    var paths = originalJsonGraph.paths;\n    var modelRoot = model._root;\n    var errorSelector = modelRoot.errorSelector;\n    var comparator = modelRoot.comparator;\n    var boundPath = model._path;\n    var resultingJsonGraphEnvelope;\n\n    // This is analogous to GetRequest _merge / flushGetRequest\n    // SetRequests are just considerably simplier.\n    var setObservable;\n    try {\n        setObservable = model._source.\n            set(originalJsonGraph, attemptCount);\n    } catch (e) {\n        callback(new InvalidSourceError$5());\n        return emptyDisposable;\n    }\n\n    var disposable = setObservable.\n        subscribe(function onNext(jsonGraphEnvelope) {\n            // When disposed, no data is inserted into.  This can sync resolve\n            // and if thats the case then its undefined.\n            if (disposable && disposable.disposed) {\n                return;\n            }\n\n            // onNext will insert all data into the model then save the json\n            // envelope from the incoming result.\n            model._path = emptyArray$2;\n\n            var successfulPaths = setJSONGraphs$2(model, [{\n                paths: paths,\n                jsonGraph: jsonGraphEnvelope.jsonGraph\n            }], null, errorSelector, comparator);\n\n            jsonGraphEnvelope.paths = successfulPaths[1];\n\n            model._path = boundPath;\n            resultingJsonGraphEnvelope = jsonGraphEnvelope;\n        }, function onError(dataSourceError) {\n            if (disposable && disposable.disposed) {\n                return;\n            }\n            model._path = emptyArray$2;\n\n            setPathValues$1(model, paths.map(function(path) {\n                return {\n                    path: path,\n                    value: dataSourceError\n                };\n            }), null, errorSelector, comparator);\n\n            model._path = boundPath;\n\n            callback(dataSourceError);\n        }, function onCompleted() {\n            callback(null, resultingJsonGraphEnvelope);\n        });\n\n    return disposable;\n};\n\nvar sendSetRequest_1 = sendSetRequest$1;\n\nvar complement$1 = {exports: {}};\n\nvar iterateKeySet$1 = lib$1.iterateKeySet;\n\n/**\n * Calculates what paths in requested path sets can be deduplicated based on an existing optimized path tree.\n *\n * For path sets with ranges or key sets, if some expanded paths can be found in the path tree, only matching paths are\n * returned as intersection. The non-matching expanded paths are returned as complement.\n *\n * The function returns an object consisting of:\n * - intersection: requested paths that were matched to the path tree\n * - optimizedComplement: optimized paths that were not found in the path tree\n * - requestedComplement: requested paths for the optimized paths that were not found in the path tree\n */\ncomplement$1.exports = function complement(requested, optimized, tree) {\n    var optimizedComplement = [];\n    var requestedComplement = [];\n    var intersection = [];\n    var i, iLen;\n\n    for (i = 0, iLen = optimized.length; i < iLen; ++i) {\n        var oPath = optimized[i];\n        var rPath = requested[i];\n        var subTree = tree[oPath.length];\n\n        var intersectionData = findPartialIntersections(rPath, oPath, subTree);\n        Array.prototype.push.apply(intersection, intersectionData[0]);\n        Array.prototype.push.apply(optimizedComplement, intersectionData[1]);\n        Array.prototype.push.apply(requestedComplement, intersectionData[2]);\n    }\n\n    return {\n        intersection: intersection,\n        optimizedComplement: optimizedComplement,\n        requestedComplement: requestedComplement\n    };\n};\n\n/**\n * Recursive function to calculate intersection and complement paths in 2 given pathsets at a given depth.\n *\n * Parameters:\n *  - requestedPath: full requested path set (can include ranges)\n *  - optimizedPath: corresponding optimized path (can include ranges)\n *  - requestTree: path tree for in-flight request, against which to dedupe\n *\n * Returns a 3-tuple consisting of\n *  - the intersection of requested paths with requestTree\n *  - the complement of optimized paths with requestTree\n *  - the complement of corresponding requested paths with requestTree\n *\n * Example scenario:\n *  - requestedPath: ['lolomo', 0, 0, 'tags', { from: 0, to: 2 }]\n *  - optimizedPath: ['videosById', 11, 'tags', { from: 0, to: 2 }]\n *  - requestTree: { videosById: 11: { tags: { 0: null, 1: null }}}\n *\n * This returns:\n * [\n *   [['lolomo', 0, 0, 'tags', 0], ['lolomo', 0, 0, 'tags', 1]],\n *   [['videosById', 11, 'tags', 2]],\n *   [['lolomo', 0, 0, 'tags', 2]]\n * ]\n *\n */\nfunction findPartialIntersections(requestedPath, optimizedPath, requestTree) {\n    var depthDiff = requestedPath.length - optimizedPath.length;\n    var i;\n\n    // Descend into the request path tree for the optimized-path prefix (when the optimized path is longer than the\n    // requested path)\n    for (i = 0; requestTree && i < -depthDiff; i++) {\n        requestTree = requestTree[optimizedPath[i]];\n    }\n\n    // There is no matching path in the request path tree, thus no candidates for deduplication\n    if (!requestTree) {\n        return [[], [optimizedPath], [requestedPath]];\n    }\n\n    if (depthDiff === 0) {\n        return recurse(requestedPath, optimizedPath, requestTree, 0, [], []);\n    } else if (depthDiff > 0) {\n        return recurse(requestedPath, optimizedPath, requestTree, 0, requestedPath.slice(0, depthDiff), []);\n    } else {\n        return recurse(requestedPath, optimizedPath, requestTree, -depthDiff, [], optimizedPath.slice(0, -depthDiff));\n    }\n}\n\nfunction recurse(requestedPath, optimizedPath, currentTree, depth, rCurrentPath, oCurrentPath) {\n    var depthDiff = requestedPath.length - optimizedPath.length;\n    var intersections = [];\n    var rComplementPaths = [];\n    var oComplementPaths = [];\n    var oPathLen = optimizedPath.length;\n\n    // Loop over the optimized path, looking for deduplication opportunities\n    for (; depth < oPathLen; ++depth) {\n        var key = optimizedPath[depth];\n        var keyType = typeof key;\n\n        if (key && keyType === \"object\") {\n            // If a range key is found, start an inner loop to iterate over all keys in the range, and add\n            // intersections and complements from each iteration separately.\n            //\n            // Range keys branch out this way, providing individual deduping opportunities for each inner key.\n            var note = {};\n            var innerKey = iterateKeySet$1(key, note);\n\n            while (!note.done) {\n                var nextTree = currentTree[innerKey];\n                if (nextTree === undefined) {\n                    // If no next sub tree exists for an inner key, it's a dead-end and we can add this to\n                    // complement paths\n                    oComplementPaths[oComplementPaths.length] = arrayConcatSlice2(\n                        oCurrentPath,\n                        innerKey,\n                        optimizedPath, depth + 1\n                    );\n                    rComplementPaths[rComplementPaths.length] = arrayConcatSlice2(\n                        rCurrentPath,\n                        innerKey,\n                        requestedPath, depth + 1 + depthDiff\n                    );\n                } else if (depth === oPathLen - 1) {\n                    // Reaching the end of the optimized path means that we found the entire path in the path tree,\n                    // so add it to intersections\n                    intersections[intersections.length] = arrayConcatElement(rCurrentPath, innerKey);\n                } else {\n                    // Otherwise keep trying to find further partial deduping opportunities in the remaining path\n                    var intersectionData = recurse(\n                        requestedPath, optimizedPath,\n                        nextTree,\n                        depth + 1,\n                        arrayConcatElement(rCurrentPath, innerKey),\n                        arrayConcatElement(oCurrentPath, innerKey)\n                    );\n\n                    Array.prototype.push.apply(intersections, intersectionData[0]);\n                    Array.prototype.push.apply(oComplementPaths, intersectionData[1]);\n                    Array.prototype.push.apply(rComplementPaths, intersectionData[2]);\n                }\n                innerKey = iterateKeySet$1(key, note);\n            }\n\n            // The remainder of the path was handled by the recursive call, terminate the loop\n            break;\n        } else {\n            // For simple keys, we don't need to branch out. Loop over `depth` instead of iterating over a range.\n            currentTree = currentTree[key];\n            oCurrentPath[oCurrentPath.length] = optimizedPath[depth];\n            rCurrentPath[rCurrentPath.length] = requestedPath[depth + depthDiff];\n\n            if (currentTree === undefined) {\n                // The path was not found in the tree, add this to complements\n                oComplementPaths[oComplementPaths.length] = arrayConcatSlice(\n                    oCurrentPath, optimizedPath, depth + 1\n                );\n                rComplementPaths[rComplementPaths.length] = arrayConcatSlice(\n                    rCurrentPath, requestedPath, depth + depthDiff + 1\n                );\n\n                break;\n            } else if (depth === oPathLen - 1) {\n                // The end of optimized path was reached, add to intersections\n                intersections[intersections.length] = rCurrentPath;\n            }\n        }\n    }\n\n    // Return accumulated intersection and complement paths\n    return [intersections, oComplementPaths, rComplementPaths];\n}\n\n// Exported for unit testing.\ncomplement$1.exports.__test = { findPartialIntersections: findPartialIntersections };\n\n/**\n * Create a new array consisting of a1 + a subset of a2. Avoids allocating an extra array by calling `slice` on a2.\n */\nfunction arrayConcatSlice(a1, a2, start) {\n    var result = a1.slice();\n    var l1 = result.length;\n    var length = a2.length - start;\n    result.length = l1 + length;\n    for (var i = 0; i < length; ++i) {\n        result[l1 + i] = a2[start + i];\n    }\n    return result;\n}\n\n/**\n * Create a new array consisting of a1 + a2 + a subset of a3. Avoids allocating an extra array by calling `slice` on a3.\n */\nfunction arrayConcatSlice2(a1, a2, a3, start) {\n    var result = a1.concat(a2);\n    var l1 = result.length;\n    var length = a3.length - start;\n    result.length = l1 + length;\n    for (var i = 0; i < length; ++i) {\n        result[l1 + i] = a3[start + i];\n    }\n    return result;\n}\n\n/**\n * Create a new array consistent of a1 plus an additional element. Avoids the unnecessary array allocation when using `a1.concat([element])`.\n */\nfunction arrayConcatElement(a1, element) {\n    var result = a1.slice();\n    result.push(element);\n    return result;\n}\n\nvar complementExports = complement$1.exports;\n\nvar pathUtils = lib$1;\nvar toTree = pathUtils.toTree;\nvar toPaths = pathUtils.toPaths;\nvar InvalidSourceError$4 = InvalidSourceError_1;\n\n/**\n * Flushes the current set of requests.  This will send the paths to the dataSource.\n * The results of the dataSource will be sent to callback which should perform the zip of all callbacks.\n *\n * @param {GetRequest} request - GetRequestV2 to be flushed to the DataSource\n * @param {Array} pathSetArrayBatch - Array of Arrays of path sets\n * @param {Function} callback -\n * @private\n */\nvar flushGetRequest$1 = function flushGetRequest(request, pathSetArrayBatch, callback) {\n    if (request._count === 0) {\n        request.requestQueue.removeRequest(request);\n        return null;\n    }\n\n    request.sent = true;\n    request.scheduled = false;\n\n    var requestPaths;\n\n    var model = request.requestQueue.model;\n    if (model._enablePathCollapse || model._enableRequestDeduplication) {\n        // Note on the if-condition: request deduplication uses request._pathMap,\n        // so we need to populate that field if the feature is enabled.\n\n        // TODO: Move this to the collapse algorithm,\n        // TODO: we should have a collapse that returns the paths and\n        // TODO: the trees.\n\n        // Take all the paths and add them to the pathMap by length.\n        // Since its a list of paths\n        var pathMap = request._pathMap;\n        var listIdx = 0,\n            listLen = pathSetArrayBatch.length;\n        for (; listIdx < listLen; ++listIdx) {\n            var paths = pathSetArrayBatch[listIdx];\n            for (var j = 0, pathLen = paths.length; j < pathLen; ++j) {\n                var pathSet = paths[j];\n                var len = pathSet.length;\n\n                if (!pathMap[len]) {\n                    pathMap[len] = [pathSet];\n                } else {\n                    var pathSetsByLength = pathMap[len];\n                    pathSetsByLength[pathSetsByLength.length] = pathSet;\n                }\n            }\n        }\n\n        // now that we have them all by length, convert each to a tree.\n        var pathMapKeys = Object.keys(pathMap);\n        var pathMapIdx = 0,\n            pathMapLen = pathMapKeys.length;\n        for (; pathMapIdx < pathMapLen; ++pathMapIdx) {\n            var pathMapKey = pathMapKeys[pathMapIdx];\n            pathMap[pathMapKey] = toTree(pathMap[pathMapKey]);\n        }\n    }\n\n    if (model._enablePathCollapse) {\n        // Take the pathMapTree and create the collapsed paths and send those\n        // off to the server.\n        requestPaths = toPaths(request._pathMap);\n    } else if (pathSetArrayBatch.length === 1) {\n        // Single batch Array of path sets, just extract it\n        requestPaths = pathSetArrayBatch[0];\n    } else {\n        // Multiple batches of Arrays of path sets, shallowly flatten into an Array of path sets\n        requestPaths = Array.prototype.concat.apply([], pathSetArrayBatch);\n    }\n\n    // Make the request.\n    // You are probably wondering why this is not cancellable.  If a request\n    // goes out, and all the requests are removed, the request should not be\n    // cancelled.  The reasoning is that another request could come in, after\n    // all callbacks have been removed and be deduped.  Might as well keep this\n    // around until it comes back.  If at that point there are no requests then\n    // we cancel at the callback above.\n    var getRequest;\n    try {\n        getRequest = model._source.get(requestPaths, request._attemptCount);\n    } catch (e) {\n        callback(new InvalidSourceError$4());\n        return null;\n    }\n\n    // Ensures that the disposable is available for the outside to cancel.\n    var jsonGraphData;\n    var disposable = getRequest.subscribe(\n        function(data) {\n            jsonGraphData = data;\n        },\n        function(err) {\n            callback(err, jsonGraphData);\n        },\n        function() {\n            callback(null, jsonGraphData);\n        }\n    );\n\n    return disposable;\n};\n\nvar currentCacheVersion$2 = {};\n\nvar version = null;\ncurrentCacheVersion$2.setVersion = function setCacheVersion(newVersion) {\n    version = newVersion;\n};\ncurrentCacheVersion$2.getVersion = function getCacheVersion() {\n    return version;\n};\n\nvar complement = complementExports;\nvar flushGetRequest = flushGetRequest$1;\nvar incrementVersion$1 = incrementVersionExports;\nvar currentCacheVersion$1 = currentCacheVersion$2;\n\nvar REQUEST_ID = 0;\nvar GetRequestType = RequestTypes$1.GetRequest;\nvar setJSONGraphs$1 = setJSONGraphs$3;\nvar setPathValues = requireSetPathValues();\nvar $error$1 = error;\nvar emptyArray$1 = [];\nvar InvalidSourceError$3 = InvalidSourceError_1;\n\n/**\n * Creates a new GetRequest.  This GetRequest takes a scheduler and\n * the request queue.  Once the scheduler fires, all batched requests\n * will be sent to the server.  Upon request completion, the data is\n * merged back into the cache and all callbacks are notified.\n *\n * @param {Scheduler} scheduler -\n * @param {RequestQueueV2} requestQueue -\n * @param {number} attemptCount\n */\nvar GetRequestV2 = function(scheduler, requestQueue, attemptCount) {\n    this.sent = false;\n    this.scheduled = false;\n    this.requestQueue = requestQueue;\n    this.id = ++REQUEST_ID;\n    this.type = GetRequestType;\n\n    this._scheduler = scheduler;\n    this._attemptCount = attemptCount;\n    this._pathMap = {};\n    this._optimizedPaths = [];\n    this._requestedPaths = [];\n    this._callbacks = [];\n    this._count = 0;\n    this._disposable = null;\n    this._collapsed = null;\n    this._disposed = false;\n};\n\nGetRequestV2.prototype = {\n    /**\n     * batches the paths that are passed in.  Once the request is complete,\n     * all callbacks will be called and the request will be removed from\n     * parent queue.\n     * @param {Array} requestedPaths -\n     * @param {Array} optimizedPaths -\n     * @param {Function} callback -\n     */\n    batch: function(requestedPaths, optimizedPaths, callback) {\n        var self = this;\n        var batchedOptPathSets = self._optimizedPaths;\n        var batchedReqPathSets = self._requestedPaths;\n        var batchedCallbacks = self._callbacks;\n        var batchIx = batchedOptPathSets.length;\n\n        // If its not sent, simply add it to the requested paths\n        // and callbacks.\n        batchedOptPathSets[batchIx] = optimizedPaths;\n        batchedReqPathSets[batchIx] = requestedPaths;\n        batchedCallbacks[batchIx] = callback;\n        ++self._count;\n\n        // If it has not been scheduled, then schedule the action\n        if (!self.scheduled) {\n            self.scheduled = true;\n\n            var flushedDisposable;\n            var scheduleDisposable = self._scheduler.schedule(function() {\n                flushedDisposable = flushGetRequest(self, batchedOptPathSets, function(err, data) {\n                    var i, fn, len;\n                    var model = self.requestQueue.model;\n                    self.requestQueue.removeRequest(self);\n                    self._disposed = true;\n\n                    if (model._treatDataSourceErrorsAsJSONGraphErrors ? err instanceof InvalidSourceError$3 : !!err) {\n                        for (i = 0, len = batchedCallbacks.length; i < len; ++i) {\n                            fn = batchedCallbacks[i];\n                            if (fn) {\n                                fn(err);\n                            }\n                        }\n                        return;\n                    }\n\n                    // If there is at least one callback remaining, then\n                    // callback the callbacks.\n                    if (self._count) {\n                        // currentVersion will get added to each inserted\n                        // node as node.$_version inside of self._merge.\n                        //\n                        // atom values just downloaded with $expires: 0\n                        // (now-expired) will get assigned $_version equal\n                        // to currentVersion, and checkCacheAndReport will\n                        // later consider those nodes to not have expired\n                        // for the duration of current event loop tick\n                        //\n                        // we unset currentCacheVersion after all callbacks\n                        // have been called, to ensure that only these\n                        // particular callbacks and any synchronous model.get\n                        // callbacks inside of these, get the now-expired\n                        // values\n                        var currentVersion = incrementVersion$1.getCurrentVersion();\n                        currentCacheVersion$1.setVersion(currentVersion);\n                        var mergeContext = { hasInvalidatedResult: false };\n\n                        var pathsErr = model._useServerPaths && data && data.paths === undefined ?\n                            new Error(\"Server responses must include a 'paths' field when Model._useServerPaths === true\") : undefined;\n\n                        if (!pathsErr) {\n                            self._merge(batchedReqPathSets, err, data, mergeContext);\n                        }\n\n                        // Call the callbacks.  The first one inserts all\n                        // the data so that the rest do not have consider\n                        // if their data is present or not.\n                        for (i = 0, len = batchedCallbacks.length; i < len; ++i) {\n                            fn = batchedCallbacks[i];\n                            if (fn) {\n                                fn(pathsErr || err, data, mergeContext.hasInvalidatedResult);\n                            }\n                        }\n                        currentCacheVersion$1.setVersion(null);\n                    }\n                });\n                self._disposable = flushedDisposable;\n            });\n\n            // If the scheduler is sync then `flushedDisposable` will be\n            // defined, and we want to use it, because that's what aborts an\n            // in-flight XHR request, for example.\n            // But if the scheduler is async, then `flushedDisposable` won't be\n            // defined yet, and so we must use the scheduler's disposable until\n            // `flushedDisposable` is defined. Since we want to still use\n            // `flushedDisposable` once it is defined (to be able to abort in-\n            // flight XHR requests), hence the reassignment of `_disposable`\n            // above.\n            self._disposable = flushedDisposable || scheduleDisposable;\n        }\n\n        // Disposes this batched request.  This does not mean that the\n        // entire request has been disposed, but just the local one, if all\n        // requests are disposed, then the outer disposable will be removed.\n        return createDisposable(self, batchIx);\n    },\n\n    /**\n     * Attempts to add paths to the outgoing request.  If there are added\n     * paths then the request callback will be added to the callback list.\n     * Handles adding partial paths as well\n     *\n     * @returns {Array} - whether new requested paths were inserted in this\n     *                    request, the remaining paths that could not be added,\n     *                    and disposable for the inserted requested paths.\n     */\n    add: function(requested, optimized, callback) {\n        // uses the length tree complement calculator.\n        var self = this;\n        var complementResult = complement(requested, optimized, self._pathMap);\n\n        var inserted = false;\n        var disposable = false;\n\n        // If we found an intersection, then just add new callback\n        // as one of the dependents of that request\n        if (complementResult.intersection.length) {\n            inserted = true;\n            var batchIx = self._callbacks.length;\n            self._callbacks[batchIx] = callback;\n            self._requestedPaths[batchIx] = complementResult.intersection;\n            self._optimizedPaths[batchIx] = [];\n            ++self._count;\n\n            disposable = createDisposable(self, batchIx);\n        }\n\n        return [inserted, complementResult.requestedComplement, complementResult.optimizedComplement, disposable];\n    },\n\n    /**\n     * merges the response into the model\"s cache.\n     */\n    _merge: function(requested, err, data, mergeContext) {\n        var self = this;\n        var model = self.requestQueue.model;\n        var modelRoot = model._root;\n        var errorSelector = modelRoot.errorSelector;\n        var comparator = modelRoot.comparator;\n        var boundPath = model._path;\n\n        model._path = emptyArray$1;\n\n        // flatten all the requested paths, adds them to the\n        var nextPaths = model._useServerPaths ? data.paths : flattenRequestedPaths(requested);\n\n        // Insert errors in every requested position.\n        if (err && model._treatDataSourceErrorsAsJSONGraphErrors) {\n            var error = err;\n\n            // Converts errors to objects, a more friendly storage\n            // of errors.\n            if (error instanceof Error) {\n                error = {\n                    message: error.message\n                };\n            }\n\n            // Not all errors are value $types.\n            if (!error.$type) {\n                error = {\n                    $type: $error$1,\n                    value: error\n                };\n            }\n\n            var pathValues = nextPaths.map(function(x) {\n                return {\n                    path: x,\n                    value: error\n                };\n            });\n            setPathValues(model, pathValues, null, errorSelector, comparator, mergeContext);\n        }\n\n        // Insert the jsonGraph from the dataSource.\n        else {\n            setJSONGraphs$1(model, [{\n                paths: nextPaths,\n                jsonGraph: data.jsonGraph\n            }], null, errorSelector, comparator, mergeContext);\n        }\n\n        // return the model\"s boundPath\n        model._path = boundPath;\n    }\n};\n\n// Creates a more efficient closure of the things that are\n// needed.  So the request and the batch index.  Also prevents code\n// duplication.\nfunction createDisposable(request, batchIx) {\n    var disposed = false;\n    return function() {\n        if (disposed || request._disposed) {\n            return;\n        }\n\n        disposed = true;\n        request._callbacks[batchIx] = null;\n        request._optimizedPaths[batchIx] = [];\n        request._requestedPaths[batchIx] = [];\n\n        // If there are no more requests, then dispose all of the request.\n        var count = --request._count;\n        var disposable = request._disposable;\n        if (count === 0) {\n            // looking for unsubscribe here to support more data sources (Rx)\n            if (disposable.unsubscribe) {\n                disposable.unsubscribe();\n            } else {\n                disposable.dispose();\n            }\n            request.requestQueue.removeRequest(request);\n        }\n    };\n}\n\nfunction flattenRequestedPaths(requested) {\n    var out = [];\n    var outLen = -1;\n    for (var i = 0, len = requested.length; i < len; ++i) {\n        var paths = requested[i];\n        for (var j = 0, innerLen = paths.length; j < innerLen; ++j) {\n            out[++outLen] = paths[j];\n        }\n    }\n    return out;\n}\n\nvar GetRequestV2_1 = GetRequestV2;\n\nvar RequestTypes = RequestTypes$1;\nvar sendSetRequest = sendSetRequest_1;\nvar GetRequest = GetRequestV2_1;\nvar falcorPathUtils = lib$1;\n\n/**\n * The request queue is responsible for queuing the operations to\n * the model\"s dataSource.\n *\n * @param {Model} model -\n * @param {Scheduler} scheduler -\n */\nfunction RequestQueueV2(model, scheduler) {\n    this.model = model;\n    this.scheduler = scheduler;\n    this.requests = this._requests = [];\n}\n\nRequestQueueV2.prototype = {\n    /**\n     * Sets the scheduler, but will not affect any current requests.\n     */\n    setScheduler: function(scheduler) {\n        this.scheduler = scheduler;\n    },\n\n    /**\n     * performs a set against the dataSource.  Sets, though are not batched\n     * currently could be batched potentially in the future.  Since no batching\n     * is required the setRequest action is simplified significantly.\n     *\n     * @param {JSONGraphEnvelope} jsonGraph -\n     * @param {number} attemptCount\n     * @param {Function} cb\n     */\n    set: function(jsonGraph, attemptCount, cb) {\n        if (this.model._enablePathCollapse) {\n            jsonGraph.paths = falcorPathUtils.collapse(jsonGraph.paths);\n        }\n\n        if (cb === undefined) {\n            cb = attemptCount;\n            attemptCount = undefined;\n        }\n\n        return sendSetRequest(jsonGraph, this.model, attemptCount, cb);\n    },\n\n    /**\n     * Creates a get request to the dataSource.  Depending on the current\n     * scheduler is how the getRequest will be flushed.\n     * @param {Array} requestedPaths -\n     * @param {Array} optimizedPaths -\n     * @param {number} attemptCount\n     * @param {Function} cb -\n     */\n    get: function(requestedPaths, optimizedPaths, attemptCount, cb) {\n        var self = this;\n        var disposables = [];\n        var count = 0;\n        var requests = self._requests;\n        var i, len;\n        var oRemainingPaths = optimizedPaths;\n        var rRemainingPaths = requestedPaths;\n        var disposed = false;\n        var request;\n\n        if (cb === undefined) {\n            cb = attemptCount;\n            attemptCount = undefined;\n        }\n\n        for (i = 0, len = requests.length; i < len; ++i) {\n            request = requests[i];\n            if (request.type !== RequestTypes.GetRequest) {\n                continue;\n            }\n\n            // The request has been sent, attempt to jump on the request\n            // if possible.\n            if (request.sent) {\n                if (this.model._enableRequestDeduplication) {\n                    var results = request.add(rRemainingPaths, oRemainingPaths, refCountCallback);\n\n                    // Checks to see if the results were successfully inserted\n                    // into the outgoing results.  Then our paths will be reduced\n                    // to the complement.\n                    if (results[0]) {\n                        rRemainingPaths = results[1];\n                        oRemainingPaths = results[2];\n                        disposables[disposables.length] = results[3];\n                        ++count;\n\n                        // If there are no more remaining paths then exit the loop.\n                        if (!oRemainingPaths.length) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // If there is an unsent request, then we can batch and leave.\n            else {\n                request.batch(rRemainingPaths, oRemainingPaths, refCountCallback);\n                oRemainingPaths = null;\n                rRemainingPaths = null;\n                ++count;\n                break;\n            }\n        }\n\n        // After going through all the available requests if there are more\n        // paths to process then a new request must be made.\n        if (oRemainingPaths && oRemainingPaths.length) {\n            request = new GetRequest(self.scheduler, self, attemptCount);\n            requests[requests.length] = request;\n            ++count;\n            var disposable = request.batch(rRemainingPaths, oRemainingPaths, refCountCallback);\n            disposables[disposables.length] = disposable;\n        }\n\n        // This is a simple refCount callback.\n        function refCountCallback(err, data, hasInvalidatedResult) {\n            if (disposed) {\n                return;\n            }\n\n            --count;\n\n            // If the count becomes 0, then its time to notify the\n            // listener that the request is done.\n            if (count === 0) {\n                cb(err, data, hasInvalidatedResult);\n            }\n        }\n\n        // When disposing the request all of the outbound requests will be\n        // disposed of.\n        return function() {\n            if (disposed || count === 0) {\n                return;\n            }\n\n            disposed = true;\n            var length = disposables.length;\n            for (var idx = 0; idx < length; ++idx) {\n                disposables[idx]();\n            }\n        };\n    },\n\n    /**\n     * Removes the request from the request queue.\n     */\n    removeRequest: function(request) {\n        var requests = this._requests;\n        var i = requests.length;\n        while (--i >= 0) {\n            if (requests[i].id === request.id) {\n                requests.splice(i, 1);\n                break;\n            }\n        }\n    }\n};\n\nvar RequestQueueV2_1 = RequestQueueV2;\n\nvar noop$1 = function noop() {};\n\nvar noop = noop$1;\n\n/**\n * A ModelResponseObserver conform to the Observable's Observer contract. It accepts either an Observer or three optional callbacks which correspond to the Observer methods onNext, onError, and onCompleted.\n * The ModelResponseObserver wraps an Observer to enforce a variety of different invariants including:\n * 1. onError callback is only called once.\n * 2. onCompleted callback is only called once.\n * @constructor ModelResponseObserver\n*/\nfunction ModelResponseObserver$1(\n    onNextOrObserver,\n    onErrorFn,\n    onCompletedFn\n) {\n    // if callbacks are passed, construct an Observer from them. Create a NOOP function for any missing callbacks.\n    if (!onNextOrObserver || typeof onNextOrObserver !== \"object\") {\n        this._observer = {\n            onNext: (\n                typeof onNextOrObserver === \"function\"\n                    ? onNextOrObserver\n                    : noop\n            ),\n            onError: (\n                typeof onErrorFn === \"function\"\n                    ? onErrorFn\n                    : noop\n            ),\n            onCompleted: (\n                typeof onCompletedFn === \"function\"\n                    ? onCompletedFn\n                    : noop\n            )\n        };\n    }\n    // if an Observer is passed\n    else {\n        this._observer = {\n            onNext: typeof onNextOrObserver.onNext === \"function\" ? function(value) { onNextOrObserver.onNext(value); } : noop,\n            onError: typeof onNextOrObserver.onError === \"function\" ? function(error) { onNextOrObserver.onError(error); } : noop,\n            onCompleted: (\n                typeof onNextOrObserver.onCompleted === \"function\"\n                    ? function() { onNextOrObserver.onCompleted(); }\n                    : noop\n            )\n        };\n    }\n}\n\nModelResponseObserver$1.prototype = {\n    onNext: function(v) {\n        if (!this._closed) {\n            this._observer.onNext(v);\n        }\n    },\n    onError: function(e) {\n        if (!this._closed) {\n            this._closed = true;\n            this._observer.onError(e);\n        }\n    },\n    onCompleted: function() {\n        if (!this._closed) {\n            this._closed = true;\n            this._observer.onCompleted();\n        }\n    }\n};\n\nvar ModelResponseObserver_1 = ModelResponseObserver$1;\n\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n}\n\n/* global window */\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = symbolObservablePonyfill(root);\n\nvar es = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tdefault: result\n});\n\nvar require$$1 = /*@__PURE__*/getAugmentedNamespace(es);\n\n/**\n * FromEsObserverAdapter is an adpater from an ES Observer to an Rx 2 Observer\n * @constructor FromEsObserverAdapter\n*/\n\nfunction FromEsObserverAdapter(esObserver) {\n    this.esObserver = esObserver;\n}\n\nFromEsObserverAdapter.prototype = {\n    onNext: function onNext(value) {\n        if (typeof this.esObserver.next === \"function\") {\n            this.esObserver.next(value);\n        }\n    },\n    onError: function onError(error) {\n        if (typeof this.esObserver.error === \"function\") {\n            this.esObserver.error(error);\n        }\n    },\n    onCompleted: function onCompleted() {\n        if (typeof this.esObserver.complete === \"function\") {\n            this.esObserver.complete();\n        }\n    }\n};\n\n/**\n * ToEsSubscriptionAdapter is an adpater from the Rx 2 subscription to the ES subscription\n * @constructor ToEsSubscriptionAdapter\n*/\nfunction ToEsSubscriptionAdapter(subscription) {\n    this.subscription = subscription;\n}\n\nToEsSubscriptionAdapter.prototype.unsubscribe = function unsubscribe() {\n    this.subscription.dispose();\n};\n\n\nfunction toEsObservable$1(_self) {\n    return {\n        subscribe: function subscribe(observer) {\n            return new ToEsSubscriptionAdapter(_self.subscribe(new FromEsObserverAdapter(observer)));\n        }\n    };\n}\n\nvar toEsObservable_1 = toEsObservable$1;\n\nvar ModelResponseObserver = ModelResponseObserver_1;\nvar $$observable = require$$1.default;\nvar toEsObservable = toEsObservable_1;\n\n/**\n * A ModelResponse is a container for the results of a get, set, or call operation performed on a Model. The ModelResponse provides methods which can be used to specify the output format of the data retrieved from a Model, as well as how that data is delivered.\n * @constructor ModelResponse\n * @augments Observable\n*/\nfunction ModelResponse$7(subscribe) {\n    this._subscribe = subscribe;\n}\n\nModelResponse$7.prototype[$$observable] = function SymbolObservable() {\n    return toEsObservable(this);\n};\n\nModelResponse$7.prototype._toJSONG = function toJSONG() {\n    return this;\n};\n\n/**\n * The progressively method breaks the response up into two parts: the data immediately available in the Model cache, and the data in the Model cache after the missing data has been retrieved from the DataSource.\n * The progressively method creates a ModelResponse that immediately returns the requested data that is available in the Model cache. If any requested paths are not available in the cache, the ModelResponse will send another JSON message with all of the requested data after it has been retrieved from the DataSource.\n * @name progressively\n * @memberof ModelResponse.prototype\n * @function\n * @return {ModelResponse.<JSONEnvelope>} the values found at the requested paths.\n * @example\nvar dataSource = (new falcor.Model({\n  cache: {\n    user: {\n      name: \"Steve\",\n      surname: \"McGuire\",\n      age: 31\n    }\n  }\n})).asDataSource();\n\nvar model = new falcor.Model({\n  source: dataSource,\n  cache: {\n    user: {\n      name: \"Steve\",\n      surname: \"McGuire\"\n    }\n  }\n});\n\nmodel.\n  get([\"user\",[\"name\", \"surname\", \"age\"]]).\n  progressively().\n  // this callback will be invoked twice, once with the data in the\n  // Model cache, and again with the additional data retrieved from the DataSource.\n  subscribe(function(json){\n    console.log(JSON.stringify(json,null,4));\n  });\n\n// prints...\n// {\n//     \"json\": {\n//         \"user\": {\n//             \"name\": \"Steve\",\n//             \"surname\": \"McGuire\"\n//         }\n//     }\n// }\n// ...and then prints...\n// {\n//     \"json\": {\n//         \"user\": {\n//             \"name\": \"Steve\",\n//             \"surname\": \"McGuire\",\n//             \"age\": 31\n//         }\n//     }\n// }\n*/\nModelResponse$7.prototype.progressively = function progressively() {\n    return this;\n};\n\nModelResponse$7.prototype.subscribe =\nModelResponse$7.prototype.forEach = function subscribe(a, b, c) {\n    var observer = new ModelResponseObserver(a, b, c);\n    var subscription = this._subscribe(observer);\n    switch (typeof subscription) {\n        case \"function\":\n            return {\n                dispose: function() {\n                    if (observer._closed) {\n                        return;\n                    }\n                    observer._closed = true;\n                    subscription();\n                }\n             };\n        case \"object\":\n            return {\n                dispose: function() {\n                    if (observer._closed) {\n                        return;\n                    }\n                    observer._closed = true;\n                    if (subscription !== null) {\n                        subscription.dispose();\n                    }\n                }\n             };\n        default:\n            return {\n                dispose: function() {\n                    observer._closed = true;\n                }\n             };\n    }\n};\n\nModelResponse$7.prototype.then = function then(onNext, onError) {\n    /* global Promise */\n    var self = this;\n    if (!self._promise) {\n        self._promise = new Promise(function(resolve, reject) {\n            var rejected = false;\n            var values = [];\n            self.subscribe(\n                function(value) {\n                    values[values.length] = value;\n                },\n                function(errors) {\n                    rejected = true;\n                    reject(errors);\n                },\n                function() {\n                    var value = values;\n                    if (values.length <= 1) {\n                        value = values[0];\n                    }\n\n                    if (rejected === false) {\n                        resolve(value);\n                    }\n                }\n            );\n        });\n    }\n    return self._promise.then(onNext, onError);\n};\n\nvar ModelResponse_1 = ModelResponse$7;\n\nvar tokenizer = {exports: {}};\n\nvar TokenTypes$6 = {\n    token: 'token',\n    dotSeparator: '.',\n    commaSeparator: ',',\n    openingBracket: '[',\n    closingBracket: ']',\n    openingBrace: '{',\n    closingBrace: '}',\n    escape: '\\\\',\n    space: ' ',\n    colon: ':',\n    quote: 'quote',\n    unknown: 'unknown'\n};\n\nvar TokenTypes_1 = TokenTypes$6;\n\nvar TokenTypes$5 = TokenTypes_1;\nvar DOT_SEPARATOR = '.';\nvar COMMA_SEPARATOR = ',';\nvar OPENING_BRACKET = '[';\nvar CLOSING_BRACKET = ']';\nvar OPENING_BRACE = '{';\nvar CLOSING_BRACE = '}';\nvar COLON = ':';\nvar ESCAPE = '\\\\';\nvar DOUBLE_OUOTES = '\"';\nvar SINGE_OUOTES = \"'\";\nvar SPACE = \" \";\nvar SPECIAL_CHARACTERS = '\\\\\\'\"[]., ';\nvar EXT_SPECIAL_CHARACTERS = '\\\\{}\\'\"[]., :';\n\nvar Tokenizer$2 = tokenizer.exports = function(string, ext) {\n    this._string = string;\n    this._idx = -1;\n    this._extended = ext;\n    this.parseString = '';\n};\n\nTokenizer$2.prototype = {\n    /**\n     * grabs the next token either from the peek operation or generates the\n     * next token.\n     */\n    next: function() {\n        var nextToken = this._nextToken ?\n            this._nextToken : getNext(this._string, this._idx, this._extended);\n\n        this._idx = nextToken.idx;\n        this._nextToken = false;\n        this.parseString += nextToken.token.token;\n\n        return nextToken.token;\n    },\n\n    /**\n     * will peak but not increment the tokenizer\n     */\n    peek: function() {\n        var nextToken = this._nextToken ?\n            this._nextToken : getNext(this._string, this._idx, this._extended);\n        this._nextToken = nextToken;\n\n        return nextToken.token;\n    }\n};\n\nTokenizer$2.toNumber = function toNumber(x) {\n    if (!isNaN(+x)) {\n        return +x;\n    }\n    return NaN;\n};\n\nfunction toOutput(token, type, done) {\n    return {\n        token: token,\n        done: done,\n        type: type\n    };\n}\n\nfunction getNext(string, idx, ext) {\n    var output = false;\n    var token = '';\n    var specialChars = ext ?\n        EXT_SPECIAL_CHARACTERS : SPECIAL_CHARACTERS;\n    var done;\n\n    do {\n\n        done = idx + 1 >= string.length;\n        if (done) {\n            break;\n        }\n\n        // we have to peek at the next token\n        var character = string[idx + 1];\n\n        if (character !== undefined &&\n            specialChars.indexOf(character) === -1) {\n\n            token += character;\n            ++idx;\n            continue;\n        }\n\n        // The token to delimiting character transition.\n        else if (token.length) {\n            break;\n        }\n\n        ++idx;\n        var type;\n        switch (character) {\n            case DOT_SEPARATOR:\n                type = TokenTypes$5.dotSeparator;\n                break;\n            case COMMA_SEPARATOR:\n                type = TokenTypes$5.commaSeparator;\n                break;\n            case OPENING_BRACKET:\n                type = TokenTypes$5.openingBracket;\n                break;\n            case CLOSING_BRACKET:\n                type = TokenTypes$5.closingBracket;\n                break;\n            case OPENING_BRACE:\n                type = TokenTypes$5.openingBrace;\n                break;\n            case CLOSING_BRACE:\n                type = TokenTypes$5.closingBrace;\n                break;\n            case SPACE:\n                type = TokenTypes$5.space;\n                break;\n            case DOUBLE_OUOTES:\n            case SINGE_OUOTES:\n                type = TokenTypes$5.quote;\n                break;\n            case ESCAPE:\n                type = TokenTypes$5.escape;\n                break;\n            case COLON:\n                type = TokenTypes$5.colon;\n                break;\n            default:\n                type = TokenTypes$5.unknown;\n                break;\n        }\n        output = toOutput(character, type, false);\n        break;\n    } while (!done);\n\n    if (!output && token.length) {\n        output = toOutput(token, TokenTypes$5.token, false);\n    }\n\n    if (!output) {\n        output = {done: true};\n    }\n\n    return {\n        token: output,\n        idx: idx\n    };\n}\n\nvar tokenizerExports = tokenizer.exports;\n\nvar exceptions = {\n    indexer: {\n        nested: 'Indexers cannot be nested.',\n        needQuotes: 'unquoted indexers must be numeric.',\n        empty: 'cannot have empty indexers.',\n        leadingDot: 'Indexers cannot have leading dots.',\n        leadingComma: 'Indexers cannot have leading comma.',\n        requiresComma: 'Indexers require commas between indexer args.',\n        routedTokens: 'Only one token can be used per indexer when specifying routed tokens.'\n    },\n    range: {\n        precedingNaN: 'ranges must be preceded by numbers.',\n        suceedingNaN: 'ranges must be suceeded by numbers.'\n    },\n    routed: {\n        invalid: 'Invalid routed token.  only integers|ranges|keys are supported.'\n    },\n    quote: {\n        empty: 'cannot have empty quoted keys.',\n        illegalEscape: 'Invalid escape character.  Only quotes are escapable.'\n    },\n    unexpectedToken: 'Unexpected token.',\n    invalidIdentifier: 'Invalid Identifier.',\n    invalidPath: 'Please provide a valid path.',\n    throwError: function(err, tokenizer, token) {\n        if (token) {\n            throw err + ' -- ' + tokenizer.parseString + ' with next token: ' + token;\n        }\n        throw err + ' -- ' + tokenizer.parseString;\n    }\n};\n\nvar Tokenizer$1 = tokenizerExports;\nvar TokenTypes$4 = TokenTypes_1;\nvar E$4 = exceptions;\n\n/**\n * The indexer is all the logic that happens in between\n * the '[', opening bracket, and ']' closing bracket.\n */\nvar range$1 = function range(tokenizer, openingToken, state, out) {\n    var token = tokenizer.peek();\n    var dotCount = 1;\n    var done = false;\n    var inclusive = true;\n\n    // Grab the last token off the stack.  Must be an integer.\n    var idx = state.indexer.length - 1;\n    var from = Tokenizer$1.toNumber(state.indexer[idx]);\n    var to;\n\n    if (isNaN(from)) {\n        E$4.throwError(E$4.range.precedingNaN, tokenizer);\n    }\n\n    // Why is number checking so difficult in javascript.\n\n    while (!done && !token.done) {\n\n        switch (token.type) {\n\n            // dotSeparators at the top level have no meaning\n            case TokenTypes$4.dotSeparator:\n                if (dotCount === 3) {\n                    E$4.throwError(E$4.unexpectedToken, tokenizer);\n                }\n                ++dotCount;\n\n                if (dotCount === 3) {\n                    inclusive = false;\n                }\n                break;\n\n            case TokenTypes$4.token:\n                // move the tokenizer forward and save to.\n                to = Tokenizer$1.toNumber(tokenizer.next().token);\n\n                // throw potential error.\n                if (isNaN(to)) {\n                    E$4.throwError(E$4.range.suceedingNaN, tokenizer);\n                }\n\n                done = true;\n                break;\n\n            default:\n                done = true;\n                break;\n        }\n\n        // Keep cycling through the tokenizer.  But ranges have to peek\n        // before they go to the next token since there is no 'terminating'\n        // character.\n        if (!done) {\n            tokenizer.next();\n\n            // go to the next token without consuming.\n            token = tokenizer.peek();\n        }\n\n        // break and remove state information.\n        else {\n            break;\n        }\n    }\n\n    state.indexer[idx] = {from: from, to: inclusive ? to : to - 1};\n};\n\nvar TokenTypes$3 = TokenTypes_1;\nvar E$3 = exceptions;\nvar quoteE = E$3.quote;\n\n/**\n * quote is all the parse tree in between quotes.  This includes the only\n * escaping logic.\n *\n * parse-tree:\n * <opening-quote>(.|(<escape><opening-quote>))*<opening-quote>\n */\nvar quote$1 = function quote(tokenizer, openingToken, state, out) {\n    var token = tokenizer.next();\n    var innerToken = '';\n    var openingQuote = openingToken.token;\n    var escaping = false;\n    var done = false;\n\n    while (!token.done) {\n\n        switch (token.type) {\n            case TokenTypes$3.token:\n            case TokenTypes$3.space:\n\n            case TokenTypes$3.dotSeparator:\n            case TokenTypes$3.commaSeparator:\n\n            case TokenTypes$3.openingBracket:\n            case TokenTypes$3.closingBracket:\n            case TokenTypes$3.openingBrace:\n            case TokenTypes$3.closingBrace:\n                if (escaping) {\n                    E$3.throwError(quoteE.illegalEscape, tokenizer);\n                }\n\n                innerToken += token.token;\n                break;\n\n\n            case TokenTypes$3.quote:\n                // the simple case.  We are escaping\n                if (escaping) {\n                    innerToken += token.token;\n                    escaping = false;\n                }\n\n                // its not a quote that is the opening quote\n                else if (token.token !== openingQuote) {\n                    innerToken += token.token;\n                }\n\n                // last thing left.  Its a quote that is the opening quote\n                // therefore we must produce the inner token of the indexer.\n                else {\n                    done = true;\n                }\n\n                break;\n            case TokenTypes$3.escape:\n                escaping = true;\n                break;\n\n            default:\n                E$3.throwError(E$3.unexpectedToken, tokenizer);\n        }\n\n        // If done, leave loop\n        if (done) {\n            break;\n        }\n\n        // Keep cycling through the tokenizer.\n        token = tokenizer.next();\n    }\n\n    if (innerToken.length === 0) {\n        E$3.throwError(quoteE.empty, tokenizer);\n    }\n\n    state.indexer[state.indexer.length] = innerToken;\n};\n\nvar RoutedTokens$2 = {\n    integers: 'integers',\n    ranges: 'ranges',\n    keys: 'keys'\n};\n\nvar TokenTypes$2 = TokenTypes_1;\nvar RoutedTokens$1 = RoutedTokens$2;\nvar E$2 = exceptions;\nvar routedE = E$2.routed;\n\n/**\n * The routing logic.\n *\n * parse-tree:\n * <opening-brace><routed-token>(:<token>)<closing-brace>\n */\nvar routed$1 = function routed(tokenizer, openingToken, state, out) {\n    var routeToken = tokenizer.next();\n    var named = false;\n    var name = '';\n\n    // ensure the routed token is a valid ident.\n    switch (routeToken.token) {\n        case RoutedTokens$1.integers:\n        case RoutedTokens$1.ranges:\n        case RoutedTokens$1.keys:\n            //valid\n            break;\n        default:\n            E$2.throwError(routedE.invalid, tokenizer);\n            break;\n    }\n\n    // Now its time for colon or ending brace.\n    var next = tokenizer.next();\n\n    // we are parsing a named identifier.\n    if (next.type === TokenTypes$2.colon) {\n        named = true;\n\n        // Get the token name.\n        next = tokenizer.next();\n        if (next.type !== TokenTypes$2.token) {\n            E$2.throwError(routedE.invalid, tokenizer);\n        }\n        name = next.token;\n\n        // move to the closing brace.\n        next = tokenizer.next();\n    }\n\n    // must close with a brace.\n\n    if (next.type === TokenTypes$2.closingBrace) {\n        var outputToken = {\n            type: routeToken.token,\n            named: named,\n            name: name\n        };\n        state.indexer[state.indexer.length] = outputToken;\n    }\n\n    // closing brace expected\n    else {\n        E$2.throwError(routedE.invalid, tokenizer);\n    }\n\n};\n\nvar TokenTypes$1 = TokenTypes_1;\nvar E$1 = exceptions;\nvar idxE = E$1.indexer;\nvar range = range$1;\nvar quote = quote$1;\nvar routed = routed$1;\n\n/**\n * The indexer is all the logic that happens in between\n * the '[', opening bracket, and ']' closing bracket.\n */\nvar indexer$1 = function indexer(tokenizer, openingToken, state, out) {\n    var token = tokenizer.next();\n    var done = false;\n    var allowedMaxLength = 1;\n    var routedIndexer = false;\n\n    // State variables\n    state.indexer = [];\n\n    while (!token.done) {\n\n        switch (token.type) {\n            case TokenTypes$1.token:\n            case TokenTypes$1.quote:\n\n                // ensures that token adders are properly delimited.\n                if (state.indexer.length === allowedMaxLength) {\n                    E$1.throwError(idxE.requiresComma, tokenizer);\n                }\n                break;\n        }\n\n        switch (token.type) {\n            // Extended syntax case\n            case TokenTypes$1.openingBrace:\n                routedIndexer = true;\n                routed(tokenizer, token, state);\n                break;\n\n\n            case TokenTypes$1.token:\n                var t = +token.token;\n                if (isNaN(t)) {\n                    E$1.throwError(idxE.needQuotes, tokenizer);\n                }\n                state.indexer[state.indexer.length] = t;\n                break;\n\n            // dotSeparators at the top level have no meaning\n            case TokenTypes$1.dotSeparator:\n                if (!state.indexer.length) {\n                    E$1.throwError(idxE.leadingDot, tokenizer);\n                }\n                range(tokenizer, token, state);\n                break;\n\n            // Spaces do nothing.\n            case TokenTypes$1.space:\n                break;\n\n            case TokenTypes$1.closingBracket:\n                done = true;\n                break;\n\n\n            // The quotes require their own tree due to what can be in it.\n            case TokenTypes$1.quote:\n                quote(tokenizer, token, state);\n                break;\n\n\n            // Its time to decend the parse tree.\n            case TokenTypes$1.openingBracket:\n                E$1.throwError(idxE.nested, tokenizer);\n                break;\n\n            case TokenTypes$1.commaSeparator:\n                ++allowedMaxLength;\n                break;\n\n            default:\n                E$1.throwError(E$1.unexpectedToken, tokenizer);\n                break;\n        }\n\n        // If done, leave loop\n        if (done) {\n            break;\n        }\n\n        // Keep cycling through the tokenizer.\n        token = tokenizer.next();\n    }\n\n    if (state.indexer.length === 0) {\n        E$1.throwError(idxE.empty, tokenizer);\n    }\n\n    if (state.indexer.length > 1 && routedIndexer) {\n        E$1.throwError(idxE.routedTokens, tokenizer);\n    }\n\n    // Remember, if an array of 1, keySets will be generated.\n    if (state.indexer.length === 1) {\n        state.indexer = state.indexer[0];\n    }\n\n    out[out.length] = state.indexer;\n\n    // Clean state.\n    state.indexer = undefined;\n};\n\nvar TokenTypes = TokenTypes_1;\nvar E = exceptions;\nvar indexer = indexer$1;\n\n/**\n * The top level of the parse tree.  This returns the generated path\n * from the tokenizer.\n */\nvar head$1 = function head(tokenizer) {\n    var token = tokenizer.next();\n    var state = {};\n    var out = [];\n\n    while (!token.done) {\n\n        switch (token.type) {\n            case TokenTypes.token:\n                var first = +token.token[0];\n                if (!isNaN(first)) {\n                    E.throwError(E.invalidIdentifier, tokenizer);\n                }\n                out[out.length] = token.token;\n                break;\n\n            // dotSeparators at the top level have no meaning\n            case TokenTypes.dotSeparator:\n                if (out.length === 0) {\n                    E.throwError(E.unexpectedToken, tokenizer);\n                }\n                break;\n\n            // Spaces do nothing.\n            case TokenTypes.space:\n                // NOTE: Spaces at the top level are allowed.\n                // titlesById  .summary is a valid path.\n                break;\n\n\n            // Its time to decend the parse tree.\n            case TokenTypes.openingBracket:\n                indexer(tokenizer, token, state, out);\n                break;\n\n            default:\n                E.throwError(E.unexpectedToken, tokenizer);\n                break;\n        }\n\n        // Keep cycling through the tokenizer.\n        token = tokenizer.next();\n    }\n\n    if (out.length === 0) {\n        E.throwError(E.invalidPath, tokenizer);\n    }\n\n    return out;\n};\n\nvar Tokenizer = tokenizerExports;\nvar head = head$1;\nvar RoutedTokens = RoutedTokens$2;\n\nvar parser = function parser(string, extendedRules) {\n    return head(new Tokenizer(string, extendedRules));\n};\n\nvar src$1 = parser;\n\n// Constructs the paths from paths / pathValues that have strings.\n// If it does not have a string, just moves the value into the return\n// results.\nparser.fromPathsOrPathValues = function(paths, ext) {\n    if (!paths) {\n        return [];\n    }\n\n    var out = [];\n    for (var i = 0, len = paths.length; i < len; i++) {\n\n        // Is the path a string\n        if (typeof paths[i] === 'string') {\n            out[i] = parser(paths[i], ext);\n        }\n\n        // is the path a path value with a string value.\n        else if (typeof paths[i].path === 'string') {\n            out[i] = {\n                path: parser(paths[i].path, ext), value: paths[i].value\n            };\n        }\n\n        // just copy it over.\n        else {\n            out[i] = paths[i];\n        }\n    }\n\n    return out;\n};\n\n// If the argument is a string, this with convert, else just return\n// the path provided.\nparser.fromPath = function(path, ext) {\n    if (!path) {\n        return [];\n    }\n\n    if (typeof path === 'string') {\n        return parser(path, ext);\n    }\n\n    return path;\n};\n\n// Potential routed tokens.\nparser.RoutedTokens = RoutedTokens;\n\nvar ModelResponse$6 = ModelResponse_1;\nvar InvalidSourceError$2 = InvalidSourceError_1;\n\nvar pathSyntax$5 = src$1;\n\n/**\n * @private\n * @augments ModelResponse\n */\nfunction CallResponse$1(model, callPath, args, suffix, paths) {\n    this.callPath = pathSyntax$5.fromPath(callPath);\n    this.args = args;\n\n    if (paths) {\n        this.paths = paths.map(pathSyntax$5.fromPath);\n    }\n    if (suffix) {\n        this.suffix = suffix.map(pathSyntax$5.fromPath);\n    }\n    this.model = model;\n}\n\nCallResponse$1.prototype = Object.create(ModelResponse$6.prototype);\nCallResponse$1.prototype._subscribe = function _subscribe(observer) {\n    var callPath = this.callPath;\n    var callArgs = this.args;\n    var suffixes = this.suffix;\n    var extraPaths = this.paths;\n    var model = this.model;\n    var rootModel = model._clone({\n        _path: []\n    });\n    var boundPath = model._path;\n    var boundCallPath = boundPath.concat(callPath);\n\n    /* eslint-disable consistent-return */\n    // Precisely the same error as the router when a call function does not\n    // exist.\n    if (!model._source) {\n        observer.onError(new Error(\"function does not exist\"));\n        return;\n    }\n\n\n    var response, obs;\n    try {\n        obs = model._source.\n            call(boundCallPath, callArgs, suffixes, extraPaths);\n    } catch (e) {\n        observer.onError(new InvalidSourceError$2(e));\n        return;\n    }\n\n    return obs.\n        subscribe(function(res) {\n            response = res;\n        }, function(err) {\n            observer.onError(err);\n        }, function() {\n\n            // Run the invalidations first then the follow up JSONGraph set.\n            var invalidations = response.invalidated;\n            if (invalidations && invalidations.length) {\n                rootModel.invalidate.apply(rootModel, invalidations);\n            }\n\n            // The set\n            rootModel.\n                withoutDataSource().\n                set(response).subscribe(function(x) {\n                    observer.onNext(x);\n                }, function(err) {\n                    observer.onError(err);\n                }, function() {\n                    observer.onCompleted();\n                });\n        });\n    /* eslint-enable consistent-return */\n};\n\nvar CallResponse_1 = CallResponse$1;\n\nvar isArray$5 = Array.isArray;\nvar isObject$4 = isObject$f;\n\nvar isPathValue$3 = function isPathValue(pathValue) {\n    return isObject$4(pathValue) && (\n        isArray$5(pathValue.path) || (\n            typeof pathValue.path === \"string\"\n        ));\n};\n\nvar isObject$3 = isObject$f;\n\nvar isJSONEnvelope$4 = function isJSONEnvelope(envelope) {\n    return isObject$3(envelope) && (\"json\" in envelope);\n};\n\nvar isArray$4 = Array.isArray;\nvar ModelResponse$5 = ModelResponse_1;\nvar isPathValue$2 = isPathValue$3;\nvar isJSONEnvelope$3 = isJSONEnvelope$4;\nvar empty$2 = {dispose: function() {}};\n\nfunction InvalidateResponse$1(model, args) {\n    // TODO: This should be removed.  There should only be 1 type of arguments\n    // coming in, but we have strayed from documentation.\n    this._model = model;\n\n    var groups = [];\n    var group, groupType;\n    var argIndex = -1;\n    var argCount = args.length;\n\n    // Validation of arguments have been moved out of this function.\n    while (++argIndex < argCount) {\n        var arg = args[argIndex];\n        var argType;\n        if (isArray$4(arg)) {\n            argType = \"PathValues\";\n        } else if (isPathValue$2(arg)) {\n            argType = \"PathValues\";\n        } else if (isJSONEnvelope$3(arg)) {\n            argType = \"PathMaps\";\n        } else {\n            throw new Error(\"Invalid Input\");\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            group = {\n                inputType: argType,\n                arguments: []\n            };\n            groups.push(group);\n        }\n\n        group.arguments.push(arg);\n    }\n\n    this._groups = groups;\n}\n\nInvalidateResponse$1.prototype = Object.create(ModelResponse$5.prototype);\nInvalidateResponse$1.prototype.progressively = function progressively() {\n    return this;\n};\nInvalidateResponse$1.prototype._toJSONG = function _toJSONG() {\n    return this;\n};\n\nInvalidateResponse$1.prototype._subscribe = function _subscribe(observer) {\n\n    var model = this._model;\n    this._groups.forEach(function(group) {\n        var inputType = group.inputType;\n        var methodArgs = group.arguments;\n        var operationName = \"_invalidate\" + inputType;\n        var operationFunc = model[operationName];\n        operationFunc(model, methodArgs);\n    });\n    observer.onCompleted();\n\n    return empty$2;\n};\n\nvar InvalidateResponse_1 = InvalidateResponse$1;\n\nfunction TimeoutScheduler$1(delay) {\n    this.delay = delay;\n}\n\nvar TimerDisposable = function TimerDisposable(id) {\n    this.id = id;\n    this.disposed = false;\n};\n\nTimeoutScheduler$1.prototype.schedule = function schedule(action) {\n    var id = setTimeout(action, this.delay);\n    return new TimerDisposable(id);\n};\n\nTimeoutScheduler$1.prototype.scheduleWithState = function scheduleWithState(state, action) {\n    var self = this;\n    var id = setTimeout(function() {\n        action(self, state);\n    }, this.delay);\n    return new TimerDisposable(id);\n};\n\nTimerDisposable.prototype.dispose = function() {\n    if (this.disposed) {\n        return;\n    }\n\n    clearTimeout(this.id);\n    this.disposed = true;\n};\n\nvar TimeoutScheduler_1 = TimeoutScheduler$1;\n\nvar empty$1 = {dispose: function() {}};\n\nfunction ImmediateScheduler$1() {}\n\nImmediateScheduler$1.prototype.schedule = function schedule(action) {\n    action();\n    return empty$1;\n};\n\nImmediateScheduler$1.prototype.scheduleWithState = function scheduleWithState(state, action) {\n    action(this, state);\n    return empty$1;\n};\n\nvar ImmediateScheduler_1 = ImmediateScheduler$1;\n\nvar removeNode = removeNode$2;\nvar updateNodeAncestors = updateNodeAncestors$3;\n\nvar collect = function collect(lru, expired, totalArg, max, ratioArg, version) {\n\n    var total = totalArg;\n    var ratio = ratioArg;\n\n    if (typeof ratio !== \"number\") {\n        ratio = 0.75;\n    }\n\n    var shouldUpdate = typeof version === \"number\";\n    var targetSize = max * ratio;\n    var parent, node, size;\n\n    node = expired.pop();\n\n    while (node) {\n        size = node.$size || 0;\n        total -= size;\n        if (shouldUpdate === true) {\n            updateNodeAncestors(node, size, lru, version);\n            // eslint-disable-next-line camelcase\n        } else if (parent = node.$_parent) { // eslint-disable-line no-cond-assign\n            // eslint-disable-next-line camelcase\n            removeNode(node, parent, node.$_key, lru);\n        }\n        node = expired.pop();\n    }\n\n    if (total >= max) {\n        // eslint-disable-next-line camelcase\n        var prev = lru.$_tail;\n        node = prev;\n        while ((total >= targetSize) && node) {\n            // eslint-disable-next-line camelcase\n            prev = prev.$_prev;\n            size = node.$size || 0;\n            total -= size;\n            if (shouldUpdate === true) {\n                updateNodeAncestors(node, size, lru, version);\n            }\n            node = prev;\n        }\n\n        // eslint-disable-next-line camelcase\n        lru.$_tail = lru.$_prev = node;\n        if (node == null) {\n            // eslint-disable-next-line camelcase\n            lru.$_head = lru.$_next = undefined;\n        } else {\n            // eslint-disable-next-line camelcase\n            node.$_next = undefined;\n        }\n    }\n};\n\nvar isArray$3 = Array.isArray;\nvar isObject$2 = isObject$f;\n\nvar isJSONGraphEnvelope$3 = function isJSONGraphEnvelope(envelope) {\n    return isObject$2(envelope) && isArray$3(envelope.paths) && (\n        isObject$2(envelope.jsonGraph) ||\n        isObject$2(envelope.jsong) ||\n        isObject$2(envelope.json) ||\n        isObject$2(envelope.values) ||\n        isObject$2(envelope.value)\n    );\n};\n\nvar createHardlink = createHardlink$2;\nvar __prefix = reservedPrefix$1;\nvar $ref$1 = ref;\n\nvar getBoundValue = requireGetBoundValue();\n\nvar isArray$2 = Array.isArray;\nvar hasOwn = hasOwn_1;\nvar isObject$1 = isObject$f;\nvar isExpired$2 = isExpired$7;\nvar isFunction = isFunction$5;\nvar isPrimitive$1 = isPrimitive$4;\nvar expireNode$1 = expireNode$5;\nvar incrementVersion = incrementVersionExports;\nvar mergeValueOrInsertBranch = mergeValueOrInsertBranch$1;\nvar NullInPathError = NullInPathError_1;\n\n/**\n * Sets a list of {@link PathMapEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of {@link PathMapEnvelope}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nvar setPathMaps = function setPathMaps(model, pathMapEnvelopes, x, errorSelector, comparator) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = incrementVersion();\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = bound.length ? getBoundValue(model, bound).value : cache;\n    var parent = node.$_parent || cache;\n    var initialVersion = cache.$_version;\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathMap(\n            pathMapEnvelope.json, 0, cache, parent, node,\n            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n    }\n\n    var newVersion = cache.$_version;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathMap(\n    pathMap, depth, root, parent, node,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var keys = getKeys(pathMap);\n\n    if (keys && keys.length) {\n\n        var keyIndex = 0;\n        var keyCount = keys.length;\n        var optimizedIndex = optimizedPath.index;\n\n        do {\n            var key = keys[keyIndex];\n            var child = pathMap[key];\n            var branch = isObject$1(child) && !child.$type;\n\n            requestedPath.depth = depth;\n\n            var results = setNode(\n                root, parent, node, key, child,\n                branch, false, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector\n            );\n\n            requestedPath[depth] = key;\n            requestedPath.index = depth;\n\n            optimizedPath[optimizedPath.index++] = key;\n            var nextNode = results[0];\n            var nextParent = results[1];\n            if (nextNode) {\n                if (branch) {\n                    setPathMap(\n                        child, depth + 1,\n                        root, nextParent, nextNode,\n                        requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                        version, expired, lru, comparator, errorSelector\n                    );\n                } else {\n                    requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                    optimizedPaths.push(optimizedPath.slice(0, optimizedPath.index));\n                }\n            }\n            if (++keyIndex >= keyCount) {\n                break;\n            }\n            optimizedPath.index = optimizedIndex;\n        } while (true);\n    }\n}\n/* eslint-enable */\n\nfunction setReference(\n    value, root, node, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var reference = node.value;\n    optimizedPath.length = 0;\n    optimizedPath.push.apply(optimizedPath, reference);\n\n    if (isExpired$2(node)) {\n        optimizedPath.index = reference.length;\n        expireNode$1(node, expired, lru);\n        return [undefined, root];\n    }\n\n    var container = node;\n    var parent = root;\n\n    node = node.$_context;\n\n    if (node != null) {\n        parent = node.$_parent || root;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n        optimizedPath.index = index;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = setNode(\n                root, parent, node, key, value,\n                branch, true, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector\n            );\n            node = results[0];\n            if (isPrimitive$1(node)) {\n                optimizedPath.index = index;\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        optimizedPath.index = index;\n\n        if (container.$_context !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction setNode(\n    root, parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var type = node.$type;\n\n    while (type === $ref$1) {\n\n        var results = setReference(\n            value, root, node, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector);\n\n        node = results[0];\n\n        if (isPrimitive$1(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        type = node && node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new NullInPathError();\n        } else if (node) {\n            key = node.$_key;\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    node = mergeValueOrInsertBranch(\n        parent, node, key, value,\n        branch, reference, requestedPath, optimizedPath,\n        version, expired, lru, comparator, errorSelector\n    );\n\n    return [node, parent];\n}\n\nfunction getKeys(pathMap) {\n\n    if (isObject$1(pathMap) && !pathMap.$type) {\n        var keys = [];\n        var itr = 0;\n        if (isArray$2(pathMap)) {\n            keys[itr++] = \"length\";\n        }\n        for (var key in pathMap) {\n            if (key[0] === __prefix || !hasOwn(pathMap, key)) {\n                continue;\n            }\n            keys[itr++] = key;\n        }\n        return keys;\n    }\n\n    return void 0;\n}\n\nvar pathSyntax$4 = src$1;\n\nfunction sentinel(type, value, props) {\n    var copy = Object.create(null);\n    if (props != null) {\n        for(var key in props) {\n            copy[key] = props[key];\n        }\n        \n        copy[\"$type\"] = type;\n        copy.value = value;\n        return copy;\n    }\n    else {\n        return { $type: type, value: value };\n    }    \n}\n\nvar src = {\n    ref: function ref(path, props) {\n        return sentinel(\"ref\", pathSyntax$4.fromPath(path), props);\n    },\n    atom: function atom(value, props) {\n        return sentinel(\"atom\", value, props);        \n    },\n    undefined: function() {\n        return sentinel(\"atom\");\n    },    \n    error: function error(errorValue, props) {\n        return sentinel(\"error\", errorValue, props);        \n    },\n    pathValue: function pathValue(path, value) {\n        return { path: pathSyntax$4.fromPath(path), value: value };\n    },\n    pathInvalidation: function pathInvalidation(path) {\n        return { path: pathSyntax$4.fromPath(path), invalidated: true };\n    }    \n};\n\nvar isArray$1 = Array.isArray;\nvar isPathValue$1 = isPathValue$3;\nvar isJSONGraphEnvelope$2 = isJSONGraphEnvelope$3;\nvar isJSONEnvelope$2 = isJSONEnvelope$4;\nvar pathSyntax$3 = src$1;\n\n/**\n *\n * @param {Object} allowedInput - allowedInput is a map of input styles\n * that are allowed\n * @private\n */\nvar validateInput$3 = function validateInput(args, allowedInput, method) {\n    for (var i = 0, len = args.length; i < len; ++i) {\n        var arg = args[i];\n        var valid = false;\n\n        // Path\n        if (isArray$1(arg) && allowedInput.path) {\n            valid = true;\n        }\n\n        // Path Syntax\n        else if (typeof arg === \"string\" && allowedInput.pathSyntax) {\n            try {\n                pathSyntax$3.fromPath(arg);\n                valid = true;\n            } catch (errorMessage) {\n                return new Error(\"Path syntax validation error -- \" + errorMessage);\n            }\n        }\n\n        // Path Value\n        else if (isPathValue$1(arg) && allowedInput.pathValue) {\n            try {\n                arg.path = pathSyntax$3.fromPath(arg.path);\n                valid = true;\n            } catch (errorMessage) {\n                return new Error(\"Path syntax validation error -- \" + errorMessage);\n            }\n        }\n\n        // jsonGraph {jsonGraph: { ... }, paths: [ ... ]}\n        else if (isJSONGraphEnvelope$2(arg) && allowedInput.jsonGraph) {\n            valid = true;\n        }\n\n        // json env {json: {...}}\n        else if (isJSONEnvelope$2(arg) && allowedInput.json) {\n            valid = true;\n        }\n\n        // selector functions\n        else if (typeof arg === \"function\" &&\n                 i + 1 === len &&\n                 allowedInput.selector) {\n            valid = true;\n        }\n\n        if (!valid) {\n            return new Error(\"Unrecognized argument \" + (typeof arg) + \" [\" + String(arg) + \"] \" + \"to Model#\" + method + \"\");\n        }\n    }\n    return true;\n};\n\nvar privatePrefix = privatePrefix$2;\n\n/**\n * Determined if the key passed in is an internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\nvar isInternalKey$1 = function isInternalKey(x) {\n    return x === \"$size\" || x.lastIndexOf(privatePrefix, 0) === 0;\n};\n\nvar isInternalKey = isInternalKey$1;\n\n/**\n * decends and copies the cache.\n */\nvar getCache$1 = function getCache(cache) {\n    var out = {};\n    _copyCache(cache, out);\n\n    return out;\n};\n\nfunction cloneBoxedValue(boxedValue) {\n    var clonedValue = {};\n\n    var keys = Object.keys(boxedValue);\n    var key;\n    var i;\n    var l;\n\n    for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n\n        if (!isInternalKey(key)) {\n            clonedValue[key] = boxedValue[key];\n        }\n    }\n\n    return clonedValue;\n}\n\nfunction _copyCache(node, out, fromKey) {\n    // copy and return\n\n    Object.\n        keys(node).\n        filter(function(k) {\n            // Its not an internal key and the node has a value.  In the cache\n            // there are 3 possibilities for values.\n            // 1: A branch node.\n            // 2: A $type-value node.\n            // 3: undefined\n            // We will strip out 3\n            return !isInternalKey(k) && node[k] !== undefined;\n        }).\n        forEach(function(key) {\n            var cacheNext = node[key];\n            var outNext = out[key];\n\n            if (!outNext) {\n                outNext = out[key] = {};\n            }\n\n            // Paste the node into the out cache.\n            if (cacheNext.$type) {\n                var isObject = cacheNext.value && typeof cacheNext.value === \"object\";\n                var isUserCreatedcacheNext = !cacheNext.$_modelCreated;\n                var value;\n                if (isObject || isUserCreatedcacheNext) {\n                    value = cloneBoxedValue(cacheNext);\n                } else {\n                    value = cacheNext.value;\n                }\n\n                out[key] = value;\n                return;\n            }\n\n            _copyCache(cacheNext, outNext);\n        });\n}\n\n/**\n * getCachePosition makes a fast walk to the bound value since all bound\n * paths are the most possible optimized path.\n *\n * @param {Model} model -\n * @param {Array} path -\n * @returns {Mixed} - undefined if there is nothing in this position.\n * @private\n */\n\nvar getCachePosition$1;\nvar hasRequiredGetCachePosition;\n\nfunction requireGetCachePosition () {\n\tif (hasRequiredGetCachePosition) return getCachePosition$1;\n\thasRequiredGetCachePosition = 1;\n\tgetCachePosition$1 = function getCachePosition(model, path) {\n\t    var currentCachePosition = model._root.cache;\n\t    var depth = -1;\n\t    var maxDepth = path.length;\n\n\t    // The loop is simple now, we follow the current cache position until\n\t    //\n\t    while (++depth < maxDepth &&\n\t           currentCachePosition && !currentCachePosition.$type) {\n\n\t        currentCachePosition = currentCachePosition[path[depth]];\n\t    }\n\n\t    return currentCachePosition;\n\t};\n\treturn getCachePosition$1;\n}\n\nvar applyErrorPrototype$1 = applyErrorPrototype_1;\n\n/**\n * When a bound model attempts to retrieve JSONGraph it should throw an\n * error.\n *\n * @private\n */\nfunction BoundJSONGraphModelError$1() {\n    var instance = new Error(\"It is not legal to use the JSON Graph \" +\n    \"format from a bound Model. JSON Graph format\" +\n    \" can only be used from a root model.\");\n\n    instance.name = \"BoundJSONGraphModelError\";\n\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    }\n\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(instance, BoundJSONGraphModelError$1);\n    }\n\n    return instance;\n}\n\napplyErrorPrototype$1(BoundJSONGraphModelError$1);\n\nvar BoundJSONGraphModelError_1 = BoundJSONGraphModelError$1;\n\nvar getCachePosition = requireGetCachePosition();\nvar InvalidModelError = requireInvalidModelError();\nvar BoundJSONGraphModelError = BoundJSONGraphModelError_1;\n\nfunction mergeInto(target, obj) {\n    /* eslint guard-for-in: 0 */\n    if (target === obj) {\n        return;\n    }\n    if (target === null || typeof target !== \"object\" || target.$type) {\n        return;\n    }\n    if (obj === null || typeof obj !== \"object\" || obj.$type) {\n        return;\n    }\n\n    for (var key in obj) {\n        // When merging over a temporary branch structure (for example, as produced by an error selector)\n        // with references, we don't want to mutate the path, particularly because it's also $_absolutePath\n        // on cache nodes\n        if (key === \"$__path\") {\n            continue;\n        }\n\n        var targetValue = target[key];\n        if (targetValue === undefined) {\n            target[key] = obj[key];\n        } else {\n            mergeInto(targetValue, obj[key]);\n        }\n    }\n}\n\nfunction defaultEnvelope(isJSONG) {\n    return isJSONG ? {jsonGraph: {}, paths: []} : {json: {}};\n}\n\nvar get$3 = function get(walk, isJSONG) {\n    return function innerGet(model, paths, seed) {\n        // Result valueNode not immutable for isJSONG.\n        var nextSeed = isJSONG ? seed : [{}];\n        var valueNode = nextSeed[0];\n        var results = {\n            values: nextSeed,\n            optimizedPaths: []\n        };\n        var cache = model._root.cache;\n        var boundPath = model._path;\n        var currentCachePosition = cache;\n        var optimizedPath, optimizedLength;\n        var i, len;\n        var requestedPath = [];\n        var derefInfo = [];\n        var referenceContainer;\n\n        // If the model is bound, then get that cache position.\n        if (boundPath.length) {\n\n            // JSONGraph output cannot ever be bound or else it will\n            // throw an error.\n            if (isJSONG) {\n                return {\n                    criticalError: new BoundJSONGraphModelError()\n                };\n            }\n\n            // using _getOptimizedPath because that's a point of extension\n            // for polyfilling legacy falcor\n            optimizedPath = model._getOptimizedBoundPath();\n            optimizedLength = optimizedPath.length;\n\n            // We need to get the new cache position path.\n            currentCachePosition = getCachePosition(model, optimizedPath);\n\n            // If there was a short, then we 'throw an error' to the outside\n            // calling function which will onError the observer.\n            if (currentCachePosition && currentCachePosition.$type) {\n                return {\n                    criticalError: new InvalidModelError(boundPath, optimizedPath)\n                };\n            }\n\n            referenceContainer = model._referenceContainer;\n        }\n\n        // Update the optimized path if we\n        else {\n            optimizedPath = [];\n            optimizedLength = 0;\n        }\n\n        for (i = 0, len = paths.length; i < len; i++) {\n            walk(model, cache, currentCachePosition, paths[i], 0,\n                 valueNode, results, derefInfo, requestedPath, optimizedPath,\n                 optimizedLength, isJSONG, false, referenceContainer);\n        }\n\n        // Merge in existing results.\n        // Default to empty envelope if no results were emitted\n        mergeInto(valueNode, paths.length ? seed[0] : defaultEnvelope(isJSONG));\n\n        return results;\n    };\n};\n\nvar promote$1 = requirePromote();\nvar clone = requireClone();\n\nvar onError$1 = function onError(model, node, depth,\n                                  requestedPath, outerResults) {\n    var value = node.value;\n    if (!outerResults.errors) {\n        outerResults.errors = [];\n    }\n\n    if (model._boxed) {\n        value = clone(node);\n    }\n    outerResults.errors.push({\n        path: requestedPath.slice(0, depth),\n        value: value\n    });\n    promote$1(model._root, node);\n};\n\nvar onMissing$1 = function onMissing(model, path, depth,\n                                    outerResults, requestedPath,\n                                    optimizedPath, optimizedLength) {\n    var pathSlice;\n    if (!outerResults.requestedMissingPaths) {\n        outerResults.requestedMissingPaths = [];\n        outerResults.optimizedMissingPaths = [];\n    }\n\n    if (depth < path.length) {\n        // If part of path has not been traversed, we need to ensure that there\n        // are no empty paths (range(1, 0) or empyt array)\n        var isEmpty = false;\n        for (var i = depth; i < path.length && !isEmpty; ++i) {\n            if (isEmptyAtom(path[i])) {\n                return;\n            }\n        }\n\n        pathSlice = path.slice(depth);\n    } else {\n        pathSlice = [];\n    }\n\n    concatAndInsertMissing(model, pathSlice, depth, requestedPath,\n                           optimizedPath, optimizedLength, outerResults);\n};\n\nfunction concatAndInsertMissing(model, remainingPath, depth, requestedPath,\n                                optimizedPath, optimizedLength, results) {\n    var requested = requestedPath.slice(0, depth);\n    Array.prototype.push.apply(requested, remainingPath);\n    results.requestedMissingPaths[results.requestedMissingPaths.length] = requested;\n\n    var optimized = optimizedPath.slice(0, optimizedLength);\n    Array.prototype.push.apply(optimized, remainingPath);\n    results.optimizedMissingPaths[results.optimizedMissingPaths.length] = optimized;\n}\n\nfunction isEmptyAtom(atom) {\n    if (atom === null || typeof atom !== \"object\") {\n        return false;\n    }\n\n    var isArray = Array.isArray(atom);\n    if (isArray && atom.length) {\n        return false;\n    }\n\n    // Empty array\n    else if (isArray) {\n        return true;\n    }\n\n    var from = atom.from;\n    var to = atom.to;\n    if (from === undefined || from <= to) {\n        return false;\n    }\n\n    return true;\n}\n\nvar isMaterialzed = function isMaterialized(model) {\n    return model._materialized && !model._source;\n};\n\nvar isExpired$1 = requireIsExpired();\nvar $error = error;\nvar onError = onError$1;\nvar onValue$1 = onValue$2;\nvar onMissing = onMissing$1;\nvar isMaterialized = isMaterialzed;\nvar expireNode = expireNode$5;\nvar currentCacheVersion = currentCacheVersion$2;\n\n\n/**\n * When we land on a valueType (or nothing) then we need to report it out to\n * the outerResults through errors, missing, or values.\n *\n * @private\n */\nvar onValueType$1 = function onValueType(\n    model, node, path, depth, seed, outerResults, branchInfo,\n    requestedPath, optimizedPath, optimizedLength, isJSONG, fromReference) {\n\n    var currType = node && node.$type;\n\n    // There are is nothing here, ether report value, or report the value\n    // that is missing.  If there is no type then report the missing value.\n    if (!node || !currType) {\n        var materialized = isMaterialized(model);\n        if (materialized || !isJSONG) {\n            onValue$1(model, node, seed, depth, outerResults, branchInfo,\n                    requestedPath, optimizedPath, optimizedLength,\n                    isJSONG);\n        }\n\n        if (!materialized) {\n            onMissing(model, path, depth,\n                      outerResults, requestedPath,\n                      optimizedPath, optimizedLength);\n        }\n        return;\n    }\n\n    // If there are expired value, then report it as missing\n    else if (isExpired$1(node) &&\n        !(node.$_version === currentCacheVersion.getVersion() &&\n            node.$expires === 0)) {\n        if (!node.$_invalidated) {\n            expireNode(node, model._root.expired, model._root);\n        }\n        onMissing(model, path, depth,\n                  outerResults, requestedPath,\n                  optimizedPath, optimizedLength);\n    }\n\n    // If there is an error, then report it as a value if\n    else if (currType === $error) {\n        if (fromReference) {\n            requestedPath[depth] = null;\n            depth += 1;\n        }\n        if (isJSONG || model._treatErrorsAsValues) {\n            onValue$1(model, node, seed, depth, outerResults, branchInfo,\n                    requestedPath, optimizedPath, optimizedLength,\n                    isJSONG);\n        } else {\n            onValue$1(model, undefined, seed, depth, outerResults, branchInfo,\n                    requestedPath, optimizedPath, optimizedLength,\n                    isJSONG);\n            onError(model, node, depth, requestedPath, outerResults);\n        }\n    }\n\n    // Report the value\n    else {\n        if (fromReference) {\n            requestedPath[depth] = null;\n            depth += 1;\n        }\n        onValue$1(model, node, seed, depth, outerResults, branchInfo,\n                requestedPath, optimizedPath, optimizedLength, isJSONG);\n    }\n};\n\nvar followReference = requireFollowReference();\nvar onValueType = onValueType$1;\nvar onValue = onValue$2;\nvar isExpired = requireIsExpired();\nvar iterateKeySet = lib$1.iterateKeySet;\nvar $ref = ref;\nvar promote = requirePromote();\n\nvar walkPath$1 = function walkPath(model, root, curr, path, depth, seed,\n                                   outerResults, branchInfo, requestedPath,\n                                   optimizedPathArg, optimizedLength, isJSONG,\n                                   fromReferenceArg, referenceContainerArg) {\n\n    var fromReference = fromReferenceArg;\n    var optimizedPath = optimizedPathArg;\n    var referenceContainer = referenceContainerArg;\n\n    // The walk is finished when:\n    // - there is no value in the current cache position\n    // - there is a JSONG leaf node in the current cache position\n    // - we've reached the end of the path\n    if (!curr || curr.$type || depth === path.length) {\n        onValueType(model, curr, path, depth, seed, outerResults, branchInfo,\n                requestedPath, optimizedPath, optimizedLength,\n                isJSONG, fromReference);\n        return;\n    }\n\n    var keySet = path[depth];\n    var isKeySet = keySet !== null && typeof keySet === \"object\";\n    var iteratorNote = false;\n    var key = keySet;\n\n    if (isKeySet) {\n        iteratorNote = {};\n        key = iterateKeySet(keySet, iteratorNote);\n    }\n\n    var allowFromWhenceYouCame = model._allowFromWhenceYouCame;\n    var optimizedLengthPlus1 = optimizedLength + 1;\n    var nextDepth = depth + 1;\n    var refPath;\n\n    // loop over every key in the key set\n    do {\n        if (key == null) {\n            // Skip null/undefined/empty keysets in path and do not descend,\n            // but capture the partial path in the result\n            onValue(model, curr, seed, depth, outerResults, branchInfo,\n                    requestedPath, optimizedPath, optimizedLength, isJSONG);\n\n            if (iteratorNote && !iteratorNote.done) {\n                key = iterateKeySet(keySet, iteratorNote);\n            }\n\n            continue;\n        }\n\n        fromReference = false;\n        optimizedPath[optimizedLength] = key;\n        requestedPath[depth] = key;\n\n        var next = curr[key];\n        var nextOptimizedPath = optimizedPath;\n        var nextOptimizedLength = optimizedLengthPlus1;\n\n        // If there is the next position we need to consider references.\n        if (next) {\n            var nType = next.$type;\n            var value = nType && next.value || next;\n\n            // If next is a reference follow it.  If we are in JSONG mode,\n            // report that value into the seed without passing the requested\n            // path.  If a requested path is passed to onValueType then it\n            // will add that path to the JSONGraph envelope under `paths`\n            if (nextDepth < path.length && nType &&\n                nType === $ref && !isExpired(next)) {\n\n                // promote the node so that the references don't get cleaned up.\n                promote(model._root, next);\n\n                if (isJSONG) {\n                    onValue(model, next, seed, nextDepth, outerResults, null,\n                            null, optimizedPath, nextOptimizedLength, isJSONG);\n                }\n\n                var ref = followReference(model, root, root, next,\n                                          value, seed, isJSONG);\n                fromReference = true;\n                next = ref[0];\n                refPath = ref[1];\n                referenceContainer = ref[2];\n                nextOptimizedPath = refPath.slice();\n                nextOptimizedLength = refPath.length;\n            }\n\n            // The next can be set to undefined by following a reference that\n            // does not exist.\n            if (next) {\n                var obj;\n\n                // There was a reference container.\n                if (referenceContainer && allowFromWhenceYouCame) {\n                    obj = {\n                        // eslint-disable-next-line camelcase\n                        $__path: next.$_absolutePath,\n                        // eslint-disable-next-line camelcase\n                        $__refPath: referenceContainer.value,\n                        // eslint-disable-next-line camelcase\n                        $__toReference: referenceContainer.$_absolutePath\n                    };\n                }\n\n                // There is no reference container meaning this request was\n                // neither from a model and/or the first n (depth) keys do not\n                // contain references.\n                else {\n                    obj = {\n                        // eslint-disable-next-line camelcase\n                        $__path: next.$_absolutePath\n                    };\n                }\n\n                branchInfo[depth] = obj;\n            }\n        }\n\n        // Recurse to the next level.\n        walkPath(model, root, next, path, nextDepth, seed, outerResults,\n                 branchInfo, requestedPath, nextOptimizedPath,\n                 nextOptimizedLength, isJSONG,\n                 fromReference, referenceContainer);\n\n        // If the iteratorNote is not done, get the next key.\n        if (iteratorNote && !iteratorNote.done) {\n            key = iterateKeySet(keySet, iteratorNote);\n        }\n    } while (iteratorNote && !iteratorNote.done);\n};\n\nvar get$2 = get$3;\nvar walkPath = walkPath$1;\n\nvar getWithPathsAsPathMap$2 = get$2(walkPath, false);\nvar getWithPathsAsJSONGraph$1 = get$2(walkPath, true);\n\nvar get_1 = {\n    getValueSync: requireGetValueSync(),\n    getBoundValue: requireGetBoundValue(),\n    getWithPathsAsPathMap: getWithPathsAsPathMap$2,\n    getWithPathsAsJSONGraph: getWithPathsAsJSONGraph$1\n};\n\nvar validInput = {\n    path: true,\n    pathSyntax: true\n};\n\nvar gets = get_1;\nvar getWithPathsAsJSONGraph = gets.getWithPathsAsJSONGraph;\nvar getWithPathsAsPathMap$1 = gets.getWithPathsAsPathMap;\n\n/**\n * Checks cache for the paths and reports if in progressive mode.  If\n * there are missing paths then return the cache hit results.\n *\n * Return value (`results`) stores missing path information as 3 index-linked arrays:\n * `requestedMissingPaths` holds requested paths that were not found in cache\n * `optimizedMissingPaths` holds optimized versions of requested paths\n *\n * Note that requestedMissingPaths is not necessarily the list of paths requested by\n * user in model.get. It does not contain those paths that were found in\n * cache. It also breaks some path sets out into separate paths, those which\n * resolve to different optimized lengths after walking through any references in\n * cache.\n * This helps maintain a 1:1 correspondence between requested and optimized missing,\n * as well as their depth differences (or, length offsets).\n *\n * Example: Given cache: `{ lolomo: { 0: $ref('vid'), 1: $ref('a.b.c.d') }}`,\n * `model.get('lolomo[0..2].name').subscribe()` will result in the following\n * corresponding values:\n *    index   requestedMissingPaths   optimizedMissingPaths\n *      0     ['lolomo', 0, 'name']   ['vid', 'name']\n *      1     ['lolomo', 1, 'name']   ['a', 'b', 'c', 'd', 'name']\n *      2     ['lolomo', 2, 'name']   ['lolomo', 2, 'name']\n *\n * @param {Model} model - The model that the request was made with.\n * @param {Array} requestedMissingPaths -\n * @param {Boolean} progressive -\n * @param {Boolean} isJSONG -\n * @param {Function} onNext -\n * @param {Function} onError -\n * @param {Function} onCompleted -\n * @param {Object} seed - The state of the output\n * @returns {Object} results -\n *\n * @private\n */\nvar checkCacheAndReport$2 = function checkCacheAndReport(model, requestedPaths, observer,\n                                              progressive, isJSONG, seed,\n                                              errors) {\n\n    // checks the cache for the data.\n    var results = isJSONG ? getWithPathsAsJSONGraph(model, requestedPaths, seed)\n                          : getWithPathsAsPathMap$1(model, requestedPaths, seed);\n\n    // We are done when there are no missing paths or the model does not\n    // have a dataSource to continue on fetching from.\n    var valueNode = results.values && results.values[0];\n    var completed = !results.requestedMissingPaths ||\n                    !results.requestedMissingPaths.length ||\n                    !model._source;\n\n    // Copy the errors into the total errors array.\n    if (results.errors) {\n        var errs = results.errors;\n        var errorsLength = errors.length;\n        for (var i = 0, len = errs.length; i < len; ++i, ++errorsLength) {\n            errors[errorsLength] = errs[i];\n        }\n    }\n\n    // Report locally available values if:\n    // - the request is in progressive mode, or\n    // - the request is complete and values were found\n    if (progressive || (completed && valueNode !== undefined)) {\n        observer.onNext(valueNode);\n    }\n\n    // We must communicate critical errors from get that are critical\n    // errors such as bound path is broken or this is a JSONGraph request\n    // with a bound path.\n    if (results.criticalError) {\n        observer.onError(results.criticalError);\n        return null;\n    }\n\n    // if there are missing paths, then lets return them.\n    if (completed) {\n        if (errors.length) {\n            observer.onError(errors);\n        } else {\n            observer.onCompleted();\n        }\n\n        return null;\n    }\n\n    // Return the results object.\n    return results;\n};\n\nvar applyErrorPrototype = applyErrorPrototype_1;\n\n/**\n * A request can only be retried up to a specified limit.  Once that\n * limit is exceeded, then an error will be thrown.\n *\n * @param {*} missingOptimizedPaths\n *\n * @private\n */\nfunction MaxRetryExceededError$2(missingOptimizedPaths) {\n    var instance = new Error(\"The allowed number of retries have been exceeded.\");\n\n    instance.name = \"MaxRetryExceededError\";\n    instance.missingOptimizedPaths = missingOptimizedPaths || [];\n\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    }\n\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(instance, MaxRetryExceededError$2);\n    }\n\n    return instance;\n}\n\napplyErrorPrototype(MaxRetryExceededError$2);\n\nMaxRetryExceededError$2.is = function(e) {\n    return e && e.name === \"MaxRetryExceededError\";\n};\n\nvar MaxRetryExceededError_1 = MaxRetryExceededError$2;\n\n/**\n * Will allow for state tracking of the current disposable.  Also fulfills the\n * disposable interface.\n * @private\n */\n\nvar AssignableDisposable$2 = function AssignableDisposable(disosableCallback) {\n    this.disposed = false;\n    this.currentDisposable = disosableCallback;\n};\n\n\nAssignableDisposable$2.prototype = {\n\n    /**\n     * Disposes of the current disposable.  This would be the getRequestCycle\n     * disposable.\n     */\n    dispose: function dispose() {\n        if (this.disposed || !this.currentDisposable) {\n            return;\n        }\n        this.disposed = true;\n\n        // If the current disposable fulfills the disposable interface or just\n        // a disposable function.\n        var currentDisposable = this.currentDisposable;\n        if (currentDisposable.dispose) {\n            currentDisposable.dispose();\n        }\n\n        else {\n            currentDisposable();\n        }\n    }\n};\n\n\nvar AssignableDisposable_1 = AssignableDisposable$2;\n\nvar checkCacheAndReport$1 = checkCacheAndReport$2;\nvar MaxRetryExceededError$1 = MaxRetryExceededError_1;\nvar collectLru$2 = collect;\nvar getSize$2 = getSize$6;\nvar AssignableDisposable$1 = AssignableDisposable_1;\nvar InvalidSourceError$1 = InvalidSourceError_1;\n\n/**\n * The get request cycle for checking the cache and reporting\n * values.  If there are missing paths then the async request cycle to\n * the data source is performed until all paths are resolved or max\n * requests are made.\n * @param {GetResponse} getResponse -\n * @param {Model} model - The model that the request was made with.\n * @param {Object} results -\n * @param {Function} onNext -\n * @param {Function} onError -\n * @param {Function} onCompleted -\n * @private\n */\nvar getRequestCycle$1 = function getRequestCycle(getResponse, model, results, observer,\n                                          errors, count) {\n    // we have exceeded the maximum retry limit.\n    if (count > model._maxRetries) {\n        observer.onError(new MaxRetryExceededError$1(results.optimizedMissingPaths));\n        return {\n            dispose: function() {}\n        };\n    }\n\n    var requestQueue = model._request;\n    var requestedMissingPaths = results.requestedMissingPaths;\n    var optimizedMissingPaths = results.optimizedMissingPaths;\n    var disposable = new AssignableDisposable$1();\n\n    // We need to prepend the bound path to all requested missing paths and\n    // pass those into the requestQueue.\n    var boundRequestedMissingPaths = [];\n    var boundPath = model._path;\n    if (boundPath.length) {\n        for (var i = 0, len = requestedMissingPaths.length; i < len; ++i) {\n            boundRequestedMissingPaths[i] = boundPath.concat(requestedMissingPaths[i]);\n        }\n    }\n\n    // No bound path, no array copy and concat.\n    else {\n        boundRequestedMissingPaths = requestedMissingPaths;\n    }\n\n    var currentRequestDisposable = requestQueue.\n        get(boundRequestedMissingPaths, optimizedMissingPaths, count, function(err, data, hasInvalidatedResult) {\n            if (model._treatDataSourceErrorsAsJSONGraphErrors ? err instanceof InvalidSourceError$1 : !!err) {\n                if (results.hasValues) {\n                    observer.onNext(results.values && results.values[0]);\n                }\n                observer.onError(err);\n                return;\n            }\n\n            var nextRequestedMissingPaths;\n            var nextSeed;\n\n            // If merging over an existing branch structure with refs has invalidated our intermediate json,\n            // we want to start over and re-get all requested paths with a fresh seed\n            if (hasInvalidatedResult) {\n                nextRequestedMissingPaths = getResponse.currentRemainingPaths;\n                nextSeed = [{}];\n            } else {\n                nextRequestedMissingPaths = requestedMissingPaths;\n                nextSeed = results.values;\n            }\n\n             // Once the request queue finishes, check the cache and bail if\n             // we can.\n            var nextResults = checkCacheAndReport$1(model, nextRequestedMissingPaths,\n                                                  observer,\n                                                  getResponse.isProgressive,\n                                                  getResponse.isJSONGraph,\n                                                  nextSeed, errors);\n\n            // If there are missing paths coming back form checkCacheAndReport\n            // the its reported from the core cache check method.\n            if (nextResults) {\n\n                // update the which disposable to use.\n                disposable.currentDisposable =\n                    getRequestCycle(getResponse, model, nextResults, observer,\n                                    errors, count + 1);\n            }\n\n            // We have finished.  Since we went to the dataSource, we must\n            // collect on the cache.\n            else {\n\n                var modelRoot = model._root;\n                var modelCache = modelRoot.cache;\n                var currentVersion = modelCache.$_version;\n\n                collectLru$2(modelRoot, modelRoot.expired, getSize$2(modelCache),\n                        model._maxSize, model._collectRatio, currentVersion);\n            }\n\n        });\n    disposable.currentDisposable = currentRequestDisposable;\n    return disposable;\n};\n\nvar ModelResponse$4 = ModelResponse_1;\nvar checkCacheAndReport = checkCacheAndReport$2;\nvar getRequestCycle = getRequestCycle$1;\nvar empty = {dispose: function() {}};\nvar collectLru$1 = collect;\nvar getSize$1 = getSize$6;\n\n/**\n * The get response.  It takes in a model and paths and starts\n * the request cycle.  It has been optimized for cache first requests\n * and closures.\n * @param {Model} model -\n * @param {Array} paths -\n * @augments ModelResponse\n * @private\n */\nvar GetResponse$3 = function GetResponse(model, paths, isJSONGraph,\n                                       isProgressive, forceCollect) {\n    this.model = model;\n    this.currentRemainingPaths = paths;\n    this.isJSONGraph = isJSONGraph || false;\n    this.isProgressive = isProgressive || false;\n    this.forceCollect = forceCollect || false;\n};\n\nGetResponse$3.prototype = Object.create(ModelResponse$4.prototype);\n\n/**\n * Makes the output of a get response JSONGraph instead of json.\n * @private\n */\nGetResponse$3.prototype._toJSONG = function _toJSONGraph() {\n    return new GetResponse$3(this.model, this.currentRemainingPaths,\n                           true, this.isProgressive, this.forceCollect);\n};\n\n/**\n * Progressively responding to data in the cache instead of once the whole\n * operation is complete.\n * @public\n */\nGetResponse$3.prototype.progressively = function progressively() {\n    return new GetResponse$3(this.model, this.currentRemainingPaths,\n                           this.isJSONGraph, true, this.forceCollect);\n};\n\n/**\n * purely for the purposes of closure creation other than the initial\n * prototype created closure.\n *\n * @private\n */\nGetResponse$3.prototype._subscribe = function _subscribe(observer) {\n    var seed = [{}];\n    var errors = [];\n    var model = this.model;\n    var isJSONG = observer.isJSONG = this.isJSONGraph;\n    var isProgressive = this.isProgressive;\n    var results = checkCacheAndReport(model, this.currentRemainingPaths,\n                                      observer, isProgressive, isJSONG, seed,\n                                      errors);\n\n    // If there are no results, finish.\n    if (!results) {\n        if (this.forceCollect) {\n            var modelRoot = model._root;\n            var modelCache = modelRoot.cache;\n            var currentVersion = modelCache.$_version;\n\n            collectLru$1(modelRoot, modelRoot.expired, getSize$1(modelCache),\n                    model._maxSize, model._collectRatio, currentVersion);\n        }\n        return empty;\n    }\n\n    // Starts the async request cycle.\n    return getRequestCycle(this, model, results,\n                           observer, errors, 1);\n};\n\nvar GetResponse_1 = GetResponse$3;\n\nvar pathSyntax$2 = src$1;\nvar ModelResponse$3 = ModelResponse_1;\nvar GET_VALID_INPUT$1 = validInput;\nvar validateInput$2 = validateInput$3;\nvar GetResponse$2 = GetResponse_1;\n\n/**\n * Performs a get on the cache and if there are missing paths\n * then the request will be forwarded to the get request cycle.\n * @private\n */\nvar get$1 = function get() {\n    // Validates the input.  If the input is not pathSets or strings then we\n    // will onError.\n    var out = validateInput$2(arguments, GET_VALID_INPUT$1, \"get\");\n    if (out !== true) {\n        return new ModelResponse$3(function(o) {\n            o.onError(out);\n        });\n    }\n\n    var paths = pathSyntax$2.fromPathsOrPathValues(arguments);\n    return new GetResponse$2(this, paths);\n};\n\nvar GetResponse$1 = GetResponse_1;\n\n/**\n * Performs a get on the cache and if there are missing paths\n * then the request will be forwarded to the get request cycle.\n * @private\n */\nvar getWithPaths = function getWithPaths(paths) {\n    return new GetResponse$1(this, paths);\n};\n\nvar setValidInput$1 = {\n    pathValue: true,\n    pathSyntax: true,\n    json: true,\n    jsonGraph: true\n};\n\nvar arrayFlatMap$1 = function arrayFlatMap(array, selector) {\n    var index = -1;\n    var i = -1;\n    var n = array.length;\n    var array2 = [];\n    while (++i < n) {\n        var array3 = selector(array[i], i, array);\n        var j = -1;\n        var k = array3.length;\n        while (++j < k) {\n            array2[++index] = array3[j];\n        }\n    }\n    return array2;\n};\n\nvar arrayFlatMap = arrayFlatMap$1;\n\n/**\n * Takes the groups that are created in the SetResponse constructor and sets\n * them into the cache.\n */\nvar setGroupsIntoCache$1 = function setGroupsIntoCache(model, groups) {\n    var modelRoot = model._root;\n    var errorSelector = modelRoot.errorSelector;\n    var groupIndex = -1;\n    var groupCount = groups.length;\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var returnValue = {\n        requestedPaths: requestedPaths,\n        optimizedPaths: optimizedPaths\n    };\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = groups[groupIndex];\n        var inputType = group.inputType;\n        var methodArgs = group.arguments;\n\n        if (methodArgs.length > 0) {\n            var operationName = \"_set\" + inputType;\n            var operationFunc = model[operationName];\n            var successfulPaths = operationFunc(model, methodArgs, null, errorSelector);\n\n            optimizedPaths.push.apply(optimizedPaths, successfulPaths[1]);\n\n            if (inputType === \"PathValues\") {\n                requestedPaths.push.apply(requestedPaths, methodArgs.map(pluckPath));\n            } else if (inputType === \"JSONGs\") {\n                requestedPaths.push.apply(requestedPaths, arrayFlatMap(methodArgs, pluckEnvelopePaths));\n            } else {\n                requestedPaths.push.apply(requestedPaths, successfulPaths[0]);\n            }\n        }\n    }\n\n    return returnValue;\n};\n\nfunction pluckPath(pathValue) {\n    return pathValue.path;\n}\n\nfunction pluckEnvelopePaths(jsonGraphEnvelope) {\n    return jsonGraphEnvelope.paths;\n}\n\nvar emptyArray = [];\nvar AssignableDisposable = AssignableDisposable_1;\nvar GetResponse = GetResponse_1;\nvar setGroupsIntoCache = setGroupsIntoCache$1;\nvar getWithPathsAsPathMap = get_1.getWithPathsAsPathMap;\nvar InvalidSourceError = InvalidSourceError_1;\nvar MaxRetryExceededError = MaxRetryExceededError_1;\n\n/**\n * The request cycle for set.  This is responsible for requesting to dataSource\n * and allowing disposing inflight requests.\n */\nvar setRequestCycle$1 = function setRequestCycle(model, observer, groups,\n                                          isJSONGraph, isProgressive, count) {\n    var requestedAndOptimizedPaths = setGroupsIntoCache(model, groups);\n    var optimizedPaths = requestedAndOptimizedPaths.optimizedPaths;\n    var requestedPaths = requestedAndOptimizedPaths.requestedPaths;\n\n    // we have exceeded the maximum retry limit.\n    if (count > model._maxRetries) {\n        observer.onError(new MaxRetryExceededError(optimizedPaths));\n        return {\n            dispose: function() {}\n        };\n    }\n\n    var isMaster = model._source === undefined;\n\n    // Local set only.  We perform a follow up get.  If performance is ever\n    // a requirement simply requiring in checkCacheAndReport and use get request\n    // internals.  Figured this is more \"pure\".\n    if (isMaster) {\n        return subscribeToFollowupGet(model, observer, requestedPaths,\n                              isJSONGraph, isProgressive);\n    }\n\n\n    // Progressively output the data from the first set.\n    var prevVersion;\n    if (isProgressive) {\n        var results = getWithPathsAsPathMap(model, requestedPaths, [{}]);\n        if (results.criticalError) {\n            observer.onError(results.criticalError);\n            return null;\n        }\n        observer.onNext(results.values[0]);\n\n        prevVersion = model._root.cache.$_version;\n    }\n\n    var currentJSONGraph = getJSONGraph(model, optimizedPaths);\n    var disposable = new AssignableDisposable();\n\n    // Sends out the setRequest.  The Queue will call the callback with the\n    // JSONGraph envelope / error.\n    var requestDisposable = model._request.\n        // TODO: There is error handling that has not been addressed yet.\n\n        // If disposed before this point then the sendSetRequest will not\n        // further any callbacks.  Therefore, if we are at this spot, we are\n        // not disposed yet.\n        set(currentJSONGraph, count, function(error, jsonGraphEnv) {\n            if (error instanceof InvalidSourceError) {\n                observer.onError(error);\n                return;\n            }\n\n            // TODO: This seems like there are errors with this approach, but\n            // for sanity sake I am going to keep this logic in here until a\n            // rethink can be done.\n            var isCompleted = false;\n            if (error || optimizedPaths.length === jsonGraphEnv.paths.length) {\n                isCompleted = true;\n            }\n\n            // If we're in progressive mode and nothing changed in the meantime, we're done\n            if (isProgressive) {\n                var nextVersion = model._root.cache.$_version;\n                var versionChanged = nextVersion !== prevVersion;\n\n                if (!versionChanged) {\n                    observer.onCompleted();\n                    return;\n                }\n            }\n\n            // Happy case.  One request to the dataSource will fulfill the\n            // required paths.\n            if (isCompleted) {\n                disposable.currentDisposable =\n                    subscribeToFollowupGet(model, observer, requestedPaths,\n                                          isJSONGraph, isProgressive);\n            }\n\n            // TODO: The unhappy case.  I am unsure how this can even be\n            // achieved.\n            else {\n                // We need to restart the setRequestCycle.\n                setRequestCycle(model, observer, groups, isJSONGraph,\n                                isProgressive, count + 1);\n            }\n        });\n\n    // Sets the current disposable as the requestDisposable.\n    disposable.currentDisposable = requestDisposable;\n\n    return disposable;\n};\n\nfunction getJSONGraph(model, optimizedPaths) {\n    var boundPath = model._path;\n    var envelope = {};\n    model._path = emptyArray;\n    model._getPathValuesAsJSONG(model._materialize().withoutDataSource(), optimizedPaths, [envelope]);\n    model._path = boundPath;\n\n    return envelope;\n}\n\nfunction subscribeToFollowupGet(model, observer, requestedPaths, isJSONGraph,\n                               isProgressive) {\n\n    // Creates a new response and subscribes to it with the original observer.\n    // Also sets forceCollect to true, incase the operation is synchronous and\n    // exceeds the cache limit size\n    var response = new GetResponse(model, requestedPaths, isJSONGraph,\n                                   isProgressive, true);\n    return response.subscribe(observer);\n}\n\nvar ModelResponse$2 = ModelResponse_1;\nvar pathSyntax$1 = src$1;\nvar isArray = Array.isArray;\nvar isPathValue = isPathValue$3;\nvar isJSONGraphEnvelope$1 = isJSONGraphEnvelope$3;\nvar isJSONEnvelope$1 = isJSONEnvelope$4;\nvar setRequestCycle = setRequestCycle$1;\n\n/**\n *  The set response is responsible for doing the request loop for the set\n * operation and subscribing to the follow up get.\n *\n * The constructors job is to parse out the arguments and put them in their\n * groups.  The following subscribe will do the actual cache set and dataSource\n * operation remoting.\n *\n * @param {Model} model -\n * @param {Array} args - The array of arguments that can be JSONGraph, JSON, or\n * pathValues.\n * @param {Boolean} isJSONGraph - if the request is a jsonGraph output format.\n * @param {Boolean} isProgressive - progressive output.\n * @augments ModelResponse\n * @private\n */\nvar SetResponse$1 = function SetResponse(model, args, isJSONGraph,\n                                       isProgressive) {\n\n    // The response properties.\n    this._model = model;\n    this._isJSONGraph = isJSONGraph || false;\n    this._isProgressive = isProgressive || false;\n    this._initialArgs = args;\n    this._value = [{}];\n\n    var groups = [];\n    var group, groupType;\n    var argIndex = -1;\n    var argCount = args.length;\n\n    // Validation of arguments have been moved out of this function.\n    while (++argIndex < argCount) {\n        var arg = args[argIndex];\n        var argType;\n        if (isArray(arg) || typeof arg === \"string\") {\n            arg = pathSyntax$1.fromPath(arg);\n            argType = \"PathValues\";\n        } else if (isPathValue(arg)) {\n            arg.path = pathSyntax$1.fromPath(arg.path);\n            argType = \"PathValues\";\n        } else if (isJSONGraphEnvelope$1(arg)) {\n            argType = \"JSONGs\";\n        } else if (isJSONEnvelope$1(arg)) {\n            argType = \"PathMaps\";\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            group = {\n                inputType: argType,\n                arguments: []\n            };\n            groups.push(group);\n        }\n\n        group.arguments.push(arg);\n    }\n\n    this._groups = groups;\n};\n\nSetResponse$1.prototype = Object.create(ModelResponse$2.prototype);\n\n/**\n * The subscribe function will setup the remoting of the operation and cache\n * setting.\n *\n * @private\n */\nSetResponse$1.prototype._subscribe = function _subscribe(observer) {\n    var groups = this._groups;\n    var model = this._model;\n    var isJSONGraph = this._isJSONGraph;\n    var isProgressive = this._isProgressive;\n\n    // Starts the async request cycle.\n    return setRequestCycle(\n        model, observer, groups, isJSONGraph, isProgressive, 1);\n};\n\n/**\n * Makes the output of a get response JSONGraph instead of json.\n * @private\n */\nSetResponse$1.prototype._toJSONG = function _toJSONGraph() {\n    return new SetResponse$1(this._model, this._initialArgs,\n                           true, this._isProgressive);\n};\n\n/**\n * Progressively responding to data in the cache instead of once the whole\n * operation is complete.\n * @public\n */\nSetResponse$1.prototype.progressively = function progressively() {\n    return new SetResponse$1(this._model, this._initialArgs,\n                           this._isJSONGraph, true);\n};\n\nvar SetResponse_1 = SetResponse$1;\n\nvar setValidInput = setValidInput$1;\nvar validateInput$1 = validateInput$3;\nvar SetResponse = SetResponse_1;\nvar ModelResponse$1 = ModelResponse_1;\n\nvar set = function set() {\n    var out = validateInput$1(arguments, setValidInput, \"set\");\n    if (out !== true) {\n        return new ModelResponse$1(function(o) {\n            o.onError(out);\n        });\n    }\n\n    var argsIdx = -1;\n    var argsLen = arguments.length;\n    var args = [];\n    while (++argsIdx < argsLen) {\n        args[argsIdx] = arguments[argsIdx];\n    }\n    return new SetResponse(this, args);\n};\n\nvar InvalidDerefInputError_1;\nvar hasRequiredInvalidDerefInputError;\n\nfunction requireInvalidDerefInputError () {\n\tif (hasRequiredInvalidDerefInputError) return InvalidDerefInputError_1;\n\thasRequiredInvalidDerefInputError = 1;\n\tvar applyErrorPrototype = applyErrorPrototype_1;\n\n\t/**\n\t * An invalid deref input is when deref is used with input that is not generated\n\t * from a get, set, or a call.\n\t *\n\t * @private\n\t */\n\tfunction InvalidDerefInputError() {\n\t    var instance = new Error(\"Deref can only be used with a non-primitive object from get, set, or call.\");\n\n\t    instance.name = \"InvalidDerefInputError\";\n\n\t    if (Object.setPrototypeOf) {\n\t        Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n\t    }\n\n\t    if (Error.captureStackTrace) {\n\t        Error.captureStackTrace(instance, InvalidDerefInputError);\n\t    }\n\n\t    return instance;\n\t}\n\n\tapplyErrorPrototype(InvalidDerefInputError);\n\n\tInvalidDerefInputError_1 = InvalidDerefInputError;\n\treturn InvalidDerefInputError_1;\n}\n\nvar deref;\nvar hasRequiredDeref;\n\nfunction requireDeref () {\n\tif (hasRequiredDeref) return deref;\n\thasRequiredDeref = 1;\n\tvar InvalidDerefInputError = requireInvalidDerefInputError();\n\tvar getCachePosition = requireGetCachePosition();\n\tvar CONTAINER_DOES_NOT_EXIST = \"e\";\n\tvar $ref = ref;\n\n\tderef = function deref(boundJSONArg) {\n\n\t    var absolutePath = boundJSONArg && boundJSONArg.$__path;\n\t    var refPath = boundJSONArg && boundJSONArg.$__refPath;\n\t    var toReference = boundJSONArg && boundJSONArg.$__toReference;\n\t    var referenceContainer;\n\n\t    // We deref and then ensure that the reference container is attached to\n\t    // the model.\n\t    if (absolutePath) {\n\t        var validContainer = CONTAINER_DOES_NOT_EXIST;\n\n\t        if (toReference) {\n\t            validContainer = false;\n\t            referenceContainer = getCachePosition(this, toReference);\n\n\t            // If the reference container is still a sentinel value then compare\n\t            // the reference value with refPath.  If they are the same, then the\n\t            // model is still valid.\n\t            if (refPath && referenceContainer &&\n\t                referenceContainer.$type === $ref) {\n\n\t                var containerPath = referenceContainer.value;\n\t                var i = 0;\n\t                var len = refPath.length;\n\n\t                validContainer = true;\n\t                for (; validContainer && i < len; ++i) {\n\t                    if (containerPath[i] !== refPath[i]) {\n\t                        validContainer = false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        // Signal to the deref'd model that it has been disconnected from the\n\t        // graph or there is no _fromWhenceYouCame\n\t        if (!validContainer) {\n\t            referenceContainer = false;\n\t        }\n\n\t        // The container did not exist, therefore there is no reference\n\t        // container and fromWhenceYouCame should always return true.\n\t        else if (validContainer === CONTAINER_DOES_NOT_EXIST) {\n\t            referenceContainer = true;\n\t        }\n\n\t        return this._clone({\n\t            _path: absolutePath,\n\t            _referenceContainer: referenceContainer\n\t        });\n\t    }\n\n\t    throw new InvalidDerefInputError();\n\t};\n\treturn deref;\n}\n\nvar hasValidParentReference;\nvar hasRequiredHasValidParentReference;\n\nfunction requireHasValidParentReference () {\n\tif (hasRequiredHasValidParentReference) return hasValidParentReference;\n\thasRequiredHasValidParentReference = 1;\n\thasValidParentReference = function fromWhenceYeCame() {\n\t    var reference = this._referenceContainer;\n\n\t    // Always true when this mode is false.\n\t    if (!this._allowFromWhenceYouCame) {\n\t        return true;\n\t    }\n\n\t    // If fromWhenceYouCame is true and the first set of keys did not have\n\t    // a reference, this case can happen.  They are always valid.\n\t    if (reference === true) {\n\t        return true;\n\t    }\n\n\t    // was invalid before even derefing.\n\t    if (reference === false) {\n\t        return false;\n\t    }\n\n\t    // Its been disconnected (set over or collected) from the graph.\n\t    // eslint-disable-next-line camelcase\n\t    if (reference && reference.$_parent === undefined) {\n\t        return false;\n\t    }\n\n\t    // The reference has expired but has not been collected from the graph.\n\t    // eslint-disable-next-line camelcase\n\t    if (reference && reference.$_invalidated) {\n\t        return false;\n\t    }\n\n\t    return true;\n\t};\n\treturn hasValidParentReference;\n}\n\nvar getValue;\nvar hasRequiredGetValue;\n\nfunction requireGetValue () {\n\tif (hasRequiredGetValue) return getValue;\n\thasRequiredGetValue = 1;\n\tvar ModelResponse = ModelResponse_1;\n\tvar pathSyntax = src$1;\n\n\tgetValue = function getValue(path) {\n\t    var parsedPath = pathSyntax.fromPath(path);\n\t    var pathIdx = 0;\n\t    var pathLen = parsedPath.length;\n\t    while (++pathIdx < pathLen) {\n\t        if (typeof parsedPath[pathIdx] === \"object\") {\n\t            /* eslint-disable no-loop-func */\n\t            return new ModelResponse(function(o) {\n\t                o.onError(new Error(\"Paths must be simple paths\"));\n\t            });\n\t            /* eslint-enable no-loop-func */\n\t        }\n\t    }\n\n\t    var self = this;\n\t    return new ModelResponse(function(obs) {\n\t        return self.get(parsedPath).subscribe(function(data) {\n\t            var curr = data.json;\n\t            var depth = -1;\n\t            var length = parsedPath.length;\n\n\t            while (curr && ++depth < length) {\n\t                curr = curr[parsedPath[depth]];\n\t            }\n\t            obs.onNext(curr);\n\t        }, function(err) {\n\t            obs.onError(err);\n\t        }, function() {\n\t            obs.onCompleted();\n\t        });\n\t    });\n\t};\n\treturn getValue;\n}\n\nvar setValue;\nvar hasRequiredSetValue;\n\nfunction requireSetValue () {\n\tif (hasRequiredSetValue) return setValue;\n\thasRequiredSetValue = 1;\n\tvar jsong = src;\n\tvar ModelResponse = ModelResponse_1;\n\tvar isPathValue = isPathValue$3;\n\n\tsetValue = function setValue(pathArg, valueArg) {\n\t    var value = isPathValue(pathArg) ? pathArg : jsong.pathValue(pathArg, valueArg);\n\t    var pathIdx = 0;\n\t    var path = value.path;\n\t    var pathLen = path.length;\n\t    while (++pathIdx < pathLen) {\n\t        if (typeof path[pathIdx] === \"object\") {\n\t            /* eslint-disable no-loop-func */\n\t            return new ModelResponse(function(o) {\n\t                o.onError(new Error(\"Paths must be simple paths\"));\n\t            });\n\t            /* eslint-enable no-loop-func */\n\t        }\n\t    }\n\t    var self = this;\n\t    return new ModelResponse(function(obs) {\n\t        return self.set(value).subscribe(function(data) {\n\t            var curr = data.json;\n\t            var depth = -1;\n\t            var length = path.length;\n\n\t            while (curr && ++depth < length) {\n\t                curr = curr[path[depth]];\n\t            }\n\t            obs.onNext(curr);\n\t        }, function(err) {\n\t            obs.onError(err);\n\t        }, function() {\n\t            obs.onCompleted();\n\t        });\n\t    });\n\t};\n\treturn setValue;\n}\n\nvar sync$2;\nvar hasRequiredSync$2;\n\nfunction requireSync$2 () {\n\tif (hasRequiredSync$2) return sync$2;\n\thasRequiredSync$2 = 1;\n\tvar pathSyntax = src$1;\n\tvar getValueSync = requireGetValueSync();\n\n\tsync$2 = function _getValueSync(pathArg) {\n\t    var path = pathSyntax.fromPath(pathArg);\n\t    if (Array.isArray(path) === false) {\n\t        throw new Error(\"Model#_getValueSync must be called with an Array path.\");\n\t    }\n\t    if (this._path.length) {\n\t        path = this._path.concat(path);\n\t    }\n\t    this._syncCheck(\"getValueSync\");\n\t    return getValueSync(this, path).value;\n\t};\n\treturn sync$2;\n}\n\nvar sync$1;\nvar hasRequiredSync$1;\n\nfunction requireSync$1 () {\n\tif (hasRequiredSync$1) return sync$1;\n\thasRequiredSync$1 = 1;\n\tvar pathSyntax = src$1;\n\tvar isPathValue = isPathValue$3;\n\tvar setPathValues = requireSetPathValues();\n\n\tsync$1 = function setValueSync(pathArg, valueArg, errorSelectorArg, comparatorArg) {\n\n\t    var path = pathSyntax.fromPath(pathArg);\n\t    var value = valueArg;\n\t    var errorSelector = errorSelectorArg;\n\t    // XXX comparator is never used.\n\t    var comparator = comparatorArg;\n\n\t    if (isPathValue(path)) {\n\t        comparator = errorSelector;\n\t        errorSelector = value;\n\t        value = path;\n\t    } else {\n\t        value = {\n\t            path: path,\n\t            value: value\n\t        };\n\t    }\n\n\t    if (isPathValue(value) === false) {\n\t        throw new Error(\"Model#setValueSync must be called with an Array path.\");\n\t    }\n\n\t    if (typeof errorSelector !== \"function\") {\n\t        errorSelector = this._root._errorSelector;\n\t    }\n\n\t    if (typeof comparator !== \"function\") {\n\t        comparator = this._root._comparator;\n\t    }\n\n\t    this._syncCheck(\"setValueSync\");\n\t    setPathValues(this, [value]);\n\t    return this._getValueSync(value.path);\n\t};\n\treturn sync$1;\n}\n\nvar sync;\nvar hasRequiredSync;\n\nfunction requireSync () {\n\tif (hasRequiredSync) return sync;\n\thasRequiredSync = 1;\n\tvar pathSyntax = src$1;\n\tvar getBoundValue = requireGetBoundValue();\n\tvar InvalidModelError = requireInvalidModelError();\n\n\tsync = function derefSync(boundPathArg) {\n\n\t    var boundPath = pathSyntax.fromPath(boundPathArg);\n\n\t    if (!Array.isArray(boundPath)) {\n\t        throw new Error(\"Model#derefSync must be called with an Array path.\");\n\t    }\n\n\t    var boundValue = getBoundValue(this, this._path.concat(boundPath), false);\n\n\t    var path = boundValue.path;\n\t    var node = boundValue.value;\n\t    var found = boundValue.found;\n\n\t    // If the node is not found or the node is found but undefined is returned,\n\t    // this happens when a reference is expired.\n\t    if (!found || node === undefined) {\n\t        return undefined;\n\t    }\n\n\t    if (node.$type) {\n\t        throw new InvalidModelError(path, path);\n\t    }\n\n\t    return this._clone({ _path: path });\n\t};\n\treturn sync;\n}\n\nvar getVersion;\nvar hasRequiredGetVersion;\n\nfunction requireGetVersion () {\n\tif (hasRequiredGetVersion) return getVersion;\n\thasRequiredGetVersion = 1;\n\tvar getValueSync = requireGetValueSync();\n\n\tgetVersion = function _getVersion(model, path) {\n\t    // ultra fast clone for boxed values.\n\t    var gen = getValueSync({\n\t        _boxed: true,\n\t        _root: model._root,\n\t        _treatErrorsAsValues: model._treatErrorsAsValues\n\t    }, path, true).value;\n\t    var version = gen && gen.$_version;\n\t    return (version == null) ? -1 : version;\n\t};\n\treturn getVersion;\n}\n\nvar invalidatePathSets;\nvar hasRequiredInvalidatePathSets;\n\nfunction requireInvalidatePathSets () {\n\tif (hasRequiredInvalidatePathSets) return invalidatePathSets;\n\thasRequiredInvalidatePathSets = 1;\n\tvar __ref = requireRef();\n\n\tvar $ref = ref;\n\n\tvar getBoundValue = requireGetBoundValue();\n\n\tvar promote = requirePromote();\n\tvar getSize = getSize$6;\n\tvar isExpired = isExpired$7;\n\tvar isFunction = isFunction$5;\n\tvar isPrimitive = isPrimitive$4;\n\tvar expireNode = expireNode$5;\n\tvar iterateKeySet = lib$1.iterateKeySet;\n\tvar incrementVersion = incrementVersionExports;\n\tvar updateNodeAncestors = updateNodeAncestors$3;\n\tvar removeNodeAndDescendants = requireRemoveNodeAndDescendants();\n\n\t/**\n\t * Invalidates a list of Paths in a JSON Graph.\n\t * @function\n\t * @param {Object} model - the Model for which to insert the PathValues.\n\t * @param {Array.<PathValue>} paths - the PathValues to set.\n\t */\n\n\tinvalidatePathSets = function invalidatePathSets(model, paths) {\n\n\t    var modelRoot = model._root;\n\t    var lru = modelRoot;\n\t    var expired = modelRoot.expired;\n\t    var version = incrementVersion();\n\t    var bound = model._path;\n\t    var cache = modelRoot.cache;\n\t    var node = bound.length ? getBoundValue(model, bound).value : cache;\n\t    // eslint-disable-next-line camelcase\n\t    var parent = node.$_parent || cache;\n\t    // eslint-disable-next-line camelcase\n\t    var initialVersion = cache.$_version;\n\n\t    var pathIndex = -1;\n\t    var pathCount = paths.length;\n\n\t    while (++pathIndex < pathCount) {\n\n\t        var path = paths[pathIndex];\n\n\t        invalidatePathSet(path, 0, cache, parent, node, version, expired, lru);\n\t    }\n\n\t    // eslint-disable-next-line camelcase\n\t    var newVersion = cache.$_version;\n\t    var rootChangeHandler = modelRoot.onChange;\n\n\t    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n\t        rootChangeHandler();\n\t    }\n\t};\n\n\tfunction invalidatePathSet(\n\t    path, depth, root, parent, node,\n\t    version, expired, lru) {\n\n\t    var note = {};\n\t    var branch = depth < path.length - 1;\n\t    var keySet = path[depth];\n\t    var key = iterateKeySet(keySet, note);\n\n\t    do {\n\t        var results = invalidateNode(root, parent, node, key, branch, expired, lru);\n\t        var nextNode = results[0];\n\t        var nextParent = results[1];\n\t        if (nextNode) {\n\t            if (branch) {\n\t                invalidatePathSet(\n\t                    path, depth + 1,\n\t                    root, nextParent, nextNode,\n\t                    version, expired, lru\n\t                );\n\t            } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru, undefined)) {\n\t                updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n\t            }\n\t        }\n\t        key = iterateKeySet(keySet, note);\n\t    } while (!note.done);\n\t}\n\n\tfunction invalidateReference(root, node, expired, lru) {\n\n\t    if (isExpired(node)) {\n\t        expireNode(node, expired, lru);\n\t        return [undefined, root];\n\t    }\n\n\t    promote(lru, node);\n\n\t    var container = node;\n\t    var reference = node.value;\n\t    var parent = root;\n\n\t    // eslint-disable-next-line camelcase\n\t    node = node.$_context;\n\n\t    if (node != null) {\n\t        // eslint-disable-next-line camelcase\n\t        parent = node.$_parent || root;\n\t    } else {\n\n\t        var index = 0;\n\t        var count = reference.length - 1;\n\n\t        parent = node = root;\n\n\t        do {\n\t            var key = reference[index];\n\t            var branch = index < count;\n\t            var results = invalidateNode(root, parent, node, key, branch, expired, lru);\n\t            node = results[0];\n\t            if (isPrimitive(node)) {\n\t                return results;\n\t            }\n\t            parent = results[1];\n\t        } while (index++ < count);\n\n\t        // eslint-disable-next-line camelcase\n\t        if (container.$_context !== node) {\n\t            // eslint-disable-next-line camelcase\n\t            var backRefs = node.$_refsLength || 0;\n\t            // eslint-disable-next-line camelcase\n\t            node.$_refsLength = backRefs + 1;\n\t            node[__ref + backRefs] = container;\n\t            // eslint-disable-next-line camelcase\n\t            container.$_context = node;\n\t            // eslint-disable-next-line camelcase\n\t            container.$_refIndex = backRefs;\n\t        }\n\t    }\n\n\t    return [node, parent];\n\t}\n\n\tfunction invalidateNode(root, parent, node, key, branch, expired, lru) {\n\n\t    var type = node.$type;\n\n\t    while (type === $ref) {\n\t        var results = invalidateReference(root, node, expired, lru);\n\n\t        node = results[0];\n\n\t        if (isPrimitive(node)) {\n\t            return results;\n\t        }\n\n\t        parent = results[1];\n\t        type = node.$type;\n\t    }\n\n\t    if (type !== void 0) {\n\t        return [node, parent];\n\t    }\n\n\t    if (key == null) {\n\t        if (branch) {\n\t            throw new Error(\"`null` is not allowed in branch key positions.\");\n\t        } else if (node) {\n\t            key = node.$_key;\n\t        }\n\t    } else {\n\t        parent = node;\n\t        node = parent[key];\n\t    }\n\n\t    return [node, parent];\n\t}\n\treturn invalidatePathSets;\n}\n\nvar invalidatePathMaps;\nvar hasRequiredInvalidatePathMaps;\n\nfunction requireInvalidatePathMaps () {\n\tif (hasRequiredInvalidatePathMaps) return invalidatePathMaps;\n\thasRequiredInvalidatePathMaps = 1;\n\tvar createHardlink = createHardlink$2;\n\tvar __prefix = reservedPrefix$1;\n\n\tvar $ref = ref;\n\n\tvar getBoundValue = requireGetBoundValue();\n\n\tvar promote = requirePromote();\n\tvar getSize = getSize$6;\n\tvar hasOwn = hasOwn_1;\n\tvar isObject = isObject$f;\n\tvar isExpired = isExpired$7;\n\tvar isFunction = isFunction$5;\n\tvar isPrimitive = isPrimitive$4;\n\tvar expireNode = expireNode$5;\n\tvar incrementVersion = incrementVersionExports;\n\tvar updateNodeAncestors = updateNodeAncestors$3;\n\tvar removeNodeAndDescendants = requireRemoveNodeAndDescendants();\n\n\t/**\n\t * Sets a list of PathMaps into a JSON Graph.\n\t * @function\n\t * @param {Object} model - the Model for which to insert the PathMaps.\n\t * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.\n\t */\n\n\tinvalidatePathMaps = function invalidatePathMaps(model, pathMapEnvelopes) {\n\n\t    var modelRoot = model._root;\n\t    var lru = modelRoot;\n\t    var expired = modelRoot.expired;\n\t    var version = incrementVersion();\n\t    var bound = model._path;\n\t    var cache = modelRoot.cache;\n\t    var node = bound.length ? getBoundValue(model, bound).value : cache;\n\t    var parent = node.$_parent || cache;\n\t    var initialVersion = cache.$_version;\n\n\t    var pathMapIndex = -1;\n\t    var pathMapCount = pathMapEnvelopes.length;\n\n\t    while (++pathMapIndex < pathMapCount) {\n\n\t        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n\n\t        invalidatePathMap(pathMapEnvelope.json, cache, parent, node, version, expired, lru);\n\t    }\n\n\t    var newVersion = cache.$_version;\n\t    var rootChangeHandler = modelRoot.onChange;\n\n\t    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n\t        rootChangeHandler();\n\t    }\n\t};\n\n\tfunction invalidatePathMap(pathMap, root, parent, node, version, expired, lru) {\n\n\t    if (isPrimitive(pathMap) || pathMap.$type) {\n\t        return;\n\t    }\n\n\t    for (var key in pathMap) {\n\t        if (key[0] !== __prefix && hasOwn(pathMap, key)) {\n\t            var child = pathMap[key];\n\t            var branch = isObject(child) && !child.$type;\n\t            var results = invalidateNode(root, parent, node, key, branch, expired, lru);\n\t            var nextNode = results[0];\n\t            var nextParent = results[1];\n\t            if (nextNode) {\n\t                if (branch) {\n\t                    invalidatePathMap(child, root, nextParent, nextNode, version, expired, lru);\n\t                } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n\t                    updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\n\tfunction invalidateReference(root, node, expired, lru) {\n\n\t    if (isExpired(node)) {\n\t        expireNode(node, expired, lru);\n\t        return [undefined, root];\n\t    }\n\n\t    promote(lru, node);\n\n\t    var container = node;\n\t    var reference = node.value;\n\t    var parent = root;\n\n\t    node = node.$_context;\n\n\t    if (node != null) {\n\t        parent = node.$_parent || root;\n\t    } else {\n\n\t        var index = 0;\n\t        var count = reference.length - 1;\n\n\t        parent = node = root;\n\n\t        do {\n\t            var key = reference[index];\n\t            var branch = index < count;\n\t            var results = invalidateNode(root, parent, node, key, branch, expired, lru);\n\t            node = results[0];\n\t            if (isPrimitive(node)) {\n\t                return results;\n\t            }\n\t            parent = results[1];\n\t        } while (index++ < count);\n\n\t        if (container.$_context !== node) {\n\t            createHardlink(container, node);\n\t        }\n\t    }\n\n\t    return [node, parent];\n\t}\n\n\tfunction invalidateNode(root, parent, node, key, branch, expired, lru) {\n\n\t    var type = node.$type;\n\n\t    while (type === $ref) {\n\t        var results = invalidateReference(root, node, expired, lru);\n\n\t        node = results[0];\n\n\t        if (isPrimitive(node)) {\n\t            return results;\n\t        }\n\n\t        parent = results[1];\n\t        type = node && node.$type;\n\t    }\n\n\t    if (type !== void 0) {\n\t        return [node, parent];\n\t    }\n\n\t    if (key == null) {\n\t        if (branch) {\n\t            throw new Error(\"`null` is not allowed in branch key positions.\");\n\t        } else if (node) {\n\t            key = node.$_key;\n\t        }\n\t    } else {\n\t        parent = node;\n\t        node = parent[key];\n\t    }\n\n\t    return [node, parent];\n\t}\n\treturn invalidatePathMaps;\n}\n\nvar ModelRoot = ModelRoot_1;\nvar ModelDataSourceAdapter = ModelDataSourceAdapter_1;\n\nvar RequestQueue = RequestQueueV2_1;\nvar ModelResponse = ModelResponse_1;\nvar CallResponse = CallResponse_1;\nvar InvalidateResponse = InvalidateResponse_1;\n\nvar TimeoutScheduler = TimeoutScheduler_1;\nvar ImmediateScheduler = ImmediateScheduler_1;\n\nvar collectLru = collect;\nvar pathSyntax = src$1;\n\nvar getSize = getSize$6;\nvar isObject = isObject$f;\nvar isPrimitive = isPrimitive$4;\nvar isJSONEnvelope = isJSONEnvelope$4;\nvar isJSONGraphEnvelope = isJSONGraphEnvelope$3;\n\nvar setCache = setPathMaps;\nvar setJSONGraphs = setJSONGraphs$3;\nvar jsong = src;\nvar ID = 0;\nvar validateInput = validateInput$3;\nvar noOp = function() {};\nvar getCache = getCache$1;\nvar get = get_1;\nvar GET_VALID_INPUT = validInput;\n\nvar Model_1 = Model;\n\nModel.ref = jsong.ref;\nModel.atom = jsong.atom;\nModel.error = jsong.error;\nModel.pathValue = jsong.pathValue;\n\n/**\n * This callback is invoked when the Model's cache is changed.\n * @callback Model~onChange\n */\n\n/**\n * This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects\n * to be transformed before being stored in the Model's cache.\n * @callback Model~errorSelector\n * @param {Object} jsonGraphError - the JSONGraph Error object to transform before it is stored in the Model's cache.\n * @returns {Object} the JSONGraph Error object to store in the Model cache.\n */\n\n/**\n * This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the\n * function returns true, the existing value is replaced with a new value and the version flag on all of the value's\n * ancestors in the tree are incremented.\n * @callback Model~comparator\n * @param {Object} existingValue - the current value in the Model cache.\n * @param {Object} newValue - the value about to be set into the Model cache.\n * @returns {Boolean} the Boolean value indicating whether the new value and the existing value are equal.\n */\n\n/**\n * @typedef {Object} Options\n * @property {DataSource} [source] A data source to retrieve and manage the {@link JSONGraph}\n * @property {JSONGraph} [cache] Initial state of the {@link JSONGraph}\n * @property {number} [maxSize] The maximum size of the cache before cache pruning is performed. The unit of this value\n * depends on the algorithm used to calculate the `$size` field on graph nodes by the backing source for the Model's\n * DataSource. If no DataSource is used, or the DataSource does not provide `$size` values, a naive algorithm is used\n * where the cache size is calculated in terms of graph node count and, for arrays and strings, element count.\n * @property {number} [collectRatio] The ratio of the maximum size to collect when the maxSize is exceeded.\n * @property {number} [maxRetries] The maximum number of times that the Model will attempt to retrieve the value from\n * its DataSource. Defaults to `3`.\n * @property {Model~errorSelector} [errorSelector] A function used to translate errors before they are returned\n * @property {Model~onChange} [onChange] A function called whenever the Model's cache is changed\n * @property {Model~comparator} [comparator] A function called whenever a value in the Model's cache is about to be\n * replaced with a new value.\n * @property {boolean} [disablePathCollapse] Disables the algorithm that collapses paths on GET requests. The algorithm\n * is enabled by default. This is a relatively computationally expensive feature.\n * @property {boolean} [disableRequestDeduplication] Disables the algorithm that deduplicates paths across in-flight GET\n * requests. The algorithm is enabled by default. This is a computationally expensive feature.\n */\n\n/**\n * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.\n * @constructor\n * @param {Options} [o] - a set of options to customize behavior\n */\nfunction Model(o) {\n    var options = o || {};\n    this._root = options._root || new ModelRoot(options);\n    this._path = options.path || options._path || [];\n    this._source = options.source || options._source;\n    this._request =\n        options.request || options._request || new RequestQueue(this, options.scheduler || new ImmediateScheduler());\n    this._ID = ID++;\n\n    if (typeof options.maxSize === \"number\") {\n        this._maxSize = options.maxSize;\n    } else {\n        this._maxSize = options._maxSize || Model.prototype._maxSize;\n    }\n\n    if (typeof options.maxRetries === \"number\") {\n        this._maxRetries = options.maxRetries;\n    } else {\n        this._maxRetries = options._maxRetries || Model.prototype._maxRetries;\n    }\n\n    if (typeof options.collectRatio === \"number\") {\n        this._collectRatio = options.collectRatio;\n    } else {\n        this._collectRatio = options._collectRatio || Model.prototype._collectRatio;\n    }\n\n    if (options.boxed || options.hasOwnProperty(\"_boxed\")) {\n        this._boxed = options.boxed || options._boxed;\n    }\n\n    if (options.materialized || options.hasOwnProperty(\"_materialized\")) {\n        this._materialized = options.materialized || options._materialized;\n    }\n\n    if (typeof options.treatErrorsAsValues === \"boolean\") {\n        this._treatErrorsAsValues = options.treatErrorsAsValues;\n    } else if (options.hasOwnProperty(\"_treatErrorsAsValues\")) {\n        this._treatErrorsAsValues = options._treatErrorsAsValues;\n    } else {\n        this._treatErrorsAsValues = false;\n    }\n\n    if (typeof options.disablePathCollapse === \"boolean\") {\n        this._enablePathCollapse = !options.disablePathCollapse;\n    } else if (options.hasOwnProperty(\"_enablePathCollapse\")) {\n        this._enablePathCollapse = options._enablePathCollapse;\n    } else {\n        this._enablePathCollapse = true;\n    }\n\n    if (typeof options.disableRequestDeduplication === \"boolean\") {\n        this._enableRequestDeduplication = !options.disableRequestDeduplication;\n    } else if (options.hasOwnProperty(\"_enableRequestDeduplication\")) {\n        this._enableRequestDeduplication = options._enableRequestDeduplication;\n    } else {\n        this._enableRequestDeduplication = true;\n    }\n\n    this._useServerPaths = options._useServerPaths || false;\n\n    this._allowFromWhenceYouCame = options.allowFromWhenceYouCame || options._allowFromWhenceYouCame || false;\n\n    this._treatDataSourceErrorsAsJSONGraphErrors = options._treatDataSourceErrorsAsJSONGraphErrors || false;\n\n    if (options.cache) {\n        this.setCache(options.cache);\n    }\n}\n\nModel.prototype.constructor = Model;\n\nModel.prototype._materialized = false;\nModel.prototype._boxed = false;\nModel.prototype._progressive = false;\nModel.prototype._treatErrorsAsValues = false;\nModel.prototype._maxSize = Math.pow(2, 53) - 1;\nModel.prototype._maxRetries = 3;\nModel.prototype._collectRatio = 0.75;\nModel.prototype._enablePathCollapse = true;\nModel.prototype._enableRequestDeduplication = true;\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype.get = get$1;\n\n/**\n * _getOptimizedBoundPath is an extension point for internal users to polyfill\n * legacy soft-bind behavior, as opposed to deref (hardBind). Current falcor\n * only supports deref, and assumes _path to be a fully optimized path.\n * @function\n * @private\n * @return {Path} - fully optimized bound path for the model\n */\nModel.prototype._getOptimizedBoundPath = function _getOptimizedBoundPath() {\n    return this._path ? this._path.slice() : this._path;\n};\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @private\n * @param {Array.<PathSet>} paths - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype._getWithPaths = getWithPaths;\n\n/**\n * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.\n * @function\n * @return {ModelResponse.<JSONEnvelope>} - an {@link Observable} stream containing the values in the JSONGraph model after the set was attempted\n */\nModel.prototype.set = set;\n\n/**\n * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - a ModelResponse that completes when the data has been loaded into the cache.\n */\nModel.prototype.preload = function preload() {\n    var out = validateInput(arguments, GET_VALID_INPUT, \"preload\");\n    if (out !== true) {\n        return new ModelResponse(function(o) {\n            o.onError(out);\n        });\n    }\n    var args = Array.prototype.slice.call(arguments);\n    var self = this;\n    return new ModelResponse(function(obs) {\n        return self.get.apply(self, args).subscribe(\n            function() {},\n            function(err) {\n                obs.onError(err);\n            },\n            function() {\n                obs.onCompleted();\n            }\n        );\n    });\n};\n\n/**\n * Invokes a function in the JSON Graph.\n * @function\n * @param {Path} functionPath - the path to the function to invoke\n * @param {Array.<Object>} args - the arguments to pass to the function\n * @param {Array.<PathSet>} refPaths - the paths to retrieve from the JSON Graph References in the message returned from the function\n * @param {Array.<PathSet>} extraPaths - additional paths to retrieve after successful function execution\n * @return {ModelResponse.<JSONEnvelope> - a JSONEnvelope contains the values returned from the function\n */\nModel.prototype.call = function call() {\n    var args;\n    var argsIdx = -1;\n    var argsLen = arguments.length;\n    args = new Array(argsLen);\n    while (++argsIdx < argsLen) {\n        var arg = arguments[argsIdx];\n        args[argsIdx] = arg;\n        var argType = typeof arg;\n        if (\n            (argsIdx > 1 && !Array.isArray(arg)) ||\n            (argsIdx === 0 && !Array.isArray(arg) && argType !== \"string\") ||\n            (argsIdx === 1 && !Array.isArray(arg) && !isPrimitive(arg))\n        ) {\n            /* eslint-disable no-loop-func */\n            return new ModelResponse(function(o) {\n                o.onError(new Error(\"Invalid argument\"));\n            });\n            /* eslint-enable no-loop-func */\n        }\n    }\n\n    return new CallResponse(this, args[0], args[1], args[2], args[3]);\n};\n\n/**\n * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.\n * @function\n * @param {...PathSet} path - the  paths to remove from the {@link Model}'s cache.\n */\nModel.prototype.invalidate = function invalidate() {\n    var args;\n    var argsIdx = -1;\n    var argsLen = arguments.length;\n    args = [];\n    while (++argsIdx < argsLen) {\n        args[argsIdx] = pathSyntax.fromPath(arguments[argsIdx]);\n        if (!Array.isArray(args[argsIdx]) || !args[argsIdx].length) {\n            throw new Error(\"Invalid argument\");\n        }\n    }\n\n    // creates the obs, subscribes and will throw the errors if encountered.\n    new InvalidateResponse(this, args).subscribe(noOp, function(e) {\n        throw e;\n    });\n};\n\n/**\n * Returns a new {@link Model} bound to a location within the {@link\n * JSONGraph}. The bound location is never a {@link Reference}: any {@link\n * Reference}s encountered while resolving the bound {@link Path} are always\n * replaced with the {@link Reference}s target value. For subsequent operations\n * on the {@link Model}, all paths will be evaluated relative to the bound\n * path. Deref allows you to:\n * - Expose only a fragment of the {@link JSONGraph} to components, rather than\n *   the entire graph\n * - Hide the location of a {@link JSONGraph} fragment from components\n * - Optimize for executing multiple operations and path looksup at/below the\n *   same location in the {@link JSONGraph}\n * @method\n * @param {Object} responseObject - an object previously retrieved from the\n * Model\n * @return {Model} - the dereferenced {@link Model}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref([\"usersById\", 32])\n    ],\n    usersById: {\n      32: {\n        name: \"Steve\",\n        surname: \"McGuire\"\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// [\"usersById\", 32] - because userModel refers to target of reference at [\"users\", 0]\n */\nModel.prototype.deref = requireDeref();\n\n/**\n * A dereferenced model can become invalid when the reference from which it was\n * built has been removed/collected/expired/etc etc.  To fix the issue, a from\n * the parent request should be made (no parent, then from the root) for a valid\n * path and re-dereference performed to update what the model is bound too.\n *\n * @method\n * @private\n * @return {Boolean} - If the currently deref'd model is still considered a\n * valid deref.\n */\nModel.prototype._hasValidParentReference = requireHasValidParentReference();\n\n/**\n * Get data for a single {@link Path}.\n * @param {Path} path - the path to retrieve\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new HttpDataSource(\"/model.json\") });\n\n model.\n     getValue('user.name').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints \"Jim\" to the console.\n */\nModel.prototype.getValue = requireGetValue();\n\n/**\n * Set value for a single {@link Path}.\n * @param {Path} path - the path to set\n * @param {Object} value - the value to set\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new HttpDataSource(\"/model.json\") });\n\n model.\n     setValue('user.name', 'Jim').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints \"Jim\" to the console.\n */\nModel.prototype.setValue = requireSetValue();\n\n// TODO: Does not throw if given a PathSet rather than a Path, not sure if it should or not.\n// TODO: Doc not accurate? I was able to invoke directly against the Model, perhaps because I don't have a data source?\n// TODO: Not clear on what it means to \"retrieve objects in addition to JSONGraph values\"\n/**\n * Synchronously retrieves a single path from the local {@link Model} only and will not retrieve missing paths from the {@link DataSource}. This method can only be invoked when the {@link Model} does not have a {@link DataSource} or from within a selector function. See {@link Model.prototype.get}. The getValueSync method differs from the asynchronous get methods (ex. get, getValues) in that it can be used to retrieve objects in addition to JSONGraph values.\n * @method\n * @private\n * @arg {Path} path - the path to retrieve\n * @return {*} - the value for the specified path\n */\nModel.prototype._getValueSync = requireSync$2();\n\n/**\n * @private\n */\nModel.prototype._setValueSync = requireSync$1();\n\n/**\n * @private\n */\nModel.prototype._derefSync = requireSync();\n\n/**\n * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.\n * @param {JSONGraph} jsonGraph - the {@link JSONGraph} fragment to use as the local cache\n */\nModel.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {\n    var cache = this._root.cache;\n    if (cacheOrJSONGraphEnvelope !== cache) {\n        var modelRoot = this._root;\n        var boundPath = this._path;\n        this._path = [];\n        this._root.cache = {};\n        if (typeof cache !== \"undefined\") {\n            collectLru(modelRoot, modelRoot.expired, getSize(cache), 0);\n        }\n        var out;\n        if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {\n            out = setJSONGraphs(this, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {\n            out = setCache(this, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isObject(cacheOrJSONGraphEnvelope)) {\n            out = setCache(this, [{ json: cacheOrJSONGraphEnvelope }])[0];\n        }\n\n        // performs promotion without producing output.\n        if (out) {\n            get.getWithPathsAsPathMap(this, out, []);\n        }\n        this._path = boundPath;\n    } else if (typeof cache === \"undefined\") {\n        this._root.cache = {};\n    }\n    return this;\n};\n\n/**\n * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.\n * @param {...Array.<PathSet>} [pathSets] - The path(s) to retrieve. If no paths are specified, the entire {@link JSONGraph} is returned.\n * @return {JSONGraph} all of the {@link JSONGraph} data in the {@link Model} cache.\n * @example\n // Storing the boxshot of the first 10 titles in the first 10 genreLists to local storage.\n localStorage.setItem('cache', JSON.stringify(model.getCache(\"genreLists[0...10][0...10].boxshot\")));\n */\nModel.prototype.getCache = function _getCache() {\n    var paths = Array.prototype.slice.call(arguments);\n    if (paths.length === 0) {\n        return getCache(this._root.cache);\n    }\n\n    var result = [{}];\n    var path = this._path;\n    get.getWithPathsAsJSONGraph(this, paths, result);\n    this._path = path;\n    return result[0].jsonGraph;\n};\n\n/**\n * Reset cache maxSize. When the new maxSize is smaller than the old force a collect.\n * @param {Number} maxSize - the new maximum cache size\n */\nModel.prototype._setMaxSize = function setMaxSize(maxSize) {\n    var oldMaxSize = this._maxSize;\n    this._maxSize = maxSize;\n    if (maxSize < oldMaxSize) {\n        var modelRoot = this._root;\n        var modelCache = modelRoot.cache;\n        // eslint-disable-next-line no-cond-assign\n        var currentVersion = modelCache.$_version;\n        collectLru(\n            modelRoot,\n            modelRoot.expired,\n            getSize(modelCache),\n            this._maxSize,\n            this._collectRatio,\n            currentVersion\n        );\n    }\n};\n\n/**\n * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.\n * @param {Path?} path - a path at which to retrieve the version number\n * @return {Number} a version number which changes whenever a value is changed underneath the Model or provided Path\n */\nModel.prototype.getVersion = function getVersion(pathArg) {\n    var path = (pathArg && pathSyntax.fromPath(pathArg)) || [];\n    if (Array.isArray(path) === false) {\n        throw new Error(\"Model#getVersion must be called with an Array path.\");\n    }\n    if (this._path.length) {\n        path = this._path.concat(path);\n    }\n    return this._getVersion(this, path);\n};\n\nModel.prototype._syncCheck = function syncCheck(name) {\n    if (Boolean(this._source) && this._root.syncRefCount <= 0 && this._root.unsafeMode === false) {\n        throw new Error(\"Model#\" + name + \" may only be called within the context of a request selector.\");\n    }\n    return true;\n};\n\n/* eslint-disable guard-for-in */\nModel.prototype._clone = function cloneModel(opts) {\n    var clone = new this.constructor(this);\n    for (var key in opts) {\n        var value = opts[key];\n        if (value === \"delete\") {\n            delete clone[key];\n        } else {\n            clone[key] = value;\n        }\n    }\n    clone.setCache = void 0;\n    return clone;\n};\n/* eslint-enable */\n\n/**\n * Returns a clone of the {@link Model} that enables batching. Within the configured time period,\n * paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching\n * can be more efficient if the {@link DataSource} access the network, potentially reducing the\n * number of HTTP requests to the server.\n *\n * @param {?Scheduler|number} schedulerOrDelay - Either a {@link Scheduler} that determines when to\n * send a batch to the {@link DataSource}, or the number in milliseconds to collect a batch before\n * sending to the {@link DataSource}. If this parameter is omitted, then batch collection ends at\n * the end of the next tick.\n * @return {Model} a Model which schedules a batch of get requests to the DataSource.\n */\nModel.prototype.batch = function batch(schedulerOrDelay) {\n    var scheduler;\n    if (typeof schedulerOrDelay === \"number\") {\n        scheduler = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));\n    } else if (!schedulerOrDelay || !schedulerOrDelay.schedule) {\n        scheduler = new TimeoutScheduler(1);\n    } else {\n        scheduler = schedulerOrDelay;\n    }\n\n    var clone = this._clone();\n    clone._request = new RequestQueue(clone, scheduler);\n\n    return clone;\n};\n\n/**\n * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.\n * @name unbatch\n * @memberof Model.prototype\n * @function\n * @return {Model} a {@link Model} that batches requests of the same type and sends them to the data source together\n */\nModel.prototype.unbatch = function unbatch() {\n    var clone = this._clone();\n    clone._request = new RequestQueue(clone, new ImmediateScheduler());\n    return clone;\n};\n\n/**\n * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.\n * @return {Model}\n */\nModel.prototype.treatErrorsAsValues = function treatErrorsAsValues() {\n    return this._clone({\n        _treatErrorsAsValues: true\n    });\n};\n\n/**\n * Adapts a Model to the {@link DataSource} interface.\n * @return {DataSource}\n * @example\nvar model =\n    new falcor.Model({\n        cache: {\n            user: {\n                name: \"Steve\",\n                surname: \"McGuire\"\n            }\n        }\n    }),\n    proxyModel = new falcor.Model({ source: model.asDataSource() });\n\n// Prints \"Steve\"\nproxyModel.getValue(\"user.name\").\n    then(function(name) {\n        console.log(name);\n    });\n */\nModel.prototype.asDataSource = function asDataSource() {\n    return new ModelDataSourceAdapter(this);\n};\n\nModel.prototype._materialize = function materialize() {\n    return this._clone({\n        _materialized: true\n    });\n};\n\nModel.prototype._dematerialize = function dematerialize() {\n    return this._clone({\n        _materialized: \"delete\"\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.\n * @return {Model}\n */\nModel.prototype.boxValues = function boxValues() {\n    return this._clone({\n        _boxed: true\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.\n * @return {Model}\n */\nModel.prototype.unboxValues = function unboxValues() {\n    return this._clone({\n        _boxed: \"delete\"\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.\n * @return {Model}\n */\nModel.prototype.withoutDataSource = function withoutDataSource() {\n    return this._clone({\n        _source: \"delete\"\n    });\n};\n\nModel.prototype.toJSON = function toJSON() {\n    return {\n        $type: \"ref\",\n        value: this._path\n    };\n};\n\n/**\n * Returns the {@link Path} to the object within the JSON Graph that this Model references.\n * @return {Path}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref([\"usersById\", 32])\n    ],\n    usersById: {\n      32: {\n        name: \"Steve\",\n        surname: \"McGuire\"\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// [\"usersById\", 32] - because userModel refers to target of reference at [\"users\", 0]\n */\nModel.prototype.getPath = function getPath() {\n    return this._path ? this._path.slice() : this._path;\n};\n\n/**\n * This one is actually private.  I would not use this without talking to\n * jhusain, sdesai, or michaelbpaulson (github).\n * @private\n */\nModel.prototype._fromWhenceYouCame = function fromWhenceYouCame(allow) {\n    return this._clone({\n        _allowFromWhenceYouCame: allow === undefined ? true : allow\n    });\n};\n\nModel.prototype._getBoundValue = requireGetBoundValue();\nModel.prototype._getVersion = requireGetVersion();\n\nModel.prototype._getPathValuesAsPathMap = get.getWithPathsAsPathMap;\nModel.prototype._getPathValuesAsJSONG = get.getWithPathsAsJSONGraph;\n\nModel.prototype._setPathValues = requireSetPathValues();\nModel.prototype._setPathMaps = setPathMaps;\nModel.prototype._setJSONGs = setJSONGraphs$3;\nModel.prototype._setCache = setPathMaps;\n\nModel.prototype._invalidatePathValues = requireInvalidatePathSets();\nModel.prototype._invalidatePathMaps = requireInvalidatePathMaps();\n\nfunction falcor(opts) {\n    return new falcor.Model(opts);\n}\n\n/**\n * A filtering method for keys from a falcor json response.  The only gotcha\n * to this method is when the incoming json is undefined, then undefined will\n * be returned.\n *\n * @public\n * @param {Object} json - The json response from a falcor model.\n * @returns {Array} - the keys that are in the model response minus the deref\n * _private_ meta data.\n */\nfalcor.keys = function getJSONKeys(json) {\n    if (!json) {\n        return undefined;\n    }\n\n    return Object.\n        keys(json).\n        filter(function(key) {\n            return key !== \"$__path\";\n        });\n};\n\nvar lib = falcor;\n\nfalcor.Model = Model_1;\n\nvar index = /*@__PURE__*/getDefaultExportFromCjs(lib);\n\nexport { index as falcor };\n", "export function extractFromCache ({ obj, path, idx = 0, root = obj, parentAtom, verbose }) {\n  if (verbose) {\n    console.log({ obj, path, idx })\n  }\n\n  if (obj && obj.$type === 'atom' && path.length - idx !== 0) {\n    const step = path[idx]\n    if (obj.value === undefined) {\n      return { value: undefined, parentAtom, $type: obj.$type }\n    }\n    return extractFromCache({ obj: obj.value[step], path, idx: idx + 1, root, parentAtom: { obj, relPath: path.slice(idx)}, verbose })\n  } else if (obj && obj.$type === 'ref') {\n    const newPath = obj.value.concat(path.slice(idx))\n    return extractFromCache({ obj: root, path: newPath, verbose })\n  } else if (path.length - idx === 0) {\n    if (obj && obj.$type === 'error') {\n      return { value: undefined, parentAtom, $type: obj.$type }\n    } else if (obj && obj.$type) {\n      return { value: obj.value, parentAtom, $type: obj.$type }\n    } else {\n      return { value: obj, parentAtom }\n    }\n  } else if (obj === null || obj === undefined) {\n    return { value: obj, parentAtom }\n  } else {\n    const step = path[idx]\n    return extractFromCache({ obj: obj[step], path, idx: idx + 1, root, verbose })\n  }\n}\n\nexport function getJsonPath (obj, path) {\n  if (obj === undefined) {\n    return\n  }\n  let current = obj\n\n  for (let i = 0; i < path.length; i++) {\n    if (current[path[i]] === undefined) {\n      return\n    }\n    current = current[path[i]]\n  }\n\n  return current\n}\n\nexport function setPathValue (o, [head, ...tail], newValue, root) {\n  if (!root) {\n    o = structuredClone(o)\n    root = o\n  }\n  if (tail.length) {\n    if (!o[head]) {\n      o[head] = {}\n    }\n\n    setPathValue(o[head], tail, newValue, root)\n  } else {\n    o[head] = newValue\n    return root\n  }\n}\n\nexport function diffCache (data, model, path = []) {\n  let changes = []\n\n  Object.entries(data).forEach(([key, newProp]) => {\n    const subPath = [...path, key]\n    const newVer = model.getVersion(subPath)\n\n    const oldProp = ntr.app.get(pathString)\n\n    if (typeof oldProp === 'undefined') {\n      newProp.$_version = newVer\n      changes.push([subPath, newProp])\n    } else if (newVer === -1 || newVer !== oldProp.$_version) {\n      if (newProp.$type === 'atom') {\n        if (!(typeof newProp.value === 'undefined' && typeof oldProp.value === 'undefined')) {\n          if (!newProp.value || !oldProp.value || !newProp.value._rev || newProp.value._rev !== oldProp.value._rev) {\n            newProp.$_version = newVer\n            changes.push([subPath, newProp])\n          }\n        }\n      } else if (newProp.$type === 'ref') {\n        if (!(newProp.value && oldProp.value && newProp.value[0] === 'byId' && newProp.value[1] === oldProp.value[1])) {\n          newProp.$_version = newVer\n          changes.push([subPath, newProp])\n        }\n      } else if (key === 'length') {\n        if (newProp !== oldProp) {\n          changes.push([subPath, newProp])\n        }\n      } else {\n        changes = changes.concat(diffCache(newProp, model, subPath))\n      }\n    }\n  })\n  return changes\n}\n", "/* eslint-disable functional/no-this-expression */\n/* eslint-disable functional/no-class */\nimport { makeRouter, toFalcorRoutes } from './falcor-router.js'\nimport { falcor } from '/_ayu/build/deps/falcor.js'\nimport { extractFromCache } from '../store/helpers.js'\n\nclass WorkerServer {\n  constructor (dataSource) {\n    this.dataSource = dataSource\n  }\n\n  execute (action) {\n    const method = action[1]\n    const jsonGraphEnvelope = action[2] // or\n    const callPath = action[2]\n    const args = action[3] || []\n    const pathSuffixes = action[4] || []\n\n    let paths\n    switch (method) {\n      case 'get':\n        paths = action[2]\n        return this.dataSource.get(paths)._toJSONG()\n      case 'set':\n        return this.dataSource.set(jsonGraphEnvelope)._toJSONG()\n      case 'call':\n        paths = action[5] || []\n        return this.dataSource.call(callPath, args, pathSuffixes, paths)._toJSONG()\n    }\n  }\n}\n\n// TODO: userId, additional dataSources\nexport default function ({\n  schema,\n  dbs,\n  session\n}) {\n  const FalcorRouter = makeRouter(toFalcorRoutes(schema))\n  const routerInstance = new FalcorRouter({ dbs, session })\n\n  const serverModel = falcor({\n    source: routerInstance,\n    maxSize: 500000,\n    collectRatio: 0.75,\n    maxRetries: 1\n  })\n    .batch()\n    .boxValues()\n\n  routerInstance.model = serverModel.withoutDataSource()\n  routerInstance.model.getPageKey = function (path, from) {\n    const listCache = extractFromCache({ path, obj: this._root.cache })\n\n    for (let index = from; index > 0; index--) {\n      if (listCache.value?.[index]?.$pageKey !== undefined) {\n        return { pageKey: listCache.value[index].$pageKey, index }\n      }\n    }\n    return { index: 0 }\n  }\n\n  const dataSource = serverModel.asDataSource()\n\n  const workerServer = new WorkerServer(dataSource)\n\n  return workerServer\n}\n", "export function addPathTags (paths, tags) {\n  if (typeof tags === 'string') {\n    tags = [ tags ]\n  }\n\n  Object.values(paths).forEach(pathConf => {\n    if (tags.includes('window') && !pathConf.get) {\n      pathConf.get = {}\n    }\n\n    const methodConfs = Object.values(pathConf).filter(conf => typeof conf === 'object')\n\n    methodConfs.forEach(conf => {\n      tags.forEach(tag => {\n        if (!conf.tags) {\n          conf.tags = [tag]\n        } else if (!conf.tags.includes(tag)) {\n          conf.tags.push(tag)\n        }\n      })\n    })\n  })\n\n  return paths\n}\n", "// example working : )\n// 'test.pest': { // test if wildcard like path handling works\n//   get: {\n//     handler: async ({ dbs, titleRanges }) => {\n//       return [{ path: ['test', 'pest', 'x', 'y'], value: 1 }]\n//     }\n//   }\n// },\n// TODO migrate to box shorthand :  {$atom: somevalue}, {$ref: [1, 'b', 'd'}, {$error: 'error 1 occured'}\n\nexport default {\n  '_sync': {\n    call: {\n      operationId: '_sync'\n    }\n  },\n\n  '_users': {\n    get: {\n      handler: async ({ dbs, session: { org, userId } }) => {\n        const { rows: sessions } = await dbs.couch.query(`ayu_main/by_type_and_title`, {\n          partition: 'system',\n          reduce: false,\n          include_docs: true,\n          startkey: [ 'session' ],\n          endkey: ['session', {}]\n        })\n\n        const users = sessions.map(row => row.doc).sort((a, b) => b.lastLogin - a.lastLogin).reduce((agg, session) => {\n          if (!agg[session.title]) {\n            agg[session.title] = session\n            agg[session.title].numSessions = 1\n          } else {\n            agg[session.title].numSessions += 1\n          }\n          return agg\n        }, {})\n\n        return {\n          jsonGraph: {\n            _users: { $type: 'atom', value: Object.values(users) }\n          }\n        }\n      }\n    }\n  },\n\n  '_sessions': {\n    get: {\n      handler: async ({ dbs, session: { org, userId } }) => {\n        const sessionName = userId + (org ? ` (${org})` : '')\n\n        const { rows: sessions } = await dbs.couch.query(`ayu_main/by_type_and_title`, {\n          partition: 'system',\n          reduce: false,\n          include_docs: true,\n          startkey: [ 'session', sessionName],\n          endkey: ['session', sessionName, {}]\n        })\n\n        return {\n          jsonGraph: {\n            _sessions: { $type: 'atom', value: sessions.map(row => row.doc).sort((a, b) => b.lastLogin - a.lastLogin) }\n          }\n        }\n      }\n    }\n  },\n\n  '_pouch': {\n    get: {\n      handler: async ({ dbs }) => {\n        return {\n          jsonGraph: {\n            _pouch: { $type: 'atom', value:  await dbs.pouch.info() }\n          }\n        }\n      }\n    }\n  },\n  '_couch': {\n    get: {\n      handler: async ({ dbs }) => {\n        return {\n          jsonGraph: {\n            _couch: { $type: 'atom', value:  await dbs.couch?.info?.() }\n          }\n        }\n      }\n    }\n  },\n\n  // // fetch(`/_api/_couch/${loggedInDbName}/${session.sessionId}`)\n  '_session[{keys:keys}]': {\n    get: {\n      handler: ({ _keys, session }) => {\n        return {\n          jsonGraph: {\n            _session: session\n          }\n        }\n      }\n    }\n  },\n\n  '_hash': {\n    get: {\n      handler: () => {\n        return {\n          jsonGraph: {\n            _hash: { $type: 'atom', value: self.ipfsHash }\n          }\n        }\n      }\n    }\n  },\n  '_updating': {\n    get: {\n      handler: () => {\n        return {\n          jsonGraph: {\n            _updating: self.updating\n          }\n        }\n      }\n    },\n    set: {\n      handler: ({_updating, model}) => {\n        self.updating = _updating\n        model.invalidate('_hash')\n        return {\n          jsonGraph: {\n            _updating\n          }\n        }\n      }\n    }\n  },\n  // '_changes.length': {\n  //   get: {\n  //     handler: async ({ dbs }) => {\n  //       const pouchRes = await dbs.pouch.info()\n  //       return { path: ['_changes', 'length'], value: pouchRes.update_seq }\n  //     }\n  //   }\n  // },\n  // '_changes': {\n  //   get: {\n  //     handler: ({ _ids, _keys, _dbs }) => {\n  //       consoe.log('fixme')\n  //       // const _pouchRes = await db.allDocs({\n  //       //   include_docs: true,\n  //       //   conflicts: true,\n  //       //   keys: ids\n  //       // })\n  //     }\n  //   }\n  // },\n  '_docs.create': {\n    call: {\n      handler: async ({ dbs, session, _Observable }, [ docs ]) => {\n        if (!Array.isArray(docs)) {\n          docs = [docs]\n        }\n        const result = await dbs.pouch.bulkDocs(docs.map(doc => {\n          if (!doc._id) {\n            // FIXME: uuid\n            doc._id = `${Math.floor(Math.random() * 1000)}:${Math.floor(Math.random() * 1000000000)}`\n          }\n          doc.changes = [{ userId: session.userId, action: 'created', date: Date.now() }]\n          return doc\n        }))\n\n        return result.map((_doc, i) => {\n          return { path: ['_docs', docs[i]._id], value: docs[i] } // { $type: 'atom', value:\n        })\n      }\n    }\n  },\n  // this route handles subkey upsert and subset key requests\n  // '_docs[{keys:ids}][{keys:keys}]': {\n  //   set: {\n  //     handler: async ({ _docs, db, _userId, keys, ids }) => {\n  //       console.log(_docs, keys, ids)\n  //       const result = await db.bulkDocs(Object.values(_docs).map(({value}) => {\n  //         if (!value.changes) {\n  //           value.changes = []\n  //         }\n  //         if (value.deleted) {\n  //           value.changes.push({ userId: session.userId, action: 'deleted',  date: Date.now() })\n  //         } else if (!value._rev) {\n  //           value.changes.push({ userId: session.userId, action: 'created',  date: Date.now() })\n  //         } else {\n  //           value.changes.push({ userId: session.userId, action: 'updated',  date: Date.now() })\n  //         }\n  //         return value\n  //       }))\n  //       result.forEach(res => {\n  //         if (res.ok) {\n  //           _docs[res.id].value._rev = res.rev\n  //         } else {\n  //           console.error('set doc error', res)\n  //         }\n  //       })\n  //       return  {\n  //         jsonGraph: {\n  //           _docs\n  //         }\n  //       }\n  //     }\n  //   },\n  //   get: {\n  //     handler: async ({ ids, keys, db }) => {\n  //       console.log( keys, ids)\n  //       const pouchRes = await db.allDocs({\n  //         include_docs: true,\n  //         conflicts: true,\n  //         keys: ids\n  //       })\n  //       // console.log(ids, pouchRes)\n  //       const missingIds = []\n  //       const _docs = {}\n  //       pouchRes.rows.forEach(row => {\n  //         if (row.error === 'not_found') {\n  //           missingIds.push(row.key)\n  //         } else if (!row.error) {\n  //           if (row.doc) {\n  //             _docs[row.key] = { $type: 'atom', value: row.doc }\n  //             if (row.doc.type) {\n  //               _docs[row.key].$schema = { $ref: row.doc.type }\n  //             } else if (row.doc.types?.length === 1) {\n  //               _docs[row.key].$schema = { $ref: row.doc.types[0].profile }\n  //             } else if (row.doc.types?.length > 1) {\n  //               _docs[row.key].$schema = { anyOf: _row.doc.types.map(type => {$ref: type.profile}) }\n  //             }\n  //           } else {\n  //             console.warn(row)\n  //           }\n  //         } else {\n  //           console.error(row)\n  //         }\n  //       })\n  //       return {\n  //         jsonGraph: {\n  //           _docs\n  //         }\n  //       }\n  //     }\n  //   }\n  // },\n\n  '_docs[{keys:ids}]': {\n    get: {\n      operationId: 'getDocs'\n    },\n    set: {\n      handler: async ({ _docs, dbs, session }) => {\n        const result = await dbs.pouch.bulkDocs(Object.values(_docs).map(({ value }) => {\n          if (!value.changes) {\n            value.changes = []\n          }\n\n          if (value.changes.length > 12) {\n            value.changes.splice(2, value.changes.length - 4)\n            value.changes.push({ userId: session.userId, action: 'aggregated', date: Date.now() })\n          }\n\n          if (value.deleted) {\n            value.changes.push({ userId: session.userId, action: 'deleted', date: Date.now() })\n          } else if (!value._rev) {\n            value.changes.push({ userId: session.userId, action: 'created', date: Date.now() })\n          } else {\n            value.changes.push({ userId: session.userId, action: 'updated', date: Date.now() })\n          }\n\n          return value\n        }))\n\n        // todo: handle errors\n        result.forEach(res => {\n          if (res.ok) {\n            _docs[res.id].value._rev = res.rev\n          } else {\n            console.error('set doc error', res)\n          }\n        })\n\n        return {\n          jsonGraph: {\n            _docs\n          }\n        }\n      }\n    }\n  }\n}\n", "export default {\n  '/(#/):_page(/:_subPage)(/*_)': {}\n}\n", "import falcorPaths from './falcor-paths.js'\nimport windowPaths from './window-paths.js'\n\nimport { addPathTags } from './helpers.js'\n\n//  TODO: normalize leading slashes warn or auto handle missing leading slashes\n// TODO: support * methods?\n\nexport default {\n  ...addPathTags(falcorPaths, 'falcor'),\n  ...addPathTags(windowPaths, 'window'),\n\n  '/*': {\n    get: {\n      tags: [ 'edge', 'service-worker' ],\n      operationId: '_ipfs'\n    }\n  },\n\n  // '/_debug': {\n  //   get: {\n  //     tags: [ 'edge' ],\n  //     operationId: '_debug'\n  //   }\n  // },\n  // codespace support TODO: remove\n  // '/signin*': {\n  //   get: {\n  //     operationId: '_bypass'\n  //   }\n  // },\n\n  // TODO: not required anymore?\n  // '/_ayu/accounts*': {\n  //   get: {\n  //     operationId: '_bypass' // '_accounts'\n  //   }\n  // },\n\n  // '/_api/_feed/*': {\n  //   get: {\n  //     tags: [ 'edge' ],\n  //     operationId: '_feed'\n  //   }\n  // },\n\n  '/_api/_session*': {\n    get: {\n      tags: [ 'edge' ],\n      operationId: '_session'\n    },\n    post: {\n      tags: [ 'edge' ],\n      operationId: '_session'\n    },\n    delete: {\n      tags: [ 'edge' ],\n      operationId: '_session'\n    }\n  },\n  '/_api/_couch/*': {\n    get: {\n      tags: [ 'edge' ],\n      operationId: '_couch'\n    },\n    put: {\n      tags: [ 'edge' ],\n      operationId: '_couch'\n    },\n    post: {\n      tags: [ 'edge' ],\n      operationId: '_couch'\n    },\n    options: {\n      tags: [ 'edge' ],\n      operationId: '_couch'\n    }\n  },\n  // cloudflare access support\n  '/cdn-cgi/access*': {\n    get: {\n      tags: [ 'service-worker' ],\n      operationId: '_bypass'\n    }\n  }\n}\n", "import makePouch from './make-pouch.js'\nimport makeFalcorServer from './falcor-server.js'\nimport { escapeId } from '../lib/helpers.js'\nimport { addPathTags } from '../schema/helpers.js'\nimport defaultPaths from '../schema/default-routes.js'\n\n// TODO: support addtional dataSources\nexport default function ({\n  dbConf = {},\n  dataSources,\n  schema,\n  onChange,\n  clientDbSeeds,\n  localOnly = false\n} = {}) {\n  if (dataSources) {\n    console.warn('Additional data sources not implemented yet.')\n  }\n  // TODO: gobally precompile schema on build time\n  if (typeof schema === 'function') {\n    schema = schema({ defaultPaths, addPathTags })\n  } else if (schema) {\n    schema.paths = { ...defaultPaths, ...schema.paths }\n  }\n\n  // we use an asynchronous updating object reference to do async initialisation in a synchronous function, this is not really nice practice, but is currently the most performant way to start the service worker without big refactor\n  // TODO: clean recreatino of falcor and all session dependent modules\n\n  self.session = {\n    loaded: false,\n    pendingInit: null,\n    value: null,\n    dbs: null,\n    falcorServer: null,\n\n    clear () {\n      self.session.value = null\n      self.session.falcorServer = null // TODO: check if needs destroy or cleanup\n      self.session.dbs?.clear()\n      self.session.dbs = null\n      self.session.loaded = false\n    },\n\n    async logout () {\n      self.session.clear()\n\n      const clientsRes = await clients.matchAll()\n      const logoutNavs = clientsRes.map(client => {\n        const url = new URL(client.url)\n        let cont = ''\n        if (url.pathname.length > 1 || url.hash) {\n          cont = `&continue=${encodeURIComponent(url.pathname + url.hash)}`\n        }\n\n        return client.postMessage(`navigate:/_api/_session?logout${cont}`)\n        // client.navigate().catch(err => console.error(err))\n      })\n\n      await Promise.all(logoutNavs)\n    },\n\n    async refresh () {\n      let redirectOtherClients = null\n      let newSession\n\n      try {\n        if (localOnly) {\n          newSession = { sessionId: 'ephemeral:localOnlySession', userId: 'anonymous', env: 'dev', appName: 'ayuApp' } // appName, org\n        } else {\n          const sessionReq = await fetch('/_api/_session', {\n            redirect: 'error',\n            headers: {\n              'X-Requested-With': 'XMLHttpRequest'\n            }\n          }).catch(error => ({ ok: false, error }))\n          if (sessionReq.ok) {\n            newSession = await sessionReq.json()\n          }\n        }\n\n        if (!newSession?.userId || !newSession?.sessionId) {\n          self.session.clear()\n          redirectOtherClients = 'logout'\n        } else if (newSession.userId !== self.session.value?.userId || newSession.sessionId !== self.session.value?.sessionId) {\n          self.session.clear()\n\n          // FIXME: this formmat and flow is awkward leftover from supporting any number of client dbs per user (now only one)\n          let newDbConf\n          if (typeof dbConf === 'function') {\n            newDbConf = dbConf({ userId: newSession.userId, appName: newSession.appName, env: newSession.env, escapeId, org: newSession.org })\n          } else {\n            newDbConf = dbConf\n          }\n\n          // (pouchdb prefix already ayu_)\n          const clientDbName = escapeId(newSession.userId + '__' + newSession.env + '__' + newSession.appName + ( newSession.org ? '__' + newSession.org : '__'))\n          const serverDbName = 'ayu_' + (newSession.env === 'prod' ? escapeId(newSession.appName) : escapeId(newSession.env + '__' + newSession.appName))\n\n          self.session.dbs = await makePouch({\n            localOnly,\n            clientDbSeeds,\n            clientDbName,\n            serverDbName,\n            sessionId: newSession.sessionId,\n            preload: newDbConf.preload,\n            clientDesignDocs: newDbConf[clientDbName]\n          })\n\n          // console.log('making falcor server')\n          self.session.falcorServer = makeFalcorServer({ dbs: self.session.dbs, schema, session: newSession })\n\n          if (newSession.userId && !self.session.loaded) {\n            redirectOtherClients = 'continue'\n          }\n        }\n\n        self.session.value = newSession\n\n        if (redirectOtherClients) {\n          const clientsRes = await clients.matchAll()\n\n          const clientNavigations = clientsRes.map(client => {\n            const url = new URL(client.url)\n            const query = new URLSearchParams(url.search)\n            if (redirectOtherClients === 'continue') {\n              if (url.pathname.startsWith('/_ayu/accounts')) {\n                const navMessage = 'navigate:' + (query.get('continue') || '/')\n                client.postMessage(navMessage)\n                client._ayu_lastNavMessage = navMessage\n                return waitForNavigation(client)\n                // client.navigate().catch(err => console.error(err))\n              }\n            } else {\n              let cont = ''\n              if (url.pathname.length > 1 || url.hash || url.search > 0) {\n                if (query.get('continue')) {\n                  cont = `continue=${query.get('continue')}`\n                } else {\n                  cont = `continue=${encodeURIComponent(url.pathname + url.search + url.hash)}`\n                }\n              }\n              if (!url.pathname.startsWith('/_ayu/accounts') && !url.pathname.startsWith('/_api/_session?login')) {\n                const url = `/_ayu/accounts/?${cont}` // `/_api/_session?login${cont}`\n                console.log('redirecting client', url, newSession, client)\n\n                client.postMessage('navigate:' + url)\n                return waitForNavigation(client)\n                // after safari support: client.navigate().catch(err => console.error(err))\n              }\n            }\n          })\n\n          await Promise.all(clientNavigations)\n        }\n        self.session.loaded = true\n      } catch (err) {\n        console.error(err)\n      }\n\n      self.session.pendingInit = null\n      return newSession\n    }\n  }\n\n  console.log('starting service worker...' + new Date().toGMTString())\n\n  clients.matchAll().then(res => {\n    // send clients hello message on startup to know pending requests need to be restarted\n    res.forEach(client => client.postMessage(JSON.stringify({ hello: 'joe' })))\n  })\n\n  // just assume the client navigated away if the id disappears\n  async function waitForNavigation (targetClient, tries = 20) {\n    const curClients = await clients.matchAll()\n    // console.log(curClients.map(e => ([e.id, e.url])), targetClient.id, targetClient.url, tries)\n\n    if (curClients.find(client => client.id === targetClient.id)) {\n      if (tries) {\n        await (new Promise(resolve => setTimeout(resolve, 500)))\n        return waitForNavigation(targetClient, tries - 1)\n      } else {\n        console.error('could not navigate client ', targetClient)\n        return false\n      }\n    }\n    return true\n  }\n\n  const pending = {}\n  function purgeClients () {\n    clients.matchAll().then(res => {\n      Object.keys(pending).forEach(clientId => {\n        if (!res.find(el => el.id === clientId)) {\n          console.log(clientId, 'disappeared')\n          Object.entries(pending[clientId]).forEach(([reqId, exec]) => {\n            exec?.unsubscribe?.()\n            exec?.dispose()\n            delete pending[clientId][reqId]\n          })\n\n          delete pending[clientId]\n        }\n      })\n    })\n  }\n  setInterval(purgeClients, 2000)\n\n  // .addEventListener('offline', e => {\n  //   console.log('offline', e)\n  // })\n  // .addEventListener('online', e => {\n  //   console.log('online', e)\n  // })\n  // self.addEventListener('periodicsync', (event) => {\n  //   console.log(event)\n  // })\n  // self.addEventListener('sync', event => {\n  //   console.log(event)\n  // })\n  // navigator.serviceWorker.ready.then(swRegistration => {\n  //   return swRegistration.sync.register('myFirstSync')\n  // })\n\n  addEventListener('message', async e => {\n    // TODO either expl. split refresh() into login and db / falcor setup or merge this behind one call + await\n    if (self.session.pendingInit) {\n      await self.session.pendingInit\n    }\n    if ((!self.session.loaded || !self.session.value?.userId) && !self.session.pendingInit) {\n      self.session.pendingInit = self.session.refresh()\n      await self.session.pendingInit\n    }\n    if (!self.session.falcorServer && !self.session.pendingInit) {\n      self.session.pendingInit = self.session.refresh()\n      await self.session.pendingInit\n    }\n    if (self.session.pendingInit) {\n      await self.session.pendingInit\n    }\n\n    const data = JSON.parse(e.data)\n    const clientId = e.source.id\n    const reqId = data[0]\n\n    if (!pending[clientId]) {\n      pending[clientId] = {}\n    }\n\n    if (reqId === -1) {\n      // ignore hello message and heartbeat\n      return\n    }\n\n    if (!self.session.falcorServer) {\n      // really logged out not just expired or not fully inited\n      //   self.session.refresh()\n      return e.source.postMessage(JSON.stringify({ id: reqId, error: 'logged out / no falcor server session active' }))\n    }\n\n    const exec = self.session.falcorServer.execute(data)\n      .subscribe(\n        result => {\n          if (data[1] === 'call' && data[2]?.[0] === '_sync') {\n            onChange?.({\n              model: self.session.falcorServer.dataSource._model,\n              data: result.json,\n              _where: 'service-worker'\n            })\n          }\n          e.source.postMessage(JSON.stringify({ id: reqId, value: result }))\n        },\n        error => {\n          // allreadcy logged as error before console.log('falcor error in executer', error)\n          e.source.postMessage(JSON.stringify({ id: reqId, error }))\n        },\n        async _done => {\n          await e.source.postMessage(JSON.stringify({ id: reqId, done: true }))\n          exec?.unsubscribe?.()\n          exec?.dispose()\n          delete pending[clientId][reqId]\n        }\n      )\n    pending[clientId][reqId] = exec\n  })\n\n  addEventListener('install', () => {\n    console.log('worker installing, skip waiting')\n    skipWaiting()\n  })\n\n  addEventListener('activate', event => {\n    console.log('worker activating, claiming clients')\n    event.waitUntil(clients.claim().then(() => {\n      clients.matchAll().then(res => {\n        res.forEach(client => client.postMessage(JSON.stringify({ worker: 'active' })))\n      })\n    }))\n  })\n}\n"],
  "mappings": "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",
  "names": ["n", "a", "d", "t", "len", "timeout", "i", "module", "s", "from", "result", "hex", "ReflectApply", "ReflectOwnKeys", "NumberIsNaN", "events", "er", "listeners", "w", "keys", "index", "once", "self", "e", "info", "batch", "onError", "range", "error", "reason", "filter", "req", "ee", "comparator", "root", "queue", "l", "opts", "key", "err", "incompatibleOpt", "PouchDB", "match", "prefix", "matcher", "fields", "field", "isArray", "collationIndex", "re", "clone", "src", "version", "openDatabases", "idbChanges", "txn", "docs", "returnVal", "callback", "setup", "v", "dbUrl", "changes", "map", "emit", "localDocName", "mapper", "reducer", "ddocValidator", "readAttachmentsAsBlobOrBuffer", "response", "metaDoc", "res", "processChange", "purge", "doc", "progress", "mapResults", "values", "S", "T", "removeListener", "preload", "sync", "getAugmentedNamespace", "n", "a", "d", "root", "result", "Symbol", "require$$0", "e", "error", "observable", "EsObservable", "onError", "BaseObservable", "Subscription", "onNext", "onCompleted", "commonjsGlobal", "getDefaultExportFromCjs", "getAugmentedNamespace", "n", "a", "d", "onRange", "onKey", "reducer", "range", "i", "len", "convertPathKeyTo", "index", "convertPathToRoute", "slice", "tokenizer", "from", "quote", "routed", "t", "indexer", "head", "parser", "convertTypes", "prettifyRoute", "get", "set", "call", "isArray", "iterateKeySet", "initializeNote", "initializeRange", "isObject", "toTree", "innerToTree", "hasIntersection", "pathsComplementFromTree", "pathsComplementFromLengthTree", "typeOfObject", "typeOfNumber", "MAX_SAFE_INTEGER", "abs", "toPaths", "collapsePathMap", "collapsePathSetIndexes", "getHashCode", "collapseIndex", "sortListAscending", "map", "keys", "collapse", "cloneArray", "catAndSlice", "$ref", "errors", "followReference", "ref", "optimizePathSets", "optimizePathSet", "getRangeOrKeySize", "getRangeSize", "getPathCount", "lib", "CallNotFoundError", "specificMatcher", "pluckIntegers", "isRoutedToken", "match", "atom", "Observable", "isFunction$1", "Subscription", "isObject$1", "tryCatch", "e", "tryCatch$1", "UnsubscriptionError", "err", "tryCatch_1", "Subscription$1", "unsubscribe", "empty", "Symbol", "Subscriber", "error", "SafeSubscriber", "$$observable", "subscribe", "observable", "queue", "Action", "AsyncAction", "QueueAction", "Scheduler", "now", "AsyncScheduler", "QueueScheduler", "root", "InnerSubscriber", "result", "value", "iterator", "OuterSubscriber", "DeferObservable", "DeferSubscriber", "ScalarObservable", "EmptyObservable", "ArrayObservable", "PromiseObservable", "IteratorObservable", "StringIterator", "ArrayIterator", "ArrayLikeObservable", "Notification", "ObserveOnOperator", "ObserveOnSubscriber", "ObserveOnMessage", "FromObservable", "ErrorObservable", "mergeMap$1", "MergeMapOperator", "MergeMapSubscriber", "_do$1", "DoOperator", "DoSubscriber", "defaultIfEmpty$1", "DefaultIfEmptyOperator", "DefaultIfEmptySubscriber", "materialize", "MaterializeOperator", "MaterializeSubscriber", "expand$1", "ExpandOperator", "ExpandSubscriber", "reduce$1", "ReduceOperator", "ReduceSubscriber", "toArray$1", "ToArrayOperator", "ToArraySubscriber", "map$1", "MapOperator", "MapSubscriber", "filter", "filter$1", "FilterOperator", "FilterSubscriber", "_catch$1", "CatchOperator", "CatchSubscriber", "MergeAllOperator", "MergeAllSubscriber", "concat$1", "symbolObservablePonyfill", "es", "outputToObservable", "v", "isJSONG", "JSONGraphError", "errorToPathValue", "onNext", "noteToJsongOrPV", "runGetAction", "rangeToArray", "isNumber", "stripFromRange", "Keys", "stripFromArray", "complement", "strip", "stripPath", "isRange", "hasAtomIntersection", "pathUtils", "getExecutableMatches", "runByPrecedence", "types", "clone", "$error", "jsongMerge", "merge", "pathValueMerge", "pathValue", "isMessage", "recurseMatchAndExecute", "normalize", "normalizePathSets", "$atom", "MaxPathsExceededError", "falcorPathUtils", "noop", "onError", "onCompleted", "rxNewToRxNewAndOld", "_subscribe", "spreadPaths", "getValue", "hasIntersectionWithTree", "CallRequiresPathsError", "route", "r", "parseTree", "matcher", "noOp", "defaultNow", "getDocs", "changes", "Observable", "i", "schedule", "info", "t", "t", "e", "r", "t", "t", "e", "t", "e", "r", "n", "s", "i", "t", "e", "r", "n", "s", "i", "t", "e", "t", "e", "r", "n", "s", "i", "a", "a", "t", "e", "i", "r", "n", "s", "s", "t", "e", "r", "n", "a", "t", "e", "a", "sleep", "result", "i", "from", "range", "e", "i", "getDefaultExportFromCjs", "getAugmentedNamespace", "n", "a", "d", "isFunction", "isObject", "get", "set", "call", "from", "isAlreadyExpired", "root", "iterateKeySet", "toTree", "hasIntersection", "hasIntersection$1", "pathsComplementFromTree", "i", "len", "pathsComplementFromLengthTree", "e", "isSafeInteger", "toPaths", "map", "keys", "index", "collapse", "errors$1", "errors", "ref", "cloneArray$1", "cloneArray_1", "catAndSlice$1", "catAndSlice", "slice", "cloneArray", "followReference$1", "optimizePathSets", "error", "range", "pathCount", "unescape", "materialize", "clone", "src", "getSize", "version", "unlinkBackReferences", "unlinkForwardReference", "hasOwn", "prefix", "removeNode", "removeNodeAndDescendants", "transferBackReferences", "comparator", "errorSelector", "mergeJSONGraphNode", "head", "hasRequiredClone", "requireClone", "privatePrefix", "isJSONG", "hasRequiredFollowReference", "requireFollowReference", "createHardlink", "onValue", "isExpired", "$ref", "promote", "followReference", "$atom", "$error", "getValueSync", "applyErrorPrototype", "InvalidModelError", "getBoundValue", "treatErrorsAsValues", "getType", "getTimestamp", "wrapNode", "insertNode", "replaceNode", "updateBackReferenceVersions", "reconstructPath", "isPrimitive", "expireNode", "incrementVersion", "mergeValueOrInsertBranch", "NullInPathError", "setPathValues", "pathValue", "setNode", "setReference", "onNext", "onError", "onCompleted", "iterateKeySet$1", "a2", "result", "pathUtils", "complement", "flushGetRequest", "self", "noop", "v", "symbolObservablePonyfill", "Symbol", "es", "require$$1", "subscribe", "tokenizer", "TokenTypes$6", "TokenTypes_1", "TokenTypes$5", "DOT_SEPARATOR", "COMMA_SEPARATOR", "OPENING_BRACKET", "CLOSING_BRACKET", "OPENING_BRACE", "CLOSING_BRACE", "COLON", "ESCAPE", "DOUBLE_OUOTES", "SINGE_OUOTES", "SPACE", "SPECIAL_CHARACTERS", "EXT_SPECIAL_CHARACTERS", "Tokenizer$2", "getNext", "toNumber", "toOutput", "tokenizerExports", "exceptions", "Tokenizer$1", "TokenTypes$4", "E$4", "range$1", "TokenTypes$3", "E$3", "quoteE", "quote$1", "quote", "RoutedTokens$2", "TokenTypes$2", "RoutedTokens$1", "E$2", "routedE", "routed$1", "routed", "TokenTypes$1", "E$1", "idxE", "indexer$1", "indexer", "t", "TokenTypes", "E", "head$1", "Tokenizer", "RoutedTokens", "parser", "isPathValue", "isArray$4", "progressively", "_subscribe", "TimerDisposable", "empty$1", "schedule", "scheduleWithState", "updateNodeAncestors", "collect", "isArray$3", "isArray$2", "setPathMaps", "atom", "isArray$1", "isPathValue$1", "isInternalKey", "l", "getCachePosition", "isArray", "onMissing", "isMaterialized", "onValueType", "walkPath", "get_1", "checkCacheAndReport", "getRequestCycle", "empty", "getWithPaths", "arrayFlatMap", "AssignableDisposable", "GetResponse", "setGroupsIntoCache", "setRequestCycle", "_toJSONGraph", "SetResponse", "deref", "getValue", "hasRequiredGetValue", "requireGetValue", "ModelResponse", "pathSyntax", "jsong", "setValue", "sync", "__ref", "invalidatePathSets", "__prefix", "invalidatePathMaps", "isJSONEnvelope", "isJSONGraphEnvelope", "setJSONGraphs", "validateInput", "noOp", "getCache", "getVersion", "toJSON", "lib", "root", "from", "index", "a", "result", "i", "error", "query", "url", "e", "result"]
}
